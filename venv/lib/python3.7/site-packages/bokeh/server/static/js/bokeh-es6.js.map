{"version":3,"sources":["/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/main.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/index.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/version.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/embed/index.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/document/index.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/document/document.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/base.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/core/util/types.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/core/util/array.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/core/util/math.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/core/util/assert.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/core/util/arrayable.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/core/has_props.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/core/signaling.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/core/util/data_structures.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/core/util/eq.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/core/util/callback.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/core/property_mixins.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/core/properties.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/core/enums.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/core/util/color.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/core/util/svg_colors.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/core/util/object.js","/home/travis/build/bokeh/bokeh/bokehjs/node_modules/tslib/tslib.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/core/util/refs.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/core/util/string.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/core/settings.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/models/index.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/models/annotations/index.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/models/annotations/annotation.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/core/util/projections.js","/home/travis/build/bokeh/bokeh/bokehjs/node_modules/proj4/lib/core.js","/home/travis/build/bokeh/bokeh/bokehjs/node_modules/proj4/lib/Proj.js","/home/travis/build/bokeh/bokeh/bokehjs/node_modules/proj4/lib/parseCode.js","/home/travis/build/bokeh/bokeh/bokehjs/node_modules/proj4/lib/defs.js","/home/travis/build/bokeh/bokeh/bokehjs/node_modules/proj4/lib/global.js","/home/travis/build/bokeh/bokeh/bokehjs/node_modules/proj4/lib/projString.js","/home/travis/build/bokeh/bokeh/bokehjs/node_modules/proj4/lib/constants/PrimeMeridian.js","/home/travis/build/bokeh/bokeh/bokehjs/node_modules/proj4/lib/constants/units.js","/home/travis/build/bokeh/bokeh/bokehjs/node_modules/proj4/lib/wkt.js","/home/travis/build/bokeh/bokeh/bokehjs/node_modules/proj4/lib/extend.js","/home/travis/build/bokeh/bokeh/bokehjs/node_modules/proj4/lib/projections.js","/home/travis/build/bokeh/bokeh/bokehjs/node_modules/proj4/lib/projections/merc.js","/home/travis/build/bokeh/bokeh/bokehjs/node_modules/proj4/lib/common/msfnz.js","/home/travis/build/bokeh/bokeh/bokehjs/node_modules/proj4/lib/common/adjust_lon.js","/home/travis/build/bokeh/bokeh/bokehjs/node_modules/proj4/lib/common/sign.js","/home/travis/build/bokeh/bokeh/bokehjs/node_modules/proj4/lib/common/tsfnz.js","/home/travis/build/bokeh/bokeh/bokehjs/node_modules/proj4/lib/common/phi2z.js","/home/travis/build/bokeh/bokeh/bokehjs/node_modules/proj4/lib/projections/longlat.js","/home/travis/build/bokeh/bokeh/bokehjs/node_modules/proj4/lib/deriveConstants.js","/home/travis/build/bokeh/bokeh/bokehjs/node_modules/proj4/lib/constants/Ellipsoid.js","/home/travis/build/bokeh/bokeh/bokehjs/node_modules/proj4/lib/constants/Datum.js","/home/travis/build/bokeh/bokeh/bokehjs/node_modules/proj4/lib/datum.js","/home/travis/build/bokeh/bokeh/bokehjs/node_modules/proj4/lib/transform.js","/home/travis/build/bokeh/bokeh/bokehjs/node_modules/proj4/lib/datum_transform.js","/home/travis/build/bokeh/bokeh/bokehjs/node_modules/proj4/lib/datumUtils.js","/home/travis/build/bokeh/bokeh/bokehjs/node_modules/proj4/lib/adjust_axis.js","/home/travis/build/bokeh/bokeh/bokehjs/node_modules/proj4/lib/common/toPoint.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/models/renderers/renderer.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/core/dom_view.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/core/view.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/core/dom.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/styles/root.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/core/visuals.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/model.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/core/logging.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/models/annotations/arrow.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/models/annotations/arrow_head.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/models/sources/column_data_source.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/models/sources/columnar_data_source.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/models/sources/data_source.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/models/selections/selection.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/core/selection_manager.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/models/renderers/glyph_renderer.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/models/renderers/data_renderer.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/models/glyphs/line.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/models/glyphs/xy_glyph.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/core/util/spatial.js","/home/travis/build/bokeh/bokeh/bokehjs/node_modules/flatbush/flatbush.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/core/util/bbox.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/models/glyphs/glyph.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/core/hittest.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/models/ranges/factor_range.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/models/ranges/range.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/models/glyphs/utils.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/models/glyphs/patch.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/models/glyphs/harea.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/models/glyphs/area.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/models/glyphs/varea.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/models/sources/cds_view.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/models/renderers/graph_renderer.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/models/graphs/graph_hit_test_policy.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/core/build_views.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/models/selections/interaction_policy.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/core/util/serialization.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/core/util/compat.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/core/util/typed_array.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/document/events.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/models/annotations/band.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/models/annotations/box_annotation.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/styles/annotations.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/models/annotations/color_bar.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/models/tickers/basic_ticker.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/models/tickers/adaptive_ticker.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/models/tickers/continuous_ticker.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/models/tickers/ticker.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/models/formatters/basic_tick_formatter.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/models/formatters/tick_formatter.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/models/mappers/linear_color_mapper.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/models/mappers/continuous_color_mapper.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/models/mappers/color_mapper.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/models/mappers/mapper.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/models/transforms/transform.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/models/scales/linear_scale.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/models/scales/scale.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/models/transforms/index.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/models/transforms/customjs_transform.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/models/transforms/dodge.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/models/transforms/interpolator.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/models/transforms/jitter.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/models/transforms/linear_interpolator.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/models/transforms/step_interpolator.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/models/scales/log_scale.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/models/ranges/range1d.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/core/util/text.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/models/annotations/label.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/models/annotations/text_annotation.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/models/annotations/label_set.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/models/annotations/legend.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/models/annotations/legend_item.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/core/vectorization.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/models/annotations/poly_annotation.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/models/annotations/slope.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/models/annotations/span.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/models/annotations/title.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/models/annotations/toolbar_panel.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/models/annotations/tooltip.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/styles/tooltips.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/styles/mixins.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/models/annotations/whisker.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/models/axes/index.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/models/axes/axis.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/models/renderers/guide_renderer.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/models/axes/categorical_axis.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/models/tickers/categorical_ticker.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/models/formatters/categorical_tick_formatter.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/models/axes/continuous_axis.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/models/axes/datetime_axis.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/models/axes/linear_axis.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/models/formatters/datetime_tick_formatter.js","/home/travis/build/bokeh/bokeh/bokehjs/node_modules/timezone/index.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/core/util/templating.js","/home/travis/build/bokeh/bokeh/bokehjs/node_modules/sprintf-js/src/sprintf.js","/home/travis/build/bokeh/bokeh/bokehjs/node_modules/numbro/numbro.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/models/tickers/datetime_ticker.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/models/tickers/composite_ticker.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/models/tickers/days_ticker.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/models/tickers/single_interval_ticker.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/models/tickers/util.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/models/tickers/months_ticker.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/models/tickers/years_ticker.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/models/axes/log_axis.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/models/formatters/log_tick_formatter.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/models/tickers/log_ticker.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/models/axes/mercator_axis.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/models/formatters/mercator_tick_formatter.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/models/tickers/mercator_ticker.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/models/callbacks/index.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/models/callbacks/customjs.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/models/callbacks/callback.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/models/callbacks/open_url.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/models/canvas/index.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/models/canvas/canvas.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/core/util/canvas.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/styles/canvas.js","/home/travis/build/bokeh/bokeh/bokehjs/node_modules/canvas2svg/canvas2svg.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/models/canvas/cartesian_frame.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/models/scales/categorical_scale.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/models/ranges/data_range1d.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/models/ranges/data_range.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/core/layout/index.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/core/layout/types.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/core/layout/layoutable.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/core/layout/alignments.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/core/layout/grid.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/core/layout/html.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/models/expressions/index.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/models/expressions/expression.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/models/expressions/stack.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/models/expressions/cumsum.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/models/filters/index.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/models/filters/boolean_filter.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/models/filters/filter.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/models/filters/customjs_filter.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/models/filters/group_filter.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/models/filters/index_filter.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/models/formatters/index.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/models/formatters/func_tick_formatter.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/models/formatters/numeral_tick_formatter.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/models/formatters/printf_tick_formatter.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/models/glyphs/index.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/models/glyphs/annular_wedge.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/models/glyphs/annulus.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/models/glyphs/arc.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/models/glyphs/bezier.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/models/glyphs/circle.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/models/glyphs/center_rotatable.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/models/glyphs/ellipse.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/models/glyphs/ellipse_oval.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/models/glyphs/hbar.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/models/glyphs/box.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/models/glyphs/hex_tile.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/models/glyphs/image.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/models/glyphs/image_base.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/models/glyphs/image_rgba.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/models/glyphs/image_url.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/core/util/image.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/models/glyphs/multi_line.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/models/glyphs/multi_polygons.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/models/glyphs/oval.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/models/glyphs/patches.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/models/glyphs/quad.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/models/glyphs/quadratic.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/models/glyphs/ray.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/models/glyphs/rect.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/models/glyphs/segment.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/models/glyphs/step.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/models/glyphs/text.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/models/glyphs/vbar.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/models/glyphs/wedge.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/models/graphs/index.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/models/graphs/layout_provider.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/models/graphs/static_layout_provider.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/models/grids/index.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/models/grids/grid.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/models/layouts/index.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/models/layouts/box.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/models/layouts/layout_dom.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/models/layouts/column.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/models/layouts/grid_box.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/models/layouts/html_box.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/models/layouts/row.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/models/layouts/spacer.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/models/layouts/tabs.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/styles/tabs.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/styles/buttons.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/styles/menus.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/models/layouts/widget_box.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/models/mappers/index.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/models/mappers/categorical_color_mapper.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/models/mappers/categorical_mapper.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/models/mappers/categorical_marker_mapper.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/models/mappers/categorical_pattern_mapper.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/models/mappers/log_color_mapper.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/models/markers/index.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/models/markers/defs.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/models/markers/marker.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/models/markers/scatter.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/models/plots/index.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/models/plots/gmap_plot.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/models/plots/plot.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/models/tools/toolbar.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/models/tools/inspectors/inspect_tool.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/models/tools/button_tool.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/models/tools/tool.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/styles/toolbar.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/models/tools/on_off_button.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/models/tools/toolbar_base.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/models/tools/gestures/gesture_tool.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/models/tools/actions/action_tool.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/models/tools/actions/help_tool.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/styles/icons.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/styles/logo.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/models/plots/plot_canvas.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/core/bokeh_events.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/core/util/throttle.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/core/layout/side_panel.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/core/ui_events.js","/home/travis/build/bokeh/bokeh/bokehjs/node_modules/hammerjs/hammer.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/core/util/wheel.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/models/plots/gmap_plot_canvas.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/models/ranges/index.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/models/renderers/index.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/models/scales/index.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/models/selections/index.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/models/sources/index.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/models/sources/server_sent_data_source.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/models/sources/web_data_source.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/models/sources/ajax_data_source.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/models/sources/remote_data_source.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/models/sources/geojson_data_source.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/models/tickers/index.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/models/tickers/fixed_ticker.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/models/tiles/index.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/models/tiles/bbox_tile_source.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/models/tiles/mercator_tile_source.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/models/tiles/tile_source.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/models/tiles/tile_utils.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/models/tiles/quadkey_tile_source.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/models/tiles/tile_renderer.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/models/tiles/wmts_tile_source.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/styles/tiles.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/models/tiles/tms_tile_source.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/models/textures/index.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/models/textures/canvas_texture.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/models/textures/texture.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/models/textures/image_url_texture.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/models/tools/index.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/models/tools/actions/custom_action.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/models/tools/actions/redo_tool.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/models/tools/actions/reset_tool.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/models/tools/actions/save_tool.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/models/tools/actions/undo_tool.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/models/tools/actions/zoom_in_tool.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/core/util/zoom.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/models/tools/actions/zoom_out_tool.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/models/tools/edit/edit_tool.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/models/tools/edit/box_edit_tool.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/models/tools/edit/freehand_draw_tool.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/models/tools/edit/point_draw_tool.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/models/tools/edit/poly_draw_tool.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/models/tools/edit/poly_tool.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/models/tools/edit/poly_edit_tool.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/models/tools/gestures/box_select_tool.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/models/tools/gestures/select_tool.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/models/tools/util.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/models/tools/gestures/box_zoom_tool.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/models/tools/gestures/lasso_select_tool.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/models/tools/gestures/pan_tool.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/models/tools/gestures/poly_select_tool.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/models/tools/gestures/range_tool.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/models/tools/gestures/tap_tool.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/models/tools/gestures/wheel_pan_tool.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/models/tools/gestures/wheel_zoom_tool.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/models/tools/inspectors/crosshair_tool.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/models/tools/inspectors/customjs_hover.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/models/tools/inspectors/hover_tool.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/models/tools/tool_proxy.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/models/tools/toolbar_box.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/embed/standalone.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/embed/dom.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/embed/server.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/client/connection.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/protocol/message.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/protocol/receiver.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/client/session.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/embed/notebook.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/styles/notebook.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/protocol/index.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/testing.js","/home/travis/build/bokeh/bokeh/bokehjs/build/js/lib/safely.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACvBA;AACA;AACA;AACA,ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACtEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AChqBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC3CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACzDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AClPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC5EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AChOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC/bA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACpLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACrLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACzGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC1DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACzEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACnWA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC/DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACrFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC3JA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC7CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACxUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACvCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC7DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AChBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC/BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC9CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC9DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AChDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AChEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC7DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACtCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACvDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACrIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACfA;AACA;AACA;AACA;AACA,ACJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC1NA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AChBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACjCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC1FA;AACA;AACA;AACA;AACA;AACA;AACA,ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACZA;AACA;AACA;AACA;AACA;AACA,ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AClBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACtDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACzNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AClFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACnCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC/EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACpCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACrOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACpDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACnDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC1CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC1DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AChUA;AACA;AACA;AACA;AACA;AACA,ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC7aA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC/FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AChGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC/HA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AChKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC3LA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACrFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC1BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACzFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACxEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACjVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACzBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC9GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACpCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AChDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACtbA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACjMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACxRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACzFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AClMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACxCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AChEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC9DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACrFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACrFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC5FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AClFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACrKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC9BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC7DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AClPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACpBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AChBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AChIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC5HA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACxKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC1gBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC7DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC7EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACjGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACzCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACnEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACdA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AChDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC9BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AChBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC5CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC/CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC9EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC5DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AChCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACnDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AChGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AClDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC/CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC7EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACjJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC5KA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC/TA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AChGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC5FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACnEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACzHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACpKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC9DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACrIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACrBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACrHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AChBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC7aA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACpBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC9IA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC9BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACdA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACxBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACzBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC1MA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC5WA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC9GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACxNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC9uBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC5DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACrEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AChFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC1BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACpCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC7DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC5BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACzBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC3CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC1EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACzBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACvCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACjEA;AACA;AACA;AACA;AACA;AACA;AACA,ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AClCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AClCA;AACA;AACA;AACA;AACA;AACA;AACA,ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AChGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACjGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC9lCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACnGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AChBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC5OA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AClBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AClBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACrDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AClQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACtHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC5eA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AChCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC7BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC9BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC5BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC1CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACrCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACnCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACnCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AClCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACpBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACpCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACtCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACrBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AClEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC9HA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACtHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACjDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC9GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC9OA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACxBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AClBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACjHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACvDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC9HA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACvKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC/EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACjIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACpEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC3KA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC9CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACxIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC7NA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AClCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACvLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACnCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACzEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC1DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AChMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC9GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACtFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACtIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACzDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC9GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACrDA;AACA;AACA;AACA;AACA,ACJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AChLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACrBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC7BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACxTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC9BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC5CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC9BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC1BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC/NA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AClBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AChBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC3CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC3BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC3BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACpDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACjQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACpIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACtDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACpEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC1IA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC9GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC3BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACxDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC3EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACnBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACvOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AChBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC5BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AChCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC9BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACj6BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACtRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC7CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACtOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC5aA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC5wEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC9BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC5MA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AClBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACrDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACjEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACzBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AClLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC9BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC9BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AChBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC9BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACvQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACpFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACzBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AChBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACxUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AClBA;AACA;AACA;AACA;AACA;AACA;AACA,ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACjBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AChCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACpBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACjCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC9EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACzCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC/BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACxBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACxBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC/BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC1CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACtDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC3CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACpJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACzJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC9FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACtFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACxPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC/DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACzOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACtGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC1GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACpKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACpGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACtHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC9FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACxPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACxEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC9FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACjEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACnFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AChCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACvYA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC/DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACzJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACtDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACtCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AChDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACrRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC7EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC/DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AChFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACrEA;AACA;AACA;AACA;AACA;AACA,ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC1CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"generated.js","sourceRoot":"","sourcesContent":["/* main.js */ function _(require, module, exports) {\n    function __export(m) {\n        for (var p in m)\n            if (!exports.hasOwnProperty(p))\n                exports[p] = m[p];\n    }\n    __export(require(1) /* ./index */);\n}\n","/* index.js */ function _(require, module, exports) {\n    var version_1 = require(2) /* ./version */;\n    exports.version = version_1.version;\n    const embed = require(3) /* ./embed */;\n    exports.embed = embed;\n    var embed_1 = require(3) /* ./embed */;\n    exports.index = embed_1.index;\n    const protocol = require(348) /* ./protocol */;\n    exports.protocol = protocol;\n    const _testing = require(349) /* ./testing */;\n    exports._testing = _testing;\n    var logging_1 = require(65) /* ./core/logging */;\n    exports.logger = logging_1.logger;\n    exports.set_log_level = logging_1.set_log_level;\n    var settings_1 = require(26) /* ./core/settings */;\n    exports.settings = settings_1.settings;\n    var base_1 = require(6) /* ./base */;\n    exports.Models = base_1.Models;\n    var document_1 = require(4) /* ./document */;\n    exports.documents = document_1.documents;\n    var safely_1 = require(350) /* ./safely */;\n    exports.safely = safely_1.safely;\n}\n","/* version.js */ function _(require, module, exports) {\n    exports.version = '1.4.0';\n}\n","/* embed/index.js */ function _(require, module, exports) {\n    const document_1 = require(4) /* ../document */;\n    const logging_1 = require(65) /* ../core/logging */;\n    const callback_1 = require(16) /* ../core/util/callback */;\n    const string_1 = require(25) /* ../core/util/string */;\n    const types_1 = require(7) /* ../core/util/types */;\n    const standalone_1 = require(339) /* ./standalone */;\n    const server_1 = require(341) /* ./server */;\n    const dom_1 = require(340) /* ./dom */;\n    var standalone_2 = require(339) /* ./standalone */;\n    exports.add_document_standalone = standalone_2.add_document_standalone;\n    exports.index = standalone_2.index;\n    var server_2 = require(341) /* ./server */;\n    exports.add_document_from_session = server_2.add_document_from_session;\n    var notebook_1 = require(346) /* ./notebook */;\n    exports.embed_items_notebook = notebook_1.embed_items_notebook;\n    exports.kernels = notebook_1.kernels;\n    var dom_2 = require(340) /* ./dom */;\n    exports.BOKEH_ROOT = dom_2.BOKEH_ROOT;\n    function embed_item(item, target_id) {\n        const docs_json = {};\n        const doc_id = string_1.uuid4();\n        docs_json[doc_id] = item.doc;\n        if (target_id == null)\n            target_id = item.target_id;\n        const element = document.getElementById(target_id);\n        if (element != null)\n            element.classList.add(dom_1.BOKEH_ROOT);\n        const roots = { [item.root_id]: target_id };\n        const render_item = { roots, docid: doc_id };\n        callback_1.defer(() => _embed_items(docs_json, [render_item]));\n    }\n    exports.embed_item = embed_item;\n    // TODO (bev) this is currently clunky. Standalone embeds only provide\n    // the first two args, whereas server provide the app_app, and *may* prove and\n    // absolute_url as well if non-relative links are needed for resources. This function\n    // should probably be split in to two pieces to reflect the different usage patterns\n    function embed_items(docs_json, render_items, app_path, absolute_url) {\n        callback_1.defer(() => _embed_items(docs_json, render_items, app_path, absolute_url));\n    }\n    exports.embed_items = embed_items;\n    function _embed_items(docs_json, render_items, app_path, absolute_url) {\n        if (types_1.isString(docs_json))\n            docs_json = JSON.parse(string_1.unescape(docs_json));\n        const docs = {};\n        for (const docid in docs_json) {\n            const doc_json = docs_json[docid];\n            docs[docid] = document_1.Document.from_json(doc_json);\n        }\n        for (const item of render_items) {\n            const element = dom_1._resolve_element(item);\n            const roots = dom_1._resolve_root_elements(item);\n            if (item.docid != null) {\n                standalone_1.add_document_standalone(docs[item.docid], element, roots, item.use_for_title);\n            }\n            else if (item.sessionid != null) {\n                const websocket_url = server_1._get_ws_url(app_path, absolute_url);\n                logging_1.logger.debug(`embed: computed ws url: ${websocket_url}`);\n                const promise = server_1.add_document_from_session(websocket_url, item.sessionid, element, roots, item.use_for_title);\n                promise.then(() => {\n                    console.log(\"Bokeh items were rendered successfully\");\n                }, (error) => {\n                    console.log(\"Error rendering Bokeh items:\", error);\n                });\n            }\n            else\n                throw new Error(`Error rendering Bokeh items: either 'docid' or 'sessionid' was expected.`);\n        }\n    }\n}\n","/* document/index.js */ function _(require, module, exports) {\n    function __export(m) {\n        for (var p in m)\n            if (!exports.hasOwnProperty(p))\n                exports[p] = m[p];\n    }\n    __export(require(5) /* ./document */);\n    __export(require(97) /* ./events */);\n}\n","/* document/document.js */ function _(require, module, exports) {\n    const base_1 = require(6) /* ../base */;\n    const version_1 = require(2) /* ../version */;\n    const logging_1 = require(65) /* ../core/logging */;\n    const bokeh_events_1 = require(274) /* ../core/bokeh_events */;\n    const has_props_1 = require(12) /* ../core/has_props */;\n    const signaling_1 = require(13) /* ../core/signaling */;\n    const refs_1 = require(24) /* ../core/util/refs */;\n    const serialization_1 = require(94) /* ../core/util/serialization */;\n    const data_structures_1 = require(14) /* ../core/util/data_structures */;\n    const array_1 = require(8) /* ../core/util/array */;\n    const object_1 = require(22) /* ../core/util/object */;\n    const eq_1 = require(15) /* ../core/util/eq */;\n    const types_1 = require(7) /* ../core/util/types */;\n    const layout_dom_1 = require(237) /* ../models/layouts/layout_dom */;\n    const column_data_source_1 = require(68) /* ../models/sources/column_data_source */;\n    const model_1 = require(64) /* ../model */;\n    const events_1 = require(97) /* ./events */;\n    class EventManager {\n        constructor(document) {\n            this.document = document;\n            // Dispatches events to the subscribed models\n            this.session = null;\n            this.subscribed_models = new data_structures_1.Set();\n        }\n        send_event(event) {\n            if (this.session != null)\n                this.session.send_event(event);\n        }\n        trigger(event) {\n            for (const id of this.subscribed_models.values) {\n                if (event.origin != null && event.origin.id !== id)\n                    continue;\n                const model = this.document._all_models[id];\n                if (model != null && model instanceof model_1.Model)\n                    model._process_event(event);\n            }\n        }\n    }\n    exports.EventManager = EventManager;\n    EventManager.__name__ = \"EventManager\";\n    exports.documents = [];\n    exports.DEFAULT_TITLE = \"Bokeh Application\";\n    // This class should match the API of the Python Document class\n    // as much as possible.\n    class Document {\n        constructor() {\n            exports.documents.push(this);\n            this._init_timestamp = Date.now();\n            this._title = exports.DEFAULT_TITLE;\n            this._roots = [];\n            this._all_models = {};\n            this._all_models_by_name = new data_structures_1.MultiDict();\n            this._all_models_freeze_count = 0;\n            this._callbacks = [];\n            this.event_manager = new EventManager(this);\n            this.idle = new signaling_1.Signal0(this, \"idle\");\n            this._idle_roots = new WeakMap(); // TODO: WeakSet would be better\n            this._interactive_timestamp = null;\n            this._interactive_plot = null;\n        }\n        get layoutables() {\n            return this._roots.filter((root) => root instanceof layout_dom_1.LayoutDOM);\n        }\n        get is_idle() {\n            for (const root of this.layoutables) {\n                if (!this._idle_roots.has(root))\n                    return false;\n            }\n            return true;\n        }\n        notify_idle(model) {\n            this._idle_roots.set(model, true);\n            if (this.is_idle) {\n                logging_1.logger.info(`document idle at ${Date.now() - this._init_timestamp} ms`);\n                this.idle.emit();\n            }\n        }\n        clear() {\n            this._push_all_models_freeze();\n            try {\n                while (this._roots.length > 0) {\n                    this.remove_root(this._roots[0]);\n                }\n            }\n            finally {\n                this._pop_all_models_freeze();\n            }\n        }\n        interactive_start(plot) {\n            if (this._interactive_plot == null) {\n                this._interactive_plot = plot;\n                this._interactive_plot.trigger_event(new bokeh_events_1.LODStart());\n            }\n            this._interactive_timestamp = Date.now();\n        }\n        interactive_stop(plot) {\n            if (this._interactive_plot != null && this._interactive_plot.id === plot.id) {\n                this._interactive_plot.trigger_event(new bokeh_events_1.LODEnd());\n            }\n            this._interactive_plot = null;\n            this._interactive_timestamp = null;\n        }\n        interactive_duration() {\n            if (this._interactive_timestamp == null)\n                return -1;\n            else\n                return Date.now() - this._interactive_timestamp;\n        }\n        destructively_move(dest_doc) {\n            if (dest_doc === this) {\n                throw new Error(\"Attempted to overwrite a document with itself\");\n            }\n            dest_doc.clear();\n            // we have to remove ALL roots before adding any\n            // to the new doc or else models referenced from multiple\n            // roots could be in both docs at once, which isn't allowed.\n            const roots = array_1.copy(this._roots);\n            this.clear();\n            for (const root of roots) {\n                if (root.document != null)\n                    throw new Error(`Somehow we didn't detach ${root}`);\n            }\n            if (Object.keys(this._all_models).length !== 0) {\n                throw new Error(`this._all_models still had stuff in it: ${this._all_models}`);\n            }\n            for (const root of roots) {\n                dest_doc.add_root(root);\n            }\n            dest_doc.set_title(this._title);\n        }\n        // TODO other fields of doc\n        _push_all_models_freeze() {\n            this._all_models_freeze_count += 1;\n        }\n        _pop_all_models_freeze() {\n            this._all_models_freeze_count -= 1;\n            if (this._all_models_freeze_count === 0) {\n                this._recompute_all_models();\n            }\n        }\n        /*protected*/ _invalidate_all_models() {\n            logging_1.logger.debug(\"invalidating document models\");\n            // if freeze count is > 0, we'll recompute on unfreeze\n            if (this._all_models_freeze_count === 0) {\n                this._recompute_all_models();\n            }\n        }\n        _recompute_all_models() {\n            let new_all_models_set = new data_structures_1.Set();\n            for (const r of this._roots) {\n                new_all_models_set = new_all_models_set.union(r.references());\n            }\n            const old_all_models_set = new data_structures_1.Set(object_1.values(this._all_models));\n            const to_detach = old_all_models_set.diff(new_all_models_set);\n            const to_attach = new_all_models_set.diff(old_all_models_set);\n            const recomputed = {};\n            for (const m of new_all_models_set.values) {\n                recomputed[m.id] = m;\n            }\n            for (const d of to_detach.values) {\n                d.detach_document();\n                if (d instanceof model_1.Model && d.name != null)\n                    this._all_models_by_name.remove_value(d.name, d);\n            }\n            for (const a of to_attach.values) {\n                a.attach_document(this);\n                if (a instanceof model_1.Model && a.name != null)\n                    this._all_models_by_name.add_value(a.name, a);\n            }\n            this._all_models = recomputed;\n        }\n        roots() {\n            return this._roots;\n        }\n        add_root(model, setter_id) {\n            logging_1.logger.debug(`Adding root: ${model}`);\n            if (array_1.includes(this._roots, model))\n                return;\n            this._push_all_models_freeze();\n            try {\n                this._roots.push(model);\n            }\n            finally {\n                this._pop_all_models_freeze();\n            }\n            this._trigger_on_change(new events_1.RootAddedEvent(this, model, setter_id));\n        }\n        remove_root(model, setter_id) {\n            const i = this._roots.indexOf(model);\n            if (i < 0)\n                return;\n            this._push_all_models_freeze();\n            try {\n                this._roots.splice(i, 1);\n            }\n            finally {\n                this._pop_all_models_freeze();\n            }\n            this._trigger_on_change(new events_1.RootRemovedEvent(this, model, setter_id));\n        }\n        title() {\n            return this._title;\n        }\n        set_title(title, setter_id) {\n            if (title !== this._title) {\n                this._title = title;\n                this._trigger_on_change(new events_1.TitleChangedEvent(this, title, setter_id));\n            }\n        }\n        get_model_by_id(model_id) {\n            if (model_id in this._all_models) {\n                return this._all_models[model_id];\n            }\n            else {\n                return null;\n            }\n        }\n        get_model_by_name(name) {\n            return this._all_models_by_name.get_one(name, `Multiple models are named '${name}'`);\n        }\n        on_change(callback) {\n            if (!array_1.includes(this._callbacks, callback))\n                this._callbacks.push(callback);\n        }\n        remove_on_change(callback) {\n            const i = this._callbacks.indexOf(callback);\n            if (i >= 0)\n                this._callbacks.splice(i, 1);\n        }\n        _trigger_on_change(event) {\n            for (const cb of this._callbacks) {\n                cb(event);\n            }\n        }\n        // called by the model\n        _notify_change(model, attr, old, new_, options) {\n            if (attr === 'name') {\n                this._all_models_by_name.remove_value(old, model);\n                if (new_ != null)\n                    this._all_models_by_name.add_value(new_, model);\n            }\n            const setter_id = options != null ? options.setter_id : void 0;\n            const hint = options != null ? options.hint : void 0;\n            this._trigger_on_change(new events_1.ModelChangedEvent(this, model, attr, old, new_, setter_id, hint));\n        }\n        static _references_json(references, include_defaults = true) {\n            const references_json = [];\n            for (const r of references) {\n                const ref = r.ref();\n                ref.attributes = r.attributes_as_json(include_defaults);\n                // server doesn't want id in here since it's already in ref above\n                delete ref.attributes.id;\n                references_json.push(ref);\n            }\n            return references_json;\n        }\n        static _instantiate_object(obj_id, obj_type, obj_attrs) {\n            const full_attrs = Object.assign(Object.assign({}, obj_attrs), { id: obj_id, __deferred__: true });\n            const model = base_1.Models(obj_type);\n            return new model(full_attrs);\n        }\n        // given a JSON representation of all models in a graph, return a\n        // dict of new model objects\n        static _instantiate_references_json(references_json, existing_models) {\n            // Create all instances, but without setting their props\n            const references = {};\n            for (const obj of references_json) {\n                const obj_id = obj.id;\n                const obj_type = obj.type;\n                const obj_attrs = obj.attributes || {};\n                let instance;\n                if (obj_id in existing_models)\n                    instance = existing_models[obj_id];\n                else {\n                    instance = Document._instantiate_object(obj_id, obj_type, obj_attrs);\n                    if (obj.subtype != null)\n                        instance.set_subtype(obj.subtype);\n                }\n                references[instance.id] = instance;\n            }\n            return references;\n        }\n        // if v looks like a ref, or a collection, resolve it, otherwise return it unchanged\n        // recurse into collections but not into HasProps\n        static _resolve_refs(value, old_references, new_references) {\n            function resolve_ref(v) {\n                if (refs_1.is_ref(v)) {\n                    if (v.id in old_references)\n                        return old_references[v.id];\n                    else if (v.id in new_references)\n                        return new_references[v.id];\n                    else\n                        throw new Error(`reference ${JSON.stringify(v)} isn't known (not in Document?)`);\n                }\n                else if (types_1.isArray(v))\n                    return resolve_array(v);\n                else if (types_1.isPlainObject(v))\n                    return resolve_dict(v);\n                else\n                    return v;\n            }\n            function resolve_array(array) {\n                const results = [];\n                for (const v of array) {\n                    results.push(resolve_ref(v));\n                }\n                return results;\n            }\n            function resolve_dict(dict) {\n                const resolved = {};\n                for (const k in dict) {\n                    const v = dict[k];\n                    resolved[k] = resolve_ref(v);\n                }\n                return resolved;\n            }\n            return resolve_ref(value);\n        }\n        // given a JSON representation of all models in a graph and new\n        // model instances, set the properties on the models from the\n        // JSON\n        static _initialize_references_json(references_json, old_references, new_references) {\n            const to_update = {};\n            for (const obj of references_json) {\n                const obj_id = obj.id;\n                const obj_attrs = obj.attributes;\n                const was_new = !(obj_id in old_references);\n                const instance = !was_new ? old_references[obj_id] : new_references[obj_id];\n                // replace references with actual instances in obj_attrs\n                const resolved_attrs = Document._resolve_refs(obj_attrs, old_references, new_references);\n                to_update[instance.id] = [instance, resolved_attrs, was_new];\n            }\n            function foreach_depth_first(items, f) {\n                const already_started = {};\n                function foreach_value(v) {\n                    if (v instanceof has_props_1.HasProps) {\n                        // note that we ignore instances that aren't updated (not in to_update)\n                        if (!(v.id in already_started) && v.id in items) {\n                            already_started[v.id] = true;\n                            const [, attrs, was_new] = items[v.id];\n                            for (const a in attrs) {\n                                const e = attrs[a];\n                                foreach_value(e);\n                            }\n                            f(v, attrs, was_new);\n                        }\n                    }\n                    else if (types_1.isArray(v)) {\n                        for (const e of v)\n                            foreach_value(e);\n                    }\n                    else if (types_1.isPlainObject(v)) {\n                        for (const k in v) {\n                            const e = v[k];\n                            foreach_value(e);\n                        }\n                    }\n                }\n                for (const k in items) {\n                    const [instance, ,] = items[k];\n                    foreach_value(instance);\n                }\n            }\n            // this first pass removes all 'refs' replacing them with real instances\n            foreach_depth_first(to_update, function (instance, attrs, was_new) {\n                if (was_new)\n                    instance.setv(attrs, { silent: true });\n            });\n            // after removing all the refs, we can run the initialize code safely\n            foreach_depth_first(to_update, function (instance, _attrs, was_new) {\n                if (was_new)\n                    instance.finalize();\n            });\n        }\n        static _event_for_attribute_change(changed_obj, key, new_value, doc, value_refs) {\n            const changed_model = doc.get_model_by_id(changed_obj.id); // XXX!\n            if (!changed_model.attribute_is_serializable(key))\n                return null;\n            else {\n                const event = {\n                    kind: \"ModelChanged\",\n                    model: {\n                        id: changed_obj.id,\n                        type: changed_obj.type,\n                    },\n                    attr: key,\n                    new: new_value,\n                };\n                has_props_1.HasProps._json_record_references(doc, new_value, value_refs, true); // true = recurse\n                return event;\n            }\n        }\n        static _events_to_sync_objects(from_obj, to_obj, to_doc, value_refs) {\n            const from_keys = Object.keys(from_obj.attributes); //XXX!\n            const to_keys = Object.keys(to_obj.attributes); //XXX!\n            const removed = array_1.difference(from_keys, to_keys);\n            const added = array_1.difference(to_keys, from_keys);\n            const shared = array_1.intersection(from_keys, to_keys);\n            const events = [];\n            for (const key of removed) {\n                // we don't really have a \"remove\" event - not sure this ever\n                // happens even. One way this could happen is if the server\n                // does include_defaults=True and we do\n                // include_defaults=false ... in that case it'd be best to\n                // just ignore this probably. Warn about it, could mean\n                // there's a bug if we don't have a key that the server sent.\n                logging_1.logger.warn(`Server sent key ${key} but we don't seem to have it in our JSON`);\n            }\n            for (const key of added) {\n                const new_value = to_obj.attributes[key]; // XXX!\n                events.push(Document._event_for_attribute_change(from_obj, key, new_value, to_doc, value_refs));\n            }\n            for (const key of shared) {\n                const old_value = from_obj.attributes[key]; // XXX!\n                const new_value = to_obj.attributes[key]; // XXX!\n                if (old_value == null && new_value == null) {\n                }\n                else if (old_value == null || new_value == null) {\n                    events.push(Document._event_for_attribute_change(from_obj, key, new_value, to_doc, value_refs));\n                }\n                else {\n                    if (!eq_1.isEqual(old_value, new_value))\n                        events.push(Document._event_for_attribute_change(from_obj, key, new_value, to_doc, value_refs));\n                }\n            }\n            return events.filter((e) => e != null);\n        }\n        // we use this to detect changes during document deserialization\n        // (in model constructors and initializers)\n        static _compute_patch_since_json(from_json, to_doc) {\n            const to_json = to_doc.to_json(false); // include_defaults=false\n            function refs(json) {\n                const result = {};\n                for (const obj of json.roots.references)\n                    result[obj.id] = obj;\n                return result;\n            }\n            const from_references = refs(from_json);\n            const from_roots = {};\n            const from_root_ids = [];\n            for (const r of from_json.roots.root_ids) {\n                from_roots[r] = from_references[r];\n                from_root_ids.push(r);\n            }\n            const to_references = refs(to_json);\n            const to_roots = {};\n            const to_root_ids = [];\n            for (const r of to_json.roots.root_ids) {\n                to_roots[r] = to_references[r];\n                to_root_ids.push(r);\n            }\n            from_root_ids.sort();\n            to_root_ids.sort();\n            if (array_1.difference(from_root_ids, to_root_ids).length > 0 ||\n                array_1.difference(to_root_ids, from_root_ids).length > 0) {\n                // this would arise if someone does add_root/remove_root during\n                // document deserialization, hopefully they won't ever do so.\n                throw new Error(\"Not implemented: computing add/remove of document roots\");\n            }\n            const value_refs = {};\n            let events = [];\n            for (const id in to_doc._all_models) {\n                if (id in from_references) {\n                    const update_model_events = Document._events_to_sync_objects(from_references[id], to_references[id], to_doc, value_refs);\n                    events = events.concat(update_model_events);\n                }\n            }\n            return {\n                references: Document._references_json(object_1.values(value_refs), false),\n                events,\n            };\n        }\n        to_json_string(include_defaults = true) {\n            return JSON.stringify(this.to_json(include_defaults));\n        }\n        to_json(include_defaults = true) {\n            const root_ids = this._roots.map((r) => r.id);\n            const root_references = object_1.values(this._all_models);\n            return {\n                version: version_1.version,\n                title: this._title,\n                roots: {\n                    root_ids,\n                    references: Document._references_json(root_references, include_defaults),\n                },\n            };\n        }\n        static from_json_string(s) {\n            const json = JSON.parse(s);\n            return Document.from_json(json);\n        }\n        static from_json(json) {\n            logging_1.logger.debug(\"Creating Document from JSON\");\n            const py_version = json.version; // XXX!\n            const is_dev = py_version.indexOf('+') !== -1 || py_version.indexOf('-') !== -1;\n            const versions_string = `Library versions: JS (${version_1.version}) / Python (${py_version})`;\n            if (!is_dev && version_1.version !== py_version) {\n                logging_1.logger.warn(\"JS/Python version mismatch\");\n                logging_1.logger.warn(versions_string);\n            }\n            else\n                logging_1.logger.debug(versions_string);\n            const roots_json = json.roots;\n            const root_ids = roots_json.root_ids;\n            const references_json = roots_json.references;\n            const references = Document._instantiate_references_json(references_json, {});\n            Document._initialize_references_json(references_json, {}, references);\n            const doc = new Document();\n            for (const r of root_ids)\n                doc.add_root(references[r]); // XXX: HasProps\n            doc.set_title(json.title); // XXX!\n            return doc;\n        }\n        replace_with_json(json) {\n            const replacement = Document.from_json(json);\n            replacement.destructively_move(this);\n        }\n        create_json_patch_string(events) {\n            return JSON.stringify(this.create_json_patch(events));\n        }\n        create_json_patch(events) {\n            const references = {};\n            const json_events = [];\n            for (const event of events) {\n                if (event.document !== this) {\n                    logging_1.logger.warn(\"Cannot create a patch using events from a different document, event had \", event.document, \" we are \", this);\n                    throw new Error(\"Cannot create a patch using events from a different document\");\n                }\n                json_events.push(event.json(references));\n            }\n            return {\n                events: json_events,\n                references: Document._references_json(object_1.values(references)),\n            };\n        }\n        apply_json_patch(patch, buffers = [], setter_id) {\n            const references_json = patch.references;\n            const events_json = patch.events;\n            const references = Document._instantiate_references_json(references_json, this._all_models);\n            // The model being changed isn't always in references so add it in\n            for (const event_json of events_json) {\n                switch (event_json.kind) {\n                    case \"RootAdded\":\n                    case \"RootRemoved\":\n                    case \"ModelChanged\": {\n                        const model_id = event_json.model.id;\n                        if (model_id in this._all_models) {\n                            references[model_id] = this._all_models[model_id];\n                        }\n                        else {\n                            if (!(model_id in references)) {\n                                logging_1.logger.warn(\"Got an event for unknown model \", event_json.model);\n                                throw new Error(\"event model wasn't known\");\n                            }\n                        }\n                        break;\n                    }\n                }\n            }\n            // split references into old and new so we know whether to initialize or update\n            const old_references = {};\n            const new_references = {};\n            for (const id in references) {\n                const value = references[id];\n                if (id in this._all_models)\n                    old_references[id] = value;\n                else\n                    new_references[id] = value;\n            }\n            Document._initialize_references_json(references_json, old_references, new_references);\n            for (const event_json of events_json) {\n                switch (event_json.kind) {\n                    case 'ModelChanged': {\n                        const patched_id = event_json.model.id;\n                        if (!(patched_id in this._all_models)) {\n                            throw new Error(`Cannot apply patch to ${patched_id} which is not in the document`);\n                        }\n                        const patched_obj = this._all_models[patched_id];\n                        const attr = event_json.attr;\n                        const model_type = event_json.model.type;\n                        // XXXX currently still need this first branch, some updates (initial?) go through here\n                        if (attr === 'data' && model_type === 'ColumnDataSource') {\n                            const [data, shapes] = serialization_1.decode_column_data(event_json.new, buffers);\n                            patched_obj.setv({ _shapes: shapes, data }, { setter_id });\n                        }\n                        else {\n                            const value = Document._resolve_refs(event_json.new, old_references, new_references);\n                            patched_obj.setv({ [attr]: value }, { setter_id });\n                        }\n                        break;\n                    }\n                    case 'ColumnDataChanged': {\n                        const column_source_id = event_json.column_source.id;\n                        if (!(column_source_id in this._all_models)) {\n                            throw new Error(`Cannot stream to ${column_source_id} which is not in the document`);\n                        }\n                        const column_source = this._all_models[column_source_id];\n                        const [data, shapes] = serialization_1.decode_column_data(event_json.new, buffers);\n                        if (event_json.cols != null) {\n                            for (const k in column_source.data) {\n                                if (!(k in data)) {\n                                    data[k] = column_source.data[k];\n                                }\n                            }\n                            for (const k in column_source._shapes) {\n                                if (!(k in shapes)) {\n                                    shapes[k] = column_source._shapes[k];\n                                }\n                            }\n                        }\n                        column_source.setv({\n                            _shapes: shapes,\n                            data,\n                        }, {\n                            setter_id,\n                            check_eq: false,\n                        });\n                        break;\n                    }\n                    case 'ColumnsStreamed': {\n                        const column_source_id = event_json.column_source.id;\n                        if (!(column_source_id in this._all_models)) {\n                            throw new Error(`Cannot stream to ${column_source_id} which is not in the document`);\n                        }\n                        const column_source = this._all_models[column_source_id];\n                        if (!(column_source instanceof column_data_source_1.ColumnDataSource)) {\n                            throw new Error(\"Cannot stream to non-ColumnDataSource\");\n                        }\n                        const data = event_json.data;\n                        const rollover = event_json.rollover;\n                        column_source.stream(data, rollover, setter_id);\n                        break;\n                    }\n                    case 'ColumnsPatched': {\n                        const column_source_id = event_json.column_source.id;\n                        if (!(column_source_id in this._all_models)) {\n                            throw new Error(`Cannot patch ${column_source_id} which is not in the document`);\n                        }\n                        const column_source = this._all_models[column_source_id];\n                        if (!(column_source instanceof column_data_source_1.ColumnDataSource)) {\n                            throw new Error(\"Cannot patch non-ColumnDataSource\");\n                        }\n                        const patches = event_json.patches;\n                        column_source.patch(patches, setter_id);\n                        break;\n                    }\n                    case 'RootAdded': {\n                        const root_id = event_json.model.id;\n                        const root_obj = references[root_id];\n                        this.add_root(root_obj, setter_id); // XXX: HasProps\n                        break;\n                    }\n                    case 'RootRemoved': {\n                        const root_id = event_json.model.id;\n                        const root_obj = references[root_id];\n                        this.remove_root(root_obj, setter_id); // XXX: HasProps\n                        break;\n                    }\n                    case 'TitleChanged': {\n                        this.set_title(event_json.title, setter_id);\n                        break;\n                    }\n                    default:\n                        throw new Error(\"Unknown patch event \" + JSON.stringify(event_json));\n                }\n            }\n        }\n    }\n    exports.Document = Document;\n    Document.__name__ = \"Document\";\n}\n","/* base.js */ function _(require, module, exports) {\n    const types_1 = require(7) /* ./core/util/types */;\n    const has_props_1 = require(12) /* ./core/has_props */;\n    exports.overrides = {};\n    const _all_models = new Map();\n    exports.Models = ((name) => {\n        const model = exports.overrides[name] || _all_models.get(name);\n        if (model == null) {\n            throw new Error(`Model '${name}' does not exist. This could be due to a widget or a custom model not being registered before first usage.`);\n        }\n        return model;\n    });\n    exports.Models.register = (name, model) => {\n        exports.overrides[name] = model;\n    };\n    exports.Models.unregister = (name) => {\n        delete exports.overrides[name];\n    };\n    function is_HasProps(obj) {\n        return types_1.isObject(obj) && obj.prototype instanceof has_props_1.HasProps;\n    }\n    exports.Models.register_models = (models, force = false, errorFn) => {\n        if (models == null)\n            return;\n        for (const name in models) {\n            const model = models[name];\n            if (is_HasProps(model)) {\n                const qualified = model.__qualified__;\n                if (force || !_all_models.has(qualified))\n                    _all_models.set(qualified, model);\n                else if (errorFn != null)\n                    errorFn(qualified);\n                else\n                    console.warn(`Model '${qualified}' was already registered`);\n            }\n        }\n    };\n    exports.register_models = exports.Models.register_models;\n    exports.Models.registered_names = () => Array.from(_all_models.keys());\n    // TODO: this doesn't belong here, but it's easier this way for backwards compatibility\n    const AllModels = require(27) /* ./models */;\n    exports.register_models(AllModels);\n}\n","/* core/util/types.js */ function _(require, module, exports) {\n    const array_1 = require(8) /* ./array */;\n    const toString = Object.prototype.toString;\n    function isBoolean(obj) {\n        return obj === true || obj === false || toString.call(obj) === '[object Boolean]';\n    }\n    exports.isBoolean = isBoolean;\n    function isNumber(obj) {\n        return toString.call(obj) === \"[object Number]\";\n    }\n    exports.isNumber = isNumber;\n    function isInteger(obj) {\n        return isNumber(obj) && isFinite(obj) && Math.floor(obj) === obj;\n    }\n    exports.isInteger = isInteger;\n    function isString(obj) {\n        return toString.call(obj) === \"[object String]\";\n    }\n    exports.isString = isString;\n    function isStrictNaN(obj) {\n        return isNumber(obj) && obj !== +obj;\n    }\n    exports.isStrictNaN = isStrictNaN;\n    function isFunction(obj) {\n        return toString.call(obj) === \"[object Function]\";\n    }\n    exports.isFunction = isFunction;\n    function isArray(obj) {\n        return Array.isArray(obj);\n    }\n    exports.isArray = isArray;\n    function isArrayOf(arr, predicate) {\n        return array_1.every(arr, predicate);\n    }\n    exports.isArrayOf = isArrayOf;\n    function isArrayableOf(arr, predicate) {\n        for (let i = 0, end = arr.length; i < end; i++) {\n            if (!predicate(arr[i]))\n                return false;\n        }\n        return true;\n    }\n    exports.isArrayableOf = isArrayableOf;\n    function isTypedArray(obj) {\n        return obj != null && obj.buffer instanceof ArrayBuffer;\n    }\n    exports.isTypedArray = isTypedArray;\n    function isObject(obj) {\n        const tp = typeof obj;\n        return tp === 'function' || tp === 'object' && !!obj;\n    }\n    exports.isObject = isObject;\n    function isPlainObject(obj) {\n        return isObject(obj) && (obj.constructor == null || obj.constructor === Object);\n    }\n    exports.isPlainObject = isPlainObject;\n}\n","/* core/util/array.js */ function _(require, module, exports) {\n    const math_1 = require(9) /* ./math */;\n    const assert_1 = require(10) /* ./assert */;\n    const arrayable_1 = require(11) /* ./arrayable */;\n    exports.map = arrayable_1.map;\n    exports.reduce = arrayable_1.reduce;\n    exports.min = arrayable_1.min;\n    exports.min_by = arrayable_1.min_by;\n    exports.max = arrayable_1.max;\n    exports.max_by = arrayable_1.max_by;\n    exports.sum = arrayable_1.sum;\n    exports.cumsum = arrayable_1.cumsum;\n    exports.every = arrayable_1.every;\n    exports.some = arrayable_1.some;\n    exports.find = arrayable_1.find;\n    exports.find_last = arrayable_1.find_last;\n    exports.find_index = arrayable_1.find_index;\n    exports.find_last_index = arrayable_1.find_last_index;\n    exports.sorted_index = arrayable_1.sorted_index;\n    const slice = Array.prototype.slice;\n    function head(array) {\n        return array[0];\n    }\n    exports.head = head;\n    function tail(array) {\n        return array[array.length - 1];\n    }\n    exports.tail = tail;\n    function last(array) {\n        return array[array.length - 1];\n    }\n    exports.last = last;\n    function copy(array) {\n        return slice.call(array);\n    }\n    exports.copy = copy;\n    function concat(arrays) {\n        return [].concat(...arrays);\n    }\n    exports.concat = concat;\n    function includes(array, value) {\n        return array.indexOf(value) !== -1;\n    }\n    exports.includes = includes;\n    exports.contains = includes;\n    function nth(array, index) {\n        return array[index >= 0 ? index : array.length + index];\n    }\n    exports.nth = nth;\n    function zip(...arrays) {\n        if (arrays.length == 0)\n            return [];\n        const n = arrayable_1.min(arrays.map((a) => a.length));\n        const k = arrays.length;\n        const result = new Array(n);\n        for (let i = 0; i < n; i++) {\n            result[i] = new Array(k);\n            for (let j = 0; j < k; j++)\n                result[i][j] = arrays[j][i];\n        }\n        return result;\n    }\n    exports.zip = zip;\n    function unzip(array) {\n        const n = array.length;\n        const k = arrayable_1.min(array.map((a) => a.length));\n        const results = Array(k);\n        for (let j = 0; j < k; j++)\n            results[j] = new Array(n);\n        for (let i = 0; i < n; i++) {\n            for (let j = 0; j < k; j++)\n                results[j][i] = array[i][j];\n        }\n        return results;\n    }\n    exports.unzip = unzip;\n    function range(start, stop, step = 1) {\n        assert_1.assert(step > 0, \"'step' must be a positive number\");\n        if (stop == null) {\n            stop = start;\n            start = 0;\n        }\n        const { max, ceil, abs } = Math;\n        const delta = start <= stop ? step : -step;\n        const length = max(ceil(abs(stop - start) / step), 0);\n        const range = Array(length);\n        for (let i = 0; i < length; i++, start += delta) {\n            range[i] = start;\n        }\n        return range;\n    }\n    exports.range = range;\n    function linspace(start, stop, num = 100) {\n        const step = (stop - start) / (num - 1);\n        const array = new Array(num);\n        for (let i = 0; i < num; i++) {\n            array[i] = start + step * i;\n        }\n        return array;\n    }\n    exports.linspace = linspace;\n    function transpose(array) {\n        const rows = array.length;\n        const cols = array[0].length;\n        const transposed = [];\n        for (let j = 0; j < cols; j++) {\n            transposed[j] = [];\n            for (let i = 0; i < rows; i++) {\n                transposed[j][i] = array[i][j];\n            }\n        }\n        return transposed;\n    }\n    exports.transpose = transpose;\n    function argmin(array) {\n        return arrayable_1.min_by(range(array.length), (i) => array[i]);\n    }\n    exports.argmin = argmin;\n    function argmax(array) {\n        return arrayable_1.max_by(range(array.length), (i) => array[i]);\n    }\n    exports.argmax = argmax;\n    function sort_by(array, key) {\n        const tmp = array.map((value, index) => {\n            return { value, index, key: key(value) };\n        });\n        tmp.sort((left, right) => {\n            const a = left.key;\n            const b = right.key;\n            if (a !== b) {\n                if (a > b || a === undefined)\n                    return 1;\n                if (a < b || b === undefined)\n                    return -1;\n            }\n            return left.index - right.index;\n        });\n        return tmp.map((item) => item.value);\n    }\n    exports.sort_by = sort_by;\n    function uniq(array) {\n        const result = [];\n        for (const value of array) {\n            if (!includes(result, value)) {\n                result.push(value);\n            }\n        }\n        return result;\n    }\n    exports.uniq = uniq;\n    function uniq_by(array, key) {\n        const result = [];\n        const seen = [];\n        for (const value of array) {\n            const computed = key(value);\n            if (!includes(seen, computed)) {\n                seen.push(computed);\n                result.push(value);\n            }\n        }\n        return result;\n    }\n    exports.uniq_by = uniq_by;\n    function union(...arrays) {\n        return uniq(concat(arrays));\n    }\n    exports.union = union;\n    function intersection(array, ...arrays) {\n        const result = [];\n        top: for (const item of array) {\n            if (includes(result, item))\n                continue;\n            for (const other of arrays) {\n                if (!includes(other, item))\n                    continue top;\n            }\n            result.push(item);\n        }\n        return result;\n    }\n    exports.intersection = intersection;\n    function difference(array, ...arrays) {\n        const rest = concat(arrays);\n        return array.filter((value) => !includes(rest, value));\n    }\n    exports.difference = difference;\n    function remove_at(array, i) {\n        const result = copy(array);\n        result.splice(i, 1);\n        return result;\n    }\n    exports.remove_at = remove_at;\n    function remove_by(array, key) {\n        for (let i = 0; i < array.length;) {\n            if (key(array[i]))\n                array.splice(i, 1);\n            else\n                i++;\n        }\n    }\n    exports.remove_by = remove_by;\n    // Shuffle a collection, using the modern version of the\n    // [Fisher-Yates shuffle](http://en.wikipedia.org/wiki/FisherYates_shuffle).\n    function shuffle(array) {\n        const length = array.length;\n        const shuffled = new Array(length);\n        for (let i = 0; i < length; i++) {\n            const rand = math_1.randomIn(0, i);\n            if (rand !== i)\n                shuffled[i] = shuffled[rand];\n            shuffled[rand] = array[i];\n        }\n        return shuffled;\n    }\n    exports.shuffle = shuffle;\n    function pairwise(array, fn) {\n        const n = array.length;\n        const result = new Array(n - 1);\n        for (let i = 0; i < n - 1; i++) {\n            result[i] = fn(array[i], array[i + 1]);\n        }\n        return result;\n    }\n    exports.pairwise = pairwise;\n    function reversed(array) {\n        const n = array.length;\n        const result = new Array(n);\n        for (let i = 0; i < n; i++) {\n            result[n - i - 1] = array[i];\n        }\n        return result;\n    }\n    exports.reversed = reversed;\n    function repeat(value, n) {\n        const result = new Array(n);\n        for (let i = 0; i < n; i++) {\n            result[i] = value;\n        }\n        return result;\n    }\n    exports.repeat = repeat;\n}\n","/* core/util/math.js */ function _(require, module, exports) {\n    function angle_norm(angle) {\n        if (angle == 0) {\n            return 0;\n        }\n        while (angle <= 0) {\n            angle += 2 * Math.PI;\n        }\n        while (angle > 2 * Math.PI) {\n            angle -= 2 * Math.PI;\n        }\n        return angle;\n    }\n    exports.angle_norm = angle_norm;\n    function angle_dist(lhs, rhs) {\n        return angle_norm(lhs - rhs);\n    }\n    exports.angle_dist = angle_dist;\n    function angle_between(mid, lhs, rhs, direction) {\n        const d = angle_dist(lhs, rhs);\n        if (d == 0)\n            return false;\n        if (d == 2 * Math.PI)\n            return true;\n        const norm_mid = angle_norm(mid);\n        const cond = angle_dist(lhs, norm_mid) <= d && angle_dist(norm_mid, rhs) <= d;\n        return (direction == 0 /* clock */) ? cond : !cond;\n    }\n    exports.angle_between = angle_between;\n    function random() {\n        return Math.random();\n    }\n    exports.random = random;\n    function randomIn(min, max) {\n        if (max == null) {\n            max = min;\n            min = 0;\n        }\n        return min + Math.floor(Math.random() * (max - min + 1));\n    }\n    exports.randomIn = randomIn;\n    function atan2(start, end) {\n        /*\n         * Calculate the angle between a line containing start and end points (composed\n         * of [x, y] arrays) and the positive x-axis.\n         */\n        return Math.atan2(end[1] - start[1], end[0] - start[0]);\n    }\n    exports.atan2 = atan2;\n    // http://www2.econ.osaka-u.ac.jp/~tanizaki/class/2013/econome3/13.pdf (Page 432)\n    function rnorm(mu, sigma) {\n        // Generate a random normal with a mean of 0 and a sigma of 1\n        let r1;\n        let r2;\n        while (true) {\n            r1 = random();\n            r2 = random();\n            r2 = (2 * r2 - 1) * Math.sqrt(2 * (1 / Math.E));\n            if (-4 * r1 * r1 * Math.log(r1) >= r2 * r2)\n                break;\n        }\n        let rn = r2 / r1;\n        // Transform the standard normal to meet the characteristics that we want (mu, sigma)\n        rn = mu + sigma * rn;\n        return rn;\n    }\n    exports.rnorm = rnorm;\n    function clamp(val, min, max) {\n        if (val > max)\n            return max;\n        if (val < min)\n            return min;\n        return val;\n    }\n    exports.clamp = clamp;\n}\n","/* core/util/assert.js */ function _(require, module, exports) {\n    class AssertionError extends Error {\n    }\n    exports.AssertionError = AssertionError;\n    AssertionError.__name__ = \"AssertionError\";\n    function assert(condition, message) {\n        if (condition === true || (condition !== false && condition()))\n            return;\n        throw new AssertionError(message || \"Assertion failed\");\n    }\n    exports.assert = assert;\n}\n","/* core/util/arrayable.js */ function _(require, module, exports) {\n    function splice(array, start, k, ...items) {\n        const len = array.length;\n        if (start < 0)\n            start += len;\n        if (start < 0)\n            start = 0;\n        else if (start > len)\n            start = len;\n        if (k == null || k > len - start)\n            k = len - start;\n        else if (k < 0)\n            k = 0;\n        const n = len - k + items.length;\n        const result = new array.constructor(n);\n        let i = 0;\n        for (; i < start; i++) {\n            result[i] = array[i];\n        }\n        for (const item of items) {\n            result[i++] = item;\n        }\n        for (let j = start + k; j < len; j++) {\n            result[i++] = array[j];\n        }\n        return result;\n    }\n    exports.splice = splice;\n    function head(array, n) {\n        return splice(array, n, array.length - n);\n    }\n    exports.head = head;\n    function insert(array, item, i) {\n        return splice(array, i, 0, item);\n    }\n    exports.insert = insert;\n    function append(array, item) {\n        return splice(array, array.length, 0, item);\n    }\n    exports.append = append;\n    function prepend(array, item) {\n        return splice(array, 0, 0, item);\n    }\n    exports.prepend = prepend;\n    function indexOf(array, item) {\n        for (let i = 0, n = array.length; i < n; i++) {\n            if (array[i] === item)\n                return i;\n        }\n        return -1;\n    }\n    exports.indexOf = indexOf;\n    function map(array, fn) {\n        const n = array.length;\n        const result = new array.constructor(n);\n        for (let i = 0; i < n; i++) {\n            result[i] = fn(array[i], i, array);\n        }\n        return result;\n    }\n    exports.map = map;\n    function filter(array, pred) {\n        const n = array.length;\n        const result = new array.constructor(n);\n        let k = 0;\n        for (let i = 0; i < n; i++) {\n            const value = array[i];\n            if (pred(value, i, array))\n                result[k++] = value;\n        }\n        return head(result, k);\n    }\n    exports.filter = filter;\n    function reduce(array, fn, initial) {\n        const n = array.length;\n        if (initial === undefined && n == 0)\n            throw new Error(\"can't reduce an empty array without an initial value\");\n        let value;\n        let i;\n        if (initial === undefined) {\n            value = array[0];\n            i = 1;\n        }\n        else {\n            value = initial;\n            i = 0;\n        }\n        for (; i < n; i++) {\n            value = fn(value, array[i], i, array);\n        }\n        return value;\n    }\n    exports.reduce = reduce;\n    function min(array) {\n        let value;\n        let result = Infinity;\n        for (let i = 0, length = array.length; i < length; i++) {\n            value = array[i];\n            if (value < result) {\n                result = value;\n            }\n        }\n        return result;\n    }\n    exports.min = min;\n    function min_by(array, key) {\n        if (array.length == 0)\n            throw new Error(\"min_by() called with an empty array\");\n        let result = array[0];\n        let resultComputed = key(result);\n        for (let i = 1, length = array.length; i < length; i++) {\n            const value = array[i];\n            const computed = key(value);\n            if (computed < resultComputed) {\n                result = value;\n                resultComputed = computed;\n            }\n        }\n        return result;\n    }\n    exports.min_by = min_by;\n    function max(array) {\n        let value;\n        let result = -Infinity;\n        for (let i = 0, length = array.length; i < length; i++) {\n            value = array[i];\n            if (value > result) {\n                result = value;\n            }\n        }\n        return result;\n    }\n    exports.max = max;\n    function max_by(array, key) {\n        if (array.length == 0)\n            throw new Error(\"max_by() called with an empty array\");\n        let result = array[0];\n        let resultComputed = key(result);\n        for (let i = 1, length = array.length; i < length; i++) {\n            const value = array[i];\n            const computed = key(value);\n            if (computed > resultComputed) {\n                result = value;\n                resultComputed = computed;\n            }\n        }\n        return result;\n    }\n    exports.max_by = max_by;\n    function sum(array) {\n        let result = 0;\n        for (let i = 0, n = array.length; i < n; i++) {\n            result += array[i];\n        }\n        return result;\n    }\n    exports.sum = sum;\n    function cumsum(array) {\n        const result = new array.constructor(array.length);\n        reduce(array, (a, b, i) => result[i] = a + b, 0);\n        return result;\n    }\n    exports.cumsum = cumsum;\n    function every(array, predicate) {\n        for (let i = 0, length = array.length; i < length; i++) {\n            if (!predicate(array[i]))\n                return false;\n        }\n        return true;\n    }\n    exports.every = every;\n    function some(array, predicate) {\n        for (let i = 0, length = array.length; i < length; i++) {\n            if (predicate(array[i]))\n                return true;\n        }\n        return false;\n    }\n    exports.some = some;\n    function index_of(array, value) {\n        for (let i = 0, length = array.length; i < length; i++) {\n            if (array[i] === value)\n                return i;\n        }\n        return -1;\n    }\n    exports.index_of = index_of;\n    function _find_index(dir) {\n        return function (array, predicate) {\n            const length = array.length;\n            let index = dir > 0 ? 0 : length - 1;\n            for (; index >= 0 && index < length; index += dir) {\n                if (predicate(array[index]))\n                    return index;\n            }\n            return -1;\n        };\n    }\n    exports.find_index = _find_index(1);\n    exports.find_last_index = _find_index(-1);\n    function find(array, predicate) {\n        const index = exports.find_index(array, predicate);\n        return index == -1 ? undefined : array[index];\n    }\n    exports.find = find;\n    function find_last(array, predicate) {\n        const index = exports.find_last_index(array, predicate);\n        return index == -1 ? undefined : array[index];\n    }\n    exports.find_last = find_last;\n    function sorted_index(array, value) {\n        let low = 0;\n        let high = array.length;\n        while (low < high) {\n            const mid = Math.floor((low + high) / 2);\n            if (array[mid] < value)\n                low = mid + 1;\n            else\n                high = mid;\n        }\n        return low;\n    }\n    exports.sorted_index = sorted_index;\n}\n","/* core/has_props.js */ function _(require, module, exports) {\n    const signaling_1 = require(13) /* ./signaling */;\n    const property_mixins = require(17) /* ./property_mixins */;\n    const refs_1 = require(24) /* ./util/refs */;\n    const p = require(18) /* ./properties */;\n    const string_1 = require(25) /* ./util/string */;\n    const array_1 = require(8) /* ./util/array */;\n    const object_1 = require(22) /* ./util/object */;\n    const types_1 = require(7) /* ./util/types */;\n    const eq_1 = require(15) /* ./util/eq */;\n    class HasProps extends signaling_1.Signalable() {\n        constructor(attrs = {}) {\n            super();\n            this._subtype = undefined;\n            this.document = null;\n            this.destroyed = new signaling_1.Signal0(this, \"destroyed\");\n            this.change = new signaling_1.Signal0(this, \"change\");\n            this.transformchange = new signaling_1.Signal0(this, \"transformchange\");\n            this.attributes = {};\n            this.properties = {};\n            this._set_after_defaults = {};\n            this._pending = false;\n            this._changing = false;\n            for (const name in this.props) {\n                const { type, default_value } = this.props[name];\n                if (type != null)\n                    this.properties[name] = new type(this, name, default_value);\n                else\n                    throw new Error(`undefined property type for ${this.type}.${name}`);\n            }\n            // auto generating ID\n            if (attrs.id == null)\n                this.setv({ id: string_1.uniqueId() }, { silent: true });\n            const deferred = attrs.__deferred__ || false;\n            if (deferred) {\n                attrs = object_1.clone(attrs);\n                delete attrs.__deferred__;\n            }\n            this.setv(attrs, { silent: true });\n            // allowing us to defer initialization when loading many models\n            // when loading a bunch of models, we want to do initialization as a second pass\n            // because other objects that this one depends on might not be loaded yet\n            if (!deferred)\n                this.finalize();\n        }\n        // XXX: setter is only required for backwards compatibility\n        set type(name) {\n            console.warn(\"prototype.type = 'ModelName' is deprecated, use static __name__ instead\");\n            this.constructor.__name__ = name;\n        }\n        get type() {\n            return this.constructor.__qualified__;\n        }\n        static get __qualified__() {\n            const { __module__, __name__ } = this;\n            return __module__ != null ? `${__module__}.${__name__}` : __name__;\n        }\n        static init_HasProps() {\n            this.prototype.props = {};\n            this.prototype.mixins = [];\n            this.define({\n                id: [p.Any],\n            });\n        }\n        // }}}\n        static _fix_default(default_value, _attr) {\n            if (default_value === undefined)\n                return undefined;\n            else if (types_1.isFunction(default_value))\n                return default_value;\n            else if (!types_1.isObject(default_value))\n                return () => default_value;\n            else {\n                //logger.warn(`${this.prototype.type}.${attr} uses unwrapped non-primitive default value`)\n                if (types_1.isArray(default_value))\n                    return () => array_1.copy(default_value);\n                else\n                    return () => object_1.clone(default_value);\n            }\n        }\n        // TODO: don't use Partial<>, but exclude inherited properties\n        static define(obj) {\n            for (const name in obj) {\n                const prop = obj[name];\n                if (this.prototype.props[name] != null)\n                    throw new Error(`attempted to redefine property '${this.prototype.type}.${name}'`);\n                if (this.prototype[name] != null)\n                    throw new Error(`attempted to redefine attribute '${this.prototype.type}.${name}'`);\n                Object.defineProperty(this.prototype, name, {\n                    // XXX: don't use tail calls in getters/setters due to https://bugs.webkit.org/show_bug.cgi?id=164306\n                    get() {\n                        const value = this.getv(name);\n                        return value;\n                    },\n                    set(value) {\n                        this.setv({ [name]: value });\n                        return this;\n                    },\n                    configurable: false,\n                    enumerable: true,\n                });\n                const [type, default_value, internal] = prop;\n                const refined_prop = {\n                    type,\n                    default_value: this._fix_default(default_value, name),\n                    internal: internal || false,\n                };\n                const props = object_1.clone(this.prototype.props);\n                props[name] = refined_prop;\n                this.prototype.props = props;\n            }\n        }\n        static internal(obj) {\n            const _object = {};\n            for (const name in obj) {\n                const prop = obj[name];\n                const [type, default_value] = prop;\n                _object[name] = [type, default_value, true];\n            }\n            this.define(_object);\n        }\n        static mixin(...names) {\n            this.define(property_mixins.create(names));\n            const mixins = this.prototype.mixins.concat(names);\n            this.prototype.mixins = mixins;\n        }\n        static mixins(names) {\n            this.mixin(...names);\n        }\n        static override(obj) {\n            for (const name in obj) {\n                const default_value = this._fix_default(obj[name], name);\n                const value = this.prototype.props[name];\n                if (value == null)\n                    throw new Error(`attempted to override nonexistent '${this.prototype.type}.${name}'`);\n                const props = object_1.clone(this.prototype.props);\n                props[name] = Object.assign(Object.assign({}, value), { default_value });\n                this.prototype.props = props;\n            }\n        }\n        toString() {\n            return `${this.type}(${this.id})`;\n        }\n        finalize() {\n            // This is necessary because the initial creation of properties relies on\n            // model.get which is not usable at that point yet in the constructor. This\n            // initializer is called when deferred initialization happens for all models\n            // and insures that the Bokeh properties are initialized from Backbone\n            // attributes in a consistent way.\n            //\n            // TODO (bev) split property creation up into two parts so that only the\n            // portion of init that can be done happens in HasProps constructor and so\n            // that subsequent updates do not duplicate that setup work.\n            for (const name in this.properties) {\n                const prop = this.properties[name];\n                prop.update();\n                if (prop.spec.transform != null)\n                    this.connect(prop.spec.transform.change, () => this.transformchange.emit());\n            }\n            this.initialize();\n            this.connect_signals();\n        }\n        initialize() { }\n        connect_signals() { }\n        disconnect_signals() {\n            signaling_1.Signal.disconnectReceiver(this);\n        }\n        destroy() {\n            this.disconnect_signals();\n            this.destroyed.emit();\n        }\n        // Create a new model with identical attributes to this one.\n        clone() {\n            return new this.constructor(this.attributes);\n        }\n        // Set a hash of model attributes on the object, firing `\"change\"`. This is\n        // the core primitive operation of a model, updating the data and notifying\n        // anyone who needs to know about the change in state. The heart of the beast.\n        _setv(attrs, options) {\n            // Extract attributes and options.\n            const check_eq = options.check_eq;\n            const silent = options.silent;\n            const changes = [];\n            const changing = this._changing;\n            this._changing = true;\n            const current = this.attributes;\n            // For each `set` attribute, update or delete the current value.\n            for (const attr in attrs) {\n                const val = attrs[attr];\n                if (check_eq !== false) {\n                    if (!eq_1.isEqual(current[attr], val))\n                        changes.push(attr);\n                }\n                else\n                    changes.push(attr);\n                current[attr] = val;\n            }\n            // Trigger all relevant attribute changes.\n            if (!silent) {\n                if (changes.length > 0)\n                    this._pending = true;\n                for (let i = 0; i < changes.length; i++)\n                    this.properties[changes[i]].change.emit();\n            }\n            // You might be wondering why there's a `while` loop here. Changes can\n            // be recursively nested within `\"change\"` events.\n            if (changing)\n                return;\n            if (!silent && !options.no_change) {\n                while (this._pending) {\n                    this._pending = false;\n                    this.change.emit();\n                }\n            }\n            this._pending = false;\n            this._changing = false;\n        }\n        setv(attrs, options = {}) {\n            for (const key in attrs) {\n                if (!attrs.hasOwnProperty(key))\n                    continue;\n                const prop_name = key;\n                if (this.props[prop_name] == null)\n                    throw new Error(`property ${this.type}.${prop_name} wasn't declared`);\n                if (!(options != null && options.defaults))\n                    this._set_after_defaults[key] = true;\n            }\n            if (!object_1.isEmpty(attrs)) {\n                const old = {};\n                for (const key in attrs)\n                    old[key] = this.getv(key);\n                this._setv(attrs, options);\n                const silent = options.silent;\n                if (silent == null || !silent) {\n                    for (const key in attrs)\n                        this._tell_document_about_change(key, old[key], this.getv(key), options);\n                }\n            }\n        }\n        getv(prop_name) {\n            if (this.props[prop_name] == null)\n                throw new Error(`property ${this.type}.${prop_name} wasn't declared`);\n            else\n                return this.attributes[prop_name];\n        }\n        ref() {\n            return refs_1.create_ref(this);\n        }\n        // we only keep the subtype so we match Python;\n        // only Python cares about this\n        set_subtype(subtype) {\n            this._subtype = subtype;\n        }\n        attribute_is_serializable(attr) {\n            const prop = this.props[attr];\n            if (prop == null)\n                throw new Error(`${this.type}.attribute_is_serializable('${attr}'): ${attr} wasn't declared`);\n            else\n                return !prop.internal;\n        }\n        // dict of attributes that should be serialized to the server. We\n        // sometimes stick things in attributes that aren't part of the\n        // Document's models, subtypes that do that have to remove their\n        // extra attributes here.\n        serializable_attributes() {\n            const attrs = {};\n            for (const name in this.attributes) {\n                const value = this.attributes[name];\n                if (this.attribute_is_serializable(name))\n                    attrs[name] = value;\n            }\n            return attrs;\n        }\n        static _value_to_json(_key, value, _optional_parent_object) {\n            if (value instanceof HasProps)\n                return value.ref();\n            else if (types_1.isArray(value)) {\n                const ref_array = [];\n                for (let i = 0; i < value.length; i++) {\n                    const v = value[i];\n                    ref_array.push(HasProps._value_to_json(i.toString(), v, value));\n                }\n                return ref_array;\n            }\n            else if (types_1.isPlainObject(value)) {\n                const ref_obj = {};\n                for (const subkey in value) {\n                    if (value.hasOwnProperty(subkey))\n                        ref_obj[subkey] = HasProps._value_to_json(subkey, value[subkey], value);\n                }\n                return ref_obj;\n            }\n            else\n                return value;\n        }\n        // Convert attributes to \"shallow\" JSON (values which are themselves models\n        // are included as just references)\n        attributes_as_json(include_defaults = true, value_to_json = HasProps._value_to_json) {\n            const serializable = this.serializable_attributes();\n            const attrs = {};\n            for (const key in serializable) {\n                if (serializable.hasOwnProperty(key)) {\n                    const value = serializable[key];\n                    if (include_defaults)\n                        attrs[key] = value;\n                    else if (key in this._set_after_defaults)\n                        attrs[key] = value;\n                }\n            }\n            return value_to_json(\"attributes\", attrs, this);\n        }\n        // this is like _value_record_references but expects to find refs\n        // instead of models, and takes a doc to look up the refs in\n        static _json_record_references(doc, v, result, recurse) {\n            if (v == null) {\n            }\n            else if (refs_1.is_ref(v)) {\n                if (!(v.id in result)) {\n                    const model = doc.get_model_by_id(v.id);\n                    HasProps._value_record_references(model, result, recurse);\n                }\n            }\n            else if (types_1.isArray(v)) {\n                for (const elem of v)\n                    HasProps._json_record_references(doc, elem, result, recurse);\n            }\n            else if (types_1.isPlainObject(v)) {\n                for (const k in v) {\n                    if (v.hasOwnProperty(k)) {\n                        const elem = v[k];\n                        HasProps._json_record_references(doc, elem, result, recurse);\n                    }\n                }\n            }\n        }\n        // add all references from 'v' to 'result', if recurse\n        // is true then descend into refs, if false only\n        // descend into non-refs\n        static _value_record_references(v, result, recurse) {\n            if (v == null) {\n            }\n            else if (v instanceof HasProps) {\n                if (!(v.id in result)) {\n                    result[v.id] = v;\n                    if (recurse) {\n                        const immediate = v._immediate_references();\n                        for (const obj of immediate)\n                            HasProps._value_record_references(obj, result, true); // true=recurse\n                    }\n                }\n            }\n            else if (v.buffer instanceof ArrayBuffer) {\n            }\n            else if (types_1.isArray(v)) {\n                for (const elem of v)\n                    HasProps._value_record_references(elem, result, recurse);\n            }\n            else if (types_1.isPlainObject(v)) {\n                for (const k in v) {\n                    if (v.hasOwnProperty(k)) {\n                        const elem = v[k];\n                        HasProps._value_record_references(elem, result, recurse);\n                    }\n                }\n            }\n        }\n        // Get models that are immediately referenced by our properties\n        // (do not recurse, do not include ourselves)\n        _immediate_references() {\n            const result = {};\n            const attrs = this.serializable_attributes();\n            for (const key in attrs) {\n                const value = attrs[key];\n                HasProps._value_record_references(value, result, false); // false = no recurse\n            }\n            return object_1.values(result);\n        }\n        references() {\n            const references = {};\n            HasProps._value_record_references(this, references, true);\n            return object_1.values(references);\n        }\n        _doc_attached() { }\n        attach_document(doc) {\n            // This should only be called by the Document implementation to set the document field\n            if (this.document != null && this.document != doc)\n                throw new Error(\"models must be owned by only a single document\");\n            this.document = doc;\n            this._doc_attached();\n        }\n        detach_document() {\n            // This should only be called by the Document implementation to unset the document field\n            this.document = null;\n        }\n        _tell_document_about_change(attr, old, new_, options) {\n            if (!this.attribute_is_serializable(attr))\n                return;\n            if (this.document != null) {\n                const new_refs = {};\n                HasProps._value_record_references(new_, new_refs, false);\n                const old_refs = {};\n                HasProps._value_record_references(old, old_refs, false);\n                let need_invalidate = false;\n                for (const new_id in new_refs) {\n                    if (!(new_id in old_refs)) {\n                        need_invalidate = true;\n                        break;\n                    }\n                }\n                if (!need_invalidate) {\n                    for (const old_id in old_refs) {\n                        if (!(old_id in new_refs)) {\n                            need_invalidate = true;\n                            break;\n                        }\n                    }\n                }\n                if (need_invalidate)\n                    this.document._invalidate_all_models();\n                this.document._notify_change(this, attr, old, new_, options);\n            }\n        }\n        materialize_dataspecs(source) {\n            // Note: this should be moved to a function separate from HasProps\n            const data = {};\n            for (const name in this.properties) {\n                const prop = this.properties[name];\n                if (!(prop instanceof p.VectorSpec))\n                    continue;\n                // this skips optional properties like radius for circles\n                if (prop.optional && prop.spec.value == null && !(name in this._set_after_defaults))\n                    continue;\n                const array = prop.array(source);\n                data[`_${name}`] = array;\n                // the shapes are indexed by the column name, but when we materialize the dataspec, we should\n                // store under the canonical field name, e.g. _image_shape, even if the column name is \"foo\"\n                if (prop.spec.field != null && prop.spec.field in source._shapes)\n                    data[`_${name}_shape`] = source._shapes[prop.spec.field];\n                if (prop instanceof p.DistanceSpec)\n                    data[`max_${name}`] = array_1.max(array);\n            }\n            return data;\n        }\n    }\n    exports.HasProps = HasProps;\n    HasProps.init_HasProps();\n}\n","/* core/signaling.js */ function _(require, module, exports) {\n    const data_structures_1 = require(14) /* ./util/data_structures */;\n    const callback_1 = require(16) /* ./util/callback */;\n    const array_1 = require(8) /* ./util/array */;\n    class Signal {\n        constructor(sender, name) {\n            this.sender = sender;\n            this.name = name;\n        }\n        connect(slot, context = null) {\n            if (!receiversForSender.has(this.sender)) {\n                receiversForSender.set(this.sender, []);\n            }\n            const receivers = receiversForSender.get(this.sender);\n            if (findConnection(receivers, this, slot, context) != null) {\n                return false;\n            }\n            const receiver = context || slot;\n            if (!sendersForReceiver.has(receiver)) {\n                sendersForReceiver.set(receiver, []);\n            }\n            const senders = sendersForReceiver.get(receiver);\n            const connection = { signal: this, slot, context };\n            receivers.push(connection);\n            senders.push(connection);\n            return true;\n        }\n        disconnect(slot, context = null) {\n            const receivers = receiversForSender.get(this.sender);\n            if (receivers == null || receivers.length === 0) {\n                return false;\n            }\n            const connection = findConnection(receivers, this, slot, context);\n            if (connection == null) {\n                return false;\n            }\n            const receiver = context || slot;\n            const senders = sendersForReceiver.get(receiver);\n            connection.signal = null;\n            scheduleCleanup(receivers);\n            scheduleCleanup(senders);\n            return true;\n        }\n        emit(args) {\n            const receivers = receiversForSender.get(this.sender) || [];\n            for (const { signal, slot, context } of receivers) {\n                if (signal === this) {\n                    slot.call(context, args, this.sender);\n                }\n            }\n        }\n    }\n    exports.Signal = Signal;\n    Signal.__name__ = \"Signal\";\n    class Signal0 extends Signal {\n        emit() {\n            super.emit(undefined);\n        }\n    }\n    exports.Signal0 = Signal0;\n    Signal0.__name__ = \"Signal0\";\n    (function (Signal) {\n        function disconnectBetween(sender, receiver) {\n            const receivers = receiversForSender.get(sender);\n            if (receivers == null || receivers.length === 0)\n                return;\n            const senders = sendersForReceiver.get(receiver);\n            if (senders == null || senders.length === 0)\n                return;\n            for (const connection of senders) {\n                if (connection.signal == null)\n                    return;\n                if (connection.signal.sender === sender)\n                    connection.signal = null;\n            }\n            scheduleCleanup(receivers);\n            scheduleCleanup(senders);\n        }\n        Signal.disconnectBetween = disconnectBetween;\n        function disconnectSender(sender) {\n            const receivers = receiversForSender.get(sender);\n            if (receivers == null || receivers.length === 0)\n                return;\n            for (const connection of receivers) {\n                if (connection.signal == null)\n                    return;\n                const receiver = connection.context || connection.slot;\n                connection.signal = null;\n                scheduleCleanup(sendersForReceiver.get(receiver));\n            }\n            scheduleCleanup(receivers);\n        }\n        Signal.disconnectSender = disconnectSender;\n        function disconnectReceiver(receiver) {\n            const senders = sendersForReceiver.get(receiver);\n            if (senders == null || senders.length === 0)\n                return;\n            for (const connection of senders) {\n                if (connection.signal == null)\n                    return;\n                const sender = connection.signal.sender;\n                connection.signal = null;\n                scheduleCleanup(receiversForSender.get(sender));\n            }\n            scheduleCleanup(senders);\n        }\n        Signal.disconnectReceiver = disconnectReceiver;\n        function disconnectAll(obj) {\n            const receivers = receiversForSender.get(obj);\n            if (receivers != null && receivers.length !== 0) {\n                for (const connection of receivers) {\n                    connection.signal = null;\n                }\n                scheduleCleanup(receivers);\n            }\n            const senders = sendersForReceiver.get(obj);\n            if (senders != null && senders.length !== 0) {\n                for (const connection of senders) {\n                    connection.signal = null;\n                }\n                scheduleCleanup(senders);\n            }\n        }\n        Signal.disconnectAll = disconnectAll;\n    })(Signal = exports.Signal || (exports.Signal = {}));\n    function Signalable(Base) {\n        // XXX: `class Foo extends Signalable(Object)` doesn't work (compiles, but fails at runtime), so\n        // we have to do this to allow signalable classes without an explict base class.\n        if (Base != null) {\n            return class extends Base {\n                connect(signal, slot) {\n                    return signal.connect(slot, this);\n                }\n                disconnect(signal, slot) {\n                    return signal.disconnect(slot, this);\n                }\n            };\n        }\n        else {\n            return class {\n                connect(signal, slot) {\n                    return signal.connect(slot, this);\n                }\n                disconnect(signal, slot) {\n                    return signal.disconnect(slot, this);\n                }\n            };\n        }\n    }\n    exports.Signalable = Signalable;\n    var _Signalable;\n    (function (_Signalable) {\n        function connect(signal, slot) {\n            return signal.connect(slot, this);\n        }\n        _Signalable.connect = connect;\n        function disconnect(signal, slot) {\n            return signal.disconnect(slot, this);\n        }\n        _Signalable.disconnect = disconnect;\n    })(_Signalable = exports._Signalable || (exports._Signalable = {}));\n    const receiversForSender = new WeakMap();\n    const sendersForReceiver = new WeakMap();\n    function findConnection(conns, signal, slot, context) {\n        return array_1.find(conns, conn => conn.signal === signal && conn.slot === slot && conn.context === context);\n    }\n    const dirtySet = new data_structures_1.Set();\n    function scheduleCleanup(connections) {\n        if (dirtySet.size === 0) {\n            callback_1.defer(cleanupDirtySet);\n        }\n        dirtySet.add(connections);\n    }\n    function cleanupDirtySet() {\n        dirtySet.forEach((connections) => {\n            array_1.remove_by(connections, (connection) => connection.signal == null);\n        });\n        dirtySet.clear();\n    }\n}\n","/* core/util/data_structures.js */ function _(require, module, exports) {\n    const array_1 = require(8) /* ./array */;\n    const eq_1 = require(15) /* ./eq */;\n    const types_1 = require(7) /* ./types */;\n    class MultiDict {\n        constructor() {\n            this._dict = {};\n        }\n        _existing(key) {\n            if (key in this._dict)\n                return this._dict[key];\n            else\n                return null;\n        }\n        add_value(key, value) {\n            /*\n            if value == null\n              throw new Error(\"Can't put null in this dict\")\n            if isArray(value)\n              throw new Error(\"Can't put arrays in this dict\")\n            */\n            const existing = this._existing(key);\n            if (existing == null) {\n                this._dict[key] = value;\n            }\n            else if (types_1.isArray(existing)) {\n                existing.push(value);\n            }\n            else {\n                this._dict[key] = [existing, value];\n            }\n        }\n        remove_value(key, value) {\n            const existing = this._existing(key);\n            if (types_1.isArray(existing)) {\n                const new_array = array_1.difference(existing, [value]);\n                if (new_array.length > 0)\n                    this._dict[key] = new_array;\n                else\n                    delete this._dict[key];\n            }\n            else if (eq_1.isEqual(existing, value)) {\n                delete this._dict[key];\n            }\n        }\n        get_one(key, duplicate_error) {\n            const existing = this._existing(key);\n            if (types_1.isArray(existing)) {\n                if (existing.length === 1)\n                    return existing[0];\n                else\n                    throw new Error(duplicate_error);\n            }\n            else\n                return existing;\n        }\n    }\n    exports.MultiDict = MultiDict;\n    MultiDict.__name__ = \"MultiDict\";\n    class Set {\n        constructor(obj) {\n            if (obj == null)\n                this._values = [];\n            else if (obj instanceof Set)\n                this._values = array_1.copy(obj._values);\n            else {\n                this._values = [];\n                for (const item of obj)\n                    this.add(item);\n            }\n        }\n        get values() {\n            return array_1.copy(this._values).sort();\n        }\n        toString() {\n            return `Set([${this.values.join(\",\")}])`;\n        }\n        get size() {\n            return this._values.length;\n        }\n        has(item) {\n            return this._values.indexOf(item) !== -1;\n        }\n        add(item) {\n            if (!this.has(item))\n                this._values.push(item);\n        }\n        remove(item) {\n            const i = this._values.indexOf(item);\n            if (i !== -1)\n                this._values.splice(i, 1);\n        }\n        toggle(item) {\n            const i = this._values.indexOf(item);\n            if (i === -1)\n                this._values.push(item);\n            else\n                this._values.splice(i, 1);\n        }\n        clear() {\n            this._values = [];\n        }\n        union(input) {\n            input = new Set(input);\n            return new Set(this._values.concat(input._values));\n        }\n        intersect(input) {\n            input = new Set(input);\n            const output = new Set();\n            for (const item of input._values) {\n                if (this.has(item) && input.has(item))\n                    output.add(item);\n            }\n            return output;\n        }\n        diff(input) {\n            input = new Set(input);\n            const output = new Set();\n            for (const item of this._values) {\n                if (!input.has(item))\n                    output.add(item);\n            }\n            return output;\n        }\n        forEach(fn, thisArg) {\n            for (const value of this._values) {\n                fn.call(thisArg || this, value, value, this);\n            }\n        }\n    }\n    exports.Set = Set;\n    Set.__name__ = \"Set\";\n    class Matrix {\n        constructor(nrows, ncols, init) {\n            this.nrows = nrows;\n            this.ncols = ncols;\n            this._matrix = new Array(nrows);\n            for (let y = 0; y < nrows; y++) {\n                this._matrix[y] = new Array(ncols);\n                for (let x = 0; x < ncols; x++) {\n                    this._matrix[y][x] = init(y, x);\n                }\n            }\n        }\n        at(row, col) {\n            return this._matrix[row][col];\n        }\n        map(fn) {\n            return new Matrix(this.nrows, this.ncols, (row, col) => fn(this.at(row, col), row, col));\n        }\n        apply(obj) {\n            const fn = Matrix.from(obj);\n            const { nrows, ncols } = this;\n            if (nrows == fn.nrows && ncols == fn.ncols)\n                return new Matrix(nrows, ncols, (row, col) => fn.at(row, col)(this.at(row, col), row, col));\n            else\n                throw new Error(\"dimensions don't match\");\n        }\n        to_sparse() {\n            const items = [];\n            for (let y = 0; y < this.nrows; y++) {\n                for (let x = 0; x < this.ncols; x++) {\n                    const value = this._matrix[y][x];\n                    items.push([value, y, x]);\n                }\n            }\n            return items;\n        }\n        static from(obj) {\n            if (obj instanceof Matrix)\n                return obj;\n            else {\n                const nrows = obj.length;\n                const ncols = array_1.min(obj.map((row) => row.length));\n                return new Matrix(nrows, ncols, (row, col) => obj[row][col]);\n            }\n        }\n    }\n    exports.Matrix = Matrix;\n    Matrix.__name__ = \"Matrix\";\n}\n","/* core/util/eq.js */ function _(require, module, exports) {\n    const types_1 = require(7) /* ./types */;\n    const toString = Object.prototype.toString;\n    // Internal recursive comparison function for `isEqual`.\n    function eq(a, b, aStack, bStack) {\n        // Identical objects are equal. `0 === -0`, but they aren't identical.\n        // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).\n        if (a === b)\n            return a !== 0 || 1 / a === 1 / b;\n        // A strict comparison is necessary because `null == undefined`.\n        if (a == null || b == null)\n            return a === b;\n        // Compare `[[Class]]` names.\n        const className = toString.call(a);\n        if (className !== toString.call(b))\n            return false;\n        switch (className) {\n            // Strings, numbers, regular expressions, dates, and booleans are compared by value.\n            case '[object RegExp]':\n            // RegExps are coerced to strings for comparison (Note: '' + /a/i === '/a/i')\n            case '[object String]':\n                // Primitives and their corresponding object wrappers are equivalent; thus, `\"5\"` is\n                // equivalent to `new String(\"5\")`.\n                return '' + a === '' + b;\n            case '[object Number]':\n                // `NaN`s are equivalent, but non-reflexive.\n                // Object(NaN) is equivalent to NaN\n                if (+a !== +a)\n                    return +b !== +b;\n                // An `egal` comparison is performed for other numeric values.\n                return +a === 0 ? 1 / +a === 1 / b : +a === +b;\n            case '[object Date]':\n            case '[object Boolean]':\n                // Coerce dates and booleans to numeric primitive values. Dates are compared by their\n                // millisecond representations. Note that invalid dates with millisecond representations\n                // of `NaN` are not equivalent.\n                return +a === +b;\n        }\n        const areArrays = className === '[object Array]';\n        if (!areArrays) {\n            if (typeof a != 'object' || typeof b != 'object')\n                return false;\n            // Objects with different constructors are not equivalent, but `Object`s or `Array`s\n            // from different frames are.\n            const aCtor = a.constructor, bCtor = b.constructor;\n            if (aCtor !== bCtor && !(types_1.isFunction(aCtor) && aCtor instanceof aCtor &&\n                types_1.isFunction(bCtor) && bCtor instanceof bCtor)\n                && ('constructor' in a && 'constructor' in b)) {\n                return false;\n            }\n        }\n        // Assume equality for cyclic structures. The algorithm for detecting cyclic\n        // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.\n        // Initializing stack of traversed objects.\n        // It's done here since we only need them for objects and arrays comparison.\n        aStack = aStack || [];\n        bStack = bStack || [];\n        let length = aStack.length;\n        while (length--) {\n            // Linear search. Performance is inversely proportional to the number of\n            // unique nested structures.\n            if (aStack[length] === a)\n                return bStack[length] === b;\n        }\n        // Add the first object to the stack of traversed objects.\n        aStack.push(a);\n        bStack.push(b);\n        // Recursively compare objects and arrays.\n        if (areArrays) {\n            // Compare array lengths to determine if a deep comparison is necessary.\n            length = a.length;\n            if (length !== b.length)\n                return false;\n            // Deep compare the contents, ignoring non-numeric properties.\n            while (length--) {\n                if (!eq(a[length], b[length], aStack, bStack))\n                    return false;\n            }\n        }\n        else {\n            // Deep compare objects.\n            const keys = Object.keys(a);\n            let key;\n            length = keys.length;\n            // Ensure that both objects contain the same number of properties before comparing deep equality.\n            if (Object.keys(b).length !== length)\n                return false;\n            while (length--) {\n                // Deep compare each member\n                key = keys[length];\n                if (!(b.hasOwnProperty(key) && eq(a[key], b[key], aStack, bStack)))\n                    return false;\n            }\n        }\n        // Remove the first object from the stack of traversed objects.\n        aStack.pop();\n        bStack.pop();\n        return true;\n    }\n    // Perform a deep comparison to check if two objects are equal.\n    function isEqual(a, b) {\n        return eq(a, b);\n    }\n    exports.isEqual = isEqual;\n}\n","/* core/util/callback.js */ function _(require, module, exports) {\n    function delay(func, wait) {\n        return setTimeout(func, wait);\n    }\n    exports.delay = delay;\n    const _defer = typeof requestAnimationFrame === \"function\" ? requestAnimationFrame : setImmediate;\n    function defer(func) {\n        return _defer(func);\n    }\n    exports.defer = defer;\n    function throttle(func, wait, options = {}) {\n        let context, args, result;\n        let timeout = null;\n        let previous = 0;\n        const later = function () {\n            previous = options.leading === false ? 0 : Date.now();\n            timeout = null;\n            result = func.apply(context, args);\n            if (!timeout)\n                context = args = null;\n        };\n        return function () {\n            const now = Date.now();\n            if (!previous && options.leading === false)\n                previous = now;\n            const remaining = wait - (now - previous);\n            context = this;\n            args = arguments;\n            if (remaining <= 0 || remaining > wait) {\n                if (timeout) {\n                    clearTimeout(timeout);\n                    timeout = null;\n                }\n                previous = now;\n                result = func.apply(context, args);\n                if (!timeout)\n                    context = args = null;\n            }\n            else if (!timeout && options.trailing !== false) {\n                timeout = setTimeout(later, remaining);\n            }\n            return result;\n        };\n    }\n    exports.throttle = throttle;\n    function once(func) {\n        let done = false;\n        let memo;\n        return function () {\n            if (!done) {\n                done = true;\n                memo = func();\n            }\n            return memo;\n        };\n    }\n    exports.once = once;\n}\n","/* core/property_mixins.js */ function _(require, module, exports) {\n    const p = require(18) /* ./properties */;\n    const object_1 = require(22) /* ./util/object */;\n    function _gen_mixin(mixin, prefix) {\n        const result = {};\n        for (const name in mixin) {\n            const prop = mixin[name];\n            result[prefix + name] = prop;\n        }\n        return result;\n    }\n    const _line_mixin = {\n        line_color: [p.ColorSpec, 'black'],\n        line_width: [p.NumberSpec, 1],\n        line_alpha: [p.NumberSpec, 1.0],\n        line_join: [p.LineJoin, 'bevel'],\n        line_cap: [p.LineCap, 'butt'],\n        line_dash: [p.Array, []],\n        line_dash_offset: [p.Number, 0],\n    };\n    exports.line = (prefix = \"\") => _gen_mixin(_line_mixin, prefix);\n    const _fill_mixin = {\n        fill_color: [p.ColorSpec, 'gray'],\n        fill_alpha: [p.NumberSpec, 1.0],\n    };\n    exports.fill = (prefix = \"\") => _gen_mixin(_fill_mixin, prefix);\n    const _hatch_mixin = {\n        hatch_color: [p.ColorSpec, 'black'],\n        hatch_alpha: [p.NumberSpec, 1.0],\n        hatch_scale: [p.NumberSpec, 12.0],\n        hatch_pattern: [p.StringSpec, null],\n        hatch_weight: [p.NumberSpec, 1.0],\n        hatch_extra: [p.Any, {}],\n    };\n    exports.hatch = (prefix = \"\") => _gen_mixin(_hatch_mixin, prefix);\n    const _text_mixin = {\n        text_font: [p.Font, 'helvetica'],\n        text_font_size: [p.FontSizeSpec, '12pt'],\n        text_font_style: [p.FontStyle, 'normal'],\n        text_color: [p.ColorSpec, '#444444'],\n        text_alpha: [p.NumberSpec, 1.0],\n        text_align: [p.TextAlign, 'left'],\n        text_baseline: [p.TextBaseline, 'bottom'],\n        text_line_height: [p.Number, 1.2],\n    };\n    exports.text = (prefix = \"\") => _gen_mixin(_text_mixin, prefix);\n    function create(configs) {\n        const result = {};\n        for (const config of configs) {\n            const [kind, prefix] = config.split(\":\");\n            let mixin;\n            switch (kind) {\n                case \"line\":\n                    mixin = exports.line;\n                    break;\n                case \"fill\":\n                    mixin = exports.fill;\n                    break;\n                case \"hatch\":\n                    mixin = exports.hatch;\n                    break;\n                case \"text\":\n                    mixin = exports.text;\n                    break;\n                default:\n                    throw new Error(`Unknown property mixin kind '${kind}'`);\n            }\n            object_1.extend(result, mixin(prefix));\n        }\n        return result;\n    }\n    exports.create = create;\n}\n","/* core/properties.js */ function _(require, module, exports) {\n    const signaling_1 = require(13) /* ./signaling */;\n    const enums = require(19) /* ./enums */;\n    const array_1 = require(8) /* ./util/array */;\n    const arrayable_1 = require(11) /* ./util/arrayable */;\n    const color_1 = require(20) /* ./util/color */;\n    const types_1 = require(7) /* ./util/types */;\n    signaling_1.Signal; // XXX: silence TS, because `Signal` appears in declarations due to Signalable\n    function valueToString(value) {\n        try {\n            return JSON.stringify(value);\n        }\n        catch (_a) {\n            return value.toString();\n        }\n    }\n    function isSpec(obj) {\n        return types_1.isPlainObject(obj) &&\n            ((obj.value === undefined ? 0 : 1) +\n                (obj.field === undefined ? 0 : 1) +\n                (obj.expr === undefined ? 0 : 1) == 1); // garbage JS XOR\n    }\n    exports.isSpec = isSpec;\n    class Property extends signaling_1.Signalable() {\n        constructor(obj, attr, default_value) {\n            super();\n            this.obj = obj;\n            this.attr = attr;\n            this.default_value = default_value;\n            this.optional = false;\n            this.change = new signaling_1.Signal0(this.obj, \"change\");\n            this._init();\n            this.connect(this.change, () => this._init());\n        }\n        update() {\n            this._init();\n        }\n        // ----- customizable policies\n        init() { }\n        transform(values) {\n            return values;\n        }\n        validate(value) {\n            if (!this.valid(value))\n                throw new Error(`${this.obj.type}.${this.attr} given invalid value: ${valueToString(value)}`);\n        }\n        valid(_value) {\n            return true;\n        }\n        // ----- property accessors\n        value(do_spec_transform = true) {\n            if (this.spec.value === undefined)\n                throw new Error(\"attempted to retrieve property value for property without value specification\");\n            let ret = this.transform([this.spec.value])[0];\n            if (this.spec.transform != null && do_spec_transform)\n                ret = this.spec.transform.compute(ret);\n            return ret;\n        }\n        // ----- private methods\n        /*protected*/ _init() {\n            const obj = this.obj;\n            const attr = this.attr;\n            let attr_value = obj.getv(attr);\n            if (attr_value === undefined) {\n                const default_value = this.default_value;\n                if (default_value !== undefined)\n                    attr_value = default_value(obj);\n                else\n                    attr_value = null;\n                obj.setv({ [attr]: attr_value }, { silent: true, defaults: true });\n            }\n            if (types_1.isArray(attr_value))\n                this.spec = { value: attr_value };\n            else if (isSpec(attr_value))\n                this.spec = attr_value;\n            else\n                this.spec = { value: attr_value };\n            //if (this.dataspec && this.spec.field != null && !isString(this.spec.field))\n            //  throw new Error(`field value for property '${attr}' is not a string`)\n            if (this.spec.value != null)\n                this.validate(this.spec.value);\n            this.init();\n        }\n        toString() {\n            /*${this.name}*/\n            return `Prop(${this.obj}.${this.attr}, spec: ${valueToString(this.spec)})`;\n        }\n    }\n    exports.Property = Property;\n    Property.__name__ = \"Property\";\n    //\n    // Primitive Properties\n    //\n    class Any extends Property {\n    }\n    exports.Any = Any;\n    Any.__name__ = \"Any\";\n    class Array extends Property {\n        valid(value) {\n            return types_1.isArray(value) || value instanceof Float64Array;\n        }\n    }\n    exports.Array = Array;\n    Array.__name__ = \"Array\";\n    class Boolean extends Property {\n        valid(value) {\n            return types_1.isBoolean(value);\n        }\n    }\n    exports.Boolean = Boolean;\n    Boolean.__name__ = \"Boolean\";\n    class Color extends Property {\n        valid(value) {\n            return types_1.isString(value) && color_1.is_color(value);\n        }\n    }\n    exports.Color = Color;\n    Color.__name__ = \"Color\";\n    class Instance extends Property {\n    }\n    exports.Instance = Instance;\n    Instance.__name__ = \"Instance\";\n    class Number extends Property {\n        valid(value) {\n            return types_1.isNumber(value);\n        }\n    }\n    exports.Number = Number;\n    Number.__name__ = \"Number\";\n    class Int extends Number {\n        valid(value) {\n            return types_1.isNumber(value) && (value | 0) == value;\n        }\n    }\n    exports.Int = Int;\n    Int.__name__ = \"Int\";\n    class Angle extends Number {\n    }\n    exports.Angle = Angle;\n    Angle.__name__ = \"Angle\";\n    class Percent extends Number {\n        valid(value) {\n            return types_1.isNumber(value) && 0 <= value && value <= 1.0;\n        }\n    }\n    exports.Percent = Percent;\n    Percent.__name__ = \"Percent\";\n    class String extends Property {\n        valid(value) {\n            return types_1.isString(value);\n        }\n    }\n    exports.String = String;\n    String.__name__ = \"String\";\n    class FontSize extends String {\n    }\n    exports.FontSize = FontSize;\n    FontSize.__name__ = \"FontSize\";\n    class Font extends String {\n    } // TODO (bev) don't think this exists python side\n    exports.Font = Font;\n    Font.__name__ = \"Font\";\n    //\n    // Enum properties\n    //\n    class EnumProperty extends Property {\n        valid(value) {\n            return types_1.isString(value) && array_1.includes(this.enum_values, value);\n        }\n    }\n    exports.EnumProperty = EnumProperty;\n    EnumProperty.__name__ = \"EnumProperty\";\n    function Enum(values) {\n        return class extends EnumProperty {\n            get enum_values() {\n                return values;\n            }\n        };\n    }\n    exports.Enum = Enum;\n    class Direction extends EnumProperty {\n        get enum_values() {\n            return enums.Direction;\n        }\n        transform(values) {\n            const result = new Uint8Array(values.length);\n            for (let i = 0; i < values.length; i++) {\n                switch (values[i]) {\n                    case \"clock\":\n                        result[i] = 0;\n                        break;\n                    case \"anticlock\":\n                        result[i] = 1;\n                        break;\n                }\n            }\n            return result;\n        }\n    }\n    exports.Direction = Direction;\n    Direction.__name__ = \"Direction\";\n    exports.Anchor = Enum(enums.Anchor);\n    exports.AngleUnits = Enum(enums.AngleUnits);\n    exports.BoxOrigin = Enum(enums.BoxOrigin);\n    exports.ButtonType = Enum(enums.ButtonType);\n    exports.Dimension = Enum(enums.Dimension);\n    exports.Dimensions = Enum(enums.Dimensions);\n    exports.Distribution = Enum(enums.Distribution);\n    exports.FontStyle = Enum(enums.FontStyle);\n    exports.HatchPatternType = Enum(enums.HatchPatternType);\n    exports.HTTPMethod = Enum(enums.HTTPMethod);\n    exports.HexTileOrientation = Enum(enums.HexTileOrientation);\n    exports.HoverMode = Enum(enums.HoverMode);\n    exports.LatLon = Enum(enums.LatLon);\n    exports.LegendClickPolicy = Enum(enums.LegendClickPolicy);\n    exports.LegendLocation = Enum(enums.LegendLocation);\n    exports.LineCap = Enum(enums.LineCap);\n    exports.LineJoin = Enum(enums.LineJoin);\n    exports.LinePolicy = Enum(enums.LinePolicy);\n    exports.Location = Enum(enums.Location);\n    exports.Logo = Enum(enums.Logo);\n    exports.MarkerType = Enum(enums.MarkerType);\n    exports.Orientation = Enum(enums.Orientation);\n    exports.OutputBackend = Enum(enums.OutputBackend);\n    exports.PaddingUnits = Enum(enums.PaddingUnits);\n    exports.Place = Enum(enums.Place);\n    exports.PointPolicy = Enum(enums.PointPolicy);\n    exports.RadiusDimension = Enum(enums.RadiusDimension);\n    exports.RenderLevel = Enum(enums.RenderLevel);\n    exports.RenderMode = Enum(enums.RenderMode);\n    exports.ResetPolicy = Enum(enums.ResetPolicy);\n    exports.RoundingFunction = Enum(enums.RoundingFunction);\n    exports.Side = Enum(enums.Side);\n    exports.SizingMode = Enum(enums.SizingMode);\n    exports.SliderCallbackPolicy = Enum(enums.SliderCallbackPolicy);\n    exports.Sort = Enum(enums.Sort);\n    exports.SpatialUnits = Enum(enums.SpatialUnits);\n    exports.StartEnd = Enum(enums.StartEnd);\n    exports.StepMode = Enum(enums.StepMode);\n    exports.TapBehavior = Enum(enums.TapBehavior);\n    exports.TextAlign = Enum(enums.TextAlign);\n    exports.TextBaseline = Enum(enums.TextBaseline);\n    exports.TextureRepetition = Enum(enums.TextureRepetition);\n    exports.TickLabelOrientation = Enum(enums.TickLabelOrientation);\n    exports.TooltipAttachment = Enum(enums.TooltipAttachment);\n    exports.UpdateMode = Enum(enums.UpdateMode);\n    exports.VerticalAlign = Enum(enums.VerticalAlign);\n    //\n    // DataSpec properties\n    //\n    class ScalarSpec extends Property {\n    }\n    exports.ScalarSpec = ScalarSpec;\n    ScalarSpec.__name__ = \"ScalarSpec\";\n    class VectorSpec extends Property {\n        array(source) {\n            let ret;\n            if (this.spec.field != null) {\n                ret = this.transform(source.get_column(this.spec.field));\n                if (ret == null)\n                    throw new Error(`attempted to retrieve property array for nonexistent field '${this.spec.field}'`);\n            }\n            else if (this.spec.expr != null) {\n                ret = this.transform(this.spec.expr.v_compute(source));\n            }\n            else {\n                let length = source.get_length();\n                if (length == null)\n                    length = 1;\n                const value = this.value(false); // don't apply any spec transform\n                ret = array_1.repeat(value, length);\n            }\n            if (this.spec.transform != null)\n                ret = this.spec.transform.v_compute(ret);\n            return ret;\n        }\n    }\n    exports.VectorSpec = VectorSpec;\n    VectorSpec.__name__ = \"VectorSpec\";\n    class DataSpec extends VectorSpec {\n    }\n    exports.DataSpec = DataSpec;\n    DataSpec.__name__ = \"DataSpec\";\n    class UnitsSpec extends VectorSpec {\n        init() {\n            if (this.spec.units == null)\n                this.spec.units = this.default_units;\n            const units = this.spec.units;\n            if (!array_1.includes(this.valid_units, units))\n                throw new Error(`units must be one of ${this.valid_units.join(\", \")}; got: ${units}`);\n        }\n        get units() {\n            return this.spec.units;\n        }\n        set units(units) {\n            this.spec.units = units;\n        }\n    }\n    exports.UnitsSpec = UnitsSpec;\n    UnitsSpec.__name__ = \"UnitsSpec\";\n    class AngleSpec extends UnitsSpec {\n        get default_units() { return \"rad\"; }\n        get valid_units() { return enums.AngleUnits; }\n        transform(values) {\n            if (this.spec.units == \"deg\")\n                values = arrayable_1.map(values, (x) => x * Math.PI / 180.0);\n            values = arrayable_1.map(values, (x) => -x);\n            return super.transform(values);\n        }\n    }\n    exports.AngleSpec = AngleSpec;\n    AngleSpec.__name__ = \"AngleSpec\";\n    class BooleanSpec extends DataSpec {\n    }\n    exports.BooleanSpec = BooleanSpec;\n    BooleanSpec.__name__ = \"BooleanSpec\";\n    class ColorSpec extends DataSpec {\n    }\n    exports.ColorSpec = ColorSpec;\n    ColorSpec.__name__ = \"ColorSpec\";\n    class CoordinateSpec extends DataSpec {\n    }\n    exports.CoordinateSpec = CoordinateSpec;\n    CoordinateSpec.__name__ = \"CoordinateSpec\";\n    class CoordinateSeqSpec extends DataSpec {\n    }\n    exports.CoordinateSeqSpec = CoordinateSeqSpec;\n    CoordinateSeqSpec.__name__ = \"CoordinateSeqSpec\";\n    class DistanceSpec extends UnitsSpec {\n        get default_units() { return \"data\"; }\n        get valid_units() { return enums.SpatialUnits; }\n    }\n    exports.DistanceSpec = DistanceSpec;\n    DistanceSpec.__name__ = \"DistanceSpec\";\n    class FontSizeSpec extends DataSpec {\n    }\n    exports.FontSizeSpec = FontSizeSpec;\n    FontSizeSpec.__name__ = \"FontSizeSpec\";\n    class MarkerSpec extends DataSpec {\n    }\n    exports.MarkerSpec = MarkerSpec;\n    MarkerSpec.__name__ = \"MarkerSpec\";\n    class NumberSpec extends DataSpec {\n    }\n    exports.NumberSpec = NumberSpec;\n    NumberSpec.__name__ = \"NumberSpec\";\n    class StringSpec extends DataSpec {\n    }\n    exports.StringSpec = StringSpec;\n    StringSpec.__name__ = \"StringSpec\";\n    class NullStringSpec extends DataSpec {\n    }\n    exports.NullStringSpec = NullStringSpec;\n    NullStringSpec.__name__ = \"NullStringSpec\";\n}\n","/* core/enums.js */ function _(require, module, exports) {\n    exports.Align = [\"start\", \"center\", \"end\"];\n    exports.Anchor = [\n        \"top_left\", \"top_center\", \"top_right\",\n        \"center_left\", \"center\", \"center_right\",\n        \"bottom_left\", \"bottom_center\", \"bottom_right\",\n    ];\n    exports.AngleUnits = [\"deg\", \"rad\"];\n    exports.BoxOrigin = [\"corner\", \"center\"];\n    exports.ButtonType = [\"default\", \"primary\", \"success\", \"warning\", \"danger\"];\n    exports.Dimension = [\"width\", \"height\"];\n    exports.Dimensions = [\"width\", \"height\", \"both\"];\n    exports.Direction = [\"clock\", \"anticlock\"];\n    exports.Distribution = [\"uniform\", \"normal\"];\n    exports.FontStyle = [\"normal\", \"italic\", \"bold\", \"bold italic\"];\n    exports.HatchPatternType = [\n        'blank', 'dot', 'ring', 'horizontal_line', 'vertical_line', 'cross', 'horizontal_dash',\n        'vertical_dash', 'spiral', 'right_diagonal_line', 'left_diagonal_line', 'diagonal_cross',\n        'right_diagonal_dash', 'left_diagonal_dash', 'horizontal_wave', 'vertical_wave', 'criss_cross',\n        ' ', '.', 'o', '-', '|', '+', '\"', ':', '@', '/', '\\\\', 'x', ',', '`', 'v', '>', '*',\n    ];\n    exports.HTTPMethod = [\"POST\", \"GET\"];\n    exports.HexTileOrientation = [\"pointytop\", \"flattop\"];\n    exports.HoverMode = [\"mouse\", \"hline\", \"vline\"];\n    exports.LatLon = [\"lat\", \"lon\"];\n    exports.LegendClickPolicy = [\"none\", \"hide\", \"mute\"];\n    exports.LegendLocation = exports.Anchor;\n    exports.LineCap = [\"butt\", \"round\", \"square\"];\n    exports.LineJoin = [\"miter\", \"round\", \"bevel\"];\n    exports.LinePolicy = [\"prev\", \"next\", \"nearest\", \"interp\", \"none\"];\n    exports.Location = [\"above\", \"below\", \"left\", \"right\"];\n    exports.Logo = [\"normal\", \"grey\"];\n    exports.MarkerType = [\n        \"asterisk\", \"circle\", \"circle_cross\", \"circle_x\", \"cross\",\n        \"dash\", \"diamond\", \"diamond_cross\", \"hex\", \"inverted_triangle\",\n        \"square\", \"square_cross\", \"square_x\", \"triangle\", \"x\",\n    ];\n    exports.Orientation = [\"vertical\", \"horizontal\"];\n    exports.OutputBackend = [\"canvas\", \"svg\", \"webgl\"];\n    exports.PaddingUnits = [\"percent\", \"absolute\"];\n    exports.Place = [\"above\", \"below\", \"left\", \"right\", \"center\"];\n    exports.PointPolicy = [\"snap_to_data\", \"follow_mouse\", \"none\"];\n    exports.RadiusDimension = [\"x\", \"y\", \"max\", \"min\"];\n    exports.RenderLevel = [\"image\", \"underlay\", \"glyph\", \"annotation\", \"overlay\"];\n    exports.RenderMode = [\"canvas\", \"css\"];\n    exports.ResetPolicy = [\"standard\", \"event_only\"];\n    exports.RoundingFunction = [\"round\", \"nearest\", \"floor\", \"rounddown\", \"ceil\", \"roundup\"];\n    exports.Side = [\"above\", \"below\", \"left\", \"right\"];\n    exports.SizingMode = [\"stretch_width\", \"stretch_height\", \"stretch_both\", \"scale_width\", \"scale_height\", \"scale_both\", \"fixed\"];\n    exports.SliderCallbackPolicy = [\"continuous\", \"throttle\", \"mouseup\"];\n    exports.Sort = [\"ascending\", \"descending\"];\n    exports.SpatialUnits = [\"screen\", \"data\"];\n    exports.StartEnd = [\"start\", \"end\"];\n    exports.StepMode = [\"after\", \"before\", \"center\"];\n    exports.TapBehavior = [\"select\", \"inspect\"];\n    exports.TextAlign = [\"left\", \"right\", \"center\"];\n    exports.TextBaseline = [\"top\", \"middle\", \"bottom\", \"alphabetic\", \"hanging\", \"ideographic\"];\n    exports.TextureRepetition = [\"repeat\", \"repeat_x\", \"repeat_y\", \"no_repeat\"];\n    exports.TickLabelOrientation = [\"vertical\", \"horizontal\", \"parallel\", \"normal\"];\n    exports.TooltipAttachment = [\"horizontal\", \"vertical\", \"left\", \"right\", \"above\", \"below\"];\n    exports.UpdateMode = [\"replace\", \"append\"];\n    exports.VerticalAlign = [\"top\", \"middle\", \"bottom\"];\n}\n","/* core/util/color.js */ function _(require, module, exports) {\n    const svg_colors_1 = require(21) /* ./svg_colors */;\n    const array_1 = require(8) /* ./array */;\n    function is_color(value) {\n        return svg_colors_1.is_svg_color(value.toLowerCase()) || value.substring(0, 1) == \"#\" || valid_rgb(value);\n    }\n    exports.is_color = is_color;\n    function _component2hex(v) {\n        const h = Number(v).toString(16);\n        return h.length == 1 ? `0${h}` : h;\n    }\n    function rgb2hex(r, g, b) {\n        const R = _component2hex(r & 0xFF);\n        const G = _component2hex(g & 0xFF);\n        const B = _component2hex(b & 0xFF);\n        return `#${R}${G}${B}`;\n    }\n    exports.rgb2hex = rgb2hex;\n    function color2hex(color) {\n        color = color + '';\n        if (color.indexOf('#') == 0)\n            return color;\n        else if (svg_colors_1.is_svg_color(color))\n            return svg_colors_1.svg_colors[color];\n        else if (color.indexOf('rgb') == 0) {\n            const rgb = color.replace(/^rgba?\\(|\\s+|\\)$/g, '').split(',');\n            let hex = rgb.slice(0, 3).map(_component2hex).join('');\n            if (rgb.length == 4)\n                hex += _component2hex(Math.floor(parseFloat(rgb[3]) * 255));\n            return `#${hex.slice(0, 8)}`; // can also be rgba\n        }\n        else\n            return color;\n    }\n    exports.color2hex = color2hex;\n    function color2rgba(color, alpha = 1.0) {\n        if (!color) // NaN, null, '', etc.\n            return [0, 0, 0, 0]; // transparent\n        // Convert to hex and then to clean version of 6 or 8 chars\n        let hex = color2hex(color);\n        hex = hex.replace(/ |#/g, '');\n        if (hex.length <= 4) {\n            hex = hex.replace(/(.)/g, '$1$1');\n        }\n        // Convert pairs to numbers\n        const rgba = hex.match(/../g).map((i) => parseInt(i, 16) / 255);\n        // Ensure correct length, add alpha if necessary\n        while (rgba.length < 3)\n            rgba.push(0);\n        if (rgba.length < 4)\n            rgba.push(alpha);\n        return rgba.slice(0, 4);\n    }\n    exports.color2rgba = color2rgba;\n    function valid_rgb(value) {\n        let params;\n        switch (value.substring(0, 4)) {\n            case \"rgba\": {\n                params = { start: \"rgba(\", len: 4, alpha: true };\n                break;\n            }\n            case \"rgb(\": {\n                params = { start: \"rgb(\", len: 3, alpha: false };\n                break;\n            }\n            default:\n                return false;\n        }\n        // if '.' and then ',' found, we know decimals are used on rgb\n        if (new RegExp(\".*?(\\\\.).*(,)\").test(value))\n            throw new Error(`color expects integers for rgb in rgb/rgba tuple, received ${value}`);\n        // extract the numerical values from inside parens\n        const contents = value.replace(params.start, \"\").replace(\")\", \"\").split(',').map(parseFloat);\n        // check length of array based on rgb/rgba\n        if (contents.length != params.len)\n            throw new Error(`color expects rgba ${params.len}-tuple, received ${value}`);\n        // check for valid numerical values for rgba\n        if (params.alpha && !(0 <= contents[3] && contents[3] <= 1))\n            throw new Error(\"color expects rgba 4-tuple to have alpha value between 0 and 1\");\n        if (array_1.includes(contents.slice(0, 3).map((rgb) => 0 <= rgb && rgb <= 255), false))\n            throw new Error(\"color expects rgb to have value between 0 and 255\");\n        return true;\n    }\n    exports.valid_rgb = valid_rgb;\n}\n","/* core/util/svg_colors.js */ function _(require, module, exports) {\n    exports.svg_colors = {\n        indianred: \"#CD5C5C\",\n        lightcoral: \"#F08080\",\n        salmon: \"#FA8072\",\n        darksalmon: \"#E9967A\",\n        lightsalmon: \"#FFA07A\",\n        crimson: \"#DC143C\",\n        red: \"#FF0000\",\n        firebrick: \"#B22222\",\n        darkred: \"#8B0000\",\n        pink: \"#FFC0CB\",\n        lightpink: \"#FFB6C1\",\n        hotpink: \"#FF69B4\",\n        deeppink: \"#FF1493\",\n        mediumvioletred: \"#C71585\",\n        palevioletred: \"#DB7093\",\n        coral: \"#FF7F50\",\n        tomato: \"#FF6347\",\n        orangered: \"#FF4500\",\n        darkorange: \"#FF8C00\",\n        orange: \"#FFA500\",\n        gold: \"#FFD700\",\n        yellow: \"#FFFF00\",\n        lightyellow: \"#FFFFE0\",\n        lemonchiffon: \"#FFFACD\",\n        lightgoldenrodyellow: \"#FAFAD2\",\n        papayawhip: \"#FFEFD5\",\n        moccasin: \"#FFE4B5\",\n        peachpuff: \"#FFDAB9\",\n        palegoldenrod: \"#EEE8AA\",\n        khaki: \"#F0E68C\",\n        darkkhaki: \"#BDB76B\",\n        lavender: \"#E6E6FA\",\n        thistle: \"#D8BFD8\",\n        plum: \"#DDA0DD\",\n        violet: \"#EE82EE\",\n        orchid: \"#DA70D6\",\n        fuchsia: \"#FF00FF\",\n        magenta: \"#FF00FF\",\n        mediumorchid: \"#BA55D3\",\n        mediumpurple: \"#9370DB\",\n        blueviolet: \"#8A2BE2\",\n        darkviolet: \"#9400D3\",\n        darkorchid: \"#9932CC\",\n        darkmagenta: \"#8B008B\",\n        purple: \"#800080\",\n        indigo: \"#4B0082\",\n        slateblue: \"#6A5ACD\",\n        darkslateblue: \"#483D8B\",\n        mediumslateblue: \"#7B68EE\",\n        greenyellow: \"#ADFF2F\",\n        chartreuse: \"#7FFF00\",\n        lawngreen: \"#7CFC00\",\n        lime: \"#00FF00\",\n        limegreen: \"#32CD32\",\n        palegreen: \"#98FB98\",\n        lightgreen: \"#90EE90\",\n        mediumspringgreen: \"#00FA9A\",\n        springgreen: \"#00FF7F\",\n        mediumseagreen: \"#3CB371\",\n        seagreen: \"#2E8B57\",\n        forestgreen: \"#228B22\",\n        green: \"#008000\",\n        darkgreen: \"#006400\",\n        yellowgreen: \"#9ACD32\",\n        olivedrab: \"#6B8E23\",\n        olive: \"#808000\",\n        darkolivegreen: \"#556B2F\",\n        mediumaquamarine: \"#66CDAA\",\n        darkseagreen: \"#8FBC8F\",\n        lightseagreen: \"#20B2AA\",\n        darkcyan: \"#008B8B\",\n        teal: \"#008080\",\n        aqua: \"#00FFFF\",\n        cyan: \"#00FFFF\",\n        lightcyan: \"#E0FFFF\",\n        paleturquoise: \"#AFEEEE\",\n        aquamarine: \"#7FFFD4\",\n        turquoise: \"#40E0D0\",\n        mediumturquoise: \"#48D1CC\",\n        darkturquoise: \"#00CED1\",\n        cadetblue: \"#5F9EA0\",\n        steelblue: \"#4682B4\",\n        lightsteelblue: \"#B0C4DE\",\n        powderblue: \"#B0E0E6\",\n        lightblue: \"#ADD8E6\",\n        skyblue: \"#87CEEB\",\n        lightskyblue: \"#87CEFA\",\n        deepskyblue: \"#00BFFF\",\n        dodgerblue: \"#1E90FF\",\n        cornflowerblue: \"#6495ED\",\n        royalblue: \"#4169E1\",\n        blue: \"#0000FF\",\n        mediumblue: \"#0000CD\",\n        darkblue: \"#00008B\",\n        navy: \"#000080\",\n        midnightblue: \"#191970\",\n        cornsilk: \"#FFF8DC\",\n        blanchedalmond: \"#FFEBCD\",\n        bisque: \"#FFE4C4\",\n        navajowhite: \"#FFDEAD\",\n        wheat: \"#F5DEB3\",\n        burlywood: \"#DEB887\",\n        tan: \"#D2B48C\",\n        rosybrown: \"#BC8F8F\",\n        sandybrown: \"#F4A460\",\n        goldenrod: \"#DAA520\",\n        darkgoldenrod: \"#B8860B\",\n        peru: \"#CD853F\",\n        chocolate: \"#D2691E\",\n        saddlebrown: \"#8B4513\",\n        sienna: \"#A0522D\",\n        brown: \"#A52A2A\",\n        maroon: \"#800000\",\n        white: \"#FFFFFF\",\n        snow: \"#FFFAFA\",\n        honeydew: \"#F0FFF0\",\n        mintcream: \"#F5FFFA\",\n        azure: \"#F0FFFF\",\n        aliceblue: \"#F0F8FF\",\n        ghostwhite: \"#F8F8FF\",\n        whitesmoke: \"#F5F5F5\",\n        seashell: \"#FFF5EE\",\n        beige: \"#F5F5DC\",\n        oldlace: \"#FDF5E6\",\n        floralwhite: \"#FFFAF0\",\n        ivory: \"#FFFFF0\",\n        antiquewhite: \"#FAEBD7\",\n        linen: \"#FAF0E6\",\n        lavenderblush: \"#FFF0F5\",\n        mistyrose: \"#FFE4E1\",\n        gainsboro: \"#DCDCDC\",\n        lightgray: \"#D3D3D3\",\n        lightgrey: \"#D3D3D3\",\n        silver: \"#C0C0C0\",\n        darkgray: \"#A9A9A9\",\n        darkgrey: \"#A9A9A9\",\n        gray: \"#808080\",\n        grey: \"#808080\",\n        dimgray: \"#696969\",\n        dimgrey: \"#696969\",\n        lightslategray: \"#778899\",\n        lightslategrey: \"#778899\",\n        slategray: \"#708090\",\n        slategrey: \"#708090\",\n        darkslategray: \"#2F4F4F\",\n        darkslategrey: \"#2F4F4F\",\n        black: \"#000000\",\n    };\n    function is_svg_color(color) {\n        return color in exports.svg_colors;\n    }\n    exports.is_svg_color = is_svg_color;\n}\n","/* core/util/object.js */ function _(require, module, exports) {\n    const tslib_1 = require(23) /* tslib */;\n    const array_1 = require(8) /* ./array */;\n    exports.keys = Object.keys;\n    function values(object) {\n        const keys = Object.keys(object);\n        const length = keys.length;\n        const values = new Array(length);\n        for (let i = 0; i < length; i++) {\n            values[i] = object[keys[i]];\n        }\n        return values;\n    }\n    exports.values = values;\n    function extend(dest, src) {\n        return tslib_1.__assign(dest, src);\n    }\n    exports.extend = extend;\n    function clone(obj) {\n        return extend({}, obj); // XXX: can't use {...obj} due to https://github.com/Microsoft/TypeScript/issues/14409\n    }\n    exports.clone = clone;\n    function merge(obj1, obj2) {\n        /*\n         * Returns an object with the array values for obj1 and obj2 unioned by key.\n         */\n        const result = Object.create(Object.prototype);\n        const keys = array_1.concat([Object.keys(obj1), Object.keys(obj2)]);\n        for (const key of keys) {\n            const arr1 = obj1.hasOwnProperty(key) ? obj1[key] : [];\n            const arr2 = obj2.hasOwnProperty(key) ? obj2[key] : [];\n            result[key] = array_1.union(arr1, arr2);\n        }\n        return result;\n    }\n    exports.merge = merge;\n    function size(obj) {\n        return Object.keys(obj).length;\n    }\n    exports.size = size;\n    function isEmpty(obj) {\n        return size(obj) === 0;\n    }\n    exports.isEmpty = isEmpty;\n}\n","/* tslib/tslib.js */ function _(require, module, exports) {\n    /*! *****************************************************************************\n    Copyright (c) Microsoft Corporation. All rights reserved.\n    Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use\n    this file except in compliance with the License. You may obtain a copy of the\n    License at http://www.apache.org/licenses/LICENSE-2.0\n    \n    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\n    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\n    MERCHANTABLITY OR NON-INFRINGEMENT.\n    \n    See the Apache Version 2.0 License for specific language governing permissions\n    and limitations under the License.\n    ***************************************************************************** */\n    /* global global, define, System, Reflect, Promise */\n    var __extends;\n    var __assign;\n    var __rest;\n    var __decorate;\n    var __param;\n    var __metadata;\n    var __awaiter;\n    var __generator;\n    var __exportStar;\n    var __values;\n    var __read;\n    var __spread;\n    var __spreadArrays;\n    var __await;\n    var __asyncGenerator;\n    var __asyncDelegator;\n    var __asyncValues;\n    var __makeTemplateObject;\n    var __importStar;\n    var __importDefault;\n    (function (factory) {\n        var root = typeof global === \"object\" ? global : typeof self === \"object\" ? self : typeof this === \"object\" ? this : {};\n        if (typeof define === \"function\" && define.amd) {\n            define(\"tslib\", [\"exports\"], function (exports) { factory(createExporter(root, createExporter(exports))); });\n        }\n        else if (typeof module === \"object\" && typeof module.exports === \"object\") {\n            factory(createExporter(root, createExporter(module.exports)));\n        }\n        else {\n            factory(createExporter(root));\n        }\n        function createExporter(exports, previous) {\n            if (exports !== root) {\n                if (typeof Object.create === \"function\") {\n                    Object.defineProperty(exports, \"__esModule\", { value: true });\n                }\n                else {\n                    exports.__esModule = true;\n                }\n            }\n            return function (id, v) { return exports[id] = previous ? previous(id, v) : v; };\n        }\n    })(function (exporter) {\n        var extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b)\n                if (b.hasOwnProperty(p))\n                    d[p] = b[p]; };\n        __extends = function (d, b) {\n            extendStatics(d, b);\n            function __() { this.constructor = d; }\n            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n        };\n        __assign = Object.assign || function (t) {\n            for (var s, i = 1, n = arguments.length; i < n; i++) {\n                s = arguments[i];\n                for (var p in s)\n                    if (Object.prototype.hasOwnProperty.call(s, p))\n                        t[p] = s[p];\n            }\n            return t;\n        };\n        __rest = function (s, e) {\n            var t = {};\n            for (var p in s)\n                if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n                    t[p] = s[p];\n            if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n                for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n                    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n                        t[p[i]] = s[p[i]];\n                }\n            return t;\n        };\n        __decorate = function (decorators, target, key, desc) {\n            var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n            if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\")\n                r = Reflect.decorate(decorators, target, key, desc);\n            else\n                for (var i = decorators.length - 1; i >= 0; i--)\n                    if (d = decorators[i])\n                        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n            return c > 3 && r && Object.defineProperty(target, key, r), r;\n        };\n        __param = function (paramIndex, decorator) {\n            return function (target, key) { decorator(target, key, paramIndex); };\n        };\n        __metadata = function (metadataKey, metadataValue) {\n            if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\")\n                return Reflect.metadata(metadataKey, metadataValue);\n        };\n        __awaiter = function (thisArg, _arguments, P, generator) {\n            return new (P || (P = Promise))(function (resolve, reject) {\n                function fulfilled(value) { try {\n                    step(generator.next(value));\n                }\n                catch (e) {\n                    reject(e);\n                } }\n                function rejected(value) { try {\n                    step(generator[\"throw\"](value));\n                }\n                catch (e) {\n                    reject(e);\n                } }\n                function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n                step((generator = generator.apply(thisArg, _arguments || [])).next());\n            });\n        };\n        __generator = function (thisArg, body) {\n            var _ = { label: 0, sent: function () { if (t[0] & 1)\n                    throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n            return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () { return this; }), g;\n            function verb(n) { return function (v) { return step([n, v]); }; }\n            function step(op) {\n                if (f)\n                    throw new TypeError(\"Generator is already executing.\");\n                while (_)\n                    try {\n                        if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)\n                            return t;\n                        if (y = 0, t)\n                            op = [op[0] & 2, t.value];\n                        switch (op[0]) {\n                            case 0:\n                            case 1:\n                                t = op;\n                                break;\n                            case 4:\n                                _.label++;\n                                return { value: op[1], done: false };\n                            case 5:\n                                _.label++;\n                                y = op[1];\n                                op = [0];\n                                continue;\n                            case 7:\n                                op = _.ops.pop();\n                                _.trys.pop();\n                                continue;\n                            default:\n                                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n                                    _ = 0;\n                                    continue;\n                                }\n                                if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) {\n                                    _.label = op[1];\n                                    break;\n                                }\n                                if (op[0] === 6 && _.label < t[1]) {\n                                    _.label = t[1];\n                                    t = op;\n                                    break;\n                                }\n                                if (t && _.label < t[2]) {\n                                    _.label = t[2];\n                                    _.ops.push(op);\n                                    break;\n                                }\n                                if (t[2])\n                                    _.ops.pop();\n                                _.trys.pop();\n                                continue;\n                        }\n                        op = body.call(thisArg, _);\n                    }\n                    catch (e) {\n                        op = [6, e];\n                        y = 0;\n                    }\n                    finally {\n                        f = t = 0;\n                    }\n                if (op[0] & 5)\n                    throw op[1];\n                return { value: op[0] ? op[1] : void 0, done: true };\n            }\n        };\n        __exportStar = function (m, exports) {\n            for (var p in m)\n                if (!exports.hasOwnProperty(p))\n                    exports[p] = m[p];\n        };\n        __values = function (o) {\n            var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\n            if (m)\n                return m.call(o);\n            return {\n                next: function () {\n                    if (o && i >= o.length)\n                        o = void 0;\n                    return { value: o && o[i++], done: !o };\n                }\n            };\n        };\n        __read = function (o, n) {\n            var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n            if (!m)\n                return o;\n            var i = m.call(o), r, ar = [], e;\n            try {\n                while ((n === void 0 || n-- > 0) && !(r = i.next()).done)\n                    ar.push(r.value);\n            }\n            catch (error) {\n                e = { error: error };\n            }\n            finally {\n                try {\n                    if (r && !r.done && (m = i[\"return\"]))\n                        m.call(i);\n                }\n                finally {\n                    if (e)\n                        throw e.error;\n                }\n            }\n            return ar;\n        };\n        __spread = function () {\n            for (var ar = [], i = 0; i < arguments.length; i++)\n                ar = ar.concat(__read(arguments[i]));\n            return ar;\n        };\n        __spreadArrays = function () {\n            for (var s = 0, i = 0, il = arguments.length; i < il; i++)\n                s += arguments[i].length;\n            for (var r = Array(s), k = 0, i = 0; i < il; i++)\n                for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\n                    r[k] = a[j];\n            return r;\n        };\n        __await = function (v) {\n            return this instanceof __await ? (this.v = v, this) : new __await(v);\n        };\n        __asyncGenerator = function (thisArg, _arguments, generator) {\n            if (!Symbol.asyncIterator)\n                throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n            var g = generator.apply(thisArg, _arguments || []), i, q = [];\n            return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\n            function verb(n) { if (g[n])\n                i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\n            function resume(n, v) { try {\n                step(g[n](v));\n            }\n            catch (e) {\n                settle(q[0][3], e);\n            } }\n            function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\n            function fulfill(value) { resume(\"next\", value); }\n            function reject(value) { resume(\"throw\", value); }\n            function settle(f, v) { if (f(v), q.shift(), q.length)\n                resume(q[0][0], q[0][1]); }\n        };\n        __asyncDelegator = function (o) {\n            var i, p;\n            return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\n            function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\n        };\n        __asyncValues = function (o) {\n            if (!Symbol.asyncIterator)\n                throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n            var m = o[Symbol.asyncIterator], i;\n            return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\n            function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\n            function settle(resolve, reject, d, v) { Promise.resolve(v).then(function (v) { resolve({ value: v, done: d }); }, reject); }\n        };\n        __makeTemplateObject = function (cooked, raw) {\n            if (Object.defineProperty) {\n                Object.defineProperty(cooked, \"raw\", { value: raw });\n            }\n            else {\n                cooked.raw = raw;\n            }\n            return cooked;\n        };\n        __importStar = function (mod) {\n            if (mod && mod.__esModule)\n                return mod;\n            var result = {};\n            if (mod != null)\n                for (var k in mod)\n                    if (Object.hasOwnProperty.call(mod, k))\n                        result[k] = mod[k];\n            result[\"default\"] = mod;\n            return result;\n        };\n        __importDefault = function (mod) {\n            return (mod && mod.__esModule) ? mod : { \"default\": mod };\n        };\n        exporter(\"__extends\", __extends);\n        exporter(\"__assign\", __assign);\n        exporter(\"__rest\", __rest);\n        exporter(\"__decorate\", __decorate);\n        exporter(\"__param\", __param);\n        exporter(\"__metadata\", __metadata);\n        exporter(\"__awaiter\", __awaiter);\n        exporter(\"__generator\", __generator);\n        exporter(\"__exportStar\", __exportStar);\n        exporter(\"__values\", __values);\n        exporter(\"__read\", __read);\n        exporter(\"__spread\", __spread);\n        exporter(\"__spreadArrays\", __spreadArrays);\n        exporter(\"__await\", __await);\n        exporter(\"__asyncGenerator\", __asyncGenerator);\n        exporter(\"__asyncDelegator\", __asyncDelegator);\n        exporter(\"__asyncValues\", __asyncValues);\n        exporter(\"__makeTemplateObject\", __makeTemplateObject);\n        exporter(\"__importStar\", __importStar);\n        exporter(\"__importDefault\", __importDefault);\n    });\n}\n","/* core/util/refs.js */ function _(require, module, exports) {\n    const types_1 = require(7) /* ./types */;\n    // Create a Bokeh reference from a HasProps subclass\n    //\n    // @param obj [HasProps] the object to create a reference for\n    // @return [Object] a Bokeh reference for `obj`\n    // @throw Error if `obj` is not a HasProps\n    //\n    function create_ref(obj) {\n        const ref = {\n            type: obj.type,\n            id: obj.id,\n        };\n        if (obj._subtype != null) {\n            ref.subtype = obj._subtype;\n        }\n        return ref;\n    }\n    exports.create_ref = create_ref;\n    // Determine whether an object has the proper format of a Bokeh reference\n    //\n    // @param arg [Object] the object to test\n    // @return [bool] whether the object is a reference\n    //\n    // @note this function does not check that the id and types are valid,\n    //   only that the format is correct (all required keys are present)\n    //\n    function is_ref(arg) {\n        if (types_1.isObject(arg)) {\n            const keys = Object.keys(arg).sort();\n            if (keys.length == 2)\n                return keys[0] == 'id' && keys[1] == 'type';\n            if (keys.length == 3)\n                return keys[0] == 'id' && keys[1] == 'subtype' && keys[2] == 'type';\n        }\n        return false;\n    }\n    exports.is_ref = is_ref;\n}\n","/* core/util/string.js */ function _(require, module, exports) {\n    const settings_1 = require(26) /* ../settings */;\n    function startsWith(str, searchString, position = 0) {\n        return str.substr(position, searchString.length) == searchString;\n    }\n    exports.startsWith = startsWith;\n    function uuid4() {\n        // from ipython project\n        // http://www.ietf.org/rfc/rfc4122.txt\n        const s = new Array(32);\n        const hexDigits = \"0123456789ABCDEF\";\n        for (let i = 0; i < 32; i++) {\n            s[i] = hexDigits.substr(Math.floor(Math.random() * 0x10), 1);\n        }\n        s[12] = \"4\"; // bits 12-15 of the time_hi_and_version field to 0010\n        s[16] = hexDigits.substr((s[16].charCodeAt(0) & 0x3) | 0x8, 1); // bits 6-7 of the clock_seq_hi_and_reserved to 01\n        return s.join(\"\");\n    }\n    exports.uuid4 = uuid4;\n    let counter = 1000;\n    function uniqueId(prefix) {\n        const id = settings_1.settings.dev ? `j${counter++}` : uuid4();\n        if (prefix != null)\n            return `${prefix}-${id}`;\n        else\n            return id;\n    }\n    exports.uniqueId = uniqueId;\n    function escape(s) {\n        return s.replace(/(?:[&<>\"'`])/g, (ch) => {\n            switch (ch) {\n                case '&': return '&amp;';\n                case '<': return '&lt;';\n                case '>': return '&gt;';\n                case '\"': return '&quot;';\n                case \"'\": return '&#x27;';\n                case '`': return '&#x60;';\n                default: return ch;\n            }\n        });\n    }\n    exports.escape = escape;\n    function unescape(s) {\n        return s.replace(/&(amp|lt|gt|quot|#x27|#x60);/g, (_, entity) => {\n            switch (entity) {\n                case 'amp': return '&';\n                case 'lt': return '<';\n                case 'gt': return '>';\n                case 'quot': return '\"';\n                case '#x27': return \"'\";\n                case '#x60': return '`';\n                default: return entity;\n            }\n        });\n    }\n    exports.unescape = unescape;\n    function use_strict(code) {\n        return `'use strict';\\n${code}`;\n    }\n    exports.use_strict = use_strict;\n}\n","/* core/settings.js */ function _(require, module, exports) {\n    class Settings {\n        constructor() {\n            this._dev = false;\n        }\n        set dev(dev) {\n            this._dev = dev;\n        }\n        get dev() {\n            return this._dev;\n        }\n    }\n    exports.Settings = Settings;\n    Settings.__name__ = \"Settings\";\n    exports.settings = new Settings();\n}\n","/* models/index.js */ function _(require, module, exports) {\n    function __export(m) {\n        for (var p in m)\n            if (!exports.hasOwnProperty(p))\n                exports[p] = m[p];\n    }\n    __export(require(28) /* ./annotations */);\n    __export(require(140) /* ./axes */);\n    __export(require(167) /* ./callbacks */);\n    __export(require(171) /* ./canvas */);\n    __export(require(186) /* ./expressions */);\n    __export(require(190) /* ./filters */);\n    __export(require(196) /* ./formatters */);\n    __export(require(200) /* ./glyphs */);\n    __export(require(230) /* ./graphs */);\n    __export(require(233) /* ./grids */);\n    __export(require(235) /* ./layouts */);\n    __export(require(248) /* ./mappers */);\n    __export(require(115) /* ./transforms */);\n    __export(require(254) /* ./markers */);\n    __export(require(258) /* ./plots */);\n    __export(require(281) /* ./ranges */);\n    __export(require(282) /* ./renderers */);\n    __export(require(283) /* ./scales */);\n    __export(require(284) /* ./selections */);\n    __export(require(285) /* ./sources */);\n    __export(require(291) /* ./tickers */);\n    __export(require(293) /* ./tiles */);\n    __export(require(303) /* ./textures */);\n    __export(require(307) /* ./tools */);\n}\n","/* models/annotations/index.js */ function _(require, module, exports) {\n    var annotation_1 = require(29) /* ./annotation */;\n    exports.Annotation = annotation_1.Annotation;\n    var arrow_1 = require(66) /* ./arrow */;\n    exports.Arrow = arrow_1.Arrow;\n    var arrow_head_1 = require(67) /* ./arrow_head */;\n    exports.ArrowHead = arrow_head_1.ArrowHead;\n    var arrow_head_2 = require(67) /* ./arrow_head */;\n    exports.OpenHead = arrow_head_2.OpenHead;\n    var arrow_head_3 = require(67) /* ./arrow_head */;\n    exports.NormalHead = arrow_head_3.NormalHead;\n    var arrow_head_4 = require(67) /* ./arrow_head */;\n    exports.TeeHead = arrow_head_4.TeeHead;\n    var arrow_head_5 = require(67) /* ./arrow_head */;\n    exports.VeeHead = arrow_head_5.VeeHead;\n    var band_1 = require(98) /* ./band */;\n    exports.Band = band_1.Band;\n    var box_annotation_1 = require(99) /* ./box_annotation */;\n    exports.BoxAnnotation = box_annotation_1.BoxAnnotation;\n    var color_bar_1 = require(101) /* ./color_bar */;\n    exports.ColorBar = color_bar_1.ColorBar;\n    var label_1 = require(125) /* ./label */;\n    exports.Label = label_1.Label;\n    var label_set_1 = require(127) /* ./label_set */;\n    exports.LabelSet = label_set_1.LabelSet;\n    var legend_1 = require(128) /* ./legend */;\n    exports.Legend = legend_1.Legend;\n    var legend_item_1 = require(129) /* ./legend_item */;\n    exports.LegendItem = legend_item_1.LegendItem;\n    var poly_annotation_1 = require(131) /* ./poly_annotation */;\n    exports.PolyAnnotation = poly_annotation_1.PolyAnnotation;\n    var slope_1 = require(132) /* ./slope */;\n    exports.Slope = slope_1.Slope;\n    var span_1 = require(133) /* ./span */;\n    exports.Span = span_1.Span;\n    var text_annotation_1 = require(126) /* ./text_annotation */;\n    exports.TextAnnotation = text_annotation_1.TextAnnotation;\n    var title_1 = require(134) /* ./title */;\n    exports.Title = title_1.Title;\n    var toolbar_panel_1 = require(135) /* ./toolbar_panel */;\n    exports.ToolbarPanel = toolbar_panel_1.ToolbarPanel;\n    var tooltip_1 = require(136) /* ./tooltip */;\n    exports.Tooltip = tooltip_1.Tooltip;\n    var whisker_1 = require(139) /* ./whisker */;\n    exports.Whisker = whisker_1.Whisker;\n}\n","/* models/annotations/annotation.js */ function _(require, module, exports) {\n    const proj = require(30) /* ../../core/util/projections */;\n    const object_1 = require(22) /* ../../core/util/object */;\n    const renderer_1 = require(58) /* ../renderers/renderer */;\n    class AnnotationView extends renderer_1.RendererView {\n        get panel() {\n            return this.layout;\n        }\n        get_size() {\n            if (this.model.visible) {\n                const { width, height } = this._get_size();\n                return { width: Math.round(width), height: Math.round(height) };\n            }\n            else\n                return { width: 0, height: 0 };\n        }\n        connect_signals() {\n            super.connect_signals();\n            const p = this.model.properties;\n            this.on_change(p.visible, () => this.plot_view.request_layout());\n        }\n        _get_size() {\n            throw new Error(\"not implemented\");\n        }\n        get ctx() {\n            return this.plot_view.canvas_view.ctx;\n        }\n        set_data(source) {\n            const data = this.model.materialize_dataspecs(source);\n            object_1.extend(this, data);\n            if (this.plot_model.use_map) {\n                const self = this;\n                if (self._x != null)\n                    [self._x, self._y] = proj.project_xy(self._x, self._y);\n                if (self._xs != null)\n                    [self._xs, self._ys] = proj.project_xsys(self._xs, self._ys);\n            }\n        }\n        get needs_clip() {\n            return this.layout == null; // TODO: change this, when center layout is fully implemented\n        }\n        serializable_state() {\n            const state = super.serializable_state();\n            return this.layout == null ? state : Object.assign(Object.assign({}, state), { bbox: this.layout.bbox.box });\n        }\n    }\n    exports.AnnotationView = AnnotationView;\n    AnnotationView.__name__ = \"AnnotationView\";\n    class Annotation extends renderer_1.Renderer {\n        constructor(attrs) {\n            super(attrs);\n        }\n        static init_Annotation() {\n            this.override({\n                level: 'annotation',\n            });\n        }\n    }\n    exports.Annotation = Annotation;\n    Annotation.__name__ = \"Annotation\";\n    Annotation.init_Annotation();\n}\n","/* core/util/projections.js */ function _(require, module, exports) {\n    const proj4 = require(31) /* proj4/lib/core */;\n    const Projection = require(32) /* proj4/lib/Proj */;\n    const mercator = new Projection('GOOGLE');\n    const wgs84 = new Projection('WGS84');\n    exports.wgs84_mercator = proj4(wgs84, mercator);\n    const mercator_bounds = {\n        lon: [-20026376.39, 20026376.39],\n        lat: [-20048966.10, 20048966.10],\n    };\n    const latlon_bounds = {\n        lon: [-180, 180],\n        lat: [-85.06, 85.06],\n    };\n    function clip_mercator(low, high, dimension) {\n        const [min, max] = mercator_bounds[dimension];\n        return [Math.max(low, min), Math.min(high, max)];\n    }\n    exports.clip_mercator = clip_mercator;\n    function in_bounds(value, dimension) {\n        return value > latlon_bounds[dimension][0] && value < latlon_bounds[dimension][1];\n    }\n    exports.in_bounds = in_bounds;\n    function project_xy(x, y) {\n        const n = Math.min(x.length, y.length);\n        const merc_x_s = new Array(n);\n        const merc_y_s = new Array(n);\n        for (let i = 0; i < n; i++) {\n            const [merc_x, merc_y] = exports.wgs84_mercator.forward([x[i], y[i]]);\n            merc_x_s[i] = merc_x;\n            merc_y_s[i] = merc_y;\n        }\n        return [merc_x_s, merc_y_s];\n    }\n    exports.project_xy = project_xy;\n    function project_xsys(xs, ys) {\n        const n = Math.min(xs.length, ys.length);\n        const merc_xs_s = new Array(n);\n        const merc_ys_s = new Array(n);\n        for (let i = 0; i < n; i++) {\n            const [merc_x_s, merc_y_s] = project_xy(xs[i], ys[i]);\n            merc_xs_s[i] = merc_x_s;\n            merc_ys_s[i] = merc_y_s;\n        }\n        return [merc_xs_s, merc_ys_s];\n    }\n    exports.project_xsys = project_xsys;\n}\n","/* proj4/lib/core.js */ function _(require, module, exports) {\n    var proj = require(32) /* ./Proj */;\n    var transform = require(53) /* ./transform */;\n    var wgs84 = proj('WGS84');\n    function transformer(from, to, coords) {\n        var transformedArray;\n        if (Array.isArray(coords)) {\n            transformedArray = transform(from, to, coords);\n            if (coords.length === 3) {\n                return [transformedArray.x, transformedArray.y, transformedArray.z];\n            }\n            else {\n                return [transformedArray.x, transformedArray.y];\n            }\n        }\n        else {\n            return transform(from, to, coords);\n        }\n    }\n    function checkProj(item) {\n        if (item instanceof proj) {\n            return item;\n        }\n        if (item.oProj) {\n            return item.oProj;\n        }\n        return proj(item);\n    }\n    function proj4(fromProj, toProj, coord) {\n        fromProj = checkProj(fromProj);\n        var single = false;\n        var obj;\n        if (typeof toProj === 'undefined') {\n            toProj = fromProj;\n            fromProj = wgs84;\n            single = true;\n        }\n        else if (typeof toProj.x !== 'undefined' || Array.isArray(toProj)) {\n            coord = toProj;\n            toProj = fromProj;\n            fromProj = wgs84;\n            single = true;\n        }\n        toProj = checkProj(toProj);\n        if (coord) {\n            return transformer(fromProj, toProj, coord);\n        }\n        else {\n            obj = {\n                forward: function (coords) {\n                    return transformer(fromProj, toProj, coords);\n                },\n                inverse: function (coords) {\n                    return transformer(toProj, fromProj, coords);\n                }\n            };\n            if (single) {\n                obj.oProj = toProj;\n            }\n            return obj;\n        }\n    }\n    module.exports = proj4;\n}\n","/* proj4/lib/Proj.js */ function _(require, module, exports) {\n    var parseCode = require(33) /* ./parseCode */;\n    var extend = require(40) /* ./extend */;\n    var projections = require(41) /* ./projections */;\n    var deriveConstants = require(49) /* ./deriveConstants */;\n    var Datum = require(51) /* ./constants/Datum */;\n    var datum = require(52) /* ./datum */;\n    function Projection(srsCode, callback) {\n        if (!(this instanceof Projection)) {\n            return new Projection(srsCode);\n        }\n        callback = callback || function (error) {\n            if (error) {\n                throw error;\n            }\n        };\n        var json = parseCode(srsCode);\n        if (typeof json !== 'object') {\n            callback(srsCode);\n            return;\n        }\n        var ourProj = Projection.projections.get(json.projName);\n        if (!ourProj) {\n            callback(srsCode);\n            return;\n        }\n        if (json.datumCode && json.datumCode !== 'none') {\n            var datumDef = Datum[json.datumCode];\n            if (datumDef) {\n                json.datum_params = datumDef.towgs84 ? datumDef.towgs84.split(',') : null;\n                json.ellps = datumDef.ellipse;\n                json.datumName = datumDef.datumName ? datumDef.datumName : json.datumCode;\n            }\n        }\n        json.k0 = json.k0 || 1.0;\n        json.axis = json.axis || 'enu';\n        var sphere = deriveConstants.sphere(json.a, json.b, json.rf, json.ellps, json.sphere);\n        var ecc = deriveConstants.eccentricity(sphere.a, sphere.b, sphere.rf, json.R_A);\n        var datumObj = json.datum || datum(json.datumCode, json.datum_params, sphere.a, sphere.b, ecc.es, ecc.ep2);\n        extend(this, json); // transfer everything over from the projection because we don't know what we'll need\n        extend(this, ourProj); // transfer all the methods from the projection\n        // copy the 4 things over we calulated in deriveConstants.sphere\n        this.a = sphere.a;\n        this.b = sphere.b;\n        this.rf = sphere.rf;\n        this.sphere = sphere.sphere;\n        // copy the 3 things we calculated in deriveConstants.eccentricity\n        this.es = ecc.es;\n        this.e = ecc.e;\n        this.ep2 = ecc.ep2;\n        // add in the datum object\n        this.datum = datumObj;\n        // init the projection\n        this.init();\n        // legecy callback from back in the day when it went to spatialreference.org\n        callback(null, this);\n    }\n    Projection.projections = projections;\n    Projection.projections.start();\n    module.exports = Projection;\n}\n","/* proj4/lib/parseCode.js */ function _(require, module, exports) {\n    var defs = require(34) /* ./defs */;\n    var wkt = require(39) /* ./wkt */;\n    var projStr = require(36) /* ./projString */;\n    function testObj(code) {\n        return typeof code === 'string';\n    }\n    function testDef(code) {\n        return code in defs;\n    }\n    var codeWords = ['GEOGCS', 'GEOCCS', 'PROJCS', 'LOCAL_CS'];\n    function testWKT(code) {\n        return codeWords.some(function (word) {\n            return code.indexOf(word) > -1;\n        });\n    }\n    function testProj(code) {\n        return code[0] === '+';\n    }\n    function parse(code) {\n        if (testObj(code)) {\n            //check to see if this is a WKT string\n            if (testDef(code)) {\n                return defs[code];\n            }\n            if (testWKT(code)) {\n                return wkt(code);\n            }\n            if (testProj(code)) {\n                return projStr(code);\n            }\n        }\n        else {\n            return code;\n        }\n    }\n    module.exports = parse;\n}\n","/* proj4/lib/defs.js */ function _(require, module, exports) {\n    var globals = require(35) /* ./global */;\n    var parseProj = require(36) /* ./projString */;\n    var wkt = require(39) /* ./wkt */;\n    function defs(name) {\n        /*global console*/\n        var that = this;\n        if (arguments.length === 2) {\n            var def = arguments[1];\n            if (typeof def === 'string') {\n                if (def.charAt(0) === '+') {\n                    defs[name] = parseProj(arguments[1]);\n                }\n                else {\n                    defs[name] = wkt(arguments[1]);\n                }\n            }\n            else {\n                defs[name] = def;\n            }\n        }\n        else if (arguments.length === 1) {\n            if (Array.isArray(name)) {\n                return name.map(function (v) {\n                    if (Array.isArray(v)) {\n                        defs.apply(that, v);\n                    }\n                    else {\n                        defs(v);\n                    }\n                });\n            }\n            else if (typeof name === 'string') {\n                if (name in defs) {\n                    return defs[name];\n                }\n            }\n            else if ('EPSG' in name) {\n                defs['EPSG:' + name.EPSG] = name;\n            }\n            else if ('ESRI' in name) {\n                defs['ESRI:' + name.ESRI] = name;\n            }\n            else if ('IAU2000' in name) {\n                defs['IAU2000:' + name.IAU2000] = name;\n            }\n            else {\n                console.log(name);\n            }\n            return;\n        }\n    }\n    globals(defs);\n    module.exports = defs;\n}\n","/* proj4/lib/global.js */ function _(require, module, exports) {\n    module.exports = function (defs) {\n        defs('EPSG:4326', \"+title=WGS 84 (long/lat) +proj=longlat +ellps=WGS84 +datum=WGS84 +units=degrees\");\n        defs('EPSG:4269', \"+title=NAD83 (long/lat) +proj=longlat +a=6378137.0 +b=6356752.31414036 +ellps=GRS80 +datum=NAD83 +units=degrees\");\n        defs('EPSG:3857', \"+title=WGS 84 / Pseudo-Mercator +proj=merc +a=6378137 +b=6378137 +lat_ts=0.0 +lon_0=0.0 +x_0=0.0 +y_0=0 +k=1.0 +units=m +nadgrids=@null +no_defs\");\n        defs.WGS84 = defs['EPSG:4326'];\n        defs['EPSG:3785'] = defs['EPSG:3857']; // maintain backward compat, official code is 3857\n        defs.GOOGLE = defs['EPSG:3857'];\n        defs['EPSG:900913'] = defs['EPSG:3857'];\n        defs['EPSG:102113'] = defs['EPSG:3857'];\n    };\n}\n","/* proj4/lib/projString.js */ function _(require, module, exports) {\n    var D2R = 0.01745329251994329577;\n    var PrimeMeridian = require(37) /* ./constants/PrimeMeridian */;\n    var units = require(38) /* ./constants/units */;\n    module.exports = function (defData) {\n        var self = {};\n        var paramObj = defData.split('+').map(function (v) {\n            return v.trim();\n        }).filter(function (a) {\n            return a;\n        }).reduce(function (p, a) {\n            var split = a.split('=');\n            split.push(true);\n            p[split[0].toLowerCase()] = split[1];\n            return p;\n        }, {});\n        var paramName, paramVal, paramOutname;\n        var params = {\n            proj: 'projName',\n            datum: 'datumCode',\n            rf: function (v) {\n                self.rf = parseFloat(v);\n            },\n            lat_0: function (v) {\n                self.lat0 = v * D2R;\n            },\n            lat_1: function (v) {\n                self.lat1 = v * D2R;\n            },\n            lat_2: function (v) {\n                self.lat2 = v * D2R;\n            },\n            lat_ts: function (v) {\n                self.lat_ts = v * D2R;\n            },\n            lon_0: function (v) {\n                self.long0 = v * D2R;\n            },\n            lon_1: function (v) {\n                self.long1 = v * D2R;\n            },\n            lon_2: function (v) {\n                self.long2 = v * D2R;\n            },\n            alpha: function (v) {\n                self.alpha = parseFloat(v) * D2R;\n            },\n            lonc: function (v) {\n                self.longc = v * D2R;\n            },\n            x_0: function (v) {\n                self.x0 = parseFloat(v);\n            },\n            y_0: function (v) {\n                self.y0 = parseFloat(v);\n            },\n            k_0: function (v) {\n                self.k0 = parseFloat(v);\n            },\n            k: function (v) {\n                self.k0 = parseFloat(v);\n            },\n            a: function (v) {\n                self.a = parseFloat(v);\n            },\n            b: function (v) {\n                self.b = parseFloat(v);\n            },\n            r_a: function () {\n                self.R_A = true;\n            },\n            zone: function (v) {\n                self.zone = parseInt(v, 10);\n            },\n            south: function () {\n                self.utmSouth = true;\n            },\n            towgs84: function (v) {\n                self.datum_params = v.split(\",\").map(function (a) {\n                    return parseFloat(a);\n                });\n            },\n            to_meter: function (v) {\n                self.to_meter = parseFloat(v);\n            },\n            units: function (v) {\n                self.units = v;\n                if (units[v]) {\n                    self.to_meter = units[v].to_meter;\n                }\n            },\n            from_greenwich: function (v) {\n                self.from_greenwich = v * D2R;\n            },\n            pm: function (v) {\n                self.from_greenwich = (PrimeMeridian[v] ? PrimeMeridian[v] : parseFloat(v)) * D2R;\n            },\n            nadgrids: function (v) {\n                if (v === '@null') {\n                    self.datumCode = 'none';\n                }\n                else {\n                    self.nadgrids = v;\n                }\n            },\n            axis: function (v) {\n                var legalAxis = \"ewnsud\";\n                if (v.length === 3 && legalAxis.indexOf(v.substr(0, 1)) !== -1 && legalAxis.indexOf(v.substr(1, 1)) !== -1 && legalAxis.indexOf(v.substr(2, 1)) !== -1) {\n                    self.axis = v;\n                }\n            }\n        };\n        for (paramName in paramObj) {\n            paramVal = paramObj[paramName];\n            if (paramName in params) {\n                paramOutname = params[paramName];\n                if (typeof paramOutname === 'function') {\n                    paramOutname(paramVal);\n                }\n                else {\n                    self[paramOutname] = paramVal;\n                }\n            }\n            else {\n                self[paramName] = paramVal;\n            }\n        }\n        if (typeof self.datumCode === 'string' && self.datumCode !== \"WGS84\") {\n            self.datumCode = self.datumCode.toLowerCase();\n        }\n        return self;\n    };\n}\n","/* proj4/lib/constants/PrimeMeridian.js */ function _(require, module, exports) {\n    exports.greenwich = 0.0; //\"0dE\",\n    exports.lisbon = -9.131906111111; //\"9d07'54.862\\\"W\",\n    exports.paris = 2.337229166667; //\"2d20'14.025\\\"E\",\n    exports.bogota = -74.080916666667; //\"74d04'51.3\\\"W\",\n    exports.madrid = -3.687938888889; //\"3d41'16.58\\\"W\",\n    exports.rome = 12.452333333333; //\"12d27'8.4\\\"E\",\n    exports.bern = 7.439583333333; //\"7d26'22.5\\\"E\",\n    exports.jakarta = 106.807719444444; //\"106d48'27.79\\\"E\",\n    exports.ferro = -17.666666666667; //\"17d40'W\",\n    exports.brussels = 4.367975; //\"4d22'4.71\\\"E\",\n    exports.stockholm = 18.058277777778; //\"18d3'29.8\\\"E\",\n    exports.athens = 23.7163375; //\"23d42'58.815\\\"E\",\n    exports.oslo = 10.722916666667; //\"10d43'22.5\\\"E\"\n}\n","/* proj4/lib/constants/units.js */ function _(require, module, exports) {\n    exports.ft = { to_meter: 0.3048 };\n    exports['us-ft'] = { to_meter: 1200 / 3937 };\n}\n","/* proj4/lib/wkt.js */ function _(require, module, exports) {\n    var D2R = 0.01745329251994329577;\n    var extend = require(40) /* ./extend */;\n    function mapit(obj, key, v) {\n        obj[key] = v.map(function (aa) {\n            var o = {};\n            sExpr(aa, o);\n            return o;\n        }).reduce(function (a, b) {\n            return extend(a, b);\n        }, {});\n    }\n    function sExpr(v, obj) {\n        var key;\n        if (!Array.isArray(v)) {\n            obj[v] = true;\n            return;\n        }\n        else {\n            key = v.shift();\n            if (key === 'PARAMETER') {\n                key = v.shift();\n            }\n            if (v.length === 1) {\n                if (Array.isArray(v[0])) {\n                    obj[key] = {};\n                    sExpr(v[0], obj[key]);\n                }\n                else {\n                    obj[key] = v[0];\n                }\n            }\n            else if (!v.length) {\n                obj[key] = true;\n            }\n            else if (key === 'TOWGS84') {\n                obj[key] = v;\n            }\n            else {\n                obj[key] = {};\n                if (['UNIT', 'PRIMEM', 'VERT_DATUM'].indexOf(key) > -1) {\n                    obj[key] = {\n                        name: v[0].toLowerCase(),\n                        convert: v[1]\n                    };\n                    if (v.length === 3) {\n                        obj[key].auth = v[2];\n                    }\n                }\n                else if (key === 'SPHEROID') {\n                    obj[key] = {\n                        name: v[0],\n                        a: v[1],\n                        rf: v[2]\n                    };\n                    if (v.length === 4) {\n                        obj[key].auth = v[3];\n                    }\n                }\n                else if (['GEOGCS', 'GEOCCS', 'DATUM', 'VERT_CS', 'COMPD_CS', 'LOCAL_CS', 'FITTED_CS', 'LOCAL_DATUM'].indexOf(key) > -1) {\n                    v[0] = ['name', v[0]];\n                    mapit(obj, key, v);\n                }\n                else if (v.every(function (aa) {\n                    return Array.isArray(aa);\n                })) {\n                    mapit(obj, key, v);\n                }\n                else {\n                    sExpr(v, obj[key]);\n                }\n            }\n        }\n    }\n    function rename(obj, params) {\n        var outName = params[0];\n        var inName = params[1];\n        if (!(outName in obj) && (inName in obj)) {\n            obj[outName] = obj[inName];\n            if (params.length === 3) {\n                obj[outName] = params[2](obj[outName]);\n            }\n        }\n    }\n    function d2r(input) {\n        return input * D2R;\n    }\n    function cleanWKT(wkt) {\n        if (wkt.type === 'GEOGCS') {\n            wkt.projName = 'longlat';\n        }\n        else if (wkt.type === 'LOCAL_CS') {\n            wkt.projName = 'identity';\n            wkt.local = true;\n        }\n        else {\n            if (typeof wkt.PROJECTION === \"object\") {\n                wkt.projName = Object.keys(wkt.PROJECTION)[0];\n            }\n            else {\n                wkt.projName = wkt.PROJECTION;\n            }\n        }\n        if (wkt.UNIT) {\n            wkt.units = wkt.UNIT.name.toLowerCase();\n            if (wkt.units === 'metre') {\n                wkt.units = 'meter';\n            }\n            if (wkt.UNIT.convert) {\n                if (wkt.type === 'GEOGCS') {\n                    if (wkt.DATUM && wkt.DATUM.SPHEROID) {\n                        wkt.to_meter = parseFloat(wkt.UNIT.convert, 10) * wkt.DATUM.SPHEROID.a;\n                    }\n                }\n                else {\n                    wkt.to_meter = parseFloat(wkt.UNIT.convert, 10);\n                }\n            }\n        }\n        if (wkt.GEOGCS) {\n            //if(wkt.GEOGCS.PRIMEM&&wkt.GEOGCS.PRIMEM.convert){\n            //  wkt.from_greenwich=wkt.GEOGCS.PRIMEM.convert*D2R;\n            //}\n            if (wkt.GEOGCS.DATUM) {\n                wkt.datumCode = wkt.GEOGCS.DATUM.name.toLowerCase();\n            }\n            else {\n                wkt.datumCode = wkt.GEOGCS.name.toLowerCase();\n            }\n            if (wkt.datumCode.slice(0, 2) === 'd_') {\n                wkt.datumCode = wkt.datumCode.slice(2);\n            }\n            if (wkt.datumCode === 'new_zealand_geodetic_datum_1949' || wkt.datumCode === 'new_zealand_1949') {\n                wkt.datumCode = 'nzgd49';\n            }\n            if (wkt.datumCode === \"wgs_1984\") {\n                if (wkt.PROJECTION === 'Mercator_Auxiliary_Sphere') {\n                    wkt.sphere = true;\n                }\n                wkt.datumCode = 'wgs84';\n            }\n            if (wkt.datumCode.slice(-6) === '_ferro') {\n                wkt.datumCode = wkt.datumCode.slice(0, -6);\n            }\n            if (wkt.datumCode.slice(-8) === '_jakarta') {\n                wkt.datumCode = wkt.datumCode.slice(0, -8);\n            }\n            if (~wkt.datumCode.indexOf('belge')) {\n                wkt.datumCode = \"rnb72\";\n            }\n            if (wkt.GEOGCS.DATUM && wkt.GEOGCS.DATUM.SPHEROID) {\n                wkt.ellps = wkt.GEOGCS.DATUM.SPHEROID.name.replace('_19', '').replace(/[Cc]larke\\_18/, 'clrk');\n                if (wkt.ellps.toLowerCase().slice(0, 13) === \"international\") {\n                    wkt.ellps = 'intl';\n                }\n                wkt.a = wkt.GEOGCS.DATUM.SPHEROID.a;\n                wkt.rf = parseFloat(wkt.GEOGCS.DATUM.SPHEROID.rf, 10);\n            }\n            if (~wkt.datumCode.indexOf('osgb_1936')) {\n                wkt.datumCode = \"osgb36\";\n            }\n        }\n        if (wkt.b && !isFinite(wkt.b)) {\n            wkt.b = wkt.a;\n        }\n        function toMeter(input) {\n            var ratio = wkt.to_meter || 1;\n            return parseFloat(input, 10) * ratio;\n        }\n        var renamer = function (a) {\n            return rename(wkt, a);\n        };\n        var list = [\n            ['standard_parallel_1', 'Standard_Parallel_1'],\n            ['standard_parallel_2', 'Standard_Parallel_2'],\n            ['false_easting', 'False_Easting'],\n            ['false_northing', 'False_Northing'],\n            ['central_meridian', 'Central_Meridian'],\n            ['latitude_of_origin', 'Latitude_Of_Origin'],\n            ['latitude_of_origin', 'Central_Parallel'],\n            ['scale_factor', 'Scale_Factor'],\n            ['k0', 'scale_factor'],\n            ['latitude_of_center', 'Latitude_of_center'],\n            ['lat0', 'latitude_of_center', d2r],\n            ['longitude_of_center', 'Longitude_Of_Center'],\n            ['longc', 'longitude_of_center', d2r],\n            ['x0', 'false_easting', toMeter],\n            ['y0', 'false_northing', toMeter],\n            ['long0', 'central_meridian', d2r],\n            ['lat0', 'latitude_of_origin', d2r],\n            ['lat0', 'standard_parallel_1', d2r],\n            ['lat1', 'standard_parallel_1', d2r],\n            ['lat2', 'standard_parallel_2', d2r],\n            ['alpha', 'azimuth', d2r],\n            ['srsCode', 'name']\n        ];\n        list.forEach(renamer);\n        if (!wkt.long0 && wkt.longc && (wkt.projName === 'Albers_Conic_Equal_Area' || wkt.projName === \"Lambert_Azimuthal_Equal_Area\")) {\n            wkt.long0 = wkt.longc;\n        }\n        if (!wkt.lat_ts && wkt.lat1 && (wkt.projName === 'Stereographic_South_Pole' || wkt.projName === 'Polar Stereographic (variant B)')) {\n            wkt.lat0 = d2r(wkt.lat1 > 0 ? 90 : -90);\n            wkt.lat_ts = wkt.lat1;\n        }\n    }\n    module.exports = function (wkt, self) {\n        var lisp = JSON.parse((\",\" + wkt).replace(/\\s*\\,\\s*([A-Z_0-9]+?)(\\[)/g, ',[\"$1\",').slice(1).replace(/\\s*\\,\\s*([A-Z_0-9]+?)\\]/g, ',\"$1\"]').replace(/,\\[\"VERTCS\".+/, ''));\n        var type = lisp.shift();\n        var name = lisp.shift();\n        lisp.unshift(['name', name]);\n        lisp.unshift(['type', type]);\n        lisp.unshift('output');\n        var obj = {};\n        sExpr(lisp, obj);\n        cleanWKT(obj.output);\n        return extend(self, obj.output);\n    };\n}\n","/* proj4/lib/extend.js */ function _(require, module, exports) {\n    module.exports = function (destination, source) {\n        destination = destination || {};\n        var value, property;\n        if (!source) {\n            return destination;\n        }\n        for (property in source) {\n            value = source[property];\n            if (value !== undefined) {\n                destination[property] = value;\n            }\n        }\n        return destination;\n    };\n}\n","/* proj4/lib/projections.js */ function _(require, module, exports) {\n    var projs = [\n        require(42) /* ./projections/merc */,\n        require(48) /* ./projections/longlat */\n    ];\n    var names = {};\n    var projStore = [];\n    function add(proj, i) {\n        var len = projStore.length;\n        if (!proj.names) {\n            console.log(i);\n            return true;\n        }\n        projStore[len] = proj;\n        proj.names.forEach(function (n) {\n            names[n.toLowerCase()] = len;\n        });\n        return this;\n    }\n    exports.add = add;\n    exports.get = function (name) {\n        if (!name) {\n            return false;\n        }\n        var n = name.toLowerCase();\n        if (typeof names[n] !== 'undefined' && projStore[names[n]]) {\n            return projStore[names[n]];\n        }\n    };\n    exports.start = function () {\n        projs.forEach(add);\n    };\n}\n","/* proj4/lib/projections/merc.js */ function _(require, module, exports) {\n    var msfnz = require(43) /* ../common/msfnz */;\n    var HALF_PI = Math.PI / 2;\n    var EPSLN = 1.0e-10;\n    var R2D = 57.29577951308232088;\n    var adjust_lon = require(44) /* ../common/adjust_lon */;\n    var FORTPI = Math.PI / 4;\n    var tsfnz = require(46) /* ../common/tsfnz */;\n    var phi2z = require(47) /* ../common/phi2z */;\n    exports.init = function () {\n        var con = this.b / this.a;\n        this.es = 1 - con * con;\n        if (!('x0' in this)) {\n            this.x0 = 0;\n        }\n        if (!('y0' in this)) {\n            this.y0 = 0;\n        }\n        this.e = Math.sqrt(this.es);\n        if (this.lat_ts) {\n            if (this.sphere) {\n                this.k0 = Math.cos(this.lat_ts);\n            }\n            else {\n                this.k0 = msfnz(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts));\n            }\n        }\n        else {\n            if (!this.k0) {\n                if (this.k) {\n                    this.k0 = this.k;\n                }\n                else {\n                    this.k0 = 1;\n                }\n            }\n        }\n    };\n    /* Mercator forward equations--mapping lat,long to x,y\n      --------------------------------------------------*/\n    exports.forward = function (p) {\n        var lon = p.x;\n        var lat = p.y;\n        // convert to radians\n        if (lat * R2D > 90 && lat * R2D < -90 && lon * R2D > 180 && lon * R2D < -180) {\n            return null;\n        }\n        var x, y;\n        if (Math.abs(Math.abs(lat) - HALF_PI) <= EPSLN) {\n            return null;\n        }\n        else {\n            if (this.sphere) {\n                x = this.x0 + this.a * this.k0 * adjust_lon(lon - this.long0);\n                y = this.y0 + this.a * this.k0 * Math.log(Math.tan(FORTPI + 0.5 * lat));\n            }\n            else {\n                var sinphi = Math.sin(lat);\n                var ts = tsfnz(this.e, lat, sinphi);\n                x = this.x0 + this.a * this.k0 * adjust_lon(lon - this.long0);\n                y = this.y0 - this.a * this.k0 * Math.log(ts);\n            }\n            p.x = x;\n            p.y = y;\n            return p;\n        }\n    };\n    /* Mercator inverse equations--mapping x,y to lat/long\n      --------------------------------------------------*/\n    exports.inverse = function (p) {\n        var x = p.x - this.x0;\n        var y = p.y - this.y0;\n        var lon, lat;\n        if (this.sphere) {\n            lat = HALF_PI - 2 * Math.atan(Math.exp(-y / (this.a * this.k0)));\n        }\n        else {\n            var ts = Math.exp(-y / (this.a * this.k0));\n            lat = phi2z(this.e, ts);\n            if (lat === -9999) {\n                return null;\n            }\n        }\n        lon = adjust_lon(this.long0 + x / (this.a * this.k0));\n        p.x = lon;\n        p.y = lat;\n        return p;\n    };\n    exports.names = [\"Mercator\", \"Popular Visualisation Pseudo Mercator\", \"Mercator_1SP\", \"Mercator_Auxiliary_Sphere\", \"merc\"];\n}\n","/* proj4/lib/common/msfnz.js */ function _(require, module, exports) {\n    module.exports = function (eccent, sinphi, cosphi) {\n        var con = eccent * sinphi;\n        return cosphi / (Math.sqrt(1 - con * con));\n    };\n}\n","/* proj4/lib/common/adjust_lon.js */ function _(require, module, exports) {\n    var TWO_PI = Math.PI * 2;\n    // SPI is slightly greater than Math.PI, so values that exceed the -180..180\n    // degree range by a tiny amount don't get wrapped. This prevents points that\n    // have drifted from their original location along the 180th meridian (due to\n    // floating point error) from changing their sign.\n    var SPI = 3.14159265359;\n    var sign = require(45) /* ./sign */;\n    module.exports = function (x) {\n        return (Math.abs(x) <= SPI) ? x : (x - (sign(x) * TWO_PI));\n    };\n}\n","/* proj4/lib/common/sign.js */ function _(require, module, exports) {\n    module.exports = function (x) {\n        return x < 0 ? -1 : 1;\n    };\n}\n","/* proj4/lib/common/tsfnz.js */ function _(require, module, exports) {\n    var HALF_PI = Math.PI / 2;\n    module.exports = function (eccent, phi, sinphi) {\n        var con = eccent * sinphi;\n        var com = 0.5 * eccent;\n        con = Math.pow(((1 - con) / (1 + con)), com);\n        return (Math.tan(0.5 * (HALF_PI - phi)) / con);\n    };\n}\n","/* proj4/lib/common/phi2z.js */ function _(require, module, exports) {\n    var HALF_PI = Math.PI / 2;\n    module.exports = function (eccent, ts) {\n        var eccnth = 0.5 * eccent;\n        var con, dphi;\n        var phi = HALF_PI - 2 * Math.atan(ts);\n        for (var i = 0; i <= 15; i++) {\n            con = eccent * Math.sin(phi);\n            dphi = HALF_PI - 2 * Math.atan(ts * (Math.pow(((1 - con) / (1 + con)), eccnth))) - phi;\n            phi += dphi;\n            if (Math.abs(dphi) <= 0.0000000001) {\n                return phi;\n            }\n        }\n        //console.log(\"phi2z has NoConvergence\");\n        return -9999;\n    };\n}\n","/* proj4/lib/projections/longlat.js */ function _(require, module, exports) {\n    exports.init = function () {\n        //no-op for longlat\n    };\n    function identity(pt) {\n        return pt;\n    }\n    exports.forward = identity;\n    exports.inverse = identity;\n    exports.names = [\"longlat\", \"identity\"];\n}\n","/* proj4/lib/deriveConstants.js */ function _(require, module, exports) {\n    // ellipoid pj_set_ell.c\n    var SIXTH = 0.1666666666666666667;\n    /* 1/6 */\n    var RA4 = 0.04722222222222222222;\n    /* 17/360 */\n    var RA6 = 0.02215608465608465608;\n    var EPSLN = 1.0e-10;\n    var Ellipsoid = require(50) /* ./constants/Ellipsoid */;\n    exports.eccentricity = function (a, b, rf, R_A) {\n        var a2 = a * a; // used in geocentric\n        var b2 = b * b; // used in geocentric\n        var es = (a2 - b2) / a2; // e ^ 2\n        var e = 0;\n        if (R_A) {\n            a *= 1 - es * (SIXTH + es * (RA4 + es * RA6));\n            a2 = a * a;\n            es = 0;\n        }\n        else {\n            e = Math.sqrt(es); // eccentricity\n        }\n        var ep2 = (a2 - b2) / b2; // used in geocentric\n        return {\n            es: es,\n            e: e,\n            ep2: ep2\n        };\n    };\n    exports.sphere = function (a, b, rf, ellps, sphere) {\n        if (!a) { // do we have an ellipsoid?\n            var ellipse = Ellipsoid[ellps];\n            if (!ellipse) {\n                ellipse = Ellipsoid.WGS84;\n            }\n            a = ellipse.a;\n            b = ellipse.b;\n            rf = ellipse.rf;\n        }\n        if (rf && !b) {\n            b = (1.0 - 1.0 / rf) * a;\n        }\n        if (rf === 0 || Math.abs(a - b) < EPSLN) {\n            sphere = true;\n            b = a;\n        }\n        return {\n            a: a,\n            b: b,\n            rf: rf,\n            sphere: sphere\n        };\n    };\n}\n","/* proj4/lib/constants/Ellipsoid.js */ function _(require, module, exports) {\n    exports.MERIT = {\n        a: 6378137.0,\n        rf: 298.257,\n        ellipseName: \"MERIT 1983\"\n    };\n    exports.SGS85 = {\n        a: 6378136.0,\n        rf: 298.257,\n        ellipseName: \"Soviet Geodetic System 85\"\n    };\n    exports.GRS80 = {\n        a: 6378137.0,\n        rf: 298.257222101,\n        ellipseName: \"GRS 1980(IUGG, 1980)\"\n    };\n    exports.IAU76 = {\n        a: 6378140.0,\n        rf: 298.257,\n        ellipseName: \"IAU 1976\"\n    };\n    exports.airy = {\n        a: 6377563.396,\n        b: 6356256.910,\n        ellipseName: \"Airy 1830\"\n    };\n    exports.APL4 = {\n        a: 6378137,\n        rf: 298.25,\n        ellipseName: \"Appl. Physics. 1965\"\n    };\n    exports.NWL9D = {\n        a: 6378145.0,\n        rf: 298.25,\n        ellipseName: \"Naval Weapons Lab., 1965\"\n    };\n    exports.mod_airy = {\n        a: 6377340.189,\n        b: 6356034.446,\n        ellipseName: \"Modified Airy\"\n    };\n    exports.andrae = {\n        a: 6377104.43,\n        rf: 300.0,\n        ellipseName: \"Andrae 1876 (Den., Iclnd.)\"\n    };\n    exports.aust_SA = {\n        a: 6378160.0,\n        rf: 298.25,\n        ellipseName: \"Australian Natl & S. Amer. 1969\"\n    };\n    exports.GRS67 = {\n        a: 6378160.0,\n        rf: 298.2471674270,\n        ellipseName: \"GRS 67(IUGG 1967)\"\n    };\n    exports.bessel = {\n        a: 6377397.155,\n        rf: 299.1528128,\n        ellipseName: \"Bessel 1841\"\n    };\n    exports.bess_nam = {\n        a: 6377483.865,\n        rf: 299.1528128,\n        ellipseName: \"Bessel 1841 (Namibia)\"\n    };\n    exports.clrk66 = {\n        a: 6378206.4,\n        b: 6356583.8,\n        ellipseName: \"Clarke 1866\"\n    };\n    exports.clrk80 = {\n        a: 6378249.145,\n        rf: 293.4663,\n        ellipseName: \"Clarke 1880 mod.\"\n    };\n    exports.clrk58 = {\n        a: 6378293.645208759,\n        rf: 294.2606763692654,\n        ellipseName: \"Clarke 1858\"\n    };\n    exports.CPM = {\n        a: 6375738.7,\n        rf: 334.29,\n        ellipseName: \"Comm. des Poids et Mesures 1799\"\n    };\n    exports.delmbr = {\n        a: 6376428.0,\n        rf: 311.5,\n        ellipseName: \"Delambre 1810 (Belgium)\"\n    };\n    exports.engelis = {\n        a: 6378136.05,\n        rf: 298.2566,\n        ellipseName: \"Engelis 1985\"\n    };\n    exports.evrst30 = {\n        a: 6377276.345,\n        rf: 300.8017,\n        ellipseName: \"Everest 1830\"\n    };\n    exports.evrst48 = {\n        a: 6377304.063,\n        rf: 300.8017,\n        ellipseName: \"Everest 1948\"\n    };\n    exports.evrst56 = {\n        a: 6377301.243,\n        rf: 300.8017,\n        ellipseName: \"Everest 1956\"\n    };\n    exports.evrst69 = {\n        a: 6377295.664,\n        rf: 300.8017,\n        ellipseName: \"Everest 1969\"\n    };\n    exports.evrstSS = {\n        a: 6377298.556,\n        rf: 300.8017,\n        ellipseName: \"Everest (Sabah & Sarawak)\"\n    };\n    exports.fschr60 = {\n        a: 6378166.0,\n        rf: 298.3,\n        ellipseName: \"Fischer (Mercury Datum) 1960\"\n    };\n    exports.fschr60m = {\n        a: 6378155.0,\n        rf: 298.3,\n        ellipseName: \"Fischer 1960\"\n    };\n    exports.fschr68 = {\n        a: 6378150.0,\n        rf: 298.3,\n        ellipseName: \"Fischer 1968\"\n    };\n    exports.helmert = {\n        a: 6378200.0,\n        rf: 298.3,\n        ellipseName: \"Helmert 1906\"\n    };\n    exports.hough = {\n        a: 6378270.0,\n        rf: 297.0,\n        ellipseName: \"Hough\"\n    };\n    exports.intl = {\n        a: 6378388.0,\n        rf: 297.0,\n        ellipseName: \"International 1909 (Hayford)\"\n    };\n    exports.kaula = {\n        a: 6378163.0,\n        rf: 298.24,\n        ellipseName: \"Kaula 1961\"\n    };\n    exports.lerch = {\n        a: 6378139.0,\n        rf: 298.257,\n        ellipseName: \"Lerch 1979\"\n    };\n    exports.mprts = {\n        a: 6397300.0,\n        rf: 191.0,\n        ellipseName: \"Maupertius 1738\"\n    };\n    exports.new_intl = {\n        a: 6378157.5,\n        b: 6356772.2,\n        ellipseName: \"New International 1967\"\n    };\n    exports.plessis = {\n        a: 6376523.0,\n        rf: 6355863.0,\n        ellipseName: \"Plessis 1817 (France)\"\n    };\n    exports.krass = {\n        a: 6378245.0,\n        rf: 298.3,\n        ellipseName: \"Krassovsky, 1942\"\n    };\n    exports.SEasia = {\n        a: 6378155.0,\n        b: 6356773.3205,\n        ellipseName: \"Southeast Asia\"\n    };\n    exports.walbeck = {\n        a: 6376896.0,\n        b: 6355834.8467,\n        ellipseName: \"Walbeck\"\n    };\n    exports.WGS60 = {\n        a: 6378165.0,\n        rf: 298.3,\n        ellipseName: \"WGS 60\"\n    };\n    exports.WGS66 = {\n        a: 6378145.0,\n        rf: 298.25,\n        ellipseName: \"WGS 66\"\n    };\n    exports.WGS7 = {\n        a: 6378135.0,\n        rf: 298.26,\n        ellipseName: \"WGS 72\"\n    };\n    exports.WGS84 = {\n        a: 6378137.0,\n        rf: 298.257223563,\n        ellipseName: \"WGS 84\"\n    };\n    exports.sphere = {\n        a: 6370997.0,\n        b: 6370997.0,\n        ellipseName: \"Normal Sphere (r=6370997)\"\n    };\n}\n","/* proj4/lib/constants/Datum.js */ function _(require, module, exports) {\n    exports.wgs84 = {\n        towgs84: \"0,0,0\",\n        ellipse: \"WGS84\",\n        datumName: \"WGS84\"\n    };\n    exports.ch1903 = {\n        towgs84: \"674.374,15.056,405.346\",\n        ellipse: \"bessel\",\n        datumName: \"swiss\"\n    };\n    exports.ggrs87 = {\n        towgs84: \"-199.87,74.79,246.62\",\n        ellipse: \"GRS80\",\n        datumName: \"Greek_Geodetic_Reference_System_1987\"\n    };\n    exports.nad83 = {\n        towgs84: \"0,0,0\",\n        ellipse: \"GRS80\",\n        datumName: \"North_American_Datum_1983\"\n    };\n    exports.nad27 = {\n        nadgrids: \"@conus,@alaska,@ntv2_0.gsb,@ntv1_can.dat\",\n        ellipse: \"clrk66\",\n        datumName: \"North_American_Datum_1927\"\n    };\n    exports.potsdam = {\n        towgs84: \"606.0,23.0,413.0\",\n        ellipse: \"bessel\",\n        datumName: \"Potsdam Rauenberg 1950 DHDN\"\n    };\n    exports.carthage = {\n        towgs84: \"-263.0,6.0,431.0\",\n        ellipse: \"clark80\",\n        datumName: \"Carthage 1934 Tunisia\"\n    };\n    exports.hermannskogel = {\n        towgs84: \"653.0,-212.0,449.0\",\n        ellipse: \"bessel\",\n        datumName: \"Hermannskogel\"\n    };\n    exports.ire65 = {\n        towgs84: \"482.530,-130.596,564.557,-1.042,-0.214,-0.631,8.15\",\n        ellipse: \"mod_airy\",\n        datumName: \"Ireland 1965\"\n    };\n    exports.rassadiran = {\n        towgs84: \"-133.63,-157.5,-158.62\",\n        ellipse: \"intl\",\n        datumName: \"Rassadiran\"\n    };\n    exports.nzgd49 = {\n        towgs84: \"59.47,-5.04,187.44,0.47,-0.1,1.024,-4.5993\",\n        ellipse: \"intl\",\n        datumName: \"New Zealand Geodetic Datum 1949\"\n    };\n    exports.osgb36 = {\n        towgs84: \"446.448,-125.157,542.060,0.1502,0.2470,0.8421,-20.4894\",\n        ellipse: \"airy\",\n        datumName: \"Airy 1830\"\n    };\n    exports.s_jtsk = {\n        towgs84: \"589,76,480\",\n        ellipse: 'bessel',\n        datumName: 'S-JTSK (Ferro)'\n    };\n    exports.beduaram = {\n        towgs84: '-106,-87,188',\n        ellipse: 'clrk80',\n        datumName: 'Beduaram'\n    };\n    exports.gunung_segara = {\n        towgs84: '-403,684,41',\n        ellipse: 'bessel',\n        datumName: 'Gunung Segara Jakarta'\n    };\n    exports.rnb72 = {\n        towgs84: \"106.869,-52.2978,103.724,-0.33657,0.456955,-1.84218,1\",\n        ellipse: \"intl\",\n        datumName: \"Reseau National Belge 1972\"\n    };\n}\n","/* proj4/lib/datum.js */ function _(require, module, exports) {\n    var PJD_3PARAM = 1;\n    var PJD_7PARAM = 2;\n    var PJD_WGS84 = 4; // WGS84 or equivalent\n    var PJD_NODATUM = 5; // WGS84 or equivalent\n    var SEC_TO_RAD = 4.84813681109535993589914102357e-6;\n    function datum(datumCode, datum_params, a, b, es, ep2) {\n        var out = {};\n        out.datum_type = PJD_WGS84; //default setting\n        if (datumCode && datumCode === 'none') {\n            out.datum_type = PJD_NODATUM;\n        }\n        if (datum_params) {\n            out.datum_params = datum_params.map(parseFloat);\n            if (out.datum_params[0] !== 0 || out.datum_params[1] !== 0 || out.datum_params[2] !== 0) {\n                out.datum_type = PJD_3PARAM;\n            }\n            if (out.datum_params.length > 3) {\n                if (out.datum_params[3] !== 0 || out.datum_params[4] !== 0 || out.datum_params[5] !== 0 || out.datum_params[6] !== 0) {\n                    out.datum_type = PJD_7PARAM;\n                    out.datum_params[3] *= SEC_TO_RAD;\n                    out.datum_params[4] *= SEC_TO_RAD;\n                    out.datum_params[5] *= SEC_TO_RAD;\n                    out.datum_params[6] = (out.datum_params[6] / 1000000.0) + 1.0;\n                }\n            }\n        }\n        out.a = a; //datum object also uses these values\n        out.b = b;\n        out.es = es;\n        out.ep2 = ep2;\n        return out;\n    }\n    module.exports = datum;\n}\n","/* proj4/lib/transform.js */ function _(require, module, exports) {\n    var D2R = 0.01745329251994329577;\n    var R2D = 57.29577951308232088;\n    var PJD_3PARAM = 1;\n    var PJD_7PARAM = 2;\n    var datum_transform = require(54) /* ./datum_transform */;\n    var adjust_axis = require(56) /* ./adjust_axis */;\n    var proj = require(32) /* ./Proj */;\n    var toPoint = require(57) /* ./common/toPoint */;\n    function checkNotWGS(source, dest) {\n        return ((source.datum.datum_type === PJD_3PARAM || source.datum.datum_type === PJD_7PARAM) && dest.datumCode !== 'WGS84') || ((dest.datum.datum_type === PJD_3PARAM || dest.datum.datum_type === PJD_7PARAM) && source.datumCode !== 'WGS84');\n    }\n    module.exports = function transform(source, dest, point) {\n        var wgs84;\n        if (Array.isArray(point)) {\n            point = toPoint(point);\n        }\n        // Workaround for datum shifts towgs84, if either source or destination projection is not wgs84\n        if (source.datum && dest.datum && checkNotWGS(source, dest)) {\n            wgs84 = new proj('WGS84');\n            point = transform(source, wgs84, point);\n            source = wgs84;\n        }\n        // DGR, 2010/11/12\n        if (source.axis !== 'enu') {\n            point = adjust_axis(source, false, point);\n        }\n        // Transform source points to long/lat, if they aren't already.\n        if (source.projName === 'longlat') {\n            point = {\n                x: point.x * D2R,\n                y: point.y * D2R\n            };\n        }\n        else {\n            if (source.to_meter) {\n                point = {\n                    x: point.x * source.to_meter,\n                    y: point.y * source.to_meter\n                };\n            }\n            point = source.inverse(point); // Convert Cartesian to longlat\n        }\n        // Adjust for the prime meridian if necessary\n        if (source.from_greenwich) {\n            point.x += source.from_greenwich;\n        }\n        // Convert datums if needed, and if possible.\n        point = datum_transform(source.datum, dest.datum, point);\n        // Adjust for the prime meridian if necessary\n        if (dest.from_greenwich) {\n            point = {\n                x: point.x - dest.grom_greenwich,\n                y: point.y\n            };\n        }\n        if (dest.projName === 'longlat') {\n            // convert radians to decimal degrees\n            point = {\n                x: point.x * R2D,\n                y: point.y * R2D\n            };\n        }\n        else { // else project\n            point = dest.forward(point);\n            if (dest.to_meter) {\n                point = {\n                    x: point.x / dest.to_meter,\n                    y: point.y / dest.to_meter\n                };\n            }\n        }\n        // DGR, 2010/11/12\n        if (dest.axis !== 'enu') {\n            return adjust_axis(dest, true, point);\n        }\n        return point;\n    };\n}\n","/* proj4/lib/datum_transform.js */ function _(require, module, exports) {\n    var PJD_3PARAM = 1;\n    var PJD_7PARAM = 2;\n    var PJD_NODATUM = 5; // WGS84 or equivalent\n    var datum = require(55) /* ./datumUtils */;\n    function checkParams(type) {\n        return (type === PJD_3PARAM || type === PJD_7PARAM);\n    }\n    module.exports = function (source, dest, point) {\n        // Short cut if the datums are identical.\n        if (datum.compareDatums(source, dest)) {\n            return point; // in this case, zero is sucess,\n            // whereas cs_compare_datums returns 1 to indicate TRUE\n            // confusing, should fix this\n        }\n        // Explicitly skip datum transform by setting 'datum=none' as parameter for either source or dest\n        if (source.datum_type === PJD_NODATUM || dest.datum_type === PJD_NODATUM) {\n            return point;\n        }\n        // If this datum requires grid shifts, then apply it to geodetic coordinates.\n        // Do we need to go through geocentric coordinates?\n        if (source.es === dest.es && source.a === dest.a && !checkParams(source.datum_type) && !checkParams(dest.datum_type)) {\n            return point;\n        }\n        // Convert to geocentric coordinates.\n        point = datum.geodeticToGeocentric(point, source.es, source.a);\n        // Convert between datums\n        if (checkParams(source.datum_type)) {\n            point = datum.geocentricToWgs84(point, source.datum_type, source.datum_params);\n        }\n        if (checkParams(dest.datum_type)) {\n            point = datum.geocentricFromWgs84(point, dest.datum_type, dest.datum_params);\n        }\n        return datum.geocentricToGeodetic(point, dest.es, dest.a, dest.b);\n    };\n}\n","/* proj4/lib/datumUtils.js */ function _(require, module, exports) {\n    var PJD_3PARAM = 1;\n    var PJD_7PARAM = 2;\n    var HALF_PI = Math.PI / 2;\n    exports.compareDatums = function (source, dest) {\n        if (source.datum_type !== dest.datum_type) {\n            return false; // false, datums are not equal\n        }\n        else if (source.a !== dest.a || Math.abs(this.es - dest.es) > 0.000000000050) {\n            // the tolerence for es is to ensure that GRS80 and WGS84\n            // are considered identical\n            return false;\n        }\n        else if (source.datum_type === PJD_3PARAM) {\n            return (this.datum_params[0] === dest.datum_params[0] && source.datum_params[1] === dest.datum_params[1] && source.datum_params[2] === dest.datum_params[2]);\n        }\n        else if (source.datum_type === PJD_7PARAM) {\n            return (source.datum_params[0] === dest.datum_params[0] && source.datum_params[1] === dest.datum_params[1] && source.datum_params[2] === dest.datum_params[2] && source.datum_params[3] === dest.datum_params[3] && source.datum_params[4] === dest.datum_params[4] && source.datum_params[5] === dest.datum_params[5] && source.datum_params[6] === dest.datum_params[6]);\n        }\n        else {\n            return true; // datums are equal\n        }\n    }; // cs_compare_datums()\n    /*\n     * The function Convert_Geodetic_To_Geocentric converts geodetic coordinates\n     * (latitude, longitude, and height) to geocentric coordinates (X, Y, Z),\n     * according to the current ellipsoid parameters.\n     *\n     *    Latitude  : Geodetic latitude in radians                     (input)\n     *    Longitude : Geodetic longitude in radians                    (input)\n     *    Height    : Geodetic height, in meters                       (input)\n     *    X         : Calculated Geocentric X coordinate, in meters    (output)\n     *    Y         : Calculated Geocentric Y coordinate, in meters    (output)\n     *    Z         : Calculated Geocentric Z coordinate, in meters    (output)\n     *\n     */\n    exports.geodeticToGeocentric = function (p, es, a) {\n        var Longitude = p.x;\n        var Latitude = p.y;\n        var Height = p.z ? p.z : 0; //Z value not always supplied\n        var Rn; /*  Earth radius at location  */\n        var Sin_Lat; /*  Math.sin(Latitude)  */\n        var Sin2_Lat; /*  Square of Math.sin(Latitude)  */\n        var Cos_Lat; /*  Math.cos(Latitude)  */\n        /*\n         ** Don't blow up if Latitude is just a little out of the value\n         ** range as it may just be a rounding issue.  Also removed longitude\n         ** test, it should be wrapped by Math.cos() and Math.sin().  NFW for PROJ.4, Sep/2001.\n         */\n        if (Latitude < -HALF_PI && Latitude > -1.001 * HALF_PI) {\n            Latitude = -HALF_PI;\n        }\n        else if (Latitude > HALF_PI && Latitude < 1.001 * HALF_PI) {\n            Latitude = HALF_PI;\n        }\n        else if ((Latitude < -HALF_PI) || (Latitude > HALF_PI)) {\n            /* Latitude out of range */\n            //..reportError('geocent:lat out of range:' + Latitude);\n            return null;\n        }\n        if (Longitude > Math.PI) {\n            Longitude -= (2 * Math.PI);\n        }\n        Sin_Lat = Math.sin(Latitude);\n        Cos_Lat = Math.cos(Latitude);\n        Sin2_Lat = Sin_Lat * Sin_Lat;\n        Rn = a / (Math.sqrt(1.0e0 - es * Sin2_Lat));\n        return {\n            x: (Rn + Height) * Cos_Lat * Math.cos(Longitude),\n            y: (Rn + Height) * Cos_Lat * Math.sin(Longitude),\n            z: ((Rn * (1 - es)) + Height) * Sin_Lat\n        };\n    }; // cs_geodetic_to_geocentric()\n    exports.geocentricToGeodetic = function (p, es, a, b) {\n        /* local defintions and variables */\n        /* end-criterium of loop, accuracy of sin(Latitude) */\n        var genau = 1e-12;\n        var genau2 = (genau * genau);\n        var maxiter = 30;\n        var P; /* distance between semi-minor axis and location */\n        var RR; /* distance between center and location */\n        var CT; /* sin of geocentric latitude */\n        var ST; /* cos of geocentric latitude */\n        var RX;\n        var RK;\n        var RN; /* Earth radius at location */\n        var CPHI0; /* cos of start or old geodetic latitude in iterations */\n        var SPHI0; /* sin of start or old geodetic latitude in iterations */\n        var CPHI; /* cos of searched geodetic latitude */\n        var SPHI; /* sin of searched geodetic latitude */\n        var SDPHI; /* end-criterium: addition-theorem of sin(Latitude(iter)-Latitude(iter-1)) */\n        var iter; /* # of continous iteration, max. 30 is always enough (s.a.) */\n        var X = p.x;\n        var Y = p.y;\n        var Z = p.z ? p.z : 0.0; //Z value not always supplied\n        var Longitude;\n        var Latitude;\n        var Height;\n        P = Math.sqrt(X * X + Y * Y);\n        RR = Math.sqrt(X * X + Y * Y + Z * Z);\n        /*      special cases for latitude and longitude */\n        if (P / a < genau) {\n            /*  special case, if P=0. (X=0., Y=0.) */\n            Longitude = 0.0;\n            /*  if (X,Y,Z)=(0.,0.,0.) then Height becomes semi-minor axis\n             *  of ellipsoid (=center of mass), Latitude becomes PI/2 */\n            if (RR / a < genau) {\n                Latitude = HALF_PI;\n                Height = -b;\n                return {\n                    x: p.x,\n                    y: p.y,\n                    z: p.z\n                };\n            }\n        }\n        else {\n            /*  ellipsoidal (geodetic) longitude\n             *  interval: -PI < Longitude <= +PI */\n            Longitude = Math.atan2(Y, X);\n        }\n        /* --------------------------------------------------------------\n         * Following iterative algorithm was developped by\n         * \"Institut for Erdmessung\", University of Hannover, July 1988.\n         * Internet: www.ife.uni-hannover.de\n         * Iterative computation of CPHI,SPHI and Height.\n         * Iteration of CPHI and SPHI to 10**-12 radian resp.\n         * 2*10**-7 arcsec.\n         * --------------------------------------------------------------\n         */\n        CT = Z / RR;\n        ST = P / RR;\n        RX = 1.0 / Math.sqrt(1.0 - es * (2.0 - es) * ST * ST);\n        CPHI0 = ST * (1.0 - es) * RX;\n        SPHI0 = CT * RX;\n        iter = 0;\n        /* loop to find sin(Latitude) resp. Latitude\n         * until |sin(Latitude(iter)-Latitude(iter-1))| < genau */\n        do {\n            iter++;\n            RN = a / Math.sqrt(1.0 - es * SPHI0 * SPHI0);\n            /*  ellipsoidal (geodetic) height */\n            Height = P * CPHI0 + Z * SPHI0 - RN * (1.0 - es * SPHI0 * SPHI0);\n            RK = es * RN / (RN + Height);\n            RX = 1.0 / Math.sqrt(1.0 - RK * (2.0 - RK) * ST * ST);\n            CPHI = ST * (1.0 - RK) * RX;\n            SPHI = CT * RX;\n            SDPHI = SPHI * CPHI0 - CPHI * SPHI0;\n            CPHI0 = CPHI;\n            SPHI0 = SPHI;\n        } while (SDPHI * SDPHI > genau2 && iter < maxiter);\n        /*      ellipsoidal (geodetic) latitude */\n        Latitude = Math.atan(SPHI / Math.abs(CPHI));\n        return {\n            x: Longitude,\n            y: Latitude,\n            z: Height\n        };\n    }; // cs_geocentric_to_geodetic()\n    /****************************************************************/\n    // pj_geocentic_to_wgs84( p )\n    //  p = point to transform in geocentric coordinates (x,y,z)\n    /** point object, nothing fancy, just allows values to be\n        passed back and forth by reference rather than by value.\n        Other point classes may be used as long as they have\n        x and y properties, which will get modified in the transform method.\n    */\n    exports.geocentricToWgs84 = function (p, datum_type, datum_params) {\n        if (datum_type === PJD_3PARAM) {\n            // if( x[io] === HUGE_VAL )\n            //    continue;\n            return {\n                x: p.x + datum_params[0],\n                y: p.y + datum_params[1],\n                z: p.z + datum_params[2],\n            };\n        }\n        else if (datum_type === PJD_7PARAM) {\n            var Dx_BF = datum_params[0];\n            var Dy_BF = datum_params[1];\n            var Dz_BF = datum_params[2];\n            var Rx_BF = datum_params[3];\n            var Ry_BF = datum_params[4];\n            var Rz_BF = datum_params[5];\n            var M_BF = datum_params[6];\n            // if( x[io] === HUGE_VAL )\n            //    continue;\n            return {\n                x: M_BF * (p.x - Rz_BF * p.y + Ry_BF * p.z) + Dx_BF,\n                y: M_BF * (Rz_BF * p.x + p.y - Rx_BF * p.z) + Dy_BF,\n                z: M_BF * (-Ry_BF * p.x + Rx_BF * p.y + p.z) + Dz_BF\n            };\n        }\n    }; // cs_geocentric_to_wgs84\n    /****************************************************************/\n    // pj_geocentic_from_wgs84()\n    //  coordinate system definition,\n    //  point to transform in geocentric coordinates (x,y,z)\n    exports.geocentricFromWgs84 = function (p, datum_type, datum_params) {\n        if (datum_type === PJD_3PARAM) {\n            //if( x[io] === HUGE_VAL )\n            //    continue;\n            return {\n                x: p.x - datum_params[0],\n                y: p.y - datum_params[1],\n                z: p.z - datum_params[2],\n            };\n        }\n        else if (datum_type === PJD_7PARAM) {\n            var Dx_BF = datum_params[0];\n            var Dy_BF = datum_params[1];\n            var Dz_BF = datum_params[2];\n            var Rx_BF = datum_params[3];\n            var Ry_BF = datum_params[4];\n            var Rz_BF = datum_params[5];\n            var M_BF = datum_params[6];\n            var x_tmp = (p.x - Dx_BF) / M_BF;\n            var y_tmp = (p.y - Dy_BF) / M_BF;\n            var z_tmp = (p.z - Dz_BF) / M_BF;\n            //if( x[io] === HUGE_VAL )\n            //    continue;\n            return {\n                x: x_tmp + Rz_BF * y_tmp - Ry_BF * z_tmp,\n                y: -Rz_BF * x_tmp + y_tmp + Rx_BF * z_tmp,\n                z: Ry_BF * x_tmp - Rx_BF * y_tmp + z_tmp\n            };\n        } //cs_geocentric_from_wgs84()\n    };\n}\n","/* proj4/lib/adjust_axis.js */ function _(require, module, exports) {\n    module.exports = function (crs, denorm, point) {\n        var xin = point.x, yin = point.y, zin = point.z || 0.0;\n        var v, t, i;\n        var out = {};\n        for (i = 0; i < 3; i++) {\n            if (denorm && i === 2 && point.z === undefined) {\n                continue;\n            }\n            if (i === 0) {\n                v = xin;\n                t = 'x';\n            }\n            else if (i === 1) {\n                v = yin;\n                t = 'y';\n            }\n            else {\n                v = zin;\n                t = 'z';\n            }\n            switch (crs.axis[i]) {\n                case 'e':\n                    out[t] = v;\n                    break;\n                case 'w':\n                    out[t] = -v;\n                    break;\n                case 'n':\n                    out[t] = v;\n                    break;\n                case 's':\n                    out[t] = -v;\n                    break;\n                case 'u':\n                    if (point[t] !== undefined) {\n                        out.z = v;\n                    }\n                    break;\n                case 'd':\n                    if (point[t] !== undefined) {\n                        out.z = -v;\n                    }\n                    break;\n                default:\n                    //console.log(\"ERROR: unknow axis (\"+crs.axis[i]+\") - check definition of \"+crs.projName);\n                    return null;\n            }\n        }\n        return out;\n    };\n}\n","/* proj4/lib/common/toPoint.js */ function _(require, module, exports) {\n    module.exports = function (array) {\n        var out = {\n            x: array[0],\n            y: array[1]\n        };\n        if (array.length > 2) {\n            out.z = array[2];\n        }\n        if (array.length > 3) {\n            out.m = array[3];\n        }\n        return out;\n    };\n}\n","/* models/renderers/renderer.js */ function _(require, module, exports) {\n    const dom_view_1 = require(59) /* ../../core/dom_view */;\n    const visuals = require(63) /* ../../core/visuals */;\n    const p = require(18) /* ../../core/properties */;\n    const model_1 = require(64) /* ../../model */;\n    // This shouldn't be a DOMView, but annotations create a mess.\n    class RendererView extends dom_view_1.DOMView {\n        initialize() {\n            super.initialize();\n            this.visuals = new visuals.Visuals(this.model);\n            this._has_finished = true; // XXX: should be in render() but subclasses don't respect super()\n        }\n        get plot_view() {\n            return this.parent;\n        }\n        get plot_model() {\n            return this.parent.model;\n        }\n        request_render() {\n            this.plot_view.request_render();\n        }\n        map_to_screen(x, y) {\n            return this.plot_view.map_to_screen(x, y, this.model.x_range_name, this.model.y_range_name);\n        }\n        get needs_clip() {\n            return false;\n        }\n        notify_finished() {\n            this.plot_view.notify_finished();\n        }\n        get has_webgl() {\n            return false;\n        }\n    }\n    exports.RendererView = RendererView;\n    RendererView.__name__ = \"RendererView\";\n    class Renderer extends model_1.Model {\n        constructor(attrs) {\n            super(attrs);\n        }\n        static init_Renderer() {\n            this.define({\n                level: [p.RenderLevel],\n                visible: [p.Boolean, true],\n            });\n        }\n    }\n    exports.Renderer = Renderer;\n    Renderer.__name__ = \"Renderer\";\n    Renderer.init_Renderer();\n}\n","/* core/dom_view.js */ function _(require, module, exports) {\n    const view_1 = require(60) /* ./view */;\n    const DOM = require(61) /* ./dom */;\n    const root_1 = require(62) /* ../styles/root */;\n    class DOMView extends view_1.View {\n        initialize() {\n            super.initialize();\n            this._has_finished = false;\n            this.el = this._createElement();\n        }\n        remove() {\n            DOM.removeElement(this.el);\n            super.remove();\n        }\n        css_classes() {\n            return [];\n        }\n        cursor(_sx, _sy) {\n            return null;\n        }\n        render() { }\n        renderTo(element) {\n            element.appendChild(this.el);\n            this.render();\n        }\n        has_finished() {\n            return this._has_finished;\n        }\n        get _root_element() {\n            return DOM.parent(this.el, `.${root_1.bk_root}`) || document.body;\n        }\n        get is_idle() {\n            return this.has_finished();\n        }\n        _createElement() {\n            return DOM.createElement(this.tagName, { class: this.css_classes() });\n        }\n    }\n    exports.DOMView = DOMView;\n    DOMView.__name__ = \"DOMView\";\n    DOMView.prototype.tagName = \"div\";\n}\n","/* core/view.js */ function _(require, module, exports) {\n    const signaling_1 = require(13) /* ./signaling */;\n    const types_1 = require(7) /* ./util/types */;\n    const string_1 = require(25) /* ./util/string */;\n    class View extends signaling_1.Signalable() {\n        constructor(options) {\n            super();\n            this.removed = new signaling_1.Signal0(this, \"removed\");\n            if (options.model != null)\n                this.model = options.model;\n            else\n                throw new Error(\"model of a view wasn't configured\");\n            this._parent = options.parent;\n            this.id = options.id || string_1.uniqueId();\n            this.initialize();\n            if (options.connect_signals !== false)\n                this.connect_signals();\n        }\n        initialize() { }\n        remove() {\n            this._parent = undefined;\n            this.disconnect_signals();\n            this.removed.emit();\n        }\n        toString() {\n            return `${this.model.type}View(${this.id})`;\n        }\n        serializable_state() {\n            return { type: this.model.type };\n        }\n        get parent() {\n            if (this._parent !== undefined)\n                return this._parent;\n            else\n                throw new Error(\"parent of a view wasn't configured\");\n        }\n        get is_root() {\n            return this.parent === null;\n        }\n        get root() {\n            return this.is_root ? this : this.parent.root;\n        }\n        assert_root() {\n            if (!this.is_root)\n                throw new Error(`${this.toString()} is not a root layout`);\n        }\n        connect_signals() { }\n        disconnect_signals() {\n            signaling_1.Signal.disconnectReceiver(this);\n        }\n        on_change(properties, fn) {\n            for (const property of types_1.isArray(properties) ? properties : [properties])\n                this.connect(property.change, fn);\n        }\n    }\n    exports.View = View;\n    View.__name__ = \"View\";\n}\n","/* core/dom.js */ function _(require, module, exports) {\n    const types_1 = require(7) /* ./util/types */;\n    const _createElement = (tag) => {\n        return (attrs = {}, ...children) => {\n            const element = document.createElement(tag);\n            element.classList.add(\"bk\");\n            for (const attr in attrs) {\n                let value = attrs[attr];\n                if (value == null || types_1.isBoolean(value) && !value)\n                    continue;\n                if (attr === \"class\") {\n                    if (types_1.isString(value))\n                        value = value.split(/\\s+/);\n                    if (types_1.isArray(value)) {\n                        for (const cls of value) {\n                            if (cls != null)\n                                element.classList.add(cls);\n                        }\n                        continue;\n                    }\n                }\n                if (attr === \"style\" && types_1.isPlainObject(value)) {\n                    for (const prop in value) {\n                        element.style[prop] = value[prop];\n                    }\n                    continue;\n                }\n                if (attr === \"data\" && types_1.isPlainObject(value)) {\n                    for (const key in value) {\n                        element.dataset[key] = value[key]; // XXX: attrs needs a better type\n                    }\n                    continue;\n                }\n                element.setAttribute(attr, value);\n            }\n            function append(child) {\n                if (child instanceof HTMLElement)\n                    element.appendChild(child);\n                else if (types_1.isString(child))\n                    element.appendChild(document.createTextNode(child));\n                else if (child != null && child !== false)\n                    throw new Error(`expected an HTMLElement, string, false or null, got ${JSON.stringify(child)}`);\n            }\n            for (const child of children) {\n                if (types_1.isArray(child)) {\n                    for (const _child of child)\n                        append(_child);\n                }\n                else\n                    append(child);\n            }\n            return element;\n        };\n    };\n    function createElement(tag, attrs, ...children) {\n        return _createElement(tag)(attrs, ...children);\n    }\n    exports.createElement = createElement;\n    exports.div = _createElement(\"div\"), exports.span = _createElement(\"span\"), exports.canvas = _createElement(\"canvas\"), exports.link = _createElement(\"link\"), exports.style = _createElement(\"style\"), exports.a = _createElement(\"a\"), exports.p = _createElement(\"p\"), exports.i = _createElement(\"i\"), exports.pre = _createElement(\"pre\"), exports.button = _createElement(\"button\"), exports.label = _createElement(\"label\"), exports.input = _createElement(\"input\"), exports.select = _createElement(\"select\"), exports.option = _createElement(\"option\"), exports.optgroup = _createElement(\"optgroup\"), exports.textarea = _createElement(\"textarea\");\n    function nbsp() {\n        return document.createTextNode(\"\\u00a0\");\n    }\n    exports.nbsp = nbsp;\n    function removeElement(element) {\n        const parent = element.parentNode;\n        if (parent != null) {\n            parent.removeChild(element);\n        }\n    }\n    exports.removeElement = removeElement;\n    function replaceWith(element, replacement) {\n        const parent = element.parentNode;\n        if (parent != null) {\n            parent.replaceChild(replacement, element);\n        }\n    }\n    exports.replaceWith = replaceWith;\n    function prepend(element, ...nodes) {\n        const first = element.firstChild;\n        for (const node of nodes) {\n            element.insertBefore(node, first);\n        }\n    }\n    exports.prepend = prepend;\n    function empty(element) {\n        let child;\n        while (child = element.firstChild) {\n            element.removeChild(child);\n        }\n    }\n    exports.empty = empty;\n    function display(element) {\n        element.style.display = \"\";\n    }\n    exports.display = display;\n    function undisplay(element) {\n        element.style.display = \"none\";\n    }\n    exports.undisplay = undisplay;\n    function show(element) {\n        element.style.visibility = \"\";\n    }\n    exports.show = show;\n    function hide(element) {\n        element.style.visibility = \"hidden\";\n    }\n    exports.hide = hide;\n    function offset(element) {\n        const rect = element.getBoundingClientRect();\n        return {\n            top: rect.top + window.pageYOffset - document.documentElement.clientTop,\n            left: rect.left + window.pageXOffset - document.documentElement.clientLeft,\n        };\n    }\n    exports.offset = offset;\n    function matches(el, selector) {\n        const p = Element.prototype;\n        const f = p.matches || p.webkitMatchesSelector || p.mozMatchesSelector || p.msMatchesSelector;\n        return f.call(el, selector);\n    }\n    exports.matches = matches;\n    function parent(el, selector) {\n        let node = el;\n        while (node = node.parentElement) {\n            if (matches(node, selector))\n                return node;\n        }\n        return null;\n    }\n    exports.parent = parent;\n    function num(value) {\n        return parseFloat(value) || 0;\n    }\n    function extents(el) {\n        const style = getComputedStyle(el);\n        return {\n            border: {\n                top: num(style.borderTopWidth),\n                bottom: num(style.borderBottomWidth),\n                left: num(style.borderLeftWidth),\n                right: num(style.borderRightWidth),\n            },\n            margin: {\n                top: num(style.marginTop),\n                bottom: num(style.marginBottom),\n                left: num(style.marginLeft),\n                right: num(style.marginRight),\n            },\n            padding: {\n                top: num(style.paddingTop),\n                bottom: num(style.paddingBottom),\n                left: num(style.paddingLeft),\n                right: num(style.paddingRight),\n            },\n        };\n    }\n    exports.extents = extents;\n    function size(el) {\n        const rect = el.getBoundingClientRect();\n        return {\n            width: Math.ceil(rect.width),\n            height: Math.ceil(rect.height),\n        };\n    }\n    exports.size = size;\n    function scroll_size(el) {\n        return {\n            width: Math.ceil(el.scrollWidth),\n            height: Math.ceil(el.scrollHeight),\n        };\n    }\n    exports.scroll_size = scroll_size;\n    function outer_size(el) {\n        const { margin: { left, right, top, bottom } } = extents(el);\n        const { width, height } = size(el);\n        return {\n            width: Math.ceil(width + left + right),\n            height: Math.ceil(height + top + bottom),\n        };\n    }\n    exports.outer_size = outer_size;\n    function content_size(el) {\n        const { left, top } = el.getBoundingClientRect();\n        const { padding } = extents(el);\n        let width = 0;\n        let height = 0;\n        for (const child of children(el)) {\n            const rect = child.getBoundingClientRect();\n            width = Math.max(width, Math.ceil(rect.left - left - padding.left + rect.width));\n            height = Math.max(height, Math.ceil(rect.top - top - padding.top + rect.height));\n        }\n        return { width, height };\n    }\n    exports.content_size = content_size;\n    function position(el, box, margin) {\n        const { style } = el;\n        style.left = `${box.x}px`;\n        style.top = `${box.y}px`;\n        style.width = `${box.width}px`;\n        style.height = `${box.height}px`;\n        if (margin == null)\n            style.margin = \"\";\n        else {\n            const { top, right, bottom, left } = margin;\n            style.margin = `${top}px ${right}px ${bottom}px ${left}px`;\n        }\n    }\n    exports.position = position;\n    function children(el) {\n        return Array.from(el.children);\n    }\n    exports.children = children;\n    class ClassList {\n        constructor(el) {\n            this.el = el;\n            this.classList = el.classList;\n        }\n        get values() {\n            const values = [];\n            for (let i = 0; i < this.classList.length; i++) {\n                const item = this.classList.item(i);\n                if (item != null)\n                    values.push(item);\n            }\n            return values;\n        }\n        has(cls) {\n            return this.classList.contains(cls);\n        }\n        add(...classes) {\n            for (const cls of classes)\n                this.classList.add(cls);\n            return this;\n        }\n        remove(...classes) {\n            for (const cls of classes)\n                this.classList.remove(cls);\n            return this;\n        }\n        clear() {\n            for (const cls of this.values) {\n                if (cls != \"bk\")\n                    this.classList.remove(cls);\n            }\n            return this;\n        }\n        toggle(cls, activate) {\n            const add = activate != null ? activate : !this.has(cls);\n            if (add)\n                this.add(cls);\n            else\n                this.remove(cls);\n            return this;\n        }\n    }\n    exports.ClassList = ClassList;\n    ClassList.__name__ = \"ClassList\";\n    function classes(el) {\n        return new ClassList(el);\n    }\n    exports.classes = classes;\n    var Keys;\n    (function (Keys) {\n        Keys[Keys[\"Backspace\"] = 8] = \"Backspace\";\n        Keys[Keys[\"Tab\"] = 9] = \"Tab\";\n        Keys[Keys[\"Enter\"] = 13] = \"Enter\";\n        Keys[Keys[\"Esc\"] = 27] = \"Esc\";\n        Keys[Keys[\"PageUp\"] = 33] = \"PageUp\";\n        Keys[Keys[\"PageDown\"] = 34] = \"PageDown\";\n        Keys[Keys[\"Left\"] = 37] = \"Left\";\n        Keys[Keys[\"Up\"] = 38] = \"Up\";\n        Keys[Keys[\"Right\"] = 39] = \"Right\";\n        Keys[Keys[\"Down\"] = 40] = \"Down\";\n        Keys[Keys[\"Delete\"] = 46] = \"Delete\";\n    })(Keys = exports.Keys || (exports.Keys = {}));\n    function undisplayed(el, fn) {\n        const { display } = el.style;\n        el.style.display = \"none\";\n        try {\n            return fn();\n        }\n        finally {\n            el.style.display = display;\n        }\n    }\n    exports.undisplayed = undisplayed;\n    function unsized(el, fn) {\n        return sized(el, {}, fn);\n    }\n    exports.unsized = unsized;\n    function sized(el, size, fn) {\n        const { width, height, position, display } = el.style;\n        el.style.position = \"absolute\";\n        el.style.display = \"\";\n        el.style.width = size.width != null && size.width != Infinity ? `${size.width}px` : \"auto\";\n        el.style.height = size.height != null && size.height != Infinity ? `${size.height}px` : \"auto\";\n        try {\n            return fn();\n        }\n        finally {\n            el.style.position = position;\n            el.style.display = display;\n            el.style.width = width;\n            el.style.height = height;\n        }\n    }\n    exports.sized = sized;\n    class StyleSheet {\n        constructor() {\n            this.style = exports.style({ type: \"text/css\" });\n            prepend(document.head, this.style);\n        }\n        append(css) {\n            this.style.appendChild(document.createTextNode(css));\n        }\n    }\n    exports.StyleSheet = StyleSheet;\n    StyleSheet.__name__ = \"StyleSheet\";\n    exports.styles = new StyleSheet();\n}\n","/* styles/root.js */ function _(require, module, exports) {\n    const _a = require(61) /* ../core/dom */;\n    _a.styles.append(\".bk-root {\\n  position: relative;\\n  width: auto;\\n  height: auto;\\n  z-index: 0;\\n  box-sizing: border-box;\\n  font-family: Helvetica, Arial, sans-serif;\\n  font-size: 10pt;\\n}\\n.bk-root .bk,\\n.bk-root .bk:before,\\n.bk-root .bk:after {\\n  box-sizing: inherit;\\n  margin: 0;\\n  border: 0;\\n  padding: 0;\\n  background-image: none;\\n  font-family: inherit;\\n  font-size: 100%;\\n  line-height: 1.42857143;\\n}\\n.bk-root pre.bk {\\n  font-family: Courier, monospace;\\n}\\n\");\n    exports.bk_root = \"bk-root\";\n}\n","/* core/visuals.js */ function _(require, module, exports) {\n    const mixins = require(17) /* ./property_mixins */;\n    const color_1 = require(20) /* ./util/color */;\n    function _horz(ctx, h, h2) {\n        ctx.moveTo(0, h2 + 0.5);\n        ctx.lineTo(h, h2 + 0.5);\n        ctx.stroke();\n    }\n    function _vert(ctx, h, h2) {\n        ctx.moveTo(h2 + 0.5, 0);\n        ctx.lineTo(h2 + 0.5, h);\n        ctx.stroke();\n    }\n    function _x(ctx, h) {\n        ctx.moveTo(0, h);\n        ctx.lineTo(h, 0);\n        ctx.stroke();\n        ctx.moveTo(0, 0);\n        ctx.lineTo(h, h);\n        ctx.stroke();\n    }\n    function _get_canvas(size) {\n        const canvas = document.createElement('canvas');\n        canvas.width = size;\n        canvas.height = size;\n        return canvas;\n    }\n    function create_hatch_canvas(hatch_pattern, hatch_color, hatch_scale, hatch_weight) {\n        const h = hatch_scale;\n        const h2 = h / 2;\n        const h4 = h2 / 2;\n        const canvas = _get_canvas(hatch_scale);\n        const ctx = canvas.getContext(\"2d\");\n        ctx.strokeStyle = hatch_color;\n        ctx.lineCap = \"square\";\n        ctx.fillStyle = hatch_color;\n        ctx.lineWidth = hatch_weight;\n        switch (hatch_pattern) {\n            // we should not need these if code conditions on hatch.doit, but\n            // include them here just for completeness\n            case \" \":\n            case \"blank\":\n                break;\n            case \".\":\n            case \"dot\":\n                ctx.arc(h2, h2, h2 / 2, 0, 2 * Math.PI, true);\n                ctx.fill();\n                break;\n            case \"o\":\n            case \"ring\":\n                ctx.arc(h2, h2, h2 / 2, 0, 2 * Math.PI, true);\n                ctx.stroke();\n                break;\n            case \"-\":\n            case \"horizontal_line\":\n                _horz(ctx, h, h2);\n                break;\n            case \"|\":\n            case \"vertical_line\":\n                _vert(ctx, h, h2);\n                break;\n            case \"+\":\n            case \"cross\":\n                _horz(ctx, h, h2);\n                _vert(ctx, h, h2);\n                break;\n            case \"\\\"\":\n            case \"horizontal_dash\":\n                _horz(ctx, h2, h2);\n                break;\n            case \":\":\n            case \"vertical_dash\":\n                _vert(ctx, h2, h2);\n                break;\n            case \"@\":\n            case \"spiral\":\n                const h30 = h / 30;\n                ctx.moveTo(h2, h2);\n                for (let i = 0; i < 360; i++) {\n                    const angle = 0.1 * i;\n                    const x = h2 + (h30 * angle) * Math.cos(angle);\n                    const y = h2 + (h30 * angle) * Math.sin(angle);\n                    ctx.lineTo(x, y);\n                }\n                ctx.stroke();\n                break;\n            case \"/\":\n            case \"right_diagonal_line\":\n                ctx.moveTo(-h4 + 0.5, h);\n                ctx.lineTo(h4 + 0.5, 0);\n                ctx.stroke();\n                ctx.moveTo(h4 + 0.5, h);\n                ctx.lineTo(3 * h4 + 0.5, 0);\n                ctx.stroke();\n                ctx.moveTo(3 * h4 + 0.5, h);\n                ctx.lineTo(5 * h4 + 0.5, 0);\n                ctx.stroke();\n                ctx.stroke();\n                break;\n            case \"\\\\\":\n            case \"left_diagonal_line\":\n                ctx.moveTo(h4 + 0.5, h);\n                ctx.lineTo(-h4 + 0.5, 0);\n                ctx.stroke();\n                ctx.moveTo(3 * h4 + 0.5, h);\n                ctx.lineTo(h4 + 0.5, 0);\n                ctx.stroke();\n                ctx.moveTo(5 * h4 + 0.5, h);\n                ctx.lineTo(3 * h4 + 0.5, 0);\n                ctx.stroke();\n                ctx.stroke();\n                break;\n            case \"x\":\n            case \"diagonal_cross\":\n                _x(ctx, h);\n                break;\n            case \",\":\n            case \"right_diagonal_dash\":\n                ctx.moveTo(h4 + 0.5, 3 * h4 + 0.5);\n                ctx.lineTo(3 * h4 + 0.5, h4 + 0.5);\n                ctx.stroke();\n                break;\n            case \"`\":\n            case \"left_diagonal_dash\":\n                ctx.moveTo(h4 + 0.5, h4 + 0.5);\n                ctx.lineTo(3 * h4 + 0.5, 3 * h4 + 0.5);\n                ctx.stroke();\n                break;\n            case \"v\":\n            case \"horizontal_wave\":\n                ctx.moveTo(0, h4);\n                ctx.lineTo(h2, 3 * h4);\n                ctx.lineTo(h, h4);\n                ctx.stroke();\n                break;\n            case \">\":\n            case \"vertical_wave\":\n                ctx.moveTo(h4, 0);\n                ctx.lineTo(3 * h4, h2);\n                ctx.lineTo(h4, h);\n                ctx.stroke();\n                break;\n            case \"*\":\n            case \"criss_cross\":\n                _x(ctx, h);\n                _horz(ctx, h, h2);\n                _vert(ctx, h, h2);\n                break;\n        }\n        return canvas;\n    }\n    class ContextProperties {\n        constructor(obj, prefix = \"\") {\n            this.obj = obj;\n            this.prefix = prefix;\n            // }\n            this.cache = {};\n            for (const attr of this.attrs)\n                this[attr] = obj.properties[prefix + attr];\n        }\n        warm_cache(source) {\n            for (const attr of this.attrs) {\n                const prop = this.obj.properties[this.prefix + attr];\n                if (prop.spec.value !== undefined) // TODO (bev) better test?\n                    this.cache[attr] = prop.spec.value;\n                else if (source != null)\n                    this.cache[attr + \"_array\"] = prop.array(source);\n                else\n                    throw new Error(\"source is required with a vectorized visual property\");\n            }\n        }\n        cache_select(attr, i) {\n            const prop = this.obj.properties[this.prefix + attr];\n            let value;\n            if (prop.spec.value !== undefined) // TODO (bev) better test?\n                this.cache[attr] = value = prop.spec.value;\n            else\n                this.cache[attr] = value = this.cache[attr + \"_array\"][i];\n            return value;\n        }\n        set_vectorize(ctx, i) {\n            if (this.all_indices != null) // all_indices is set by a Visuals instance associated with a CDSView\n                this._set_vectorize(ctx, this.all_indices[i]);\n            else // all_indices is not set for annotations which may have vectorized visual props\n                this._set_vectorize(ctx, i);\n        }\n    }\n    exports.ContextProperties = ContextProperties;\n    ContextProperties.__name__ = \"ContextProperties\";\n    class Line extends ContextProperties {\n        set_value(ctx) {\n            ctx.strokeStyle = this.line_color.value();\n            ctx.globalAlpha = this.line_alpha.value();\n            ctx.lineWidth = this.line_width.value();\n            ctx.lineJoin = this.line_join.value();\n            ctx.lineCap = this.line_cap.value();\n            ctx.setLineDash(this.line_dash.value());\n            ctx.setLineDashOffset(this.line_dash_offset.value());\n        }\n        get doit() {\n            return !(this.line_color.spec.value === null ||\n                this.line_alpha.spec.value == 0 ||\n                this.line_width.spec.value == 0);\n        }\n        _set_vectorize(ctx, i) {\n            this.cache_select(\"line_color\", i);\n            if (ctx.strokeStyle !== this.cache.line_color)\n                ctx.strokeStyle = this.cache.line_color;\n            this.cache_select(\"line_alpha\", i);\n            if (ctx.globalAlpha !== this.cache.line_alpha)\n                ctx.globalAlpha = this.cache.line_alpha;\n            this.cache_select(\"line_width\", i);\n            if (ctx.lineWidth !== this.cache.line_width)\n                ctx.lineWidth = this.cache.line_width;\n            this.cache_select(\"line_join\", i);\n            if (ctx.lineJoin !== this.cache.line_join)\n                ctx.lineJoin = this.cache.line_join;\n            this.cache_select(\"line_cap\", i);\n            if (ctx.lineCap !== this.cache.line_cap)\n                ctx.lineCap = this.cache.line_cap;\n            this.cache_select(\"line_dash\", i);\n            if (ctx.getLineDash() !== this.cache.line_dash)\n                ctx.setLineDash(this.cache.line_dash);\n            this.cache_select(\"line_dash_offset\", i);\n            if (ctx.getLineDashOffset() !== this.cache.line_dash_offset)\n                ctx.setLineDashOffset(this.cache.line_dash_offset);\n        }\n        color_value() {\n            const [r, g, b, a] = color_1.color2rgba(this.line_color.value(), this.line_alpha.value());\n            return `rgba(${r * 255},${g * 255},${b * 255},${a})`;\n        }\n    }\n    exports.Line = Line;\n    Line.__name__ = \"Line\";\n    Line.prototype.attrs = Object.keys(mixins.line());\n    class Fill extends ContextProperties {\n        set_value(ctx) {\n            ctx.fillStyle = this.fill_color.value();\n            ctx.globalAlpha = this.fill_alpha.value();\n        }\n        get doit() {\n            return !(this.fill_color.spec.value === null ||\n                this.fill_alpha.spec.value == 0);\n        }\n        _set_vectorize(ctx, i) {\n            this.cache_select(\"fill_color\", i);\n            if (ctx.fillStyle !== this.cache.fill_color)\n                ctx.fillStyle = this.cache.fill_color;\n            this.cache_select(\"fill_alpha\", i);\n            if (ctx.globalAlpha !== this.cache.fill_alpha)\n                ctx.globalAlpha = this.cache.fill_alpha;\n        }\n        color_value() {\n            const [r, g, b, a] = color_1.color2rgba(this.fill_color.value(), this.fill_alpha.value());\n            return `rgba(${r * 255},${g * 255},${b * 255},${a})`;\n        }\n    }\n    exports.Fill = Fill;\n    Fill.__name__ = \"Fill\";\n    Fill.prototype.attrs = Object.keys(mixins.fill());\n    class Hatch extends ContextProperties {\n        cache_select(name, i) {\n            let value;\n            if (name == \"pattern\") {\n                this.cache_select(\"hatch_color\", i);\n                this.cache_select(\"hatch_scale\", i);\n                this.cache_select(\"hatch_pattern\", i);\n                this.cache_select(\"hatch_weight\", i);\n                const { hatch_color, hatch_scale, hatch_pattern, hatch_weight, hatch_extra } = this.cache;\n                if (hatch_extra != null && hatch_extra.hasOwnProperty(hatch_pattern)) {\n                    const custom = hatch_extra[hatch_pattern];\n                    this.cache.pattern = custom.get_pattern(hatch_color, hatch_scale, hatch_weight);\n                }\n                else {\n                    this.cache.pattern = (ctx) => {\n                        const canvas = create_hatch_canvas(hatch_pattern, hatch_color, hatch_scale, hatch_weight);\n                        return ctx.createPattern(canvas, 'repeat');\n                    };\n                }\n            }\n            else\n                value = super.cache_select(name, i);\n            return value;\n        }\n        _try_defer(defer_func) {\n            const { hatch_pattern, hatch_extra } = this.cache;\n            if (hatch_extra != null && hatch_extra.hasOwnProperty(hatch_pattern)) {\n                const custom = hatch_extra[hatch_pattern];\n                custom.onload(defer_func);\n            }\n        }\n        get doit() {\n            return !(this.hatch_color.spec.value === null ||\n                this.hatch_alpha.spec.value == 0 ||\n                this.hatch_pattern.spec.value == \" \" ||\n                this.hatch_pattern.spec.value == \"blank\" ||\n                this.hatch_pattern.spec.value === null);\n        }\n        doit2(ctx, i, ready_func, defer_func) {\n            if (!this.doit) {\n                return;\n            }\n            this.cache_select(\"pattern\", i);\n            const pattern = this.cache.pattern(ctx);\n            if (pattern == null) {\n                this._try_defer(defer_func);\n            }\n            else {\n                this.set_vectorize(ctx, i);\n                ready_func();\n            }\n        }\n        _set_vectorize(ctx, i) {\n            this.cache_select(\"pattern\", i);\n            ctx.fillStyle = this.cache.pattern(ctx);\n            this.cache_select(\"hatch_alpha\", i);\n            if (ctx.globalAlpha !== this.cache.hatch_alpha)\n                ctx.globalAlpha = this.cache.hatch_alpha;\n        }\n        color_value() {\n            const [r, g, b, a] = color_1.color2rgba(this.hatch_color.value(), this.hatch_alpha.value());\n            return `rgba(${r * 255},${g * 255},${b * 255},${a})`;\n        }\n    }\n    exports.Hatch = Hatch;\n    Hatch.__name__ = \"Hatch\";\n    Hatch.prototype.attrs = Object.keys(mixins.hatch());\n    class Text extends ContextProperties {\n        cache_select(name, i) {\n            let value;\n            if (name == \"font\") {\n                super.cache_select(\"text_font_style\", i);\n                super.cache_select(\"text_font_size\", i);\n                super.cache_select(\"text_font\", i);\n                const { text_font_style, text_font_size, text_font } = this.cache;\n                this.cache.font = value = `${text_font_style} ${text_font_size} ${text_font}`;\n            }\n            else\n                value = super.cache_select(name, i);\n            return value;\n        }\n        font_value() {\n            const font = this.text_font.value();\n            const font_size = this.text_font_size.value();\n            const font_style = this.text_font_style.value();\n            return font_style + \" \" + font_size + \" \" + font;\n        }\n        color_value() {\n            const [r, g, b, a] = color_1.color2rgba(this.text_color.value(), this.text_alpha.value());\n            return `rgba(${r * 255},${g * 255},${b * 255},${a})`;\n        }\n        set_value(ctx) {\n            ctx.font = this.font_value();\n            ctx.fillStyle = this.text_color.value();\n            ctx.globalAlpha = this.text_alpha.value();\n            ctx.textAlign = this.text_align.value();\n            ctx.textBaseline = this.text_baseline.value();\n        }\n        get doit() {\n            return !(this.text_color.spec.value === null ||\n                this.text_alpha.spec.value == 0);\n        }\n        _set_vectorize(ctx, i) {\n            this.cache_select(\"font\", i);\n            if (ctx.font !== this.cache.font)\n                ctx.font = this.cache.font;\n            this.cache_select(\"text_color\", i);\n            if (ctx.fillStyle !== this.cache.text_color)\n                ctx.fillStyle = this.cache.text_color;\n            this.cache_select(\"text_alpha\", i);\n            if (ctx.globalAlpha !== this.cache.text_alpha)\n                ctx.globalAlpha = this.cache.text_alpha;\n            this.cache_select(\"text_align\", i);\n            if (ctx.textAlign !== this.cache.text_align)\n                ctx.textAlign = this.cache.text_align;\n            this.cache_select(\"text_baseline\", i);\n            if (ctx.textBaseline !== this.cache.text_baseline)\n                ctx.textBaseline = this.cache.text_baseline;\n        }\n    }\n    exports.Text = Text;\n    Text.__name__ = \"Text\";\n    Text.prototype.attrs = Object.keys(mixins.text());\n    class Visuals {\n        constructor(model) {\n            for (const mixin of model.mixins) {\n                const [name, prefix = \"\"] = mixin.split(\":\");\n                let cls;\n                switch (name) {\n                    case \"line\":\n                        cls = Line;\n                        break;\n                    case \"fill\":\n                        cls = Fill;\n                        break;\n                    case \"hatch\":\n                        cls = Hatch;\n                        break;\n                    case \"text\":\n                        cls = Text;\n                        break;\n                    default:\n                        throw new Error(`unknown visual: ${name}`);\n                }\n                this[prefix + name] = new cls(model, prefix);\n            }\n        }\n        warm_cache(source) {\n            for (const name in this) {\n                if (this.hasOwnProperty(name)) {\n                    const prop = this[name];\n                    if (prop instanceof ContextProperties)\n                        prop.warm_cache(source);\n                }\n            }\n        }\n        set_all_indices(all_indices) {\n            for (const name in this) {\n                if (this.hasOwnProperty(name)) {\n                    const prop = this[name];\n                    if (prop instanceof ContextProperties)\n                        prop.all_indices = all_indices;\n                }\n            }\n        }\n    }\n    exports.Visuals = Visuals;\n    Visuals.__name__ = \"Visuals\";\n}\n","/* model.js */ function _(require, module, exports) {\n    const has_props_1 = require(12) /* ./core/has_props */;\n    const p = require(18) /* ./core/properties */;\n    const types_1 = require(7) /* ./core/util/types */;\n    const object_1 = require(22) /* ./core/util/object */;\n    const logging_1 = require(65) /* ./core/logging */;\n    class Model extends has_props_1.HasProps {\n        constructor(attrs) {\n            super(attrs);\n        }\n        static init_Model() {\n            this.define({\n                tags: [p.Array, []],\n                name: [p.String],\n                js_property_callbacks: [p.Any, {}],\n                js_event_callbacks: [p.Any, {}],\n                subscribed_events: [p.Array, []],\n            });\n        }\n        connect_signals() {\n            super.connect_signals();\n            this._update_property_callbacks();\n            this.connect(this.properties.js_property_callbacks.change, () => this._update_property_callbacks());\n            this.connect(this.properties.js_event_callbacks.change, () => this._update_event_callbacks());\n            this.connect(this.properties.subscribed_events.change, () => this._update_event_callbacks());\n        }\n        /*protected*/ _process_event(event) {\n            for (const callback of this.js_event_callbacks[event.event_name] || [])\n                callback.execute(event);\n            if (this.document != null && this.subscribed_events.some((m) => m == event.event_name))\n                this.document.event_manager.send_event(event);\n        }\n        trigger_event(event) {\n            if (this.document != null) {\n                event.origin = this;\n                this.document.event_manager.trigger(event);\n            }\n        }\n        _update_event_callbacks() {\n            if (this.document == null) {\n                // File an issue: SidePanel in particular seems to have this issue\n                logging_1.logger.warn('WARNING: Document not defined for updating event callbacks');\n                return;\n            }\n            this.document.event_manager.subscribed_models.add(this.id);\n        }\n        _update_property_callbacks() {\n            const signal_for = (event) => {\n                const [evt, attr = null] = event.split(\":\");\n                return attr != null ? this.properties[attr][evt] : this[evt];\n            };\n            for (const event in this._js_callbacks) {\n                const callbacks = this._js_callbacks[event];\n                const signal = signal_for(event);\n                for (const cb of callbacks)\n                    this.disconnect(signal, cb);\n            }\n            this._js_callbacks = {};\n            for (const event in this.js_property_callbacks) {\n                const callbacks = this.js_property_callbacks[event];\n                const wrappers = callbacks.map((cb) => () => cb.execute(this));\n                this._js_callbacks[event] = wrappers;\n                const signal = signal_for(event);\n                for (const cb of wrappers)\n                    this.connect(signal, cb);\n            }\n        }\n        _doc_attached() {\n            if (!object_1.isEmpty(this.js_event_callbacks) || !object_1.isEmpty(this.subscribed_events))\n                this._update_event_callbacks();\n        }\n        select(selector) {\n            if (types_1.isString(selector))\n                return this.references().filter((ref) => ref instanceof Model && ref.name === selector);\n            else if (selector.prototype instanceof has_props_1.HasProps)\n                return this.references().filter((ref) => ref instanceof selector);\n            else\n                throw new Error(\"invalid selector\");\n        }\n        select_one(selector) {\n            const result = this.select(selector);\n            switch (result.length) {\n                case 0:\n                    return null;\n                case 1:\n                    return result[0];\n                default:\n                    throw new Error(\"found more than one object matching given selector\");\n            }\n        }\n    }\n    exports.Model = Model;\n    Model.__name__ = \"Model\";\n    Model.init_Model();\n}\n","/* core/logging.js */ function _(require, module, exports) {\n    const types_1 = require(7) /* ./util/types */;\n    const _loggers = {};\n    class LogLevel {\n        constructor(name, level) {\n            this.name = name;\n            this.level = level;\n        }\n    }\n    exports.LogLevel = LogLevel;\n    LogLevel.__name__ = \"LogLevel\";\n    class Logger {\n        constructor(name, level = Logger.INFO) {\n            this._name = name;\n            this.set_level(level);\n        }\n        static get levels() {\n            return Object.keys(Logger.log_levels);\n        }\n        static get(name, level = Logger.INFO) {\n            if (name.length > 0) {\n                let logger = _loggers[name];\n                if (logger == null)\n                    _loggers[name] = logger = new Logger(name, level);\n                return logger;\n            }\n            else\n                throw new TypeError(\"Logger.get() expects a non-empty string name and an optional log-level\");\n        }\n        get level() {\n            return this.get_level();\n        }\n        get_level() {\n            return this._log_level;\n        }\n        set_level(log_level) {\n            if (log_level instanceof LogLevel)\n                this._log_level = log_level;\n            else if (types_1.isString(log_level) && Logger.log_levels[log_level] != null)\n                this._log_level = Logger.log_levels[log_level];\n            else\n                throw new Error(\"Logger.set_level() expects a log-level object or a string name of a log-level\");\n            const logger_name = `[${this._name}]`;\n            for (const name in Logger.log_levels) {\n                const log_level = Logger.log_levels[name];\n                if (log_level.level < this._log_level.level || this._log_level.level === Logger.OFF.level)\n                    this[name] = function () { };\n                else\n                    this[name] = _method_factory(name, logger_name);\n            }\n        }\n        trace(..._args) { }\n        debug(..._args) { }\n        info(..._args) { }\n        warn(..._args) { }\n        error(..._args) { }\n    }\n    exports.Logger = Logger;\n    Logger.__name__ = \"Logger\";\n    Logger.TRACE = new LogLevel(\"trace\", 0);\n    Logger.DEBUG = new LogLevel(\"debug\", 1);\n    Logger.INFO = new LogLevel(\"info\", 2);\n    Logger.WARN = new LogLevel(\"warn\", 6);\n    Logger.ERROR = new LogLevel(\"error\", 7);\n    Logger.FATAL = new LogLevel(\"fatal\", 8);\n    Logger.OFF = new LogLevel(\"off\", 9);\n    Logger.log_levels = {\n        trace: Logger.TRACE,\n        debug: Logger.DEBUG,\n        info: Logger.INFO,\n        warn: Logger.WARN,\n        error: Logger.ERROR,\n        fatal: Logger.FATAL,\n        off: Logger.OFF,\n    };\n    function _method_factory(method_name, logger_name) {\n        if (console[method_name] != null)\n            return console[method_name].bind(console, logger_name);\n        else if (console.log != null)\n            return console.log.bind(console, logger_name);\n        else\n            return function () { };\n    }\n    exports.logger = Logger.get(\"bokeh\");\n    function set_log_level(level) {\n        if (Logger.log_levels[level] == null) {\n            console.log(`[bokeh] unrecognized logging level '${level}' passed to Bokeh.set_log_level(), ignoring`);\n            console.log(`[bokeh] valid log levels are: ${Logger.levels.join(', ')}`);\n        }\n        else {\n            console.log(`[bokeh] setting log level to: '${level}'`);\n            exports.logger.set_level(level);\n        }\n    }\n    exports.set_log_level = set_log_level;\n}\n","/* models/annotations/arrow.js */ function _(require, module, exports) {\n    const annotation_1 = require(29) /* ./annotation */;\n    const arrow_head_1 = require(67) /* ./arrow_head */;\n    const column_data_source_1 = require(68) /* ../sources/column_data_source */;\n    const p = require(18) /* ../../core/properties */;\n    const math_1 = require(9) /* ../../core/util/math */;\n    class ArrowView extends annotation_1.AnnotationView {\n        initialize() {\n            super.initialize();\n            if (this.model.source == null)\n                this.model.source = new column_data_source_1.ColumnDataSource();\n            this.set_data(this.model.source);\n        }\n        connect_signals() {\n            super.connect_signals();\n            this.connect(this.model.change, () => this.set_data(this.model.source));\n            this.connect(this.model.source.streaming, () => this.set_data(this.model.source));\n            this.connect(this.model.source.patching, () => this.set_data(this.model.source));\n        }\n        set_data(source) {\n            super.set_data(source);\n            this.visuals.warm_cache(source);\n            this.plot_view.request_render();\n        }\n        _map_data() {\n            const { frame } = this.plot_view;\n            let sx_start, sy_start;\n            if (this.model.start_units == 'data') {\n                sx_start = frame.xscales[this.model.x_range_name].v_compute(this._x_start);\n                sy_start = frame.yscales[this.model.y_range_name].v_compute(this._y_start);\n            }\n            else {\n                sx_start = frame.xview.v_compute(this._x_start);\n                sy_start = frame.yview.v_compute(this._y_start);\n            }\n            let sx_end, sy_end;\n            if (this.model.end_units == 'data') {\n                sx_end = frame.xscales[this.model.x_range_name].v_compute(this._x_end);\n                sy_end = frame.yscales[this.model.y_range_name].v_compute(this._y_end);\n            }\n            else {\n                sx_end = frame.xview.v_compute(this._x_end);\n                sy_end = frame.yview.v_compute(this._y_end);\n            }\n            return [[sx_start, sy_start], [sx_end, sy_end]];\n        }\n        render() {\n            if (!this.model.visible)\n                return;\n            const { ctx } = this.plot_view.canvas_view;\n            ctx.save();\n            // Order in this function is important. First we draw all the arrow heads.\n            const [start, end] = this._map_data();\n            if (this.model.end != null)\n                this._arrow_head(ctx, \"render\", this.model.end, start, end);\n            if (this.model.start != null)\n                this._arrow_head(ctx, \"render\", this.model.start, end, start);\n            // Next we call .clip on all the arrow heads, inside an initial canvas sized\n            // rect, to create an \"inverted\" clip region for the arrow heads\n            ctx.beginPath();\n            const { x, y, width, height } = this.plot_view.layout.bbox;\n            ctx.rect(x, y, width, height);\n            if (this.model.end != null)\n                this._arrow_head(ctx, \"clip\", this.model.end, start, end);\n            if (this.model.start != null)\n                this._arrow_head(ctx, \"clip\", this.model.start, end, start);\n            ctx.closePath();\n            ctx.clip();\n            // Finally we draw the arrow body, with the clipping regions set up. This prevents\n            // \"fat\" arrows from overlapping the arrow head in a bad way.\n            this._arrow_body(ctx, start, end);\n            ctx.restore();\n        }\n        _arrow_head(ctx, action, head, start, end) {\n            for (let i = 0, _end = this._x_start.length; i < _end; i++) {\n                // arrow head runs orthogonal to arrow body\n                const angle = Math.PI / 2 + math_1.atan2([start[0][i], start[1][i]], [end[0][i], end[1][i]]);\n                ctx.save();\n                ctx.translate(end[0][i], end[1][i]);\n                ctx.rotate(angle);\n                if (action == \"render\")\n                    head.render(ctx, i);\n                else if (action == \"clip\")\n                    head.clip(ctx, i);\n                ctx.restore();\n            }\n        }\n        _arrow_body(ctx, start, end) {\n            if (!this.visuals.line.doit)\n                return;\n            for (let i = 0, n = this._x_start.length; i < n; i++) {\n                this.visuals.line.set_vectorize(ctx, i);\n                ctx.beginPath();\n                ctx.moveTo(start[0][i], start[1][i]);\n                ctx.lineTo(end[0][i], end[1][i]);\n                ctx.stroke();\n            }\n        }\n    }\n    exports.ArrowView = ArrowView;\n    ArrowView.__name__ = \"ArrowView\";\n    class Arrow extends annotation_1.Annotation {\n        constructor(attrs) {\n            super(attrs);\n        }\n        static init_Arrow() {\n            this.prototype.default_view = ArrowView;\n            this.mixins(['line']);\n            this.define({\n                x_start: [p.NumberSpec],\n                y_start: [p.NumberSpec],\n                start_units: [p.SpatialUnits, 'data'],\n                start: [p.Instance, null],\n                x_end: [p.NumberSpec],\n                y_end: [p.NumberSpec],\n                end_units: [p.SpatialUnits, 'data'],\n                end: [p.Instance, () => new arrow_head_1.OpenHead({})],\n                source: [p.Instance],\n                x_range_name: [p.String, 'default'],\n                y_range_name: [p.String, 'default'],\n            });\n        }\n    }\n    exports.Arrow = Arrow;\n    Arrow.__name__ = \"Arrow\";\n    Arrow.init_Arrow();\n}\n","/* models/annotations/arrow_head.js */ function _(require, module, exports) {\n    const annotation_1 = require(29) /* ./annotation */;\n    const visuals_1 = require(63) /* ../../core/visuals */;\n    const p = require(18) /* ../../core/properties */;\n    class ArrowHead extends annotation_1.Annotation {\n        constructor(attrs) {\n            super(attrs);\n        }\n        static init_ArrowHead() {\n            this.define({\n                size: [p.Number, 25],\n            });\n        }\n        initialize() {\n            super.initialize();\n            this.visuals = new visuals_1.Visuals(this);\n        }\n    }\n    exports.ArrowHead = ArrowHead;\n    ArrowHead.__name__ = \"ArrowHead\";\n    ArrowHead.init_ArrowHead();\n    class OpenHead extends ArrowHead {\n        constructor(attrs) {\n            super(attrs);\n        }\n        static init_OpenHead() {\n            this.mixins(['line']);\n        }\n        clip(ctx, i) {\n            // This method should not begin or close a path\n            this.visuals.line.set_vectorize(ctx, i);\n            ctx.moveTo(0.5 * this.size, this.size);\n            ctx.lineTo(0.5 * this.size, -2);\n            ctx.lineTo(-0.5 * this.size, -2);\n            ctx.lineTo(-0.5 * this.size, this.size);\n            ctx.lineTo(0, 0);\n            ctx.lineTo(0.5 * this.size, this.size);\n        }\n        render(ctx, i) {\n            if (this.visuals.line.doit) {\n                this.visuals.line.set_vectorize(ctx, i);\n                ctx.beginPath();\n                ctx.moveTo(0.5 * this.size, this.size);\n                ctx.lineTo(0, 0);\n                ctx.lineTo(-0.5 * this.size, this.size);\n                ctx.stroke();\n            }\n        }\n    }\n    exports.OpenHead = OpenHead;\n    OpenHead.__name__ = \"OpenHead\";\n    OpenHead.init_OpenHead();\n    class NormalHead extends ArrowHead {\n        constructor(attrs) {\n            super(attrs);\n        }\n        static init_NormalHead() {\n            this.mixins(['line', 'fill']);\n            this.override({\n                fill_color: 'black',\n            });\n        }\n        clip(ctx, i) {\n            // This method should not begin or close a path\n            this.visuals.line.set_vectorize(ctx, i);\n            ctx.moveTo(0.5 * this.size, this.size);\n            ctx.lineTo(0.5 * this.size, -2);\n            ctx.lineTo(-0.5 * this.size, -2);\n            ctx.lineTo(-0.5 * this.size, this.size);\n            ctx.lineTo(0.5 * this.size, this.size);\n        }\n        render(ctx, i) {\n            if (this.visuals.fill.doit) {\n                this.visuals.fill.set_vectorize(ctx, i);\n                this._normal(ctx, i);\n                ctx.fill();\n            }\n            if (this.visuals.line.doit) {\n                this.visuals.line.set_vectorize(ctx, i);\n                this._normal(ctx, i);\n                ctx.stroke();\n            }\n        }\n        _normal(ctx, _i) {\n            ctx.beginPath();\n            ctx.moveTo(0.5 * this.size, this.size);\n            ctx.lineTo(0, 0);\n            ctx.lineTo(-0.5 * this.size, this.size);\n            ctx.closePath();\n        }\n    }\n    exports.NormalHead = NormalHead;\n    NormalHead.__name__ = \"NormalHead\";\n    NormalHead.init_NormalHead();\n    class VeeHead extends ArrowHead {\n        constructor(attrs) {\n            super(attrs);\n        }\n        static init_VeeHead() {\n            this.mixins(['line', 'fill']);\n            this.override({\n                fill_color: 'black',\n            });\n        }\n        clip(ctx, i) {\n            // This method should not begin or close a path\n            this.visuals.line.set_vectorize(ctx, i);\n            ctx.moveTo(0.5 * this.size, this.size);\n            ctx.lineTo(0.5 * this.size, -2);\n            ctx.lineTo(-0.5 * this.size, -2);\n            ctx.lineTo(-0.5 * this.size, this.size);\n            ctx.lineTo(0, 0.5 * this.size);\n            ctx.lineTo(0.5 * this.size, this.size);\n        }\n        render(ctx, i) {\n            if (this.visuals.fill.doit) {\n                this.visuals.fill.set_vectorize(ctx, i);\n                this._vee(ctx, i);\n                ctx.fill();\n            }\n            if (this.visuals.line.doit) {\n                this.visuals.line.set_vectorize(ctx, i);\n                this._vee(ctx, i);\n                ctx.stroke();\n            }\n        }\n        _vee(ctx, _i) {\n            ctx.beginPath();\n            ctx.moveTo(0.5 * this.size, this.size);\n            ctx.lineTo(0, 0);\n            ctx.lineTo(-0.5 * this.size, this.size);\n            ctx.lineTo(0, 0.5 * this.size);\n            ctx.closePath();\n        }\n    }\n    exports.VeeHead = VeeHead;\n    VeeHead.__name__ = \"VeeHead\";\n    VeeHead.init_VeeHead();\n    class TeeHead extends ArrowHead {\n        constructor(attrs) {\n            super(attrs);\n        }\n        static init_TeeHead() {\n            this.mixins(['line']);\n        }\n        render(ctx, i) {\n            if (this.visuals.line.doit) {\n                this.visuals.line.set_vectorize(ctx, i);\n                ctx.beginPath();\n                ctx.moveTo(0.5 * this.size, 0);\n                ctx.lineTo(-0.5 * this.size, 0);\n                ctx.stroke();\n            }\n        }\n        clip(_ctx, _i) { }\n    }\n    exports.TeeHead = TeeHead;\n    TeeHead.__name__ = \"TeeHead\";\n    TeeHead.init_TeeHead();\n}\n","/* models/sources/column_data_source.js */ function _(require, module, exports) {\n    const columnar_data_source_1 = require(69) /* ./columnar_data_source */;\n    const has_props_1 = require(12) /* ../../core/has_props */;\n    const p = require(18) /* ../../core/properties */;\n    const data_structures_1 = require(14) /* ../../core/util/data_structures */;\n    const serialization_1 = require(94) /* ../../core/util/serialization */;\n    const types_1 = require(7) /* ../../core/util/types */;\n    const typed_array = require(96) /* ../../core/util/typed_array */;\n    const object_1 = require(22) /* ../../core/util/object */;\n    const events_1 = require(97) /* ../../document/events */;\n    //exported for testing\n    function stream_to_column(col, new_col, rollover) {\n        if (types_1.isArray(col)) {\n            const result = col.concat(new_col);\n            if (rollover != null && result.length > rollover)\n                return result.slice(-rollover);\n            else\n                return result;\n        }\n        else if (types_1.isTypedArray(col)) {\n            const total_len = col.length + new_col.length;\n            // handle rollover case for typed arrays\n            if (rollover != null && total_len > rollover) {\n                const start = total_len - rollover;\n                const end = col.length;\n                // resize col if it is shorter than the rollover length\n                let result;\n                if (col.length < rollover) {\n                    result = new col.constructor(rollover);\n                    result.set(col, 0);\n                }\n                else\n                    result = col;\n                // shift values in original col to accommodate new_col\n                for (let i = start, endi = end; i < endi; i++) {\n                    result[i - start] = result[i];\n                }\n                // update end values in col with new_col\n                for (let i = 0, endi = new_col.length; i < endi; i++) {\n                    result[i + (end - start)] = new_col[i];\n                }\n                return result;\n            }\n            else {\n                const tmp = new col.constructor(new_col);\n                return typed_array.concat(col, tmp);\n            }\n        }\n        else\n            throw new Error(\"unsupported array types\");\n    }\n    exports.stream_to_column = stream_to_column;\n    // exported for testing\n    function slice(ind, length) {\n        let start, step, stop;\n        if (types_1.isNumber(ind)) {\n            start = ind;\n            stop = ind + 1;\n            step = 1;\n        }\n        else {\n            start = ind.start != null ? ind.start : 0;\n            stop = ind.stop != null ? ind.stop : length;\n            step = ind.step != null ? ind.step : 1;\n        }\n        return [start, stop, step];\n    }\n    exports.slice = slice;\n    // exported for testing\n    function patch_to_column(col, patch, shapes) {\n        const patched = new data_structures_1.Set();\n        let patched_range = false;\n        for (const [ind, val] of patch) {\n            // make the single index case look like the length-3 multi-index case\n            let item, shape;\n            let index;\n            let value;\n            if (types_1.isArray(ind)) {\n                const [i] = ind;\n                patched.add(i);\n                shape = shapes[i];\n                item = col[i];\n                value = val;\n                // this is basically like NumPy's \"newaxis\", inserting an empty dimension\n                // makes length 2 and 3 multi-index cases uniform, so that the same code\n                // can handle both\n                if (ind.length === 2) {\n                    shape = [1, shape[0]];\n                    index = [ind[0], 0, ind[1]];\n                }\n                else\n                    index = ind;\n            }\n            else {\n                if (types_1.isNumber(ind)) {\n                    value = [val];\n                    patched.add(ind);\n                }\n                else {\n                    value = val;\n                    patched_range = true;\n                }\n                index = [0, 0, ind];\n                shape = [1, col.length];\n                item = col;\n            }\n            // now this one nested loop handles all cases\n            let flat_index = 0;\n            const [istart, istop, istep] = slice(index[1], shape[0]);\n            const [jstart, jstop, jstep] = slice(index[2], shape[1]);\n            for (let i = istart; i < istop; i += istep) {\n                for (let j = jstart; j < jstop; j += jstep) {\n                    if (patched_range) {\n                        patched.add(j);\n                    }\n                    item[(i * shape[1]) + j] = value[flat_index];\n                    flat_index++;\n                }\n            }\n        }\n        return patched;\n    }\n    exports.patch_to_column = patch_to_column;\n    class ColumnDataSource extends columnar_data_source_1.ColumnarDataSource {\n        constructor(attrs) {\n            super(attrs);\n        }\n        static init_ColumnDataSource() {\n            this.define({\n                data: [p.Any, {}],\n            });\n        }\n        initialize() {\n            super.initialize();\n            [this.data, this._shapes] = serialization_1.decode_column_data(this.data);\n        }\n        attributes_as_json(include_defaults = true, value_to_json = ColumnDataSource._value_to_json) {\n            const attrs = {};\n            const obj = this.serializable_attributes();\n            for (const key of object_1.keys(obj)) {\n                let value = obj[key];\n                if (key === 'data')\n                    value = serialization_1.encode_column_data(value, this._shapes);\n                if (include_defaults)\n                    attrs[key] = value;\n                else if (key in this._set_after_defaults)\n                    attrs[key] = value;\n            }\n            return value_to_json(\"attributes\", attrs, this);\n        }\n        static _value_to_json(key, value, optional_parent_object) {\n            if (types_1.isPlainObject(value) && key === 'data')\n                return serialization_1.encode_column_data(value, optional_parent_object._shapes); // XXX: unknown vs. any\n            else\n                return has_props_1.HasProps._value_to_json(key, value, optional_parent_object);\n        }\n        stream(new_data, rollover, setter_id) {\n            const { data } = this;\n            for (const k in new_data) {\n                data[k] = stream_to_column(data[k], new_data[k], rollover);\n            }\n            this.setv({ data }, { silent: true });\n            this.streaming.emit();\n            if (this.document != null) {\n                const hint = new events_1.ColumnsStreamedEvent(this.document, this.ref(), new_data, rollover);\n                this.document._notify_change(this, 'data', null, null, { setter_id, hint });\n            }\n        }\n        patch(patches, setter_id) {\n            const { data } = this;\n            let patched = new data_structures_1.Set();\n            for (const k in patches) {\n                const patch = patches[k];\n                patched = patched.union(patch_to_column(data[k], patch, this._shapes[k]));\n            }\n            this.setv({ data }, { silent: true });\n            this.patching.emit(patched.values);\n            if (this.document != null) {\n                const hint = new events_1.ColumnsPatchedEvent(this.document, this.ref(), patches);\n                this.document._notify_change(this, 'data', null, null, { setter_id, hint });\n            }\n        }\n    }\n    exports.ColumnDataSource = ColumnDataSource;\n    ColumnDataSource.__name__ = \"ColumnDataSource\";\n    ColumnDataSource.init_ColumnDataSource();\n}\n","/* models/sources/columnar_data_source.js */ function _(require, module, exports) {\n    const data_source_1 = require(70) /* ./data_source */;\n    const signaling_1 = require(13) /* ../../core/signaling */;\n    const logging_1 = require(65) /* ../../core/logging */;\n    const selection_manager_1 = require(72) /* ../../core/selection_manager */;\n    const p = require(18) /* ../../core/properties */;\n    const types_1 = require(7) /* ../../core/util/types */;\n    const array_1 = require(8) /* ../../core/util/array */;\n    const object_1 = require(22) /* ../../core/util/object */;\n    const selection_1 = require(71) /* ../selections/selection */;\n    const interaction_policy_1 = require(93) /* ../selections/interaction_policy */;\n    class ColumnarDataSource extends data_source_1.DataSource {\n        constructor(attrs) {\n            super(attrs);\n        }\n        get_array(key) {\n            let column = this.data[key];\n            if (column == null)\n                this.data[key] = column = [];\n            else if (!types_1.isArray(column))\n                this.data[key] = column = Array.from(column);\n            return column;\n        }\n        static init_ColumnarDataSource() {\n            this.define({\n                selection_policy: [p.Instance, () => new interaction_policy_1.UnionRenderers()],\n            });\n            this.internal({\n                selection_manager: [p.Instance, (self) => new selection_manager_1.SelectionManager({ source: self })],\n                inspected: [p.Instance, () => new selection_1.Selection()],\n                _shapes: [p.Any, {}],\n            });\n        }\n        initialize() {\n            super.initialize();\n            this._select = new signaling_1.Signal0(this, \"select\");\n            this.inspect = new signaling_1.Signal(this, \"inspect\"); // XXX: <[indices, tool, renderer-view, source, data], this>\n            this.streaming = new signaling_1.Signal0(this, \"streaming\");\n            this.patching = new signaling_1.Signal(this, \"patching\");\n        }\n        get_column(colname) {\n            const column = this.data[colname];\n            return column != null ? column : null;\n        }\n        columns() {\n            // return the column names in this data source\n            return object_1.keys(this.data);\n        }\n        get_length(soft = true) {\n            const lengths = array_1.uniq(object_1.values(this.data).map((v) => v.length));\n            switch (lengths.length) {\n                case 0: {\n                    return null; // XXX: don't guess, treat on case-by-case basis\n                }\n                case 1: {\n                    return lengths[0];\n                }\n                default: {\n                    const msg = \"data source has columns of inconsistent lengths\";\n                    if (soft) {\n                        logging_1.logger.warn(msg);\n                        return lengths.sort()[0];\n                    }\n                    else\n                        throw new Error(msg);\n                }\n            }\n        }\n        get_indices() {\n            const length = this.get_length();\n            return array_1.range(0, length != null ? length : 1);\n            //TODO: returns [0] when no data, should it?\n        }\n        clear() {\n            const empty = {};\n            for (const col of this.columns()) {\n                empty[col] = new this.data[col].constructor(0);\n            }\n            this.data = empty;\n        }\n    }\n    exports.ColumnarDataSource = ColumnarDataSource;\n    ColumnarDataSource.__name__ = \"ColumnarDataSource\";\n    ColumnarDataSource.init_ColumnarDataSource();\n}\n","/* models/sources/data_source.js */ function _(require, module, exports) {\n    const model_1 = require(64) /* ../../model */;\n    const selection_1 = require(71) /* ../selections/selection */;\n    const p = require(18) /* ../../core/properties */;\n    class DataSource extends model_1.Model {\n        constructor(attrs) {\n            super(attrs);\n        }\n        static init_DataSource() {\n            this.define({\n                selected: [p.Instance, () => new selection_1.Selection()],\n                callback: [p.Any],\n            });\n        }\n        connect_signals() {\n            super.connect_signals();\n            this.connect(this.selected.change, () => {\n                if (this.callback != null)\n                    this.callback.execute(this);\n            });\n        }\n    }\n    exports.DataSource = DataSource;\n    DataSource.__name__ = \"DataSource\";\n    DataSource.init_DataSource();\n}\n","/* models/selections/selection.js */ function _(require, module, exports) {\n    const model_1 = require(64) /* ../../model */;\n    const p = require(18) /* ../../core/properties */;\n    const array_1 = require(8) /* ../../core/util/array */;\n    const object_1 = require(22) /* ../../core/util/object */;\n    class Selection extends model_1.Model {\n        constructor(attrs) {\n            super(attrs);\n        }\n        static init_Selection() {\n            this.define({\n                indices: [p.Array, []],\n                line_indices: [p.Array, []],\n                multiline_indices: [p.Any, {}],\n            });\n            this.internal({\n                final: [p.Boolean],\n                selected_glyphs: [p.Array, []],\n                get_view: [p.Any],\n                image_indices: [p.Array, []],\n            });\n        }\n        initialize() {\n            super.initialize();\n            this['0d'] = { glyph: null, indices: [], flag: false, get_view: () => null };\n            this['1d'] = { indices: this.indices };\n            this['2d'] = { indices: {} };\n            this.get_view = () => null;\n            this.connect(this.properties.indices.change, () => this['1d'].indices = this.indices);\n            this.connect(this.properties.line_indices.change, () => {\n                this['0d'].indices = this.line_indices;\n                this['0d'].flag = this.line_indices.length != 0;\n            });\n            this.connect(this.properties.selected_glyphs.change, () => this['0d'].glyph = this.selected_glyph);\n            this.connect(this.properties.get_view.change, () => this['0d'].get_view = this.get_view);\n            this.connect(this.properties.multiline_indices.change, () => this['2d'].indices = this.multiline_indices);\n        }\n        get selected_glyph() {\n            return this.selected_glyphs.length > 0 ? this.selected_glyphs[0] : null;\n        }\n        add_to_selected_glyphs(glyph) {\n            this.selected_glyphs.push(glyph);\n        }\n        update(selection, final, append) {\n            this.final = final;\n            if (append)\n                this.update_through_union(selection);\n            else {\n                this.indices = selection.indices;\n                this.line_indices = selection.line_indices;\n                this.selected_glyphs = selection.selected_glyphs;\n                this.get_view = selection.get_view;\n                this.multiline_indices = selection.multiline_indices;\n                this.image_indices = selection.image_indices;\n            }\n        }\n        clear() {\n            this.final = true;\n            this.indices = [];\n            this.line_indices = [];\n            this.multiline_indices = {};\n            this.get_view = () => null;\n            this.selected_glyphs = [];\n        }\n        is_empty() {\n            return this.indices.length == 0 && this.line_indices.length == 0 && this.image_indices.length == 0;\n        }\n        update_through_union(other) {\n            this.indices = array_1.union(other.indices, this.indices);\n            this.selected_glyphs = array_1.union(other.selected_glyphs, this.selected_glyphs);\n            this.line_indices = array_1.union(other.line_indices, this.line_indices);\n            if (!this.get_view())\n                this.get_view = other.get_view;\n            this.multiline_indices = object_1.merge(other.multiline_indices, this.multiline_indices);\n        }\n        update_through_intersection(other) {\n            this.indices = array_1.intersection(other.indices, this.indices);\n            // TODO: think through and fix any logic below\n            this.selected_glyphs = array_1.union(other.selected_glyphs, this.selected_glyphs);\n            this.line_indices = array_1.union(other.line_indices, this.line_indices);\n            if (!this.get_view())\n                this.get_view = other.get_view;\n            this.multiline_indices = object_1.merge(other.multiline_indices, this.multiline_indices);\n        }\n    }\n    exports.Selection = Selection;\n    Selection.__name__ = \"Selection\";\n    Selection.init_Selection();\n}\n","/* core/selection_manager.js */ function _(require, module, exports) {\n    const has_props_1 = require(12) /* ./has_props */;\n    const selection_1 = require(71) /* ../models/selections/selection */;\n    const glyph_renderer_1 = require(73) /* ../models/renderers/glyph_renderer */;\n    const graph_renderer_1 = require(90) /* ../models/renderers/graph_renderer */;\n    const p = require(18) /* ./properties */;\n    class SelectionManager extends has_props_1.HasProps {\n        constructor(attrs) {\n            super(attrs);\n            this.inspectors = {};\n        }\n        static init_SelectionManager() {\n            this.internal({\n                source: [p.Any],\n            });\n        }\n        select(renderer_views, geometry, final, append = false) {\n            // divide renderers into glyph_renderers or graph_renderers\n            const glyph_renderer_views = [];\n            const graph_renderer_views = [];\n            for (const r of renderer_views) {\n                if (r instanceof glyph_renderer_1.GlyphRendererView)\n                    glyph_renderer_views.push(r);\n                else if (r instanceof graph_renderer_1.GraphRendererView)\n                    graph_renderer_views.push(r);\n            }\n            let did_hit = false;\n            // graph renderer case\n            for (const r of graph_renderer_views) {\n                const hit_test_result = r.model.selection_policy.hit_test(geometry, r);\n                did_hit = did_hit || r.model.selection_policy.do_selection(hit_test_result, r.model, final, append);\n            }\n            // glyph renderers\n            if (glyph_renderer_views.length > 0) {\n                const hit_test_result = this.source.selection_policy.hit_test(geometry, glyph_renderer_views);\n                did_hit = did_hit || this.source.selection_policy.do_selection(hit_test_result, this.source, final, append);\n            }\n            return did_hit;\n        }\n        inspect(renderer_view, geometry) {\n            let did_hit = false;\n            if (renderer_view instanceof glyph_renderer_1.GlyphRendererView) {\n                const hit_test_result = renderer_view.hit_test(geometry);\n                if (hit_test_result != null) {\n                    did_hit = !hit_test_result.is_empty();\n                    const inspection = this.get_or_create_inspector(renderer_view.model);\n                    inspection.update(hit_test_result, true, false);\n                    this.source.setv({ inspected: inspection }, { silent: true });\n                    this.source.inspect.emit([renderer_view, { geometry }]);\n                }\n            }\n            else if (renderer_view instanceof graph_renderer_1.GraphRendererView) {\n                const hit_test_result = renderer_view.model.inspection_policy.hit_test(geometry, renderer_view);\n                did_hit = did_hit || renderer_view.model.inspection_policy.do_inspection(hit_test_result, geometry, renderer_view, false, false);\n            }\n            return did_hit;\n        }\n        clear(rview) {\n            this.source.selected.clear();\n            if (rview != null)\n                this.get_or_create_inspector(rview.model).clear();\n        }\n        get_or_create_inspector(rmodel) {\n            if (this.inspectors[rmodel.id] == null)\n                this.inspectors[rmodel.id] = new selection_1.Selection();\n            return this.inspectors[rmodel.id];\n        }\n    }\n    exports.SelectionManager = SelectionManager;\n    SelectionManager.__name__ = \"SelectionManager\";\n    SelectionManager.init_SelectionManager();\n}\n","/* models/renderers/glyph_renderer.js */ function _(require, module, exports) {\n    const data_renderer_1 = require(74) /* ./data_renderer */;\n    const line_1 = require(75) /* ../glyphs/line */;\n    const patch_1 = require(85) /* ../glyphs/patch */;\n    const harea_1 = require(86) /* ../glyphs/harea */;\n    const varea_1 = require(88) /* ../glyphs/varea */;\n    const cds_view_1 = require(89) /* ../sources/cds_view */;\n    const logging_1 = require(65) /* ../../core/logging */;\n    const p = require(18) /* ../../core/properties */;\n    const arrayable_1 = require(11) /* ../../core/util/arrayable */;\n    const array_1 = require(8) /* ../../core/util/array */;\n    const object_1 = require(22) /* ../../core/util/object */;\n    const factor_range_1 = require(82) /* ../ranges/factor_range */;\n    const selection_defaults = {\n        fill: {},\n        line: {},\n    };\n    const decimated_defaults = {\n        fill: { fill_alpha: 0.3, fill_color: \"grey\" },\n        line: { line_alpha: 0.3, line_color: \"grey\" },\n    };\n    const nonselection_defaults = {\n        fill: { fill_alpha: 0.2 },\n        line: {},\n    };\n    class GlyphRendererView extends data_renderer_1.DataRendererView {\n        initialize() {\n            super.initialize();\n            const base_glyph = this.model.glyph;\n            const has_fill = array_1.includes(base_glyph.mixins, \"fill\");\n            const has_line = array_1.includes(base_glyph.mixins, \"line\");\n            const glyph_attrs = object_1.clone(base_glyph.attributes);\n            delete glyph_attrs.id;\n            function mk_glyph(defaults) {\n                const attrs = object_1.clone(glyph_attrs);\n                if (has_fill)\n                    object_1.extend(attrs, defaults.fill);\n                if (has_line)\n                    object_1.extend(attrs, defaults.line);\n                return new base_glyph.constructor(attrs);\n            }\n            this.glyph = this.build_glyph_view(base_glyph);\n            let { selection_glyph } = this.model;\n            if (selection_glyph == null)\n                selection_glyph = mk_glyph({ fill: {}, line: {} });\n            else if (selection_glyph === \"auto\")\n                selection_glyph = mk_glyph(selection_defaults);\n            this.selection_glyph = this.build_glyph_view(selection_glyph);\n            let { nonselection_glyph } = this.model;\n            if ((nonselection_glyph == null))\n                nonselection_glyph = mk_glyph({ fill: {}, line: {} });\n            else if (nonselection_glyph === \"auto\")\n                nonselection_glyph = mk_glyph(nonselection_defaults);\n            this.nonselection_glyph = this.build_glyph_view(nonselection_glyph);\n            const { hover_glyph } = this.model;\n            if (hover_glyph != null)\n                this.hover_glyph = this.build_glyph_view(hover_glyph);\n            const { muted_glyph } = this.model;\n            if (muted_glyph != null)\n                this.muted_glyph = this.build_glyph_view(muted_glyph);\n            const decimated_glyph = mk_glyph(decimated_defaults);\n            this.decimated_glyph = this.build_glyph_view(decimated_glyph);\n            this.xscale = this.plot_view.frame.xscales[this.model.x_range_name];\n            this.yscale = this.plot_view.frame.yscales[this.model.y_range_name];\n            this.set_data(false);\n        }\n        build_glyph_view(model) {\n            return new model.default_view({ model, parent: this }); // XXX\n        }\n        connect_signals() {\n            super.connect_signals();\n            this.connect(this.model.change, () => this.request_render());\n            this.connect(this.model.glyph.change, () => this.set_data());\n            this.connect(this.model.data_source.change, () => this.set_data());\n            this.connect(this.model.data_source.streaming, () => this.set_data());\n            this.connect(this.model.data_source.patching, (indices /* XXX: WHY? */) => this.set_data(true, indices));\n            this.connect(this.model.data_source.selected.change, () => this.request_render());\n            this.connect(this.model.data_source._select, () => this.request_render());\n            if (this.hover_glyph != null)\n                this.connect(this.model.data_source.inspect, () => this.request_render());\n            this.connect(this.model.properties.view.change, () => this.set_data());\n            this.connect(this.model.view.change, () => this.set_data());\n            this.connect(this.model.properties.visible.change, () => this.plot_view.update_dataranges());\n            const { x_ranges, y_ranges } = this.plot_view.frame;\n            for (const name in x_ranges) {\n                const rng = x_ranges[name];\n                if (rng instanceof factor_range_1.FactorRange)\n                    this.connect(rng.change, () => this.set_data());\n            }\n            for (const name in y_ranges) {\n                const rng = y_ranges[name];\n                if (rng instanceof factor_range_1.FactorRange)\n                    this.connect(rng.change, () => this.set_data());\n            }\n            this.connect(this.model.glyph.transformchange, () => this.set_data());\n        }\n        have_selection_glyphs() {\n            return this.selection_glyph != null && this.nonselection_glyph != null;\n        }\n        // in case of partial updates like patching, the list of indices that actually\n        // changed may be passed as the \"indices\" parameter to afford any optional optimizations\n        set_data(request_render = true, indices = null) {\n            const t0 = Date.now();\n            const source = this.model.data_source;\n            this.all_indices = this.model.view.indices;\n            // TODO (bev) this is a bit clunky, need to make sure glyphs use the correct ranges when they call\n            // mapping functions on the base Renderer class\n            this.glyph.model.setv({ x_range_name: this.model.x_range_name,\n                y_range_name: this.model.y_range_name }, { silent: true });\n            this.glyph.set_data(source, this.all_indices, indices);\n            this.glyph.set_visuals(source);\n            this.decimated_glyph.set_visuals(source);\n            if (this.have_selection_glyphs()) {\n                this.selection_glyph.set_visuals(source);\n                this.nonselection_glyph.set_visuals(source);\n            }\n            if (this.hover_glyph != null)\n                this.hover_glyph.set_visuals(source);\n            if (this.muted_glyph != null)\n                this.muted_glyph.set_visuals(source);\n            const { lod_factor } = this.plot_model;\n            this.decimated = [];\n            for (let i = 0, end = Math.floor(this.all_indices.length / lod_factor); i < end; i++) {\n                this.decimated.push(i * lod_factor);\n            }\n            const dt = Date.now() - t0;\n            logging_1.logger.debug(`${this.glyph.model.type} GlyphRenderer (${this.model.id}): set_data finished in ${dt}ms`);\n            this.set_data_timestamp = Date.now();\n            if (request_render)\n                this.request_render();\n        }\n        get has_webgl() {\n            return this.glyph.glglyph != null;\n        }\n        render() {\n            if (!this.model.visible)\n                return;\n            const t0 = Date.now();\n            const glsupport = this.has_webgl;\n            this.glyph.map_data();\n            const dtmap = Date.now() - t0;\n            const tmask = Date.now();\n            // all_indices is in full data space, indices is converted to subset space\n            // either by mask_data (that uses the spatial index) or manually\n            let indices = this.glyph.mask_data(this.all_indices);\n            if (indices.length === this.all_indices.length) {\n                indices = array_1.range(0, this.all_indices.length);\n            }\n            const dtmask = Date.now() - tmask;\n            const { ctx } = this.plot_view.canvas_view;\n            ctx.save();\n            // selected is in full set space\n            const { selected } = this.model.data_source;\n            let selected_full_indices;\n            if (!selected || selected.is_empty())\n                selected_full_indices = [];\n            else {\n                if (this.glyph instanceof line_1.LineView && selected.selected_glyph === this.glyph.model)\n                    selected_full_indices = this.model.view.convert_indices_from_subset(indices);\n                else\n                    selected_full_indices = selected.indices;\n            }\n            // inspected is in full set space\n            const { inspected } = this.model.data_source;\n            const inspected_full_indices = new Set((() => {\n                if (!inspected || inspected.is_empty())\n                    return [];\n                else {\n                    if (inspected['0d'].glyph)\n                        return this.model.view.convert_indices_from_subset(indices);\n                    else if (inspected['1d'].indices.length > 0)\n                        return inspected['1d'].indices;\n                    else\n                        return arrayable_1.map(Object.keys(inspected[\"2d\"].indices), (i) => parseInt(i));\n                }\n            })());\n            // inspected is transformed to subset space\n            const inspected_subset_indices = arrayable_1.filter(indices, (i) => inspected_full_indices.has(this.all_indices[i]));\n            const { lod_threshold } = this.plot_model;\n            let glyph;\n            let nonselection_glyph;\n            let selection_glyph;\n            if ((this.model.document != null ? this.model.document.interactive_duration() > 0 : false)\n                && !glsupport && lod_threshold != null && this.all_indices.length > lod_threshold) {\n                // Render decimated during interaction if too many elements and not using GL\n                indices = this.decimated;\n                glyph = this.decimated_glyph;\n                nonselection_glyph = this.decimated_glyph;\n                selection_glyph = this.selection_glyph;\n            }\n            else {\n                glyph = this.model.muted && this.muted_glyph != null ? this.muted_glyph : this.glyph;\n                nonselection_glyph = this.nonselection_glyph;\n                selection_glyph = this.selection_glyph;\n            }\n            if (this.hover_glyph != null && inspected_subset_indices.length)\n                indices = array_1.difference(indices, inspected_subset_indices);\n            // Render with no selection\n            let dtselect = null;\n            let trender;\n            if (!(selected_full_indices.length && this.have_selection_glyphs())) {\n                trender = Date.now();\n                if (this.glyph instanceof line_1.LineView) {\n                    if (this.hover_glyph && inspected_subset_indices.length)\n                        this.hover_glyph.render(ctx, this.model.view.convert_indices_from_subset(inspected_subset_indices), this.glyph);\n                    else\n                        glyph.render(ctx, this.all_indices, this.glyph);\n                }\n                else if (this.glyph instanceof patch_1.PatchView || this.glyph instanceof harea_1.HAreaView || this.glyph instanceof varea_1.VAreaView) {\n                    if (inspected.selected_glyphs.length == 0 || this.hover_glyph == null) {\n                        glyph.render(ctx, this.all_indices, this.glyph);\n                    }\n                    else {\n                        for (const sglyph of inspected.selected_glyphs) {\n                            if (sglyph.id == this.glyph.model.id)\n                                this.hover_glyph.render(ctx, this.all_indices, this.glyph);\n                        }\n                    }\n                }\n                else {\n                    glyph.render(ctx, indices, this.glyph);\n                    if (this.hover_glyph && inspected_subset_indices.length)\n                        this.hover_glyph.render(ctx, inspected_subset_indices, this.glyph);\n                }\n                // Render with selection\n            }\n            else {\n                // reset the selection mask\n                const tselect = Date.now();\n                const selected_mask = {};\n                for (const i of selected_full_indices) {\n                    selected_mask[i] = true;\n                }\n                // intersect/different selection with render mask\n                const selected_subset_indices = new Array();\n                const nonselected_subset_indices = new Array();\n                // now, selected is changed to subset space, except for Line glyph\n                if (this.glyph instanceof line_1.LineView) {\n                    for (const i of this.all_indices) {\n                        if (selected_mask[i] != null)\n                            selected_subset_indices.push(i);\n                        else\n                            nonselected_subset_indices.push(i);\n                    }\n                }\n                else {\n                    for (const i of indices) {\n                        if (selected_mask[this.all_indices[i]] != null)\n                            selected_subset_indices.push(i);\n                        else\n                            nonselected_subset_indices.push(i);\n                    }\n                }\n                dtselect = Date.now() - tselect;\n                trender = Date.now();\n                nonselection_glyph.render(ctx, nonselected_subset_indices, this.glyph);\n                selection_glyph.render(ctx, selected_subset_indices, this.glyph);\n                if (this.hover_glyph != null) {\n                    if (this.glyph instanceof line_1.LineView)\n                        this.hover_glyph.render(ctx, this.model.view.convert_indices_from_subset(inspected_subset_indices), this.glyph);\n                    else\n                        this.hover_glyph.render(ctx, inspected_subset_indices, this.glyph);\n                }\n            }\n            const dtrender = Date.now() - trender;\n            this.last_dtrender = dtrender;\n            const dttot = Date.now() - t0;\n            logging_1.logger.debug(`${this.glyph.model.type} GlyphRenderer (${this.model.id}): render finished in ${dttot}ms`);\n            logging_1.logger.trace(` - map_data finished in       : ${dtmap}ms`);\n            logging_1.logger.trace(` - mask_data finished in      : ${dtmask}ms`);\n            if (dtselect != null) {\n                logging_1.logger.trace(` - selection mask finished in : ${dtselect}ms`);\n            }\n            logging_1.logger.trace(` - glyph renders finished in  : ${dtrender}ms`);\n            ctx.restore();\n        }\n        draw_legend(ctx, x0, x1, y0, y1, field, label, index) {\n            if (index == null)\n                index = this.model.get_reference_point(field, label);\n            this.glyph.draw_legend_for_index(ctx, { x0, x1, y0, y1 }, index);\n        }\n        hit_test(geometry) {\n            if (!this.model.visible)\n                return null;\n            const hit_test_result = this.glyph.hit_test(geometry);\n            // glyphs that don't have hit-testing implemented will return null\n            if (hit_test_result == null)\n                return null;\n            return this.model.view.convert_selection_from_subset(hit_test_result);\n        }\n    }\n    exports.GlyphRendererView = GlyphRendererView;\n    GlyphRendererView.__name__ = \"GlyphRendererView\";\n    class GlyphRenderer extends data_renderer_1.DataRenderer {\n        constructor(attrs) {\n            super(attrs);\n        }\n        static init_GlyphRenderer() {\n            this.prototype.default_view = GlyphRendererView;\n            this.define({\n                data_source: [p.Instance],\n                view: [p.Instance, () => new cds_view_1.CDSView()],\n                glyph: [p.Instance],\n                hover_glyph: [p.Instance],\n                nonselection_glyph: [p.Any, 'auto'],\n                selection_glyph: [p.Any, 'auto'],\n                muted_glyph: [p.Instance],\n                muted: [p.Boolean, false],\n            });\n        }\n        initialize() {\n            super.initialize();\n            if (this.view.source == null) {\n                this.view.source = this.data_source;\n                this.view.compute_indices();\n            }\n        }\n        get_reference_point(field, value) {\n            let index = 0;\n            if (field != null) {\n                const data = this.data_source.get_column(field);\n                if (data != null) {\n                    const i = arrayable_1.indexOf(data, value);\n                    if (i != -1)\n                        index = i;\n                }\n            }\n            return index;\n        }\n        get_selection_manager() {\n            return this.data_source.selection_manager;\n        }\n    }\n    exports.GlyphRenderer = GlyphRenderer;\n    GlyphRenderer.__name__ = \"GlyphRenderer\";\n    GlyphRenderer.init_GlyphRenderer();\n}\n","/* models/renderers/data_renderer.js */ function _(require, module, exports) {\n    const renderer_1 = require(58) /* ./renderer */;\n    const p = require(18) /* ../../core/properties */;\n    class DataRendererView extends renderer_1.RendererView {\n    }\n    exports.DataRendererView = DataRendererView;\n    DataRendererView.__name__ = \"DataRendererView\";\n    class DataRenderer extends renderer_1.Renderer {\n        constructor(attrs) {\n            super(attrs);\n        }\n        static init_DataRenderer() {\n            this.define({\n                x_range_name: [p.String, 'default'],\n                y_range_name: [p.String, 'default'],\n            });\n            this.override({\n                level: 'glyph',\n            });\n        }\n    }\n    exports.DataRenderer = DataRenderer;\n    DataRenderer.__name__ = \"DataRenderer\";\n    DataRenderer.init_DataRenderer();\n}\n","/* models/glyphs/line.js */ function _(require, module, exports) {\n    const xy_glyph_1 = require(76) /* ./xy_glyph */;\n    const utils_1 = require(84) /* ./utils */;\n    const hittest = require(81) /* ../../core/hittest */;\n    class LineView extends xy_glyph_1.XYGlyphView {\n        _render(ctx, indices, { sx, sy }) {\n            let drawing = false;\n            let last_index = null;\n            this.visuals.line.set_value(ctx);\n            for (const i of indices) {\n                if (drawing) {\n                    if (!isFinite(sx[i] + sy[i])) {\n                        ctx.stroke();\n                        ctx.beginPath();\n                        drawing = false;\n                        last_index = i;\n                        continue;\n                    }\n                    if (last_index != null && i - last_index > 1) {\n                        ctx.stroke();\n                        drawing = false;\n                    }\n                }\n                if (drawing)\n                    ctx.lineTo(sx[i], sy[i]);\n                else {\n                    ctx.beginPath();\n                    ctx.moveTo(sx[i], sy[i]);\n                    drawing = true;\n                }\n                last_index = i;\n            }\n            if (drawing)\n                ctx.stroke();\n        }\n        _hit_point(geometry) {\n            /* Check if the point geometry hits this line glyph and return an object\n            that describes the hit result:\n              Args:\n                * geometry (object): object with the following keys\n                  * sx (float): screen x coordinate of the point\n                  * sy (float): screen y coordinate of the point\n                  * type (str): type of geometry (in this case it's a point)\n              Output:\n                Object with the following keys:\n                  * 0d (bool): whether the point hits the glyph or not\n                  * 1d (array(int)): array with the indices hit by the point\n            */\n            const result = hittest.create_empty_hit_test_result();\n            const point = { x: geometry.sx, y: geometry.sy };\n            let shortest = 9999;\n            const threshold = Math.max(2, this.visuals.line.line_width.value() / 2);\n            for (let i = 0, end = this.sx.length - 1; i < end; i++) {\n                const p0 = { x: this.sx[i], y: this.sy[i] };\n                const p1 = { x: this.sx[i + 1], y: this.sy[i + 1] };\n                const dist = hittest.dist_to_segment(point, p0, p1);\n                if (dist < threshold && dist < shortest) {\n                    shortest = dist;\n                    result.add_to_selected_glyphs(this.model);\n                    result.get_view = () => this;\n                    result.line_indices = [i];\n                }\n            }\n            return result;\n        }\n        _hit_span(geometry) {\n            const { sx, sy } = geometry;\n            const result = hittest.create_empty_hit_test_result();\n            let val;\n            let values;\n            if (geometry.direction == 'v') {\n                val = this.renderer.yscale.invert(sy);\n                values = this._y;\n            }\n            else {\n                val = this.renderer.xscale.invert(sx);\n                values = this._x;\n            }\n            for (let i = 0, end = values.length - 1; i < end; i++) {\n                if ((values[i] <= val && val <= values[i + 1]) || (values[i + 1] <= val && val <= values[i])) {\n                    result.add_to_selected_glyphs(this.model);\n                    result.get_view = () => this;\n                    result.line_indices.push(i);\n                }\n            }\n            return result;\n        }\n        get_interpolation_hit(i, geometry) {\n            const [x2, y2, x3, y3] = [this._x[i], this._y[i], this._x[i + 1], this._y[i + 1]];\n            return utils_1.line_interpolation(this.renderer, geometry, x2, y2, x3, y3);\n        }\n        draw_legend_for_index(ctx, bbox, index) {\n            utils_1.generic_line_legend(this.visuals, ctx, bbox, index);\n        }\n    }\n    exports.LineView = LineView;\n    LineView.__name__ = \"LineView\";\n    class Line extends xy_glyph_1.XYGlyph {\n        constructor(attrs) {\n            super(attrs);\n        }\n        static init_Line() {\n            this.prototype.default_view = LineView;\n            this.mixins(['line']);\n        }\n    }\n    exports.Line = Line;\n    Line.__name__ = \"Line\";\n    Line.init_Line();\n}\n","/* models/glyphs/xy_glyph.js */ function _(require, module, exports) {\n    const spatial_1 = require(77) /* ../../core/util/spatial */;\n    const glyph_1 = require(80) /* ./glyph */;\n    class XYGlyphView extends glyph_1.GlyphView {\n        _index_data() {\n            const points = [];\n            for (let i = 0, end = this._x.length; i < end; i++) {\n                const x = this._x[i];\n                const y = this._y[i];\n                if (isNaN(x + y) || !isFinite(x + y))\n                    continue;\n                points.push({ x0: x, y0: y, x1: x, y1: y, i });\n            }\n            return new spatial_1.SpatialIndex(points);\n        }\n        scenterx(i) {\n            return this.sx[i];\n        }\n        scentery(i) {\n            return this.sy[i];\n        }\n    }\n    exports.XYGlyphView = XYGlyphView;\n    XYGlyphView.__name__ = \"XYGlyphView\";\n    class XYGlyph extends glyph_1.Glyph {\n        constructor(attrs) {\n            super(attrs);\n        }\n        static init_XYGlyph() {\n            this.coords([['x', 'y']]);\n        }\n    }\n    exports.XYGlyph = XYGlyph;\n    XYGlyph.__name__ = \"XYGlyph\";\n    XYGlyph.init_XYGlyph();\n}\n","/* core/util/spatial.js */ function _(require, module, exports) {\n    const FlatBush = require(78) /* flatbush */;\n    const bbox_1 = require(79) /* ./bbox */;\n    class SpatialIndex {\n        constructor(points) {\n            this.points = points;\n            this.index = null;\n            if (points.length > 0) {\n                this.index = new FlatBush(points.length);\n                for (const p of points) {\n                    const { x0, y0, x1, y1 } = p;\n                    this.index.add(x0, y0, x1, y1);\n                }\n                this.index.finish();\n            }\n        }\n        _normalize(rect) {\n            let { x0, y0, x1, y1 } = rect;\n            if (x0 > x1)\n                [x0, x1] = [x1, x0];\n            if (y0 > y1)\n                [y0, y1] = [y1, y0];\n            return { x0, y0, x1, y1 };\n        }\n        get bbox() {\n            if (this.index == null)\n                return bbox_1.empty();\n            else {\n                const { minX, minY, maxX, maxY } = this.index;\n                return { x0: minX, y0: minY, x1: maxX, y1: maxY };\n            }\n        }\n        search(rect) {\n            if (this.index == null)\n                return [];\n            else {\n                const { x0, y0, x1, y1 } = this._normalize(rect);\n                const indices = this.index.search(x0, y0, x1, y1);\n                return indices.map((j) => this.points[j]);\n            }\n        }\n        indices(rect) {\n            return this.search(rect).map(({ i }) => i);\n        }\n    }\n    exports.SpatialIndex = SpatialIndex;\n    SpatialIndex.__name__ = \"SpatialIndex\";\n}\n","/* flatbush/flatbush.js */ function _(require, module, exports) {\n    (function (global, factory) {\n        typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\n            typeof define === 'function' && define.amd ? define(factory) :\n                (global = global || self, global.Flatbush = factory());\n    }(this, function () {\n        'use strict';\n        var FlatQueue = function FlatQueue() {\n            this.ids = [];\n            this.values = [];\n            this.length = 0;\n        };\n        FlatQueue.prototype.clear = function clear() {\n            this.length = this.ids.length = this.values.length = 0;\n        };\n        FlatQueue.prototype.push = function push(id, value) {\n            this.ids.push(id);\n            this.values.push(value);\n            var pos = this.length++;\n            while (pos > 0) {\n                var parent = (pos - 1) >> 1;\n                var parentValue = this.values[parent];\n                if (value >= parentValue) {\n                    break;\n                }\n                this.ids[pos] = this.ids[parent];\n                this.values[pos] = parentValue;\n                pos = parent;\n            }\n            this.ids[pos] = id;\n            this.values[pos] = value;\n        };\n        FlatQueue.prototype.pop = function pop() {\n            if (this.length === 0) {\n                return undefined;\n            }\n            var top = this.ids[0];\n            this.length--;\n            if (this.length > 0) {\n                var id = this.ids[0] = this.ids[this.length];\n                var value = this.values[0] = this.values[this.length];\n                var halfLength = this.length >> 1;\n                var pos = 0;\n                while (pos < halfLength) {\n                    var left = (pos << 1) + 1;\n                    var right = left + 1;\n                    var bestIndex = this.ids[left];\n                    var bestValue = this.values[left];\n                    var rightValue = this.values[right];\n                    if (right < this.length && rightValue < bestValue) {\n                        left = right;\n                        bestIndex = this.ids[right];\n                        bestValue = rightValue;\n                    }\n                    if (bestValue >= value) {\n                        break;\n                    }\n                    this.ids[pos] = bestIndex;\n                    this.values[pos] = bestValue;\n                    pos = left;\n                }\n                this.ids[pos] = id;\n                this.values[pos] = value;\n            }\n            this.ids.pop();\n            this.values.pop();\n            return top;\n        };\n        FlatQueue.prototype.peek = function peek() {\n            return this.ids[0];\n        };\n        FlatQueue.prototype.peekValue = function peekValue() {\n            return this.values[0];\n        };\n        var ARRAY_TYPES = [\n            Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array,\n            Int32Array, Uint32Array, Float32Array, Float64Array\n        ];\n        var VERSION = 3; // serialized format version\n        var Flatbush = function Flatbush(numItems, nodeSize, ArrayType, data) {\n            if (nodeSize === void 0)\n                nodeSize = 16;\n            if (ArrayType === void 0)\n                ArrayType = Float64Array;\n            if (numItems === undefined) {\n                throw new Error('Missing required argument: numItems.');\n            }\n            if (isNaN(numItems) || numItems <= 0) {\n                throw new Error((\"Unpexpected numItems value: \" + numItems + \".\"));\n            }\n            this.numItems = +numItems;\n            this.nodeSize = Math.min(Math.max(+nodeSize, 2), 65535);\n            // calculate the total number of nodes in the R-tree to allocate space for\n            // and the index of each tree level (used in search later)\n            var n = numItems;\n            var numNodes = n;\n            this._levelBounds = [n * 4];\n            do {\n                n = Math.ceil(n / this.nodeSize);\n                numNodes += n;\n                this._levelBounds.push(numNodes * 4);\n            } while (n !== 1);\n            this.ArrayType = ArrayType || Float64Array;\n            this.IndexArrayType = numNodes < 16384 ? Uint16Array : Uint32Array;\n            var arrayTypeIndex = ARRAY_TYPES.indexOf(this.ArrayType);\n            var nodesByteSize = numNodes * 4 * this.ArrayType.BYTES_PER_ELEMENT;\n            if (arrayTypeIndex < 0) {\n                throw new Error((\"Unexpected typed array class: \" + ArrayType + \".\"));\n            }\n            if (data && (data instanceof ArrayBuffer)) {\n                this.data = data;\n                this._boxes = new this.ArrayType(this.data, 8, numNodes * 4);\n                this._indices = new this.IndexArrayType(this.data, 8 + nodesByteSize, numNodes);\n                this._pos = numNodes * 4;\n                this.minX = this._boxes[this._pos - 4];\n                this.minY = this._boxes[this._pos - 3];\n                this.maxX = this._boxes[this._pos - 2];\n                this.maxY = this._boxes[this._pos - 1];\n            }\n            else {\n                this.data = new ArrayBuffer(8 + nodesByteSize + numNodes * this.IndexArrayType.BYTES_PER_ELEMENT);\n                this._boxes = new this.ArrayType(this.data, 8, numNodes * 4);\n                this._indices = new this.IndexArrayType(this.data, 8 + nodesByteSize, numNodes);\n                this._pos = 0;\n                this.minX = Infinity;\n                this.minY = Infinity;\n                this.maxX = -Infinity;\n                this.maxY = -Infinity;\n                new Uint8Array(this.data, 0, 2).set([0xfb, (VERSION << 4) + arrayTypeIndex]);\n                new Uint16Array(this.data, 2, 1)[0] = nodeSize;\n                new Uint32Array(this.data, 4, 1)[0] = numItems;\n            }\n            // a priority queue for k-nearest-neighbors queries\n            this._queue = new FlatQueue();\n        };\n        Flatbush.from = function from(data) {\n            if (!(data instanceof ArrayBuffer)) {\n                throw new Error('Data must be an instance of ArrayBuffer.');\n            }\n            var ref = new Uint8Array(data, 0, 2);\n            var magic = ref[0];\n            var versionAndType = ref[1];\n            if (magic !== 0xfb) {\n                throw new Error('Data does not appear to be in a Flatbush format.');\n            }\n            if (versionAndType >> 4 !== VERSION) {\n                throw new Error((\"Got v\" + (versionAndType >> 4) + \" data when expected v\" + VERSION + \".\"));\n            }\n            var ref$1 = new Uint16Array(data, 2, 1);\n            var nodeSize = ref$1[0];\n            var ref$2 = new Uint32Array(data, 4, 1);\n            var numItems = ref$2[0];\n            return new Flatbush(numItems, nodeSize, ARRAY_TYPES[versionAndType & 0x0f], data);\n        };\n        Flatbush.prototype.add = function add(minX, minY, maxX, maxY) {\n            var index = this._pos >> 2;\n            this._indices[index] = index;\n            this._boxes[this._pos++] = minX;\n            this._boxes[this._pos++] = minY;\n            this._boxes[this._pos++] = maxX;\n            this._boxes[this._pos++] = maxY;\n            if (minX < this.minX) {\n                this.minX = minX;\n            }\n            if (minY < this.minY) {\n                this.minY = minY;\n            }\n            if (maxX > this.maxX) {\n                this.maxX = maxX;\n            }\n            if (maxY > this.maxY) {\n                this.maxY = maxY;\n            }\n        };\n        Flatbush.prototype.finish = function finish() {\n            if (this._pos >> 2 !== this.numItems) {\n                throw new Error((\"Added \" + (this._pos >> 2) + \" items when expected \" + (this.numItems) + \".\"));\n            }\n            var width = this.maxX - this.minX;\n            var height = this.maxY - this.minY;\n            var hilbertValues = new Uint32Array(this.numItems);\n            var hilbertMax = (1 << 16) - 1;\n            // map item centers into Hilbert coordinate space and calculate Hilbert values\n            for (var i = 0; i < this.numItems; i++) {\n                var pos = 4 * i;\n                var minX = this._boxes[pos++];\n                var minY = this._boxes[pos++];\n                var maxX = this._boxes[pos++];\n                var maxY = this._boxes[pos++];\n                var x = Math.floor(hilbertMax * ((minX + maxX) / 2 - this.minX) / width);\n                var y = Math.floor(hilbertMax * ((minY + maxY) / 2 - this.minY) / height);\n                hilbertValues[i] = hilbert(x, y);\n            }\n            // sort items by their Hilbert value (for packing later)\n            sort(hilbertValues, this._boxes, this._indices, 0, this.numItems - 1);\n            // generate nodes at each tree level, bottom-up\n            for (var i$1 = 0, pos$1 = 0; i$1 < this._levelBounds.length - 1; i$1++) {\n                var end = this._levelBounds[i$1];\n                // generate a parent node for each block of consecutive <nodeSize> nodes\n                while (pos$1 < end) {\n                    var nodeMinX = Infinity;\n                    var nodeMinY = Infinity;\n                    var nodeMaxX = -Infinity;\n                    var nodeMaxY = -Infinity;\n                    var nodeIndex = pos$1;\n                    // calculate bbox for the new node\n                    for (var i$2 = 0; i$2 < this.nodeSize && pos$1 < end; i$2++) {\n                        var minX$1 = this._boxes[pos$1++];\n                        var minY$1 = this._boxes[pos$1++];\n                        var maxX$1 = this._boxes[pos$1++];\n                        var maxY$1 = this._boxes[pos$1++];\n                        if (minX$1 < nodeMinX) {\n                            nodeMinX = minX$1;\n                        }\n                        if (minY$1 < nodeMinY) {\n                            nodeMinY = minY$1;\n                        }\n                        if (maxX$1 > nodeMaxX) {\n                            nodeMaxX = maxX$1;\n                        }\n                        if (maxY$1 > nodeMaxY) {\n                            nodeMaxY = maxY$1;\n                        }\n                    }\n                    // add the new node to the tree data\n                    this._indices[this._pos >> 2] = nodeIndex;\n                    this._boxes[this._pos++] = nodeMinX;\n                    this._boxes[this._pos++] = nodeMinY;\n                    this._boxes[this._pos++] = nodeMaxX;\n                    this._boxes[this._pos++] = nodeMaxY;\n                }\n            }\n        };\n        Flatbush.prototype.search = function search(minX, minY, maxX, maxY, filterFn) {\n            if (this._pos !== this._boxes.length) {\n                throw new Error('Data not yet indexed - call index.finish().');\n            }\n            var nodeIndex = this._boxes.length - 4;\n            var level = this._levelBounds.length - 1;\n            var queue = [];\n            var results = [];\n            while (nodeIndex !== undefined) {\n                // find the end index of the node\n                var end = Math.min(nodeIndex + this.nodeSize * 4, this._levelBounds[level]);\n                // search through child nodes\n                for (var pos = nodeIndex; pos < end; pos += 4) {\n                    var index = this._indices[pos >> 2] | 0;\n                    // check if node bbox intersects with query bbox\n                    if (maxX < this._boxes[pos]) {\n                        continue;\n                    } // maxX < nodeMinX\n                    if (maxY < this._boxes[pos + 1]) {\n                        continue;\n                    } // maxY < nodeMinY\n                    if (minX > this._boxes[pos + 2]) {\n                        continue;\n                    } // minX > nodeMaxX\n                    if (minY > this._boxes[pos + 3]) {\n                        continue;\n                    } // minY > nodeMaxY\n                    if (nodeIndex < this.numItems * 4) {\n                        if (filterFn === undefined || filterFn(index)) {\n                            results.push(index); // leaf item\n                        }\n                    }\n                    else {\n                        queue.push(index); // node; add it to the search queue\n                        queue.push(level - 1);\n                    }\n                }\n                level = queue.pop();\n                nodeIndex = queue.pop();\n            }\n            return results;\n        };\n        Flatbush.prototype.neighbors = function neighbors(x, y, maxResults, maxDistance, filterFn) {\n            if (maxResults === void 0)\n                maxResults = Infinity;\n            if (maxDistance === void 0)\n                maxDistance = Infinity;\n            if (this._pos !== this._boxes.length) {\n                throw new Error('Data not yet indexed - call index.finish().');\n            }\n            var nodeIndex = this._boxes.length - 4;\n            var q = this._queue;\n            var results = [];\n            var maxDistSquared = maxDistance * maxDistance;\n            while (nodeIndex !== undefined) {\n                // find the end index of the node\n                var end = Math.min(nodeIndex + this.nodeSize * 4, upperBound(nodeIndex, this._levelBounds));\n                // add child nodes to the queue\n                for (var pos = nodeIndex; pos < end; pos += 4) {\n                    var index = this._indices[pos >> 2] | 0;\n                    var dx = axisDist(x, this._boxes[pos], this._boxes[pos + 2]);\n                    var dy = axisDist(y, this._boxes[pos + 1], this._boxes[pos + 3]);\n                    var dist = dx * dx + dy * dy;\n                    if (nodeIndex < this.numItems * 4) { // leaf node\n                        if (filterFn === undefined || filterFn(index)) {\n                            // put a negative index if it's an item rather than a node, to recognize later\n                            q.push(-index - 1, dist);\n                        }\n                    }\n                    else {\n                        q.push(index, dist);\n                    }\n                }\n                // pop items from the queue\n                while (q.length && q.peek() < 0) {\n                    var dist$1 = q.peekValue();\n                    if (dist$1 > maxDistSquared) {\n                        q.clear();\n                        return results;\n                    }\n                    results.push(-q.pop() - 1);\n                    if (results.length === maxResults) {\n                        q.clear();\n                        return results;\n                    }\n                }\n                nodeIndex = q.pop();\n            }\n            q.clear();\n            return results;\n        };\n        function axisDist(k, min, max) {\n            return k < min ? min - k : k <= max ? 0 : k - max;\n        }\n        // binary search for the first value in the array bigger than the given\n        function upperBound(value, arr) {\n            var i = 0;\n            var j = arr.length - 1;\n            while (i < j) {\n                var m = (i + j) >> 1;\n                if (arr[m] > value) {\n                    j = m;\n                }\n                else {\n                    i = m + 1;\n                }\n            }\n            return arr[i];\n        }\n        // custom quicksort that sorts bbox data alongside the hilbert values\n        function sort(values, boxes, indices, left, right) {\n            if (left >= right) {\n                return;\n            }\n            var pivot = values[(left + right) >> 1];\n            var i = left - 1;\n            var j = right + 1;\n            while (true) {\n                do {\n                    i++;\n                } while (values[i] < pivot);\n                do {\n                    j--;\n                } while (values[j] > pivot);\n                if (i >= j) {\n                    break;\n                }\n                swap(values, boxes, indices, i, j);\n            }\n            sort(values, boxes, indices, left, j);\n            sort(values, boxes, indices, j + 1, right);\n        }\n        // swap two values and two corresponding boxes\n        function swap(values, boxes, indices, i, j) {\n            var temp = values[i];\n            values[i] = values[j];\n            values[j] = temp;\n            var k = 4 * i;\n            var m = 4 * j;\n            var a = boxes[k];\n            var b = boxes[k + 1];\n            var c = boxes[k + 2];\n            var d = boxes[k + 3];\n            boxes[k] = boxes[m];\n            boxes[k + 1] = boxes[m + 1];\n            boxes[k + 2] = boxes[m + 2];\n            boxes[k + 3] = boxes[m + 3];\n            boxes[m] = a;\n            boxes[m + 1] = b;\n            boxes[m + 2] = c;\n            boxes[m + 3] = d;\n            var e = indices[i];\n            indices[i] = indices[j];\n            indices[j] = e;\n        }\n        // Fast Hilbert curve algorithm by http://threadlocalmutex.com/\n        // Ported from C++ https://github.com/rawrunprotected/hilbert_curves (public domain)\n        function hilbert(x, y) {\n            var a = x ^ y;\n            var b = 0xFFFF ^ a;\n            var c = 0xFFFF ^ (x | y);\n            var d = x & (y ^ 0xFFFF);\n            var A = a | (b >> 1);\n            var B = (a >> 1) ^ a;\n            var C = ((c >> 1) ^ (b & (d >> 1))) ^ c;\n            var D = ((a & (c >> 1)) ^ (d >> 1)) ^ d;\n            a = A;\n            b = B;\n            c = C;\n            d = D;\n            A = ((a & (a >> 2)) ^ (b & (b >> 2)));\n            B = ((a & (b >> 2)) ^ (b & ((a ^ b) >> 2)));\n            C ^= ((a & (c >> 2)) ^ (b & (d >> 2)));\n            D ^= ((b & (c >> 2)) ^ ((a ^ b) & (d >> 2)));\n            a = A;\n            b = B;\n            c = C;\n            d = D;\n            A = ((a & (a >> 4)) ^ (b & (b >> 4)));\n            B = ((a & (b >> 4)) ^ (b & ((a ^ b) >> 4)));\n            C ^= ((a & (c >> 4)) ^ (b & (d >> 4)));\n            D ^= ((b & (c >> 4)) ^ ((a ^ b) & (d >> 4)));\n            a = A;\n            b = B;\n            c = C;\n            d = D;\n            C ^= ((a & (c >> 8)) ^ (b & (d >> 8)));\n            D ^= ((b & (c >> 8)) ^ ((a ^ b) & (d >> 8)));\n            a = C ^ (C >> 1);\n            b = D ^ (D >> 1);\n            var i0 = x ^ y;\n            var i1 = b | (0xFFFF ^ (i0 | a));\n            i0 = (i0 | (i0 << 8)) & 0x00FF00FF;\n            i0 = (i0 | (i0 << 4)) & 0x0F0F0F0F;\n            i0 = (i0 | (i0 << 2)) & 0x33333333;\n            i0 = (i0 | (i0 << 1)) & 0x55555555;\n            i1 = (i1 | (i1 << 8)) & 0x00FF00FF;\n            i1 = (i1 | (i1 << 4)) & 0x0F0F0F0F;\n            i1 = (i1 | (i1 << 2)) & 0x33333333;\n            i1 = (i1 | (i1 << 1)) & 0x55555555;\n            return ((i1 << 1) | i0) >>> 0;\n        }\n        return Flatbush;\n    }));\n}\n","/* core/util/bbox.js */ function _(require, module, exports) {\n    const { min, max } = Math;\n    function empty() {\n        return {\n            x0: Infinity,\n            y0: Infinity,\n            x1: -Infinity,\n            y1: -Infinity,\n        };\n    }\n    exports.empty = empty;\n    function positive_x() {\n        return {\n            x0: Number.MIN_VALUE,\n            y0: -Infinity,\n            x1: Infinity,\n            y1: Infinity,\n        };\n    }\n    exports.positive_x = positive_x;\n    function positive_y() {\n        return {\n            x0: -Infinity,\n            y0: Number.MIN_VALUE,\n            x1: Infinity,\n            y1: Infinity,\n        };\n    }\n    exports.positive_y = positive_y;\n    function union(a, b) {\n        return {\n            x0: min(a.x0, b.x0),\n            x1: max(a.x1, b.x1),\n            y0: min(a.y0, b.y0),\n            y1: max(a.y1, b.y1),\n        };\n    }\n    exports.union = union;\n    class BBox {\n        constructor(box) {\n            if (box == null) {\n                this.x0 = 0;\n                this.y0 = 0;\n                this.x1 = 0;\n                this.y1 = 0;\n            }\n            else if ('x0' in box) {\n                const { x0, y0, x1, y1 } = box;\n                if (!(x0 <= x1 && y0 <= y1))\n                    throw new Error(`invalid bbox {x0: ${x0}, y0: ${y0}, x1: ${x1}, y1: ${y1}}`);\n                this.x0 = x0;\n                this.y0 = y0;\n                this.x1 = x1;\n                this.y1 = y1;\n            }\n            else if (\"x\" in box) {\n                const { x, y, width, height } = box;\n                if (!(width >= 0 && height >= 0))\n                    throw new Error(`invalid bbox {x: ${x}, y: ${y}, width: ${width}, height: ${height}}`);\n                this.x0 = x;\n                this.y0 = y;\n                this.x1 = x + width;\n                this.y1 = y + height;\n            }\n            else {\n                let left, right;\n                let top, bottom;\n                if (\"width\" in box) {\n                    if (\"left\" in box) {\n                        left = box.left;\n                        right = left + box.width;\n                    }\n                    else if (\"right\" in box) {\n                        right = box.right;\n                        left = right - box.width;\n                    }\n                    else {\n                        const w2 = box.width / 2;\n                        left = box.hcenter - w2;\n                        right = box.hcenter + w2;\n                    }\n                }\n                else {\n                    left = box.left;\n                    right = box.right;\n                }\n                if (\"height\" in box) {\n                    if (\"top\" in box) {\n                        top = box.top;\n                        bottom = top + box.height;\n                    }\n                    else if (\"bottom\" in box) {\n                        bottom = box.bottom;\n                        top = bottom - box.height;\n                    }\n                    else {\n                        const h2 = box.height / 2;\n                        top = box.vcenter - h2;\n                        bottom = box.vcenter + h2;\n                    }\n                }\n                else {\n                    top = box.top;\n                    bottom = box.bottom;\n                }\n                if (!(left <= right && top <= bottom))\n                    throw new Error(`invalid bbox {left: ${left}, top: ${top}, right: ${right}, bottom: ${bottom}}`);\n                this.x0 = left;\n                this.y0 = top;\n                this.x1 = right;\n                this.y1 = bottom;\n            }\n        }\n        toString() {\n            return `BBox({left: ${this.left}, top: ${this.top}, width: ${this.width}, height: ${this.height}})`;\n        }\n        get left() { return this.x0; }\n        get top() { return this.y0; }\n        get right() { return this.x1; }\n        get bottom() { return this.y1; }\n        get p0() { return [this.x0, this.y0]; }\n        get p1() { return [this.x1, this.y1]; }\n        get x() { return this.x0; }\n        get y() { return this.y0; }\n        get width() { return this.x1 - this.x0; }\n        get height() { return this.y1 - this.y0; }\n        get rect() { return { x0: this.x0, y0: this.y0, x1: this.x1, y1: this.y1 }; }\n        get box() { return { x: this.x, y: this.y, width: this.width, height: this.height }; }\n        get h_range() { return { start: this.x0, end: this.x1 }; }\n        get v_range() { return { start: this.y0, end: this.y1 }; }\n        get ranges() { return [this.h_range, this.v_range]; }\n        get aspect() { return this.width / this.height; }\n        get hcenter() { return (this.left + this.right) / 2; }\n        get vcenter() { return (this.top + this.bottom) / 2; }\n        contains(x, y) {\n            return x >= this.x0 && x <= this.x1 && y >= this.y0 && y <= this.y1;\n        }\n        clip(x, y) {\n            if (x < this.x0)\n                x = this.x0;\n            else if (x > this.x1)\n                x = this.x1;\n            if (y < this.y0)\n                y = this.y0;\n            else if (y > this.y1)\n                y = this.y1;\n            return [x, y];\n        }\n        union(that) {\n            return new BBox({\n                x0: min(this.x0, that.x0),\n                y0: min(this.y0, that.y0),\n                x1: max(this.x1, that.x1),\n                y1: max(this.y1, that.y1),\n            });\n        }\n        equals(that) {\n            return this.x0 == that.x0 && this.y0 == that.y0 && this.x1 == that.x1 && this.y1 == that.y1;\n        }\n        get xview() {\n            return {\n                compute: (x) => {\n                    return this.left + x;\n                },\n                v_compute: (xx) => {\n                    const _xx = new Float64Array(xx.length);\n                    const left = this.left;\n                    for (let i = 0; i < xx.length; i++) {\n                        _xx[i] = left + xx[i];\n                    }\n                    return _xx;\n                },\n            };\n        }\n        get yview() {\n            return {\n                compute: (y) => {\n                    return this.bottom - y;\n                },\n                v_compute: (yy) => {\n                    const _yy = new Float64Array(yy.length);\n                    const bottom = this.bottom;\n                    for (let i = 0; i < yy.length; i++) {\n                        _yy[i] = bottom - yy[i];\n                    }\n                    return _yy;\n                },\n            };\n        }\n    }\n    exports.BBox = BBox;\n    BBox.__name__ = \"BBox\";\n}\n","/* models/glyphs/glyph.js */ function _(require, module, exports) {\n    const hittest = require(81) /* ../../core/hittest */;\n    const p = require(18) /* ../../core/properties */;\n    const bbox = require(79) /* ../../core/util/bbox */;\n    const proj = require(30) /* ../../core/util/projections */;\n    const visuals = require(63) /* ../../core/visuals */;\n    const view_1 = require(60) /* ../../core/view */;\n    const model_1 = require(64) /* ../../model */;\n    const logging_1 = require(65) /* ../../core/logging */;\n    const arrayable_1 = require(11) /* ../../core/util/arrayable */;\n    const object_1 = require(22) /* ../../core/util/object */;\n    const types_1 = require(7) /* ../../core/util/types */;\n    const line_1 = require(75) /* ./line */;\n    const factor_range_1 = require(82) /* ../ranges/factor_range */;\n    class GlyphView extends view_1.View {\n        constructor() {\n            super(...arguments);\n            this._nohit_warned = {};\n        }\n        get renderer() {\n            return this.parent;\n        }\n        initialize() {\n            super.initialize();\n            this._nohit_warned = {};\n            this.visuals = new visuals.Visuals(this.model);\n            // Init gl (this should really be done anytime renderer is set,\n            // and not done if it isn't ever set, but for now it only\n            // matters in the unit tests because we build a view without a\n            // renderer there)\n            const { gl } = this.renderer.plot_view;\n            if (gl != null) {\n                let webgl_module = null;\n                try {\n                    webgl_module = require(352) /* ./webgl/index */;\n                }\n                catch (e) {\n                    if (e.code === 'MODULE_NOT_FOUND') {\n                        logging_1.logger.warn('WebGL was requested and is supported, but bokeh-gl(.min).js is not available, falling back to 2D rendering.');\n                    }\n                    else\n                        throw e;\n                }\n                if (webgl_module != null) {\n                    const Cls = webgl_module[this.model.type + 'GLGlyph'];\n                    if (Cls != null)\n                        this.glglyph = new Cls(gl.ctx, this);\n                }\n            }\n        }\n        set_visuals(source) {\n            this.visuals.warm_cache(source);\n            if (this.glglyph != null)\n                this.glglyph.set_visuals_changed();\n        }\n        render(ctx, indices, data) {\n            ctx.beginPath();\n            if (this.glglyph != null) {\n                if (this.glglyph.render(ctx, indices, data))\n                    return;\n            }\n            this._render(ctx, indices, data);\n        }\n        has_finished() {\n            return true;\n        }\n        notify_finished() {\n            this.renderer.notify_finished();\n        }\n        _bounds(bounds) {\n            return bounds;\n        }\n        bounds() {\n            return this._bounds(this.index.bbox);\n        }\n        log_bounds() {\n            const bb = bbox.empty();\n            const positive_x_bbs = this.index.search(bbox.positive_x());\n            for (const x of positive_x_bbs) {\n                if (x.x0 < bb.x0)\n                    bb.x0 = x.x0;\n                if (x.x1 > bb.x1)\n                    bb.x1 = x.x1;\n            }\n            const positive_y_bbs = this.index.search(bbox.positive_y());\n            for (const y of positive_y_bbs) {\n                if (y.y0 < bb.y0)\n                    bb.y0 = y.y0;\n                if (y.y1 > bb.y1)\n                    bb.y1 = y.y1;\n            }\n            return this._bounds(bb);\n        }\n        get_anchor_point(anchor, i, [sx, sy]) {\n            switch (anchor) {\n                case \"center\": return { x: this.scenterx(i, sx, sy), y: this.scentery(i, sx, sy) };\n                default: return null;\n            }\n        }\n        sdist(scale, pts, spans, pts_location = \"edge\", dilate = false) {\n            let pt0;\n            let pt1;\n            const n = pts.length;\n            if (pts_location == 'center') {\n                const halfspan = arrayable_1.map(spans, (d) => d / 2);\n                pt0 = new Float64Array(n);\n                for (let i = 0; i < n; i++) {\n                    pt0[i] = pts[i] - halfspan[i];\n                }\n                pt1 = new Float64Array(n);\n                for (let i = 0; i < n; i++) {\n                    pt1[i] = pts[i] + halfspan[i];\n                }\n            }\n            else {\n                pt0 = pts;\n                pt1 = new Float64Array(n);\n                for (let i = 0; i < n; i++) {\n                    pt1[i] = pt0[i] + spans[i];\n                }\n            }\n            const spt0 = scale.v_compute(pt0);\n            const spt1 = scale.v_compute(pt1);\n            if (dilate)\n                return arrayable_1.map(spt0, (_, i) => Math.ceil(Math.abs(spt1[i] - spt0[i])));\n            else\n                return arrayable_1.map(spt0, (_, i) => Math.abs(spt1[i] - spt0[i]));\n        }\n        draw_legend_for_index(_ctx, _bbox, _index) { }\n        hit_test(geometry) {\n            let result = null;\n            const func = `_hit_${geometry.type}`;\n            if (this[func] != null) {\n                result = this[func](geometry);\n            }\n            else if (this._nohit_warned[geometry.type] == null) {\n                logging_1.logger.debug(`'${geometry.type}' selection not available for ${this.model.type}`);\n                this._nohit_warned[geometry.type] = true;\n            }\n            return result;\n        }\n        _hit_rect_against_index(geometry) {\n            const { sx0, sx1, sy0, sy1 } = geometry;\n            const [x0, x1] = this.renderer.xscale.r_invert(sx0, sx1);\n            const [y0, y1] = this.renderer.yscale.r_invert(sy0, sy1);\n            const result = hittest.create_empty_hit_test_result();\n            result.indices = this.index.indices({ x0, x1, y0, y1 });\n            return result;\n        }\n        set_data(source, indices, indices_to_update) {\n            let data = this.model.materialize_dataspecs(source);\n            this.visuals.set_all_indices(indices);\n            if (indices && !(this instanceof line_1.LineView)) {\n                const data_subset = {};\n                for (const k in data) {\n                    const v = data[k];\n                    if (k.charAt(0) === '_')\n                        data_subset[k] = indices.map((i) => v[i]);\n                    else\n                        data_subset[k] = v;\n                }\n                data = data_subset;\n            }\n            const self = this;\n            object_1.extend(self, data);\n            // TODO (bev) Should really probably delegate computing projected\n            // coordinates to glyphs, instead of centralizing here in one place.\n            if (this.renderer.plot_view.model.use_map) {\n                if (self._x != null)\n                    [self._x, self._y] = proj.project_xy(self._x, self._y);\n                if (self._xs != null)\n                    [self._xs, self._ys] = proj.project_xsys(self._xs, self._ys);\n                if (self._x0 != null)\n                    [self._x0, self._y0] = proj.project_xy(self._x0, self._y0);\n                if (self._x1 != null)\n                    [self._x1, self._y1] = proj.project_xy(self._x1, self._y1);\n            }\n            // if we have any coordinates that are categorical, convert them to\n            // synthetic coords here\n            if (this.renderer.plot_view.frame.x_ranges != null) { // XXXX JUST TEMP FOR TESTS TO PASS\n                const xr = this.renderer.plot_view.frame.x_ranges[this.model.x_range_name];\n                const yr = this.renderer.plot_view.frame.y_ranges[this.model.y_range_name];\n                for (let [xname, yname] of this.model._coords) {\n                    xname = `_${xname}`;\n                    yname = `_${yname}`;\n                    // TODO (bev) more robust detection of multi-glyph case\n                    // hand multi glyph case\n                    if (self._xs != null) {\n                        if (xr instanceof factor_range_1.FactorRange) {\n                            self[xname] = arrayable_1.map(self[xname], (arr) => xr.v_synthetic(arr));\n                        }\n                        if (yr instanceof factor_range_1.FactorRange) {\n                            self[yname] = arrayable_1.map(self[yname], (arr) => yr.v_synthetic(arr));\n                        }\n                    }\n                    else {\n                        // hand standard glyph case\n                        if (xr instanceof factor_range_1.FactorRange) {\n                            self[xname] = xr.v_synthetic(self[xname]);\n                        }\n                        if (yr instanceof factor_range_1.FactorRange) {\n                            self[yname] = yr.v_synthetic(self[yname]);\n                        }\n                    }\n                }\n            }\n            if (this.glglyph != null)\n                this.glglyph.set_data_changed(self._x.length);\n            this._set_data(indices_to_update); //TODO doesn't take subset indices into account\n            this.index_data();\n        }\n        _set_data(_indices) { }\n        index_data() {\n            this.index = this._index_data();\n        }\n        mask_data(indices) {\n            // WebGL can do the clipping much more efficiently\n            if (this.glglyph != null || this._mask_data == null)\n                return indices;\n            else\n                return this._mask_data();\n        }\n        map_data() {\n            // TODO: if using gl, skip this (when is this called?)\n            // map all the coordinate fields\n            const self = this;\n            for (let [xname, yname] of this.model._coords) {\n                const sxname = `s${xname}`;\n                const syname = `s${yname}`;\n                xname = `_${xname}`;\n                yname = `_${yname}`;\n                if (self[xname] != null && (types_1.isArray(self[xname][0]) || types_1.isTypedArray(self[xname][0]))) {\n                    const n = self[xname].length;\n                    self[sxname] = new Array(n);\n                    self[syname] = new Array(n);\n                    for (let i = 0; i < n; i++) {\n                        const [sx, sy] = this.map_to_screen(self[xname][i], self[yname][i]);\n                        self[sxname][i] = sx;\n                        self[syname][i] = sy;\n                    }\n                }\n                else\n                    [self[sxname], self[syname]] = this.map_to_screen(self[xname], self[yname]);\n            }\n            this._map_data();\n        }\n        // This is where specs not included in coords are computed, e.g. radius.\n        _map_data() { }\n        map_to_screen(x, y) {\n            return this.renderer.plot_view.map_to_screen(x, y, this.model.x_range_name, this.model.y_range_name);\n        }\n    }\n    exports.GlyphView = GlyphView;\n    GlyphView.__name__ = \"GlyphView\";\n    class Glyph extends model_1.Model {\n        constructor(attrs) {\n            super(attrs);\n        }\n        static init_Glyph() {\n            this.prototype._coords = [];\n            this.internal({\n                x_range_name: [p.String, 'default'],\n                y_range_name: [p.String, 'default'],\n            });\n        }\n        static coords(coords) {\n            const _coords = this.prototype._coords.concat(coords);\n            this.prototype._coords = _coords;\n            const result = {};\n            for (const [x, y] of coords) {\n                result[x] = [p.CoordinateSpec];\n                result[y] = [p.CoordinateSpec];\n            }\n            this.define(result);\n        }\n    }\n    exports.Glyph = Glyph;\n    Glyph.__name__ = \"Glyph\";\n    Glyph.init_Glyph();\n}\n","/* core/hittest.js */ function _(require, module, exports) {\n    const array_1 = require(8) /* ./util/array */;\n    const selection_1 = require(71) /* ../models/selections/selection */;\n    function point_in_poly(x, y, px, py) {\n        let inside = false;\n        let x1 = px[px.length - 1];\n        let y1 = py[py.length - 1];\n        for (let i = 0; i < px.length; i++) {\n            const x2 = px[i];\n            const y2 = py[i];\n            if ((y1 < y) != (y2 < y)) {\n                if (x1 + (y - y1) / (y2 - y1) * (x2 - x1) < x)\n                    inside = !inside;\n            }\n            x1 = x2;\n            y1 = y2;\n        }\n        return inside;\n    }\n    exports.point_in_poly = point_in_poly;\n    function point_in_ellipse(x, y, angle, b, a, x0, y0) {\n        const A = (Math.pow((Math.cos(angle) / a), 2) + Math.pow((Math.sin(angle) / b), 2));\n        const B = 2 * Math.cos(angle) * Math.sin(angle) * (Math.pow((1 / a), 2) - Math.pow((1 / b), 2));\n        const C = (Math.pow((Math.cos(angle) / b), 2) + Math.pow((Math.sin(angle) / a), 2));\n        const eqn = A * Math.pow((x - x0), 2) + B * (x - x0) * (y - y0) + C * Math.pow((y - y0), 2);\n        const inside = eqn <= 1;\n        return inside;\n    }\n    exports.point_in_ellipse = point_in_ellipse;\n    function create_empty_hit_test_result() {\n        return new selection_1.Selection();\n    }\n    exports.create_empty_hit_test_result = create_empty_hit_test_result;\n    function create_hit_test_result_from_hits(hits) {\n        const result = new selection_1.Selection();\n        result.indices = array_1.sort_by(hits, ([_i, dist]) => dist).map(([i, _dist]) => i);\n        return result;\n    }\n    exports.create_hit_test_result_from_hits = create_hit_test_result_from_hits;\n    function sqr(x) {\n        return x * x;\n    }\n    function dist_2_pts(p0, p1) {\n        return sqr(p0.x - p1.x) + sqr(p0.y - p1.y);\n    }\n    exports.dist_2_pts = dist_2_pts;\n    function dist_to_segment_squared(p, v, w) {\n        const l2 = dist_2_pts(v, w);\n        if (l2 == 0)\n            return dist_2_pts(p, v);\n        const t = ((p.x - v.x) * (w.x - v.x) + (p.y - v.y) * (w.y - v.y)) / l2;\n        if (t < 0)\n            return dist_2_pts(p, v);\n        if (t > 1)\n            return dist_2_pts(p, w);\n        const q = { x: v.x + t * (w.x - v.x), y: v.y + t * (w.y - v.y) };\n        return dist_2_pts(p, q);\n    }\n    exports.dist_to_segment_squared = dist_to_segment_squared;\n    function dist_to_segment(p, v, w) {\n        return Math.sqrt(dist_to_segment_squared(p, v, w));\n    }\n    exports.dist_to_segment = dist_to_segment;\n    function check_2_segments_intersect(l0_x0, l0_y0, l0_x1, l0_y1, l1_x0, l1_y0, l1_x1, l1_y1) {\n        /*\n         *  Check if 2 segments (l0 and l1) intersect. Returns a structure with\n         *  the following attributes:\n         *   * hit (boolean): whether the 2 segments intersect\n         *   * x (float): x coordinate of the intersection point\n         *   * y (float): y coordinate of the intersection point\n         */\n        const den = ((l1_y1 - l1_y0) * (l0_x1 - l0_x0)) - ((l1_x1 - l1_x0) * (l0_y1 - l0_y0));\n        if (den == 0) {\n            return { hit: false, x: null, y: null };\n        }\n        else {\n            let a = l0_y0 - l1_y0;\n            let b = l0_x0 - l1_x0;\n            const num1 = ((l1_x1 - l1_x0) * a) - ((l1_y1 - l1_y0) * b);\n            const num2 = ((l0_x1 - l0_x0) * a) - ((l0_y1 - l0_y0) * b);\n            a = num1 / den;\n            b = num2 / den;\n            const x = l0_x0 + (a * (l0_x1 - l0_x0));\n            const y = l0_y0 + (a * (l0_y1 - l0_y0));\n            return { hit: (a > 0 && a < 1) && (b > 0 && b < 1), x, y };\n        }\n    }\n    exports.check_2_segments_intersect = check_2_segments_intersect;\n}\n","/* models/ranges/factor_range.js */ function _(require, module, exports) {\n    const range_1 = require(83) /* ./range */;\n    const p = require(18) /* ../../core/properties */;\n    const arrayable_1 = require(11) /* ../../core/util/arrayable */;\n    const array_1 = require(8) /* ../../core/util/array */;\n    const types_1 = require(7) /* ../../core/util/types */;\n    function map_one_level(factors, padding, offset = 0) {\n        const mapping = {};\n        for (let i = 0; i < factors.length; i++) {\n            const factor = factors[i];\n            if (factor in mapping)\n                throw new Error(`duplicate factor or subfactor: ${factor}`);\n            else\n                mapping[factor] = { value: 0.5 + i * (1 + padding) + offset };\n        }\n        return [mapping, (factors.length - 1) * padding];\n    }\n    exports.map_one_level = map_one_level;\n    function map_two_levels(factors, outer_pad, factor_pad, offset = 0) {\n        const mapping = {};\n        const tops = {};\n        const tops_order = [];\n        for (const [f0, f1] of factors) {\n            if (!(f0 in tops)) {\n                tops[f0] = [];\n                tops_order.push(f0);\n            }\n            tops[f0].push(f1);\n        }\n        let suboffset = offset;\n        let total_subpad = 0;\n        for (const f0 of tops_order) {\n            const n = tops[f0].length;\n            const [submap, subpad] = map_one_level(tops[f0], factor_pad, suboffset);\n            total_subpad += subpad;\n            const subtot = array_1.sum(tops[f0].map((f1) => submap[f1].value));\n            mapping[f0] = { value: subtot / n, mapping: submap };\n            suboffset += n + outer_pad + subpad;\n        }\n        return [mapping, tops_order, (tops_order.length - 1) * outer_pad + total_subpad];\n    }\n    exports.map_two_levels = map_two_levels;\n    function map_three_levels(factors, outer_pad, inner_pad, factor_pad, offset = 0) {\n        const mapping = {};\n        const tops = {};\n        const tops_order = [];\n        for (const [f0, f1, f2] of factors) {\n            if (!(f0 in tops)) {\n                tops[f0] = [];\n                tops_order.push(f0);\n            }\n            tops[f0].push([f1, f2]);\n        }\n        const mids_order = [];\n        let suboffset = offset;\n        let total_subpad = 0;\n        for (const f0 of tops_order) {\n            const n = tops[f0].length;\n            const [submap, submids_order, subpad] = map_two_levels(tops[f0], inner_pad, factor_pad, suboffset);\n            for (const f1 of submids_order)\n                mids_order.push([f0, f1]);\n            total_subpad += subpad;\n            const subtot = array_1.sum(tops[f0].map(([f1]) => submap[f1].value));\n            mapping[f0] = { value: subtot / n, mapping: submap };\n            suboffset += n + outer_pad + subpad;\n        }\n        return [mapping, tops_order, mids_order, (tops_order.length - 1) * outer_pad + total_subpad];\n    }\n    exports.map_three_levels = map_three_levels;\n    class FactorRange extends range_1.Range {\n        constructor(attrs) {\n            super(attrs);\n        }\n        static init_FactorRange() {\n            this.define({\n                factors: [p.Array, []],\n                factor_padding: [p.Number, 0],\n                subgroup_padding: [p.Number, 0.8],\n                group_padding: [p.Number, 1.4],\n                range_padding: [p.Number, 0],\n                range_padding_units: [p.PaddingUnits, \"percent\"],\n                start: [p.Number],\n                end: [p.Number],\n            });\n            this.internal({\n                levels: [p.Number],\n                mids: [p.Array],\n                tops: [p.Array],\n                tops_groups: [p.Array],\n            });\n        }\n        get min() {\n            return this.start;\n        }\n        get max() {\n            return this.end;\n        }\n        initialize() {\n            super.initialize();\n            this._init(true);\n        }\n        connect_signals() {\n            super.connect_signals();\n            this.connect(this.properties.factors.change, () => this.reset());\n            this.connect(this.properties.factor_padding.change, () => this.reset());\n            this.connect(this.properties.group_padding.change, () => this.reset());\n            this.connect(this.properties.subgroup_padding.change, () => this.reset());\n            this.connect(this.properties.range_padding.change, () => this.reset());\n            this.connect(this.properties.range_padding_units.change, () => this.reset());\n        }\n        reset() {\n            this._init(false);\n            this.change.emit();\n        }\n        _lookup(x) {\n            if (x.length == 1) {\n                const m = this._mapping;\n                if (!m.hasOwnProperty(x[0])) {\n                    return NaN;\n                }\n                return m[x[0]].value;\n            }\n            else if (x.length == 2) {\n                const m = this._mapping;\n                if (!m.hasOwnProperty(x[0]) || !m[x[0]].mapping.hasOwnProperty(x[1])) {\n                    return NaN;\n                }\n                return m[x[0]].mapping[x[1]].value;\n            }\n            else if (x.length == 3) {\n                const m = this._mapping;\n                if (!m.hasOwnProperty(x[0]) || !m[x[0]].mapping.hasOwnProperty(x[1]) || !m[x[0]].mapping[x[1]].mapping.hasOwnProperty(x[2])) {\n                    return NaN;\n                }\n                return m[x[0]].mapping[x[1]].mapping[x[2]].value;\n            }\n            else\n                throw new Error(\"unreachable code\");\n        }\n        // convert a string factor into a synthetic coordinate\n        synthetic(x) {\n            if (types_1.isNumber(x))\n                return x;\n            if (types_1.isString(x))\n                return this._lookup([x]);\n            let offset = 0;\n            const off = x[x.length - 1];\n            if (types_1.isNumber(off)) {\n                offset = off;\n                x = x.slice(0, -1);\n            }\n            return this._lookup(x) + offset;\n        }\n        // convert an array of string factors into synthetic coordinates\n        v_synthetic(xs) {\n            return arrayable_1.map(xs, (x) => this.synthetic(x));\n        }\n        _init(silent) {\n            let levels;\n            let inside_padding;\n            if (array_1.every(this.factors, types_1.isString)) {\n                levels = 1;\n                [this._mapping, inside_padding] = map_one_level(this.factors, this.factor_padding);\n            }\n            else if (array_1.every(this.factors, (x) => types_1.isArray(x) && x.length == 2 && types_1.isString(x[0]) && types_1.isString(x[1]))) {\n                levels = 2;\n                [this._mapping, this.tops, inside_padding] = map_two_levels(this.factors, this.group_padding, this.factor_padding);\n            }\n            else if (array_1.every(this.factors, (x) => types_1.isArray(x) && x.length == 3 && types_1.isString(x[0]) && types_1.isString(x[1]) && types_1.isString(x[2]))) {\n                levels = 3;\n                [this._mapping, this.tops, this.mids, inside_padding] = map_three_levels(this.factors, this.group_padding, this.subgroup_padding, this.factor_padding);\n            }\n            else\n                throw new Error(\"???\");\n            let start = 0;\n            let end = this.factors.length + inside_padding;\n            if (this.range_padding_units == \"percent\") {\n                const half_span = (end - start) * this.range_padding / 2;\n                start -= half_span;\n                end += half_span;\n            }\n            else {\n                start -= this.range_padding;\n                end += this.range_padding;\n            }\n            this.setv({ start, end, levels }, { silent });\n            if (this.bounds == \"auto\")\n                this.setv({ bounds: [start, end] }, { silent: true });\n        }\n    }\n    exports.FactorRange = FactorRange;\n    FactorRange.__name__ = \"FactorRange\";\n    FactorRange.init_FactorRange();\n}\n","/* models/ranges/range.js */ function _(require, module, exports) {\n    const model_1 = require(64) /* ../../model */;\n    const p = require(18) /* ../../core/properties */;\n    const types_1 = require(7) /* ../../core/util/types */;\n    class Range extends model_1.Model {\n        constructor(attrs) {\n            super(attrs);\n            this.have_updated_interactively = false;\n        }\n        static init_Range() {\n            this.define({\n                callback: [p.Any],\n                bounds: [p.Any],\n                min_interval: [p.Any],\n                max_interval: [p.Any],\n            });\n            this.internal({\n                plots: [p.Array, []],\n            });\n        }\n        connect_signals() {\n            super.connect_signals();\n            this.connect(this.change, () => this._emit_callback());\n        }\n        _emit_callback() {\n            if (this.callback != null) {\n                if (types_1.isFunction(this.callback))\n                    this.callback(this);\n                else\n                    this.callback.execute(this, {});\n            }\n        }\n        get is_reversed() {\n            return this.start > this.end;\n        }\n    }\n    exports.Range = Range;\n    Range.__name__ = \"Range\";\n    Range.init_Range();\n}\n","/* models/glyphs/utils.js */ function _(require, module, exports) {\n    const hittest = require(81) /* ../../core/hittest */;\n    function generic_line_legend(visuals, ctx, { x0, x1, y0, y1 }, index) {\n        ctx.save();\n        ctx.beginPath();\n        ctx.moveTo(x0, (y0 + y1) / 2);\n        ctx.lineTo(x1, (y0 + y1) / 2);\n        if (visuals.line.doit) {\n            visuals.line.set_vectorize(ctx, index);\n            ctx.stroke();\n        }\n        ctx.restore();\n    }\n    exports.generic_line_legend = generic_line_legend;\n    function generic_area_legend(visuals, ctx, { x0, x1, y0, y1 }, index) {\n        const w = Math.abs(x1 - x0);\n        const dw = w * 0.1;\n        const h = Math.abs(y1 - y0);\n        const dh = h * 0.1;\n        const sx0 = x0 + dw;\n        const sx1 = x1 - dw;\n        const sy0 = y0 + dh;\n        const sy1 = y1 - dh;\n        if (visuals.fill.doit) {\n            visuals.fill.set_vectorize(ctx, index);\n            ctx.fillRect(sx0, sy0, sx1 - sx0, sy1 - sy0);\n        }\n        if (visuals.hatch != null && visuals.hatch.doit) {\n            visuals.hatch.set_vectorize(ctx, index);\n            ctx.fillRect(sx0, sy0, sx1 - sx0, sy1 - sy0);\n        }\n        if (visuals.line && visuals.line.doit) {\n            ctx.beginPath();\n            ctx.rect(sx0, sy0, sx1 - sx0, sy1 - sy0);\n            visuals.line.set_vectorize(ctx, index);\n            ctx.stroke();\n        }\n    }\n    exports.generic_area_legend = generic_area_legend;\n    function line_interpolation(renderer, geometry, x2, y2, x3, y3) {\n        const { sx, sy } = geometry;\n        let x0, x1;\n        let y0, y1;\n        if (geometry.type == 'point') {\n            // The +/- adjustments here are to dilate the hit point into a virtual \"segment\" to use below\n            [y0, y1] = renderer.yscale.r_invert(sy - 1, sy + 1);\n            [x0, x1] = renderer.xscale.r_invert(sx - 1, sx + 1);\n        }\n        else {\n            // The +/- adjustments here are to handle cases such as purely horizontal or vertical lines\n            if (geometry.direction == 'v') {\n                [y0, y1] = renderer.yscale.r_invert(sy, sy);\n                [x0, x1] = [Math.min(x2 - 1, x3 - 1), Math.max(x2 + 1, x3 + 1)];\n            }\n            else {\n                [x0, x1] = renderer.xscale.r_invert(sx, sx);\n                [y0, y1] = [Math.min(y2 - 1, y3 - 1), Math.max(y2 + 1, y3 + 1)];\n            }\n        }\n        const { x, y } = hittest.check_2_segments_intersect(x0, y0, x1, y1, x2, y2, x3, y3);\n        return [x, y]; // XXX: null is not handled at use sites\n    }\n    exports.line_interpolation = line_interpolation;\n}\n","/* models/glyphs/patch.js */ function _(require, module, exports) {\n    const xy_glyph_1 = require(76) /* ./xy_glyph */;\n    const utils_1 = require(84) /* ./utils */;\n    const hittest = require(81) /* ../../core/hittest */;\n    class PatchView extends xy_glyph_1.XYGlyphView {\n        _inner_loop(ctx, indices, sx, sy, func) {\n            for (const i of indices) {\n                if (i == 0) {\n                    ctx.beginPath();\n                    ctx.moveTo(sx[i], sy[i]);\n                    continue;\n                }\n                else if (isNaN(sx[i] + sy[i])) {\n                    ctx.closePath();\n                    func.apply(ctx);\n                    ctx.beginPath();\n                    continue;\n                }\n                else\n                    ctx.lineTo(sx[i], sy[i]);\n            }\n            ctx.closePath();\n            func.call(ctx);\n        }\n        _render(ctx, indices, { sx, sy }) {\n            if (this.visuals.fill.doit) {\n                this.visuals.fill.set_value(ctx);\n                this._inner_loop(ctx, indices, sx, sy, ctx.fill);\n            }\n            this.visuals.hatch.doit2(ctx, 0, () => this._inner_loop(ctx, indices, sx, sy, ctx.fill), () => this.renderer.request_render());\n            if (this.visuals.line.doit) {\n                this.visuals.line.set_value(ctx);\n                this._inner_loop(ctx, indices, sx, sy, ctx.stroke);\n            }\n        }\n        draw_legend_for_index(ctx, bbox, index) {\n            utils_1.generic_area_legend(this.visuals, ctx, bbox, index);\n        }\n        _hit_point(geometry) {\n            const result = hittest.create_empty_hit_test_result();\n            if (hittest.point_in_poly(geometry.sx, geometry.sy, this.sx, this.sy)) {\n                result.add_to_selected_glyphs(this.model);\n                result.get_view = () => this;\n            }\n            return result;\n        }\n    }\n    exports.PatchView = PatchView;\n    PatchView.__name__ = \"PatchView\";\n    class Patch extends xy_glyph_1.XYGlyph {\n        constructor(attrs) {\n            super(attrs);\n        }\n        static init_Patch() {\n            this.prototype.default_view = PatchView;\n            this.mixins(['line', 'fill', 'hatch']);\n        }\n    }\n    exports.Patch = Patch;\n    Patch.__name__ = \"Patch\";\n    Patch.init_Patch();\n}\n","/* models/glyphs/harea.js */ function _(require, module, exports) {\n    const area_1 = require(87) /* ./area */;\n    const spatial_1 = require(77) /* ../../core/util/spatial */;\n    const hittest = require(81) /* ../../core/hittest */;\n    const p = require(18) /* ../../core/properties */;\n    class HAreaView extends area_1.AreaView {\n        _index_data() {\n            const points = [];\n            for (let i = 0, end = this._x1.length; i < end; i++) {\n                const x1 = this._x1[i];\n                const x2 = this._x2[i];\n                const y = this._y[i];\n                if (isNaN(x1 + x2 + y) || !isFinite(x1 + x2 + y))\n                    continue;\n                points.push({ x0: Math.min(x1, x2), y0: y, x1: Math.max(x1, x2), y1: y, i });\n            }\n            return new spatial_1.SpatialIndex(points);\n        }\n        _inner(ctx, sx1, sx2, sy, func) {\n            ctx.beginPath();\n            for (let i = 0, end = sx1.length; i < end; i++) {\n                ctx.lineTo(sx1[i], sy[i]);\n            }\n            // iterate backwards so that the upper end is below the lower start\n            for (let start = sx2.length - 1, i = start; i >= 0; i--) {\n                ctx.lineTo(sx2[i], sy[i]);\n            }\n            ctx.closePath();\n            func.call(ctx);\n        }\n        _render(ctx, _indices, { sx1, sx2, sy }) {\n            if (this.visuals.fill.doit) {\n                this.visuals.fill.set_value(ctx);\n                this._inner(ctx, sx1, sx2, sy, ctx.fill);\n            }\n            this.visuals.hatch.doit2(ctx, 0, () => this._inner(ctx, sx1, sx2, sy, ctx.fill), () => this.renderer.request_render());\n        }\n        _hit_point(geometry) {\n            const result = hittest.create_empty_hit_test_result();\n            const L = this.sy.length;\n            const sx = new Float64Array(2 * L);\n            const sy = new Float64Array(2 * L);\n            for (let i = 0, end = L; i < end; i++) {\n                sx[i] = this.sx1[i];\n                sy[i] = this.sy[i];\n                sx[L + i] = this.sx2[L - i - 1];\n                sy[L + i] = this.sy[L - i - 1];\n            }\n            if (hittest.point_in_poly(geometry.sx, geometry.sy, sx, sy)) {\n                result.add_to_selected_glyphs(this.model);\n                result.get_view = () => this;\n            }\n            return result;\n        }\n        scenterx(i) {\n            return (this.sx1[i] + this.sx2[i]) / 2;\n        }\n        scentery(i) {\n            return this.sy[i];\n        }\n        _map_data() {\n            this.sx1 = this.renderer.xscale.v_compute(this._x1);\n            this.sx2 = this.renderer.xscale.v_compute(this._x2);\n            this.sy = this.renderer.yscale.v_compute(this._y);\n        }\n    }\n    exports.HAreaView = HAreaView;\n    HAreaView.__name__ = \"HAreaView\";\n    class HArea extends area_1.Area {\n        constructor(attrs) {\n            super(attrs);\n        }\n        static init_HArea() {\n            this.prototype.default_view = HAreaView;\n            this.define({\n                x1: [p.CoordinateSpec],\n                x2: [p.CoordinateSpec],\n                y: [p.CoordinateSpec],\n            });\n        }\n    }\n    exports.HArea = HArea;\n    HArea.__name__ = \"HArea\";\n    HArea.init_HArea();\n}\n","/* models/glyphs/area.js */ function _(require, module, exports) {\n    const glyph_1 = require(80) /* ./glyph */;\n    const utils_1 = require(84) /* ./utils */;\n    class AreaView extends glyph_1.GlyphView {\n        draw_legend_for_index(ctx, bbox, index) {\n            utils_1.generic_area_legend(this.visuals, ctx, bbox, index);\n        }\n    }\n    exports.AreaView = AreaView;\n    AreaView.__name__ = \"AreaView\";\n    class Area extends glyph_1.Glyph {\n        constructor(attrs) {\n            super(attrs);\n        }\n        static init_Area() {\n            this.mixins(['fill', 'hatch']);\n        }\n    }\n    exports.Area = Area;\n    Area.__name__ = \"Area\";\n    Area.init_Area();\n}\n","/* models/glyphs/varea.js */ function _(require, module, exports) {\n    const area_1 = require(87) /* ./area */;\n    const spatial_1 = require(77) /* ../../core/util/spatial */;\n    const hittest = require(81) /* ../../core/hittest */;\n    const p = require(18) /* ../../core/properties */;\n    class VAreaView extends area_1.AreaView {\n        _index_data() {\n            const points = [];\n            for (let i = 0, end = this._x.length; i < end; i++) {\n                const x = this._x[i];\n                const y1 = this._y1[i];\n                const y2 = this._y2[i];\n                if (isNaN(x + y1 + y2) || !isFinite(x + y1 + y2))\n                    continue;\n                points.push({ x0: x, y0: Math.min(y1, y2), x1: x, y1: Math.max(y1, y2), i });\n            }\n            return new spatial_1.SpatialIndex(points);\n        }\n        _inner(ctx, sx, sy1, sy2, func) {\n            ctx.beginPath();\n            for (let i = 0, end = sy1.length; i < end; i++) {\n                ctx.lineTo(sx[i], sy1[i]);\n            }\n            // iterate backwards so that the upper end is below the lower start\n            for (let start = sy2.length - 1, i = start; i >= 0; i--) {\n                ctx.lineTo(sx[i], sy2[i]);\n            }\n            ctx.closePath();\n            func.call(ctx);\n        }\n        _render(ctx, _indices, { sx, sy1, sy2 }) {\n            if (this.visuals.fill.doit) {\n                this.visuals.fill.set_value(ctx);\n                this._inner(ctx, sx, sy1, sy2, ctx.fill);\n            }\n            this.visuals.hatch.doit2(ctx, 0, () => this._inner(ctx, sx, sy1, sy2, ctx.fill), () => this.renderer.request_render());\n        }\n        scenterx(i) {\n            return this.sx[i];\n        }\n        scentery(i) {\n            return (this.sy1[i] + this.sy2[i]) / 2;\n        }\n        _hit_point(geometry) {\n            const result = hittest.create_empty_hit_test_result();\n            const L = this.sx.length;\n            const sx = new Float64Array(2 * L);\n            const sy = new Float64Array(2 * L);\n            for (let i = 0, end = L; i < end; i++) {\n                sx[i] = this.sx[i];\n                sy[i] = this.sy1[i];\n                sx[L + i] = this.sx[L - i - 1];\n                sy[L + i] = this.sy2[L - i - 1];\n            }\n            if (hittest.point_in_poly(geometry.sx, geometry.sy, sx, sy)) {\n                result.add_to_selected_glyphs(this.model);\n                result.get_view = () => this;\n            }\n            return result;\n        }\n        _map_data() {\n            this.sx = this.renderer.xscale.v_compute(this._x);\n            this.sy1 = this.renderer.yscale.v_compute(this._y1);\n            this.sy2 = this.renderer.yscale.v_compute(this._y2);\n        }\n    }\n    exports.VAreaView = VAreaView;\n    VAreaView.__name__ = \"VAreaView\";\n    class VArea extends area_1.Area {\n        constructor(attrs) {\n            super(attrs);\n        }\n        static init_VArea() {\n            this.prototype.default_view = VAreaView;\n            this.define({\n                x: [p.CoordinateSpec],\n                y1: [p.CoordinateSpec],\n                y2: [p.CoordinateSpec],\n            });\n        }\n    }\n    exports.VArea = VArea;\n    VArea.__name__ = \"VArea\";\n    VArea.init_VArea();\n}\n","/* models/sources/cds_view.js */ function _(require, module, exports) {\n    const model_1 = require(64) /* ../../model */;\n    const p = require(18) /* ../../core/properties */;\n    const selection_1 = require(71) /* ../selections/selection */;\n    const array_1 = require(8) /* ../../core/util/array */;\n    const columnar_data_source_1 = require(69) /* ./columnar_data_source */;\n    class CDSView extends model_1.Model {\n        constructor(attrs) {\n            super(attrs);\n        }\n        static init_CDSView() {\n            this.define({\n                filters: [p.Array, []],\n                source: [p.Instance],\n            });\n            this.internal({\n                indices: [p.Array, []],\n                indices_map: [p.Any, {}],\n            });\n        }\n        initialize() {\n            super.initialize();\n            this.compute_indices();\n        }\n        connect_signals() {\n            super.connect_signals();\n            this.connect(this.properties.filters.change, () => {\n                this.compute_indices();\n                this.change.emit();\n            });\n            const connect_listeners = () => {\n                const fn = () => this.compute_indices();\n                if (this.source != null) {\n                    this.connect(this.source.change, fn);\n                    if (this.source instanceof columnar_data_source_1.ColumnarDataSource) {\n                        this.connect(this.source.streaming, fn);\n                        this.connect(this.source.patching, fn);\n                    }\n                }\n            };\n            let initialized = this.source != null;\n            if (initialized)\n                connect_listeners();\n            else {\n                this.connect(this.properties.source.change, () => {\n                    if (!initialized) {\n                        connect_listeners();\n                        initialized = true;\n                    }\n                });\n            }\n        }\n        compute_indices() {\n            const indices = this.filters\n                .map((filter) => filter.compute_indices(this.source))\n                .filter((indices) => indices != null);\n            if (indices.length > 0)\n                this.indices = array_1.intersection.apply(this, indices);\n            else if (this.source instanceof columnar_data_source_1.ColumnarDataSource)\n                this.indices = this.source.get_indices();\n            this.indices_map_to_subset();\n        }\n        indices_map_to_subset() {\n            this.indices_map = {};\n            for (let i = 0; i < this.indices.length; i++) {\n                this.indices_map[this.indices[i]] = i;\n            }\n        }\n        convert_selection_from_subset(selection_subset) {\n            const selection_full = new selection_1.Selection();\n            selection_full.update_through_union(selection_subset);\n            const indices_1d = selection_subset.indices.map((i) => this.indices[i]);\n            selection_full.indices = indices_1d;\n            selection_full.image_indices = selection_subset.image_indices;\n            return selection_full;\n        }\n        convert_selection_to_subset(selection_full) {\n            const selection_subset = new selection_1.Selection();\n            selection_subset.update_through_union(selection_full);\n            const indices_1d = selection_full.indices.map((i) => this.indices_map[i]);\n            selection_subset.indices = indices_1d;\n            selection_subset.image_indices = selection_full.image_indices;\n            return selection_subset;\n        }\n        convert_indices_from_subset(indices) {\n            return indices.map((i) => this.indices[i]);\n        }\n    }\n    exports.CDSView = CDSView;\n    CDSView.__name__ = \"CDSView\";\n    CDSView.init_CDSView();\n}\n","/* models/renderers/graph_renderer.js */ function _(require, module, exports) {\n    const data_renderer_1 = require(74) /* ./data_renderer */;\n    const graph_hit_test_policy_1 = require(91) /* ../graphs/graph_hit_test_policy */;\n    const p = require(18) /* ../../core/properties */;\n    const build_views_1 = require(92) /* ../../core/build_views */;\n    class GraphRendererView extends data_renderer_1.DataRendererView {\n        initialize() {\n            super.initialize();\n            this.xscale = this.plot_view.frame.xscales.default;\n            this.yscale = this.plot_view.frame.yscales.default;\n            this._renderer_views = {};\n            [this.node_view, this.edge_view] = build_views_1.build_views(this._renderer_views, [\n                this.model.node_renderer,\n                this.model.edge_renderer,\n            ], { parent: this.parent });\n            this.set_data();\n        }\n        connect_signals() {\n            super.connect_signals();\n            this.connect(this.model.layout_provider.change, () => this.set_data());\n            this.connect(this.model.node_renderer.data_source._select, () => this.set_data());\n            this.connect(this.model.node_renderer.data_source.inspect, () => this.set_data());\n            this.connect(this.model.node_renderer.data_source.change, () => this.set_data());\n            this.connect(this.model.edge_renderer.data_source._select, () => this.set_data());\n            this.connect(this.model.edge_renderer.data_source.inspect, () => this.set_data());\n            this.connect(this.model.edge_renderer.data_source.change, () => this.set_data());\n            const { x_ranges, y_ranges } = this.plot_view.frame;\n            for (const name in x_ranges) {\n                const rng = x_ranges[name];\n                this.connect(rng.change, () => this.set_data());\n            }\n            for (const name in y_ranges) {\n                const rng = y_ranges[name];\n                this.connect(rng.change, () => this.set_data());\n            }\n        }\n        set_data(request_render = true) {\n            // TODO (bev) this is a bit clunky, need to make sure glyphs use the correct ranges when they call\n            // mapping functions on the base Renderer class\n            this.node_view.glyph.model.setv({ x_range_name: this.model.x_range_name, y_range_name: this.model.y_range_name }, { silent: true });\n            this.edge_view.glyph.model.setv({ x_range_name: this.model.x_range_name, y_range_name: this.model.y_range_name }, { silent: true });\n            // XXX\n            const node_glyph = this.node_view.glyph;\n            [node_glyph._x, node_glyph._y] =\n                this.model.layout_provider.get_node_coordinates(this.model.node_renderer.data_source);\n            const edge_glyph = this.edge_view.glyph;\n            [edge_glyph._xs, edge_glyph._ys] =\n                this.model.layout_provider.get_edge_coordinates(this.model.edge_renderer.data_source);\n            node_glyph.index_data();\n            edge_glyph.index_data();\n            if (request_render)\n                this.request_render();\n        }\n        render() {\n            this.edge_view.render();\n            this.node_view.render();\n        }\n    }\n    exports.GraphRendererView = GraphRendererView;\n    GraphRendererView.__name__ = \"GraphRendererView\";\n    class GraphRenderer extends data_renderer_1.DataRenderer {\n        constructor(attrs) {\n            super(attrs);\n        }\n        static init_GraphRenderer() {\n            this.prototype.default_view = GraphRendererView;\n            this.define({\n                layout_provider: [p.Instance],\n                node_renderer: [p.Instance],\n                edge_renderer: [p.Instance],\n                selection_policy: [p.Instance, () => new graph_hit_test_policy_1.NodesOnly()],\n                inspection_policy: [p.Instance, () => new graph_hit_test_policy_1.NodesOnly()],\n            });\n        }\n        get_selection_manager() {\n            return this.node_renderer.data_source.selection_manager;\n        }\n    }\n    exports.GraphRenderer = GraphRenderer;\n    GraphRenderer.__name__ = \"GraphRenderer\";\n    GraphRenderer.init_GraphRenderer();\n}\n","/* models/graphs/graph_hit_test_policy.js */ function _(require, module, exports) {\n    const model_1 = require(64) /* ../../model */;\n    const arrayable_1 = require(11) /* ../../core/util/arrayable */;\n    const array_1 = require(8) /* ../../core/util/array */;\n    const hittest_1 = require(81) /* ../../core/hittest */;\n    class GraphHitTestPolicy extends model_1.Model {\n        constructor(attrs) {\n            super(attrs);\n        }\n        _hit_test_nodes(geometry, graph_view) {\n            if (!graph_view.model.visible)\n                return null;\n            const hit_test_result = graph_view.node_view.glyph.hit_test(geometry);\n            if (hit_test_result == null)\n                return null;\n            else\n                return graph_view.node_view.model.view.convert_selection_from_subset(hit_test_result);\n        }\n        _hit_test_edges(geometry, graph_view) {\n            if (!graph_view.model.visible)\n                return null;\n            const hit_test_result = graph_view.edge_view.glyph.hit_test(geometry);\n            if (hit_test_result == null)\n                return null;\n            else\n                return graph_view.edge_view.model.view.convert_selection_from_subset(hit_test_result);\n        }\n    }\n    exports.GraphHitTestPolicy = GraphHitTestPolicy;\n    GraphHitTestPolicy.__name__ = \"GraphHitTestPolicy\";\n    class NodesOnly extends GraphHitTestPolicy {\n        constructor(attrs) {\n            super(attrs);\n        }\n        hit_test(geometry, graph_view) {\n            return this._hit_test_nodes(geometry, graph_view);\n        }\n        do_selection(hit_test_result, graph, final, append) {\n            if (hit_test_result == null)\n                return false;\n            const node_selection = graph.node_renderer.data_source.selected;\n            node_selection.update(hit_test_result, final, append);\n            graph.node_renderer.data_source._select.emit();\n            return !node_selection.is_empty();\n        }\n        do_inspection(hit_test_result, geometry, graph_view, final, append) {\n            if (hit_test_result == null)\n                return false;\n            const node_inspection = graph_view.model.get_selection_manager().get_or_create_inspector(graph_view.node_view.model);\n            node_inspection.update(hit_test_result, final, append);\n            // silently set inspected attr to avoid triggering data_source.change event and rerender\n            graph_view.node_view.model.data_source.setv({ inspected: node_inspection }, { silent: true });\n            graph_view.node_view.model.data_source.inspect.emit([graph_view.node_view, { geometry }]);\n            return !node_inspection.is_empty();\n        }\n    }\n    exports.NodesOnly = NodesOnly;\n    NodesOnly.__name__ = \"NodesOnly\";\n    class NodesAndLinkedEdges extends GraphHitTestPolicy {\n        constructor(attrs) {\n            super(attrs);\n        }\n        hit_test(geometry, graph_view) {\n            return this._hit_test_nodes(geometry, graph_view);\n        }\n        get_linked_edges(node_source, edge_source, mode) {\n            let node_indices = [];\n            if (mode == 'selection') {\n                node_indices = node_source.selected.indices.map((i) => node_source.data.index[i]);\n            }\n            else if (mode == 'inspection') {\n                node_indices = node_source.inspected.indices.map((i) => node_source.data.index[i]);\n            }\n            const edge_indices = [];\n            for (let i = 0; i < edge_source.data.start.length; i++) {\n                if (array_1.contains(node_indices, edge_source.data.start[i]) || array_1.contains(node_indices, edge_source.data.end[i]))\n                    edge_indices.push(i);\n            }\n            const linked_edges = hittest_1.create_empty_hit_test_result();\n            for (const i of edge_indices) {\n                linked_edges.multiline_indices[i] = [0]; //currently only supports 2-element multilines, so this is all of it\n            }\n            linked_edges.indices = edge_indices;\n            return linked_edges;\n        }\n        do_selection(hit_test_result, graph, final, append) {\n            if (hit_test_result == null)\n                return false;\n            const node_selection = graph.node_renderer.data_source.selected;\n            node_selection.update(hit_test_result, final, append);\n            const edge_selection = graph.edge_renderer.data_source.selected;\n            const linked_edges_selection = this.get_linked_edges(graph.node_renderer.data_source, graph.edge_renderer.data_source, 'selection');\n            edge_selection.update(linked_edges_selection, final, append);\n            graph.node_renderer.data_source._select.emit();\n            return !node_selection.is_empty();\n        }\n        do_inspection(hit_test_result, geometry, graph_view, final, append) {\n            if (hit_test_result == null)\n                return false;\n            const node_inspection = graph_view.node_view.model.data_source.selection_manager.get_or_create_inspector(graph_view.node_view.model);\n            node_inspection.update(hit_test_result, final, append);\n            graph_view.node_view.model.data_source.setv({ inspected: node_inspection }, { silent: true });\n            const edge_inspection = graph_view.edge_view.model.data_source.selection_manager.get_or_create_inspector(graph_view.edge_view.model);\n            const linked_edges = this.get_linked_edges(graph_view.node_view.model.data_source, graph_view.edge_view.model.data_source, 'inspection');\n            edge_inspection.update(linked_edges, final, append);\n            //silently set inspected attr to avoid triggering data_source.change event and rerender\n            graph_view.edge_view.model.data_source.setv({ inspected: edge_inspection }, { silent: true });\n            graph_view.node_view.model.data_source.inspect.emit([graph_view.node_view, { geometry }]);\n            return !node_inspection.is_empty();\n        }\n    }\n    exports.NodesAndLinkedEdges = NodesAndLinkedEdges;\n    NodesAndLinkedEdges.__name__ = \"NodesAndLinkedEdges\";\n    class EdgesAndLinkedNodes extends GraphHitTestPolicy {\n        constructor(attrs) {\n            super(attrs);\n        }\n        hit_test(geometry, graph_view) {\n            return this._hit_test_edges(geometry, graph_view);\n        }\n        get_linked_nodes(node_source, edge_source, mode) {\n            let edge_indices = [];\n            if (mode == 'selection')\n                edge_indices = edge_source.selected.indices;\n            else if (mode == 'inspection')\n                edge_indices = edge_source.inspected.indices;\n            const nodes = [];\n            for (const i of edge_indices) {\n                nodes.push(edge_source.data.start[i]);\n                nodes.push(edge_source.data.end[i]);\n            }\n            const node_indices = array_1.uniq(nodes).map((i) => arrayable_1.indexOf(node_source.data.index, i));\n            const linked_nodes = hittest_1.create_empty_hit_test_result();\n            linked_nodes.indices = node_indices;\n            return linked_nodes;\n        }\n        do_selection(hit_test_result, graph, final, append) {\n            if (hit_test_result == null)\n                return false;\n            const edge_selection = graph.edge_renderer.data_source.selected;\n            edge_selection.update(hit_test_result, final, append);\n            const node_selection = graph.node_renderer.data_source.selected;\n            const linked_nodes = this.get_linked_nodes(graph.node_renderer.data_source, graph.edge_renderer.data_source, 'selection');\n            node_selection.update(linked_nodes, final, append);\n            graph.edge_renderer.data_source._select.emit();\n            return !edge_selection.is_empty();\n        }\n        do_inspection(hit_test_result, geometry, graph_view, final, append) {\n            if (hit_test_result == null)\n                return false;\n            const edge_inspection = graph_view.edge_view.model.data_source.selection_manager.get_or_create_inspector(graph_view.edge_view.model);\n            edge_inspection.update(hit_test_result, final, append);\n            graph_view.edge_view.model.data_source.setv({ inspected: edge_inspection }, { silent: true });\n            const node_inspection = graph_view.node_view.model.data_source.selection_manager.get_or_create_inspector(graph_view.node_view.model);\n            const linked_nodes = this.get_linked_nodes(graph_view.node_view.model.data_source, graph_view.edge_view.model.data_source, 'inspection');\n            node_inspection.update(linked_nodes, final, append);\n            // silently set inspected attr to avoid triggering data_source.change event and rerender\n            graph_view.node_view.model.data_source.setv({ inspected: node_inspection }, { silent: true });\n            graph_view.edge_view.model.data_source.inspect.emit([graph_view.edge_view, { geometry }]);\n            return !edge_inspection.is_empty();\n        }\n    }\n    exports.EdgesAndLinkedNodes = EdgesAndLinkedNodes;\n    EdgesAndLinkedNodes.__name__ = \"EdgesAndLinkedNodes\";\n}\n","/* core/build_views.js */ function _(require, module, exports) {\n    const array_1 = require(8) /* ./util/array */;\n    function build_views(view_storage, models, options, cls = (model) => model.default_view) {\n        const to_remove = array_1.difference(Object.keys(view_storage), models.map((model) => model.id));\n        for (const model_id of to_remove) {\n            view_storage[model_id].remove();\n            delete view_storage[model_id];\n        }\n        const created_views = [];\n        const new_models = models.filter((model) => view_storage[model.id] == null);\n        for (const model of new_models) {\n            const view_cls = cls(model);\n            const view_options = Object.assign(Object.assign({}, options), { model, connect_signals: false });\n            const view = new view_cls(view_options);\n            view_storage[model.id] = view;\n            created_views.push(view);\n        }\n        for (const view of created_views)\n            view.connect_signals();\n        return created_views;\n    }\n    exports.build_views = build_views;\n    function remove_views(view_storage) {\n        for (const id in view_storage) {\n            view_storage[id].remove();\n            delete view_storage[id];\n        }\n    }\n    exports.remove_views = remove_views;\n}\n","/* models/selections/interaction_policy.js */ function _(require, module, exports) {\n    const model_1 = require(64) /* ../../model */;\n    class SelectionPolicy extends model_1.Model {\n        do_selection(hit_test_result, source, final, append) {\n            if (hit_test_result === null) {\n                return false;\n            }\n            else {\n                source.selected.update(hit_test_result, final, append);\n                source._select.emit();\n                return !source.selected.is_empty();\n            }\n        }\n    }\n    exports.SelectionPolicy = SelectionPolicy;\n    SelectionPolicy.__name__ = \"SelectionPolicy\";\n    class IntersectRenderers extends SelectionPolicy {\n        hit_test(geometry, renderer_views) {\n            const hit_test_result_renderers = [];\n            for (const r of renderer_views) {\n                const result = r.hit_test(geometry);\n                if (result !== null)\n                    hit_test_result_renderers.push(result);\n            }\n            if (hit_test_result_renderers.length > 0) {\n                const hit_test_result = hit_test_result_renderers[0];\n                for (const hit_test_result_other of hit_test_result_renderers) {\n                    hit_test_result.update_through_intersection(hit_test_result_other);\n                }\n                return hit_test_result;\n            }\n            else {\n                return null;\n            }\n        }\n    }\n    exports.IntersectRenderers = IntersectRenderers;\n    IntersectRenderers.__name__ = \"IntersectRenderers\";\n    class UnionRenderers extends SelectionPolicy {\n        hit_test(geometry, renderer_views) {\n            const hit_test_result_renderers = [];\n            for (const r of renderer_views) {\n                const result = r.hit_test(geometry);\n                if (result !== null)\n                    hit_test_result_renderers.push(result);\n            }\n            if (hit_test_result_renderers.length > 0) {\n                const hit_test_result = hit_test_result_renderers[0];\n                for (const hit_test_result_other of hit_test_result_renderers) {\n                    hit_test_result.update_through_union(hit_test_result_other);\n                }\n                return hit_test_result;\n            }\n            else {\n                return null;\n            }\n        }\n    }\n    exports.UnionRenderers = UnionRenderers;\n    UnionRenderers.__name__ = \"UnionRenderers\";\n}\n","/* core/util/serialization.js */ function _(require, module, exports) {\n    const types_1 = require(7) /* ./types */;\n    const compat_1 = require(95) /* ./compat */;\n    exports.ARRAY_TYPES = {\n        uint8: Uint8Array,\n        int8: Int8Array,\n        uint16: Uint16Array,\n        int16: Int16Array,\n        uint32: Uint32Array,\n        int32: Int32Array,\n        float32: Float32Array,\n        float64: Float64Array,\n    };\n    exports.DTYPES = {\n        Uint8Array: \"uint8\",\n        Int8Array: \"int8\",\n        Uint16Array: \"uint16\",\n        Int16Array: \"int16\",\n        Uint32Array: \"uint32\",\n        Int32Array: \"int32\",\n        Float32Array: \"float32\",\n        Float64Array: \"float64\",\n    };\n    function arrayName(array) {\n        if (\"name\" in array.constructor)\n            return array.constructor.name;\n        else {\n            switch (true) {\n                case array instanceof Uint8Array: return \"Uint8Array\";\n                case array instanceof Int8Array: return \"Int8Array\";\n                case array instanceof Uint16Array: return \"Uint16Array\";\n                case array instanceof Int16Array: return \"Int16Array\";\n                case array instanceof Uint32Array: return \"Uint32Array\";\n                case array instanceof Int32Array: return \"Int32Array\";\n                case array instanceof Float32Array: return \"Float32Array\";\n                case array instanceof Float64Array: return \"Float64Array\";\n                default:\n                    throw new Error(\"unsupported typed array\");\n            }\n        }\n    }\n    exports.BYTE_ORDER = compat_1.is_little_endian ? \"little\" : \"big\";\n    function swap16(a) {\n        const x = new Uint8Array(a.buffer, a.byteOffset, a.length * 2);\n        for (let i = 0, end = x.length; i < end; i += 2) {\n            const t = x[i];\n            x[i] = x[i + 1];\n            x[i + 1] = t;\n        }\n    }\n    exports.swap16 = swap16;\n    function swap32(a) {\n        const x = new Uint8Array(a.buffer, a.byteOffset, a.length * 4);\n        for (let i = 0, end = x.length; i < end; i += 4) {\n            let t = x[i];\n            x[i] = x[i + 3];\n            x[i + 3] = t;\n            t = x[i + 1];\n            x[i + 1] = x[i + 2];\n            x[i + 2] = t;\n        }\n    }\n    exports.swap32 = swap32;\n    function swap64(a) {\n        const x = new Uint8Array(a.buffer, a.byteOffset, a.length * 8);\n        for (let i = 0, end = x.length; i < end; i += 8) {\n            let t = x[i];\n            x[i] = x[i + 7];\n            x[i + 7] = t;\n            t = x[i + 1];\n            x[i + 1] = x[i + 6];\n            x[i + 6] = t;\n            t = x[i + 2];\n            x[i + 2] = x[i + 5];\n            x[i + 5] = t;\n            t = x[i + 3];\n            x[i + 3] = x[i + 4];\n            x[i + 4] = t;\n        }\n    }\n    exports.swap64 = swap64;\n    function process_buffer(specification, buffers) {\n        const need_swap = specification.order !== exports.BYTE_ORDER;\n        const { shape } = specification;\n        let bytes = null;\n        for (const buf of buffers) {\n            const header = JSON.parse(buf[0]);\n            if (header.id === specification.__buffer__) {\n                bytes = buf[1];\n                break;\n            }\n        }\n        const arr = new (exports.ARRAY_TYPES[specification.dtype])(bytes);\n        if (need_swap) {\n            if (arr.BYTES_PER_ELEMENT === 2) {\n                swap16(arr);\n            }\n            else if (arr.BYTES_PER_ELEMENT === 4) {\n                swap32(arr);\n            }\n            else if (arr.BYTES_PER_ELEMENT === 8) {\n                swap64(arr);\n            }\n        }\n        return [arr, shape];\n    }\n    exports.process_buffer = process_buffer;\n    function process_array(obj, buffers) {\n        if (types_1.isObject(obj) && '__ndarray__' in obj)\n            return decode_base64(obj);\n        else if (types_1.isObject(obj) && '__buffer__' in obj)\n            return process_buffer(obj, buffers);\n        else if (types_1.isArray(obj) || types_1.isTypedArray(obj))\n            return [obj, []];\n        else\n            return undefined;\n    }\n    exports.process_array = process_array;\n    function arrayBufferToBase64(buffer) {\n        const bytes = new Uint8Array(buffer);\n        const chars = Array.from(bytes).map((b) => String.fromCharCode(b));\n        return btoa(chars.join(\"\"));\n    }\n    exports.arrayBufferToBase64 = arrayBufferToBase64;\n    function base64ToArrayBuffer(base64) {\n        const binary_string = atob(base64);\n        const len = binary_string.length;\n        const bytes = new Uint8Array(len);\n        for (let i = 0, end = len; i < end; i++) {\n            bytes[i] = binary_string.charCodeAt(i);\n        }\n        return bytes.buffer;\n    }\n    exports.base64ToArrayBuffer = base64ToArrayBuffer;\n    function decode_base64(input) {\n        const bytes = base64ToArrayBuffer(input.__ndarray__);\n        const dtype = input.dtype;\n        const shape = input.shape;\n        let array;\n        if (dtype in exports.ARRAY_TYPES)\n            array = new (exports.ARRAY_TYPES[dtype])(bytes);\n        else\n            throw new Error(`unknown dtype: ${dtype}`);\n        return [array, shape];\n    }\n    exports.decode_base64 = decode_base64;\n    function encode_base64(array, shape) {\n        const b64 = arrayBufferToBase64(array.buffer);\n        const name = arrayName(array);\n        let dtype;\n        if (name in exports.DTYPES)\n            dtype = exports.DTYPES[name];\n        else\n            throw new Error(`unknown array type: ${name}`);\n        const data = {\n            __ndarray__: b64,\n            shape,\n            dtype,\n        };\n        return data;\n    }\n    exports.encode_base64 = encode_base64;\n    function decode_traverse_data(v, buffers) {\n        // v is just a regular array of scalars\n        if (v.length == 0 || !(types_1.isObject(v[0]) || types_1.isArray(v[0]))) {\n            return [v, []];\n        }\n        const arrays = [];\n        const shapes = [];\n        for (const obj of v) {\n            const [arr, shape] = types_1.isArray(obj) ? decode_traverse_data(obj, buffers)\n                : process_array(obj, buffers);\n            arrays.push(arr);\n            shapes.push(shape);\n        }\n        // If there is a list of empty lists, reduce that to just a list\n        const filtered_shapes = shapes.map((shape) => shape.filter((v) => v.length != 0));\n        return [arrays, filtered_shapes];\n    }\n    function decode_column_data(data, buffers = []) {\n        const new_data = {};\n        const new_shapes = {};\n        for (const k in data) {\n            // might be array of scalars, or might be ragged array or arrays\n            const v = data[k];\n            if (types_1.isArray(v)) {\n                // v is just a regular array of scalars\n                if (v.length == 0 || !(types_1.isObject(v[0]) || types_1.isArray(v[0]))) {\n                    new_data[k] = v;\n                    continue;\n                }\n                // v is a ragged array of arrays\n                const [arrays, shapes] = decode_traverse_data(v, buffers);\n                new_data[k] = arrays;\n                new_shapes[k] = shapes;\n                // must be object or array (single array case)\n            }\n            else {\n                const [arr, shape] = process_array(v, buffers);\n                new_data[k] = arr;\n                new_shapes[k] = shape;\n            }\n        }\n        return [new_data, new_shapes];\n    }\n    exports.decode_column_data = decode_column_data;\n    function encode_traverse_data(v, shapes) {\n        const new_array = [];\n        for (let i = 0, end = v.length; i < end; i++) {\n            const item = v[i];\n            if (types_1.isTypedArray(item)) {\n                const shape = shapes[i] ? shapes[i] : undefined;\n                new_array.push(encode_base64(item, shape));\n            }\n            else if (types_1.isArray(item)) {\n                new_array.push(encode_traverse_data(item, shapes ? shapes[i] : []));\n            }\n            else\n                new_array.push(item);\n        }\n        return new_array;\n    }\n    function encode_column_data(data, shapes) {\n        const new_data = {};\n        for (const k in data) {\n            const v = data[k];\n            const shapes_k = shapes != null ? shapes[k] : undefined;\n            let new_v;\n            if (types_1.isTypedArray(v)) {\n                new_v = encode_base64(v, shapes_k);\n            }\n            else if (types_1.isArray(v)) {\n                new_v = encode_traverse_data(v, shapes_k || []);\n            }\n            else\n                new_v = v;\n            new_data[k] = new_v;\n        }\n        return new_data;\n    }\n    exports.encode_column_data = encode_column_data;\n}\n","/* core/util/compat.js */ function _(require, module, exports) {\n    exports.is_ie = (() => {\n        const ua = typeof navigator !== \"undefined\" ? navigator.userAgent : \"\";\n        return ua.indexOf('MSIE') >= 0 || ua.indexOf('Trident') > 0 || ua.indexOf('Edge') > 0;\n    })();\n    exports.is_mobile = (() => {\n        return typeof window !== \"undefined\" && (\"ontouchstart\" in window || navigator.maxTouchPoints > 0);\n    })();\n    exports.is_little_endian = (() => {\n        const buf = new ArrayBuffer(4);\n        const buf8 = new Uint8Array(buf);\n        const buf32 = new Uint32Array(buf);\n        buf32[1] = 0x0a0b0c0d;\n        let little_endian = true;\n        if (buf8[4] == 0x0a && buf8[5] == 0x0b && buf8[6] == 0x0c && buf8[7] == 0x0d) {\n            little_endian = false;\n        }\n        return little_endian;\n    })();\n}\n","/* core/util/typed_array.js */ function _(require, module, exports) {\n    function concat(array0, ...arrays) {\n        let n = array0.length;\n        for (const array of arrays)\n            n += array.length;\n        const result = new array0.constructor(n);\n        result.set(array0, 0);\n        let i = array0.length;\n        for (const array of arrays) {\n            result.set(array, i);\n            i += array.length;\n        }\n        return result;\n    }\n    exports.concat = concat;\n}\n","/* document/events.js */ function _(require, module, exports) {\n    const has_props_1 = require(12) /* ../core/has_props */;\n    class DocumentChangedEvent {\n        constructor(document) {\n            this.document = document;\n        }\n    }\n    exports.DocumentChangedEvent = DocumentChangedEvent;\n    DocumentChangedEvent.__name__ = \"DocumentChangedEvent\";\n    class ModelChangedEvent extends DocumentChangedEvent {\n        constructor(document, model, attr, old, new_, setter_id, hint) {\n            super(document);\n            this.model = model;\n            this.attr = attr;\n            this.old = old;\n            this.new_ = new_;\n            this.setter_id = setter_id;\n            this.hint = hint;\n        }\n        json(references) {\n            if (this.attr === \"id\") {\n                throw new Error(\"'id' field should never change, whatever code just set it is wrong\");\n            }\n            if (this.hint != null)\n                return this.hint.json(references);\n            const value = this.new_;\n            const value_json = has_props_1.HasProps._value_to_json(this.attr, value, this.model);\n            const value_refs = {};\n            has_props_1.HasProps._value_record_references(value, value_refs, true); // true = recurse\n            if (this.model.id in value_refs && this.model !== value) {\n                // we know we don't want a whole new copy of the obj we're\n                // patching unless it's also the value itself\n                delete value_refs[this.model.id];\n            }\n            for (const id in value_refs) {\n                references[id] = value_refs[id];\n            }\n            return {\n                kind: \"ModelChanged\",\n                model: this.model.ref(),\n                attr: this.attr,\n                new: value_json,\n            };\n        }\n    }\n    exports.ModelChangedEvent = ModelChangedEvent;\n    ModelChangedEvent.__name__ = \"ModelChangedEvent\";\n    class ColumnsPatchedEvent extends DocumentChangedEvent {\n        constructor(document, column_source, patches) {\n            super(document);\n            this.column_source = column_source;\n            this.patches = patches;\n        }\n        json(_references) {\n            return {\n                kind: \"ColumnsPatched\",\n                column_source: this.column_source,\n                patches: this.patches,\n            };\n        }\n    }\n    exports.ColumnsPatchedEvent = ColumnsPatchedEvent;\n    ColumnsPatchedEvent.__name__ = \"ColumnsPatchedEvent\";\n    class ColumnsStreamedEvent extends DocumentChangedEvent {\n        constructor(document, column_source, data, rollover) {\n            super(document);\n            this.column_source = column_source;\n            this.data = data;\n            this.rollover = rollover;\n        }\n        json(_references) {\n            return {\n                kind: \"ColumnsStreamed\",\n                column_source: this.column_source,\n                data: this.data,\n                rollover: this.rollover,\n            };\n        }\n    }\n    exports.ColumnsStreamedEvent = ColumnsStreamedEvent;\n    ColumnsStreamedEvent.__name__ = \"ColumnsStreamedEvent\";\n    class TitleChangedEvent extends DocumentChangedEvent {\n        constructor(document, title, setter_id) {\n            super(document);\n            this.title = title;\n            this.setter_id = setter_id;\n        }\n        json(_references) {\n            return {\n                kind: \"TitleChanged\",\n                title: this.title,\n            };\n        }\n    }\n    exports.TitleChangedEvent = TitleChangedEvent;\n    TitleChangedEvent.__name__ = \"TitleChangedEvent\";\n    class RootAddedEvent extends DocumentChangedEvent {\n        constructor(document, model, setter_id) {\n            super(document);\n            this.model = model;\n            this.setter_id = setter_id;\n        }\n        json(references) {\n            has_props_1.HasProps._value_record_references(this.model, references, true);\n            return {\n                kind: \"RootAdded\",\n                model: this.model.ref(),\n            };\n        }\n    }\n    exports.RootAddedEvent = RootAddedEvent;\n    RootAddedEvent.__name__ = \"RootAddedEvent\";\n    class RootRemovedEvent extends DocumentChangedEvent {\n        constructor(document, model, setter_id) {\n            super(document);\n            this.model = model;\n            this.setter_id = setter_id;\n        }\n        json(_references) {\n            return {\n                kind: \"RootRemoved\",\n                model: this.model.ref(),\n            };\n        }\n    }\n    exports.RootRemovedEvent = RootRemovedEvent;\n    RootRemovedEvent.__name__ = \"RootRemovedEvent\";\n}\n","/* models/annotations/band.js */ function _(require, module, exports) {\n    const annotation_1 = require(29) /* ./annotation */;\n    const column_data_source_1 = require(68) /* ../sources/column_data_source */;\n    const p = require(18) /* ../../core/properties */;\n    class BandView extends annotation_1.AnnotationView {\n        initialize() {\n            super.initialize();\n            this.set_data(this.model.source);\n        }\n        connect_signals() {\n            super.connect_signals();\n            this.connect(this.model.source.streaming, () => this.set_data(this.model.source));\n            this.connect(this.model.source.patching, () => this.set_data(this.model.source));\n            this.connect(this.model.source.change, () => this.set_data(this.model.source));\n        }\n        set_data(source) {\n            super.set_data(source);\n            this.visuals.warm_cache(source);\n            this.plot_view.request_render();\n        }\n        _map_data() {\n            const { frame } = this.plot_view;\n            const dim = this.model.dimension;\n            const xscale = frame.xscales[this.model.x_range_name];\n            const yscale = frame.yscales[this.model.y_range_name];\n            const limit_scale = dim == \"height\" ? yscale : xscale;\n            const base_scale = dim == \"height\" ? xscale : yscale;\n            const limit_view = dim == \"height\" ? frame.yview : frame.xview;\n            const base_view = dim == \"height\" ? frame.xview : frame.yview;\n            let _lower_sx;\n            if (this.model.properties.lower.units == \"data\")\n                _lower_sx = limit_scale.v_compute(this._lower);\n            else\n                _lower_sx = limit_view.v_compute(this._lower);\n            let _upper_sx;\n            if (this.model.properties.upper.units == \"data\")\n                _upper_sx = limit_scale.v_compute(this._upper);\n            else\n                _upper_sx = limit_view.v_compute(this._upper);\n            let _base_sx;\n            if (this.model.properties.base.units == \"data\")\n                _base_sx = base_scale.v_compute(this._base);\n            else\n                _base_sx = base_view.v_compute(this._base);\n            const [i, j] = dim == 'height' ? [1, 0] : [0, 1];\n            const _lower = [_lower_sx, _base_sx];\n            const _upper = [_upper_sx, _base_sx];\n            this._lower_sx = _lower[i];\n            this._lower_sy = _lower[j];\n            this._upper_sx = _upper[i];\n            this._upper_sy = _upper[j];\n        }\n        render() {\n            if (!this.model.visible)\n                return;\n            this._map_data();\n            const { ctx } = this.plot_view.canvas_view;\n            // Draw the band body\n            ctx.beginPath();\n            ctx.moveTo(this._lower_sx[0], this._lower_sy[0]);\n            for (let i = 0, end = this._lower_sx.length; i < end; i++) {\n                ctx.lineTo(this._lower_sx[i], this._lower_sy[i]);\n            }\n            // iterate backwards so that the upper end is below the lower start\n            for (let start = this._upper_sx.length - 1, i = start; i >= 0; i--) {\n                ctx.lineTo(this._upper_sx[i], this._upper_sy[i]);\n            }\n            ctx.closePath();\n            if (this.visuals.fill.doit) {\n                this.visuals.fill.set_value(ctx);\n                ctx.fill();\n            }\n            // Draw the lower band edge\n            ctx.beginPath();\n            ctx.moveTo(this._lower_sx[0], this._lower_sy[0]);\n            for (let i = 0, end = this._lower_sx.length; i < end; i++) {\n                ctx.lineTo(this._lower_sx[i], this._lower_sy[i]);\n            }\n            if (this.visuals.line.doit) {\n                this.visuals.line.set_value(ctx);\n                ctx.stroke();\n            }\n            // Draw the upper band edge\n            ctx.beginPath();\n            ctx.moveTo(this._upper_sx[0], this._upper_sy[0]);\n            for (let i = 0, end = this._upper_sx.length; i < end; i++) {\n                ctx.lineTo(this._upper_sx[i], this._upper_sy[i]);\n            }\n            if (this.visuals.line.doit) {\n                this.visuals.line.set_value(ctx);\n                ctx.stroke();\n            }\n        }\n    }\n    exports.BandView = BandView;\n    BandView.__name__ = \"BandView\";\n    class Band extends annotation_1.Annotation {\n        constructor(attrs) {\n            super(attrs);\n        }\n        static init_Band() {\n            this.prototype.default_view = BandView;\n            this.mixins(['line', 'fill']);\n            this.define({\n                lower: [p.DistanceSpec],\n                upper: [p.DistanceSpec],\n                base: [p.DistanceSpec],\n                dimension: [p.Dimension, 'height'],\n                source: [p.Instance, () => new column_data_source_1.ColumnDataSource()],\n                x_range_name: [p.String, 'default'],\n                y_range_name: [p.String, 'default'],\n            });\n            this.override({\n                fill_color: \"#fff9ba\",\n                fill_alpha: 0.4,\n                line_color: \"#cccccc\",\n                line_alpha: 0.3,\n            });\n        }\n    }\n    exports.Band = Band;\n    Band.__name__ = \"Band\";\n    Band.init_Band();\n}\n","/* models/annotations/box_annotation.js */ function _(require, module, exports) {\n    const annotation_1 = require(29) /* ./annotation */;\n    const signaling_1 = require(13) /* ../../core/signaling */;\n    const dom_1 = require(61) /* ../../core/dom */;\n    const p = require(18) /* ../../core/properties */;\n    const bbox_1 = require(79) /* ../../core/util/bbox */;\n    const annotations_1 = require(100) /* ../../styles/annotations */;\n    exports.EDGE_TOLERANCE = 2.5;\n    class BoxAnnotationView extends annotation_1.AnnotationView {\n        initialize() {\n            super.initialize();\n            this.plot_view.canvas_overlays.appendChild(this.el);\n            this.el.classList.add(annotations_1.bk_shading);\n            dom_1.undisplay(this.el);\n        }\n        connect_signals() {\n            super.connect_signals();\n            // need to respond to either normal BB change events or silent\n            // \"data only updates\" that tools might want to use\n            if (this.model.render_mode == 'css') {\n                // dispatch CSS update immediately\n                this.connect(this.model.change, () => this.render());\n                this.connect(this.model.data_update, () => this.render());\n            }\n            else {\n                this.connect(this.model.change, () => this.plot_view.request_render());\n                this.connect(this.model.data_update, () => this.plot_view.request_render());\n            }\n        }\n        render() {\n            if (!this.model.visible && this.model.render_mode == 'css')\n                dom_1.undisplay(this.el);\n            if (!this.model.visible)\n                return;\n            // don't render if *all* position are null\n            if (this.model.left == null && this.model.right == null && this.model.top == null && this.model.bottom == null) {\n                dom_1.undisplay(this.el);\n                return;\n            }\n            const { frame } = this.plot_view;\n            const xscale = frame.xscales[this.model.x_range_name];\n            const yscale = frame.yscales[this.model.y_range_name];\n            const _calc_dim = (dim, dim_units, scale, view, frame_extrema) => {\n                let sdim;\n                if (dim != null) {\n                    if (this.model.screen)\n                        sdim = dim;\n                    else {\n                        if (dim_units == 'data')\n                            sdim = scale.compute(dim);\n                        else\n                            sdim = view.compute(dim);\n                    }\n                }\n                else\n                    sdim = frame_extrema;\n                return sdim;\n            };\n            this.sleft = _calc_dim(this.model.left, this.model.left_units, xscale, frame.xview, frame._left.value);\n            this.sright = _calc_dim(this.model.right, this.model.right_units, xscale, frame.xview, frame._right.value);\n            this.stop = _calc_dim(this.model.top, this.model.top_units, yscale, frame.yview, frame._top.value);\n            this.sbottom = _calc_dim(this.model.bottom, this.model.bottom_units, yscale, frame.yview, frame._bottom.value);\n            const draw = this.model.render_mode == 'css' ? this._css_box.bind(this) : this._canvas_box.bind(this);\n            draw(this.sleft, this.sright, this.sbottom, this.stop);\n        }\n        _css_box(sleft, sright, sbottom, stop) {\n            const line_width = this.model.properties.line_width.value();\n            const sw = Math.floor(sright - sleft) - line_width;\n            const sh = Math.floor(sbottom - stop) - line_width;\n            this.el.style.left = `${sleft}px`;\n            this.el.style.width = `${sw}px`;\n            this.el.style.top = `${stop}px`;\n            this.el.style.height = `${sh}px`;\n            this.el.style.borderWidth = `${line_width}px`;\n            this.el.style.borderColor = this.model.properties.line_color.value();\n            this.el.style.backgroundColor = this.model.properties.fill_color.value();\n            this.el.style.opacity = this.model.properties.fill_alpha.value();\n            // try our best to honor line dashing in some way, if we can\n            const ld = this.model.properties.line_dash.value().length < 2 ? \"solid\" : \"dashed\";\n            this.el.style.borderStyle = ld;\n            dom_1.display(this.el);\n        }\n        _canvas_box(sleft, sright, sbottom, stop) {\n            const { ctx } = this.plot_view.canvas_view;\n            ctx.save();\n            ctx.beginPath();\n            ctx.rect(sleft, stop, sright - sleft, sbottom - stop);\n            this.visuals.fill.set_value(ctx);\n            ctx.fill();\n            this.visuals.line.set_value(ctx);\n            ctx.stroke();\n            ctx.restore();\n        }\n        interactive_bbox() {\n            const tol = this.model.properties.line_width.value() + exports.EDGE_TOLERANCE;\n            return new bbox_1.BBox({\n                x0: this.sleft - tol,\n                y0: this.stop - tol,\n                x1: this.sright + tol,\n                y1: this.sbottom + tol,\n            });\n        }\n        interactive_hit(sx, sy) {\n            if (this.model.in_cursor == null)\n                return false;\n            const bbox = this.interactive_bbox();\n            return bbox.contains(sx, sy);\n        }\n        cursor(sx, sy) {\n            const tol = 3;\n            if (Math.abs(sx - this.sleft) < tol || Math.abs(sx - this.sright) < tol)\n                return this.model.ew_cursor;\n            else if (Math.abs(sy - this.sbottom) < tol || Math.abs(sy - this.stop) < tol)\n                return this.model.ns_cursor;\n            else if (sx > this.sleft && sx < this.sright && sy > this.stop && sy < this.sbottom)\n                return this.model.in_cursor;\n            else\n                return null;\n        }\n    }\n    exports.BoxAnnotationView = BoxAnnotationView;\n    BoxAnnotationView.__name__ = \"BoxAnnotationView\";\n    class BoxAnnotation extends annotation_1.Annotation {\n        constructor(attrs) {\n            super(attrs);\n        }\n        static init_BoxAnnotation() {\n            this.prototype.default_view = BoxAnnotationView;\n            this.mixins(['line', 'fill']);\n            this.define({\n                render_mode: [p.RenderMode, 'canvas'],\n                x_range_name: [p.String, 'default'],\n                y_range_name: [p.String, 'default'],\n                top: [p.Number, null],\n                top_units: [p.SpatialUnits, 'data'],\n                bottom: [p.Number, null],\n                bottom_units: [p.SpatialUnits, 'data'],\n                left: [p.Number, null],\n                left_units: [p.SpatialUnits, 'data'],\n                right: [p.Number, null],\n                right_units: [p.SpatialUnits, 'data'],\n            });\n            this.internal({\n                screen: [p.Boolean, false],\n                ew_cursor: [p.String, null],\n                ns_cursor: [p.String, null],\n                in_cursor: [p.String, null],\n            });\n            this.override({\n                fill_color: '#fff9ba',\n                fill_alpha: 0.4,\n                line_color: '#cccccc',\n                line_alpha: 0.3,\n            });\n        }\n        initialize() {\n            super.initialize();\n            this.data_update = new signaling_1.Signal0(this, \"data_update\");\n        }\n        update({ left, right, top, bottom }) {\n            this.setv({ left, right, top, bottom, screen: true }, { silent: true });\n            this.data_update.emit();\n        }\n    }\n    exports.BoxAnnotation = BoxAnnotation;\n    BoxAnnotation.__name__ = \"BoxAnnotation\";\n    BoxAnnotation.init_BoxAnnotation();\n}\n","/* styles/annotations.js */ function _(require, module, exports) {\n    require(62) /* ./root */;\n    const _a = require(61) /* ../core/dom */;\n    _a.styles.append(\".bk-root .bk-shading {\\n  position: absolute;\\n  display: block;\\n  border: 1px dashed green;\\n}\\n\");\n    exports.bk_annotation = \"bk-annotation\";\n    exports.bk_shading = \"bk-shading\";\n    exports.bk_annotation_child = \"bk-annotation-child\";\n}\n","/* models/annotations/color_bar.js */ function _(require, module, exports) {\n    const annotation_1 = require(29) /* ./annotation */;\n    const basic_ticker_1 = require(102) /* ../tickers/basic_ticker */;\n    const basic_tick_formatter_1 = require(106) /* ../formatters/basic_tick_formatter */;\n    const linear_color_mapper_1 = require(108) /* ../mappers/linear_color_mapper */;\n    const linear_scale_1 = require(113) /* ../scales/linear_scale */;\n    const log_scale_1 = require(122) /* ../scales/log_scale */;\n    const range1d_1 = require(123) /* ../ranges/range1d */;\n    const p = require(18) /* ../../core/properties */;\n    const text_util = require(124) /* ../../core/util/text */;\n    const array_1 = require(8) /* ../../core/util/array */;\n    const arrayable_1 = require(11) /* ../../core/util/arrayable */;\n    const object_1 = require(22) /* ../../core/util/object */;\n    const types_1 = require(7) /* ../../core/util/types */;\n    const SHORT_DIM = 25;\n    const LONG_DIM_MIN_SCALAR = 0.3;\n    const LONG_DIM_MAX_SCALAR = 0.8;\n    class ColorBarView extends annotation_1.AnnotationView {\n        initialize() {\n            super.initialize();\n            this._set_canvas_image();\n        }\n        connect_signals() {\n            super.connect_signals();\n            this.connect(this.model.properties.visible.change, () => this.plot_view.request_render());\n            this.connect(this.model.ticker.change, () => this.plot_view.request_render());\n            this.connect(this.model.formatter.change, () => this.plot_view.request_render());\n            if (this.model.color_mapper != null) {\n                this.connect(this.model.color_mapper.change, () => {\n                    this._set_canvas_image();\n                    this.plot_view.request_render();\n                });\n            }\n        }\n        _get_size() {\n            if (this.model.color_mapper == null)\n                return { width: 0, height: 0 };\n            else {\n                const { width, height } = this.compute_legend_dimensions();\n                return { width, height };\n            }\n        }\n        _set_canvas_image() {\n            if (this.model.color_mapper == null)\n                return;\n            let { palette } = this.model.color_mapper;\n            if (this.model.orientation == 'vertical')\n                palette = array_1.reversed(palette);\n            let w, h;\n            switch (this.model.orientation) {\n                case \"vertical\": {\n                    [w, h] = [1, palette.length];\n                    break;\n                }\n                case \"horizontal\": {\n                    [w, h] = [palette.length, 1];\n                    break;\n                }\n                default:\n                    throw new Error(\"unreachable code\");\n            }\n            const canvas = document.createElement('canvas');\n            canvas.width = w;\n            canvas.height = h;\n            const image_ctx = canvas.getContext('2d');\n            const image_data = image_ctx.getImageData(0, 0, w, h);\n            // We always want to draw the entire palette linearly, so we create a new\n            // LinearColorMapper instance and map a monotonic range of values with\n            // length = palette.length to get each palette color in order.\n            const cmap = new linear_color_mapper_1.LinearColorMapper({ palette }).rgba_mapper;\n            const buf8 = cmap.v_compute(array_1.range(0, palette.length));\n            image_data.data.set(buf8);\n            image_ctx.putImageData(image_data, 0, 0);\n            this.image = canvas;\n        }\n        compute_legend_dimensions() {\n            const image_dimensions = this._computed_image_dimensions();\n            const [image_height, image_width] = [image_dimensions.height, image_dimensions.width];\n            const label_extent = this._get_label_extent();\n            const title_extent = this._title_extent();\n            const tick_extent = this._tick_extent();\n            const { padding } = this.model;\n            let legend_height, legend_width;\n            switch (this.model.orientation) {\n                case \"vertical\":\n                    legend_height = image_height + title_extent + 2 * padding;\n                    legend_width = image_width + tick_extent + label_extent + 2 * padding;\n                    break;\n                case \"horizontal\":\n                    legend_height = image_height + title_extent + tick_extent + label_extent + 2 * padding;\n                    legend_width = image_width + 2 * padding;\n                    break;\n                default:\n                    throw new Error(\"unreachable code\");\n            }\n            return { width: legend_width, height: legend_height };\n        }\n        compute_legend_location() {\n            const legend_dimensions = this.compute_legend_dimensions();\n            const [legend_height, legend_width] = [legend_dimensions.height, legend_dimensions.width];\n            const legend_margin = this.model.margin;\n            const panel = this.panel != null ? this.panel : this.plot_view.frame;\n            const [hr, vr] = panel.bbox.ranges;\n            const { location } = this.model;\n            let sx, sy;\n            if (types_1.isString(location)) {\n                switch (location) {\n                    case 'top_left':\n                        sx = hr.start + legend_margin;\n                        sy = vr.start + legend_margin;\n                        break;\n                    case 'top_center':\n                        sx = (hr.end + hr.start) / 2 - legend_width / 2;\n                        sy = vr.start + legend_margin;\n                        break;\n                    case 'top_right':\n                        sx = hr.end - legend_margin - legend_width;\n                        sy = vr.start + legend_margin;\n                        break;\n                    case 'bottom_right':\n                        sx = hr.end - legend_margin - legend_width;\n                        sy = vr.end - legend_margin - legend_height;\n                        break;\n                    case 'bottom_center':\n                        sx = (hr.end + hr.start) / 2 - legend_width / 2;\n                        sy = vr.end - legend_margin - legend_height;\n                        break;\n                    case 'bottom_left':\n                        sx = hr.start + legend_margin;\n                        sy = vr.end - legend_margin - legend_height;\n                        break;\n                    case 'center_left':\n                        sx = hr.start + legend_margin;\n                        sy = (vr.end + vr.start) / 2 - legend_height / 2;\n                        break;\n                    case 'center':\n                        sx = (hr.end + hr.start) / 2 - legend_width / 2;\n                        sy = (vr.end + vr.start) / 2 - legend_height / 2;\n                        break;\n                    case 'center_right':\n                        sx = hr.end - legend_margin - legend_width;\n                        sy = (vr.end + vr.start) / 2 - legend_height / 2;\n                        break;\n                    default:\n                        throw new Error(\"unreachable code\");\n                }\n            }\n            else if (types_1.isArray(location) && location.length == 2) {\n                const [vx, vy] = location;\n                sx = panel.xview.compute(vx);\n                sy = panel.yview.compute(vy) - legend_height;\n            }\n            else\n                throw new Error(\"unreachable code\");\n            return { sx, sy };\n        }\n        render() {\n            if (!this.model.visible || this.model.color_mapper == null)\n                return;\n            const { ctx } = this.plot_view.canvas_view;\n            ctx.save();\n            const { sx, sy } = this.compute_legend_location();\n            ctx.translate(sx, sy);\n            this._draw_bbox(ctx);\n            const image_offset = this._get_image_offset();\n            ctx.translate(image_offset.x, image_offset.y);\n            this._draw_image(ctx);\n            if (this.model.color_mapper.low != null && this.model.color_mapper.high != null) {\n                const tick_info = this.tick_info();\n                this._draw_major_ticks(ctx, tick_info);\n                this._draw_minor_ticks(ctx, tick_info);\n                this._draw_major_labels(ctx, tick_info);\n            }\n            if (this.model.title)\n                this._draw_title(ctx);\n            ctx.restore();\n        }\n        _draw_bbox(ctx) {\n            const bbox = this.compute_legend_dimensions();\n            ctx.save();\n            if (this.visuals.background_fill.doit) {\n                this.visuals.background_fill.set_value(ctx);\n                ctx.fillRect(0, 0, bbox.width, bbox.height);\n            }\n            if (this.visuals.border_line.doit) {\n                this.visuals.border_line.set_value(ctx);\n                ctx.strokeRect(0, 0, bbox.width, bbox.height);\n            }\n            ctx.restore();\n        }\n        _draw_image(ctx) {\n            const image = this._computed_image_dimensions();\n            ctx.save();\n            ctx.setImageSmoothingEnabled(false);\n            ctx.globalAlpha = this.model.scale_alpha;\n            ctx.drawImage(this.image, 0, 0, image.width, image.height);\n            if (this.visuals.bar_line.doit) {\n                this.visuals.bar_line.set_value(ctx);\n                ctx.strokeRect(0, 0, image.width, image.height);\n            }\n            ctx.restore();\n        }\n        _draw_major_ticks(ctx, tick_info) {\n            if (!this.visuals.major_tick_line.doit)\n                return;\n            const [nx, ny] = this._normals();\n            const image = this._computed_image_dimensions();\n            const [x_offset, y_offset] = [image.width * nx, image.height * ny];\n            const [sx, sy] = tick_info.coords.major;\n            const tin = this.model.major_tick_in;\n            const tout = this.model.major_tick_out;\n            ctx.save();\n            ctx.translate(x_offset, y_offset);\n            this.visuals.major_tick_line.set_value(ctx);\n            for (let i = 0, end = sx.length; i < end; i++) {\n                ctx.beginPath();\n                ctx.moveTo(Math.round(sx[i] + nx * tout), Math.round(sy[i] + ny * tout));\n                ctx.lineTo(Math.round(sx[i] - nx * tin), Math.round(sy[i] - ny * tin));\n                ctx.stroke();\n            }\n            ctx.restore();\n        }\n        _draw_minor_ticks(ctx, tick_info) {\n            if (!this.visuals.minor_tick_line.doit)\n                return;\n            const [nx, ny] = this._normals();\n            const image = this._computed_image_dimensions();\n            const [x_offset, y_offset] = [image.width * nx, image.height * ny];\n            const [sx, sy] = tick_info.coords.minor;\n            const tin = this.model.minor_tick_in;\n            const tout = this.model.minor_tick_out;\n            ctx.save();\n            ctx.translate(x_offset, y_offset);\n            this.visuals.minor_tick_line.set_value(ctx);\n            for (let i = 0, end = sx.length; i < end; i++) {\n                ctx.beginPath();\n                ctx.moveTo(Math.round(sx[i] + nx * tout), Math.round(sy[i] + ny * tout));\n                ctx.lineTo(Math.round(sx[i] - nx * tin), Math.round(sy[i] - ny * tin));\n                ctx.stroke();\n            }\n            ctx.restore();\n        }\n        _draw_major_labels(ctx, tick_info) {\n            if (!this.visuals.major_label_text.doit)\n                return;\n            const [nx, ny] = this._normals();\n            const image = this._computed_image_dimensions();\n            const [x_offset, y_offset] = [image.width * nx, image.height * ny];\n            const standoff = (this.model.label_standoff + this._tick_extent());\n            const [x_standoff, y_standoff] = [standoff * nx, standoff * ny];\n            const [sx, sy] = tick_info.coords.major;\n            const formatted_labels = tick_info.labels.major;\n            this.visuals.major_label_text.set_value(ctx);\n            ctx.save();\n            ctx.translate(x_offset + x_standoff, y_offset + y_standoff);\n            for (let i = 0, end = sx.length; i < end; i++) {\n                ctx.fillText(formatted_labels[i], Math.round(sx[i] + nx * this.model.label_standoff), Math.round(sy[i] + ny * this.model.label_standoff));\n            }\n            ctx.restore();\n        }\n        _draw_title(ctx) {\n            if (!this.visuals.title_text.doit)\n                return;\n            ctx.save();\n            this.visuals.title_text.set_value(ctx);\n            ctx.fillText(this.model.title, 0, -this.model.title_standoff);\n            ctx.restore();\n        }\n        /*protected*/ _get_label_extent() {\n            const major_labels = this.tick_info().labels.major;\n            let label_extent;\n            if (this.model.color_mapper.low != null && this.model.color_mapper.high != null && !object_1.isEmpty(major_labels)) {\n                const { ctx } = this.plot_view.canvas_view;\n                ctx.save();\n                this.visuals.major_label_text.set_value(ctx);\n                switch (this.model.orientation) {\n                    case \"vertical\":\n                        label_extent = array_1.max((major_labels.map((label) => ctx.measureText(label.toString()).width)));\n                        break;\n                    case \"horizontal\":\n                        label_extent = text_util.measure_font(this.visuals.major_label_text.font_value()).height;\n                        break;\n                    default:\n                        throw new Error(\"unreachable code\");\n                }\n                label_extent += this.model.label_standoff;\n                ctx.restore();\n            }\n            else\n                label_extent = 0;\n            return label_extent;\n        }\n        /*protected*/ _get_image_offset() {\n            // Returns image offset relative to legend bounding box\n            const x = this.model.padding;\n            const y = this.model.padding + this._title_extent();\n            return { x, y };\n        }\n        // {{{ TODO: state\n        _normals() {\n            return this.model.orientation == 'vertical' ? [1, 0] : [0, 1];\n        }\n        _title_extent() {\n            const font_value = this.model.title_text_font + \" \" + this.model.title_text_font_size + \" \" + this.model.title_text_font_style;\n            const title_extent = this.model.title ? text_util.measure_font(font_value).height + this.model.title_standoff : 0;\n            return title_extent;\n        }\n        _tick_extent() {\n            if (this.model.color_mapper.low != null && this.model.color_mapper.high != null)\n                return array_1.max([this.model.major_tick_out, this.model.minor_tick_out]);\n            else\n                return 0;\n        }\n        _computed_image_dimensions() {\n            /*\n            Heuristics to determine ColorBar image dimensions if set to \"auto\"\n        \n            Note: Returns the height/width values for the ColorBar's scale image, not\n            the dimensions of the entire ColorBar.\n        \n            If the short dimension (the width of a vertical bar or height of a\n            horizontal bar) is set to \"auto\", the resulting dimension will be set to\n            25 px.\n        \n            For a ColorBar in a side panel with the long dimension (the height of a\n            vertical bar or width of a horizontal bar) set to \"auto\", the\n            resulting dimension will be as long as the adjacent frame edge, so that the\n            bar \"fits\" to the plot.\n        \n            For a ColorBar in the plot frame with the long dimension set to \"auto\", the\n            resulting dimension will be the greater of:\n              * The length of the color palette * 25px\n              * The parallel frame dimension * 0.30\n                (i.e the frame height for a vertical ColorBar)\n            But not greater than:\n              * The parallel frame dimension * 0.80\n            */\n            const frame_height = this.plot_view.frame._height.value;\n            const frame_width = this.plot_view.frame._width.value;\n            const title_extent = this._title_extent();\n            let height, width;\n            switch (this.model.orientation) {\n                case \"vertical\": {\n                    if (this.model.height == 'auto') {\n                        if (this.panel != null)\n                            height = frame_height - 2 * this.model.padding - title_extent;\n                        else {\n                            height = array_1.max([this.model.color_mapper.palette.length * SHORT_DIM, frame_height * LONG_DIM_MIN_SCALAR]);\n                            height = array_1.min([height, frame_height * LONG_DIM_MAX_SCALAR - 2 * this.model.padding - title_extent]);\n                        }\n                    }\n                    else\n                        height = this.model.height;\n                    width = this.model.width == 'auto' ? SHORT_DIM : this.model.width;\n                    break;\n                }\n                case \"horizontal\": {\n                    height = this.model.height == 'auto' ? SHORT_DIM : this.model.height;\n                    if (this.model.width == 'auto') {\n                        if (this.panel != null)\n                            width = frame_width - 2 * this.model.padding;\n                        else {\n                            width = array_1.max([this.model.color_mapper.palette.length * SHORT_DIM, frame_width * LONG_DIM_MIN_SCALAR]);\n                            width = array_1.min([width, frame_width * LONG_DIM_MAX_SCALAR - 2 * this.model.padding]);\n                        }\n                    }\n                    else\n                        width = this.model.width;\n                    break;\n                }\n                default:\n                    throw new Error(\"unreachable code\");\n            }\n            return { width, height };\n        }\n        /*protected*/ _tick_coordinate_scale(scale_length) {\n            /*\n            Creates and returns a scale instance that maps the `color_mapper` range\n            (low to high) to a screen space range equal to the length of the ColorBar's\n            scale image. The scale is used to calculate the tick coordinates in screen\n            coordinates for plotting purposes.\n        \n            Note: the type of color_mapper has to match the type of scale (i.e.\n            a LinearColorMapper will require a corresponding LinearScale instance).\n            */\n            const ranges = {\n                source_range: new range1d_1.Range1d({\n                    start: this.model.color_mapper.low,\n                    end: this.model.color_mapper.high,\n                }),\n                target_range: new range1d_1.Range1d({\n                    start: 0,\n                    end: scale_length,\n                }),\n            };\n            switch (this.model.color_mapper.type) {\n                case \"LinearColorMapper\": return new linear_scale_1.LinearScale(ranges);\n                case \"LogColorMapper\": return new log_scale_1.LogScale(ranges);\n                default:\n                    throw new Error(\"unreachable code\");\n            }\n        }\n        _format_major_labels(initial_labels, major_ticks) {\n            // XXX: passing null as cross_loc probably means MercatorTickFormatters, etc\n            // will not function properly in conjunction with colorbars\n            const formatted_labels = this.model.formatter.doFormat(initial_labels, null);\n            for (let i = 0, end = major_ticks.length; i < end; i++) {\n                if (major_ticks[i] in this.model.major_label_overrides)\n                    formatted_labels[i] = this.model.major_label_overrides[major_ticks[i]];\n            }\n            return formatted_labels;\n        }\n        tick_info() {\n            const image_dimensions = this._computed_image_dimensions();\n            let scale_length;\n            switch (this.model.orientation) {\n                case \"vertical\": {\n                    scale_length = image_dimensions.height;\n                    break;\n                }\n                case \"horizontal\": {\n                    scale_length = image_dimensions.width;\n                    break;\n                }\n                default:\n                    throw new Error(\"unreachable code\");\n            }\n            const scale = this._tick_coordinate_scale(scale_length);\n            const [i, j] = this._normals();\n            const [start, end] = [this.model.color_mapper.low, this.model.color_mapper.high];\n            // XXX: passing null as cross_loc probably means MercatorTickers, etc\n            // will not function properly in conjunction with colorbars\n            const ticks = this.model.ticker.get_ticks(start, end, null, null, this.model.ticker.desired_num_ticks);\n            const majors = ticks.major;\n            const minors = ticks.minor;\n            const major_coords = [[], []];\n            const minor_coords = [[], []];\n            for (let ii = 0, _end = majors.length; ii < _end; ii++) {\n                if (majors[ii] < start || majors[ii] > end)\n                    continue;\n                major_coords[i].push(majors[ii]);\n                major_coords[j].push(0);\n            }\n            for (let ii = 0, _end = minors.length; ii < _end; ii++) {\n                if (minors[ii] < start || minors[ii] > end)\n                    continue;\n                minor_coords[i].push(minors[ii]);\n                minor_coords[j].push(0);\n            }\n            const labels = { major: this._format_major_labels(major_coords[i], majors) };\n            const coords = {\n                major: [[], []],\n                minor: [[], []],\n            };\n            coords.major[i] = scale.v_compute(major_coords[i]);\n            coords.minor[i] = scale.v_compute(minor_coords[i]);\n            coords.major[j] = major_coords[j];\n            coords.minor[j] = minor_coords[j];\n            // Because we want the scale to be reversed\n            if (this.model.orientation == 'vertical') {\n                coords.major[i] = arrayable_1.map(coords.major[i], (coord) => scale_length - coord);\n                coords.minor[i] = arrayable_1.map(coords.minor[i], (coord) => scale_length - coord);\n            }\n            return { coords, labels };\n        }\n    }\n    exports.ColorBarView = ColorBarView;\n    ColorBarView.__name__ = \"ColorBarView\";\n    class ColorBar extends annotation_1.Annotation {\n        constructor(attrs) {\n            super(attrs);\n        }\n        static init_ColorBar() {\n            this.prototype.default_view = ColorBarView;\n            this.mixins([\n                'text:major_label_',\n                'text:title_',\n                'line:major_tick_',\n                'line:minor_tick_',\n                'line:border_',\n                'line:bar_',\n                'fill:background_',\n            ]);\n            this.define({\n                location: [p.Any, 'top_right'],\n                orientation: [p.Orientation, 'vertical'],\n                title: [p.String],\n                title_standoff: [p.Number, 2],\n                width: [p.Any, 'auto'],\n                height: [p.Any, 'auto'],\n                scale_alpha: [p.Number, 1.0],\n                ticker: [p.Instance, () => new basic_ticker_1.BasicTicker()],\n                formatter: [p.Instance, () => new basic_tick_formatter_1.BasicTickFormatter()],\n                major_label_overrides: [p.Any, {}],\n                color_mapper: [p.Instance],\n                label_standoff: [p.Number, 5],\n                margin: [p.Number, 30],\n                padding: [p.Number, 10],\n                major_tick_in: [p.Number, 5],\n                major_tick_out: [p.Number, 0],\n                minor_tick_in: [p.Number, 0],\n                minor_tick_out: [p.Number, 0],\n            });\n            this.override({\n                background_fill_color: \"#ffffff\",\n                background_fill_alpha: 0.95,\n                bar_line_color: null,\n                border_line_color: null,\n                major_label_text_align: \"center\",\n                major_label_text_baseline: \"middle\",\n                major_label_text_font_size: \"8pt\",\n                major_tick_line_color: \"#ffffff\",\n                minor_tick_line_color: null,\n                title_text_font_size: \"10pt\",\n                title_text_font_style: \"italic\",\n            });\n        }\n    }\n    exports.ColorBar = ColorBar;\n    ColorBar.__name__ = \"ColorBar\";\n    ColorBar.init_ColorBar();\n}\n","/* models/tickers/basic_ticker.js */ function _(require, module, exports) {\n    const adaptive_ticker_1 = require(103) /* ./adaptive_ticker */;\n    class BasicTicker extends adaptive_ticker_1.AdaptiveTicker {\n        constructor(attrs) {\n            super(attrs);\n        }\n    }\n    exports.BasicTicker = BasicTicker;\n    BasicTicker.__name__ = \"BasicTicker\";\n}\n","/* models/tickers/adaptive_ticker.js */ function _(require, module, exports) {\n    const continuous_ticker_1 = require(104) /* ./continuous_ticker */;\n    const array_1 = require(8) /* ../../core/util/array */;\n    const p = require(18) /* ../../core/properties */;\n    // Forces a number x into a specified range [min_val, max_val].\n    function clamp(x, min_val, max_val) {\n        return Math.max(min_val, Math.min(max_val, x));\n    }\n    // A log function with an optional base.\n    function log(x, base = Math.E) {\n        return Math.log(x) / Math.log(base);\n    }\n    class AdaptiveTicker extends continuous_ticker_1.ContinuousTicker {\n        constructor(attrs) {\n            super(attrs);\n        }\n        static init_AdaptiveTicker() {\n            this.define({\n                base: [p.Number, 10.0],\n                mantissas: [p.Array, [1, 2, 5]],\n                min_interval: [p.Number, 0.0],\n                max_interval: [p.Number],\n            });\n        }\n        // These arguments control the range of possible intervals.  The interval I\n        // returned by get_interval() will be the one that most closely matches the\n        // desired number of ticks, subject to the following constraints:\n        // I = (M * B^N), where\n        // M is a member of mantissas,\n        // B is base,\n        // and N is an integer;\n        // and min_interval <= I <= max_interval.\n        initialize() {\n            super.initialize();\n            const prefix_mantissa = array_1.nth(this.mantissas, -1) / this.base;\n            const suffix_mantissa = array_1.nth(this.mantissas, 0) * this.base;\n            this.extended_mantissas = [prefix_mantissa, ...this.mantissas, suffix_mantissa];\n            this.base_factor = this.get_min_interval() === 0.0 ? 1.0 : this.get_min_interval();\n        }\n        get_interval(data_low, data_high, desired_n_ticks) {\n            const data_range = data_high - data_low;\n            const ideal_interval = this.get_ideal_interval(data_low, data_high, desired_n_ticks);\n            const interval_exponent = Math.floor(log(ideal_interval / this.base_factor, this.base));\n            const ideal_magnitude = Math.pow(this.base, interval_exponent) * this.base_factor;\n            // An untested optimization.\n            //   const ideal_mantissa = ideal_interval / ideal_magnitude\n            //   index = sorted_index(this.extended_mantissas, ideal_mantissa)\n            //   candidate_mantissas = this.extended_mantissas[index..index + 1]\n            const candidate_mantissas = this.extended_mantissas;\n            const errors = candidate_mantissas.map((mantissa) => {\n                return Math.abs(desired_n_ticks - (data_range / (mantissa * ideal_magnitude)));\n            });\n            const best_mantissa = candidate_mantissas[array_1.argmin(errors)];\n            const interval = best_mantissa * ideal_magnitude;\n            return clamp(interval, this.get_min_interval(), this.get_max_interval());\n        }\n    }\n    exports.AdaptiveTicker = AdaptiveTicker;\n    AdaptiveTicker.__name__ = \"AdaptiveTicker\";\n    AdaptiveTicker.init_AdaptiveTicker();\n}\n","/* models/tickers/continuous_ticker.js */ function _(require, module, exports) {\n    const ticker_1 = require(105) /* ./ticker */;\n    const p = require(18) /* ../../core/properties */;\n    const array_1 = require(8) /* ../../core/util/array */;\n    const types_1 = require(7) /* ../../core/util/types */;\n    class ContinuousTicker extends ticker_1.Ticker {\n        constructor(attrs) {\n            super(attrs);\n        }\n        static init_ContinuousTicker() {\n            this.define({\n                num_minor_ticks: [p.Number, 5],\n                desired_num_ticks: [p.Number, 6],\n            });\n        }\n        get_ticks(data_low, data_high, _range, cross_loc, _) {\n            return this.get_ticks_no_defaults(data_low, data_high, cross_loc, this.desired_num_ticks);\n        }\n        // The version of get_ticks() that does the work (and the version that\n        // should be overridden in subclasses).\n        get_ticks_no_defaults(data_low, data_high, _cross_loc, desired_n_ticks) {\n            const interval = this.get_interval(data_low, data_high, desired_n_ticks);\n            const start_factor = Math.floor(data_low / interval);\n            const end_factor = Math.ceil(data_high / interval);\n            let factors;\n            if (types_1.isStrictNaN(start_factor) || types_1.isStrictNaN(end_factor))\n                factors = [];\n            else\n                factors = array_1.range(start_factor, end_factor + 1);\n            const ticks = factors\n                .map((factor) => factor * interval)\n                .filter((tick) => data_low <= tick && tick <= data_high);\n            const num_minor_ticks = this.num_minor_ticks;\n            const minor_ticks = [];\n            if (num_minor_ticks > 0 && ticks.length > 0) {\n                const minor_interval = interval / num_minor_ticks;\n                const minor_offsets = array_1.range(0, num_minor_ticks).map((i) => i * minor_interval);\n                for (const x of minor_offsets.slice(1)) {\n                    const mt = ticks[0] - x;\n                    if (data_low <= mt && mt <= data_high) {\n                        minor_ticks.push(mt);\n                    }\n                }\n                for (const tick of ticks) {\n                    for (const x of minor_offsets) {\n                        const mt = tick + x;\n                        if (data_low <= mt && mt <= data_high) {\n                            minor_ticks.push(mt);\n                        }\n                    }\n                }\n            }\n            return {\n                major: ticks,\n                minor: minor_ticks,\n            };\n        }\n        // Returns the smallest interval that can be returned by get_interval().\n        get_min_interval() {\n            return this.min_interval;\n        }\n        // Returns the largest interval that can be returned by get_interval().\n        get_max_interval() {\n            return this.max_interval != null ? this.max_interval : Infinity;\n        }\n        // Returns the interval size that would produce exactly the number of\n        // desired ticks.  (In general we won't use exactly this interval, because\n        // we want the ticks to be round numbers.)\n        get_ideal_interval(data_low, data_high, desired_n_ticks) {\n            const data_range = data_high - data_low;\n            return data_range / desired_n_ticks;\n        }\n    }\n    exports.ContinuousTicker = ContinuousTicker;\n    ContinuousTicker.__name__ = \"ContinuousTicker\";\n    ContinuousTicker.init_ContinuousTicker();\n}\n","/* models/tickers/ticker.js */ function _(require, module, exports) {\n    const model_1 = require(64) /* ../../model */;\n    class Ticker extends model_1.Model {\n        constructor(attrs) {\n            super(attrs);\n        }\n    }\n    exports.Ticker = Ticker;\n    Ticker.__name__ = \"Ticker\";\n}\n","/* models/formatters/basic_tick_formatter.js */ function _(require, module, exports) {\n    const tick_formatter_1 = require(107) /* ./tick_formatter */;\n    const p = require(18) /* ../../core/properties */;\n    const types_1 = require(7) /* ../../core/util/types */;\n    class BasicTickFormatter extends tick_formatter_1.TickFormatter {\n        constructor(attrs) {\n            super(attrs);\n            this.last_precision = 3;\n        }\n        static init_BasicTickFormatter() {\n            this.define({\n                precision: [p.Any, 'auto'],\n                use_scientific: [p.Boolean, true],\n                power_limit_high: [p.Number, 5],\n                power_limit_low: [p.Number, -3],\n            });\n        }\n        get scientific_limit_low() {\n            return Math.pow(10.0, this.power_limit_low);\n        }\n        get scientific_limit_high() {\n            return Math.pow(10.0, this.power_limit_high);\n        }\n        doFormat(ticks, _opts) {\n            if (ticks.length == 0)\n                return [];\n            let zero_eps = 0;\n            if (ticks.length >= 2)\n                zero_eps = Math.abs(ticks[1] - ticks[0]) / 10000;\n            let need_sci = false;\n            if (this.use_scientific) {\n                for (const tick of ticks) {\n                    const tick_abs = Math.abs(tick);\n                    if (tick_abs > zero_eps && (tick_abs >= this.scientific_limit_high || tick_abs <= this.scientific_limit_low)) {\n                        need_sci = true;\n                        break;\n                    }\n                }\n            }\n            const labels = new Array(ticks.length);\n            const { precision } = this;\n            if (precision == null || types_1.isNumber(precision)) {\n                if (need_sci) {\n                    for (let i = 0, end = ticks.length; i < end; i++) {\n                        labels[i] = ticks[i].toExponential(precision || undefined);\n                    }\n                }\n                else {\n                    for (let i = 0, end = ticks.length; i < end; i++) {\n                        labels[i] = ticks[i].toFixed(precision || undefined).replace(/(\\.[0-9]*?)0+$/, \"$1\").replace(/\\.$/, \"\");\n                    }\n                }\n            }\n            else {\n                for (let x = this.last_precision, asc = this.last_precision <= 15; asc ? x <= 15 : x >= 15; asc ? x++ : x--) {\n                    let is_ok = true;\n                    if (need_sci) {\n                        for (let i = 0, end = ticks.length; i < end; i++) {\n                            labels[i] = ticks[i].toExponential(x);\n                            if (i > 0) {\n                                if (labels[i] === labels[i - 1]) {\n                                    is_ok = false;\n                                    break;\n                                }\n                            }\n                        }\n                        if (is_ok) {\n                            break;\n                        }\n                    }\n                    else {\n                        for (let i = 0, end = ticks.length; i < end; i++) {\n                            labels[i] = ticks[i].toFixed(x).replace(/(\\.[0-9]*?)0+$/, \"$1\").replace(/\\.$/, \"\");\n                            if (i > 0) {\n                                if (labels[i] == labels[i - 1]) {\n                                    is_ok = false;\n                                    break;\n                                }\n                            }\n                        }\n                        if (is_ok) {\n                            break;\n                        }\n                    }\n                    if (is_ok) {\n                        this.last_precision = x;\n                        break;\n                    }\n                }\n            }\n            return labels;\n        }\n    }\n    exports.BasicTickFormatter = BasicTickFormatter;\n    BasicTickFormatter.__name__ = \"BasicTickFormatter\";\n    BasicTickFormatter.init_BasicTickFormatter();\n}\n","/* models/formatters/tick_formatter.js */ function _(require, module, exports) {\n    const model_1 = require(64) /* ../../model */;\n    class TickFormatter extends model_1.Model {\n        constructor(attrs) {\n            super(attrs);\n        }\n    }\n    exports.TickFormatter = TickFormatter;\n    TickFormatter.__name__ = \"TickFormatter\";\n}\n","/* models/mappers/linear_color_mapper.js */ function _(require, module, exports) {\n    const continuous_color_mapper_1 = require(109) /* ./continuous_color_mapper */;\n    const arrayable_1 = require(11) /* ../../core/util/arrayable */;\n    class LinearColorMapper extends continuous_color_mapper_1.ContinuousColorMapper {\n        constructor(attrs) {\n            super(attrs);\n        }\n        _v_compute(data, values, palette, colors) {\n            const { nan_color, low_color, high_color } = colors;\n            const low = this.low != null ? this.low : arrayable_1.min(data);\n            const high = this.high != null ? this.high : arrayable_1.max(data);\n            const max_key = palette.length - 1;\n            const norm_factor = 1 / (high - low);\n            const normed_interval = 1 / palette.length;\n            for (let i = 0, end = data.length; i < end; i++) {\n                const d = data[i];\n                if (isNaN(d)) {\n                    values[i] = nan_color;\n                    continue;\n                }\n                // This handles the edge case where d == high, since the code below maps\n                // values exactly equal to high to palette.length, which is greater than\n                // max_key\n                if (d == high) {\n                    values[i] = palette[max_key];\n                    continue;\n                }\n                const normed_d = (d - low) * norm_factor;\n                const key = Math.floor(normed_d / normed_interval);\n                if (key < 0)\n                    values[i] = low_color != null ? low_color : palette[0];\n                else if (key > max_key)\n                    values[i] = high_color != null ? high_color : palette[max_key];\n                else\n                    values[i] = palette[key];\n            }\n        }\n    }\n    exports.LinearColorMapper = LinearColorMapper;\n    LinearColorMapper.__name__ = \"LinearColorMapper\";\n}\n","/* models/mappers/continuous_color_mapper.js */ function _(require, module, exports) {\n    const color_mapper_1 = require(110) /* ./color_mapper */;\n    const p = require(18) /* ../../core/properties */;\n    class ContinuousColorMapper extends color_mapper_1.ColorMapper {\n        constructor(attrs) {\n            super(attrs);\n        }\n        static init_ContinuousColorMapper() {\n            this.define({\n                high: [p.Number],\n                low: [p.Number],\n                high_color: [p.Color],\n                low_color: [p.Color],\n            });\n        }\n        _colors(conv) {\n            return Object.assign(Object.assign({}, super._colors(conv)), { low_color: this.low_color != null ? conv(this.low_color) : undefined, high_color: this.high_color != null ? conv(this.high_color) : undefined });\n        }\n    }\n    exports.ContinuousColorMapper = ContinuousColorMapper;\n    ContinuousColorMapper.__name__ = \"ContinuousColorMapper\";\n    ContinuousColorMapper.init_ContinuousColorMapper();\n}\n","/* models/mappers/color_mapper.js */ function _(require, module, exports) {\n    const mapper_1 = require(111) /* ./mapper */;\n    const p = require(18) /* ../../core/properties */;\n    const types_1 = require(7) /* ../../core/util/types */;\n    const color_1 = require(20) /* ../../core/util/color */;\n    const compat_1 = require(95) /* ../../core/util/compat */;\n    function _convert_color(color) {\n        if (types_1.isNumber(color))\n            return color;\n        if (color[0] != \"#\")\n            color = color_1.color2hex(color);\n        if (color.length != 9)\n            color = color + 'ff';\n        return parseInt(color.slice(1), 16);\n    }\n    exports._convert_color = _convert_color;\n    function _convert_palette(palette) {\n        const new_palette = new Uint32Array(palette.length);\n        for (let i = 0, end = palette.length; i < end; i++)\n            new_palette[i] = _convert_color(palette[i]);\n        return new_palette;\n    }\n    exports._convert_palette = _convert_palette;\n    function _uint32_to_rgba(values) {\n        if (compat_1.is_little_endian) {\n            const view = new DataView(values.buffer);\n            for (let i = 0, end = values.length; i < end; i++)\n                view.setUint32(i * 4, values[i]);\n        }\n        return new Uint8Array(values.buffer);\n    }\n    exports._uint32_to_rgba = _uint32_to_rgba;\n    class ColorMapper extends mapper_1.Mapper {\n        constructor(attrs) {\n            super(attrs);\n        }\n        static init_ColorMapper() {\n            this.define({\n                palette: [p.Any],\n                nan_color: [p.Color, \"gray\"],\n            });\n        }\n        v_compute(xs) {\n            const values = new Array(xs.length);\n            this._v_compute(xs, values, this.palette, this._colors((c) => c));\n            return values;\n        }\n        get rgba_mapper() {\n            const self = this;\n            const palette = _convert_palette(this.palette);\n            const colors = this._colors(_convert_color);\n            return {\n                v_compute(xs) {\n                    const values = new Uint32Array(xs.length);\n                    self._v_compute(xs, values, palette, colors);\n                    return _uint32_to_rgba(values);\n                },\n            };\n        }\n        _colors(conv) {\n            return { nan_color: conv(this.nan_color) };\n        }\n    }\n    exports.ColorMapper = ColorMapper;\n    ColorMapper.__name__ = \"ColorMapper\";\n    ColorMapper.init_ColorMapper();\n}\n","/* models/mappers/mapper.js */ function _(require, module, exports) {\n    const transform_1 = require(112) /* ../transforms/transform */;\n    class Mapper extends transform_1.Transform {\n        constructor(attrs) {\n            super(attrs);\n        }\n        compute(_x) {\n            // If it's just a single value, then a mapper doesn't really make sense.\n            throw new Error(\"mapping single values is not supported\");\n        }\n    }\n    exports.Mapper = Mapper;\n    Mapper.__name__ = \"Mapper\";\n}\n","/* models/transforms/transform.js */ function _(require, module, exports) {\n    const model_1 = require(64) /* ../../model */;\n    class Transform extends model_1.Model {\n        constructor(attrs) {\n            super(attrs);\n        }\n    }\n    exports.Transform = Transform;\n    Transform.__name__ = \"Transform\";\n}\n","/* models/scales/linear_scale.js */ function _(require, module, exports) {\n    const scale_1 = require(114) /* ./scale */;\n    class LinearScale extends scale_1.Scale {\n        constructor(attrs) {\n            super(attrs);\n        }\n        compute(x) {\n            const [factor, offset] = this._compute_state();\n            return factor * x + offset;\n        }\n        v_compute(xs) {\n            const [factor, offset] = this._compute_state();\n            const result = new Float64Array(xs.length);\n            for (let i = 0; i < xs.length; i++)\n                result[i] = factor * xs[i] + offset;\n            return result;\n        }\n        invert(xprime) {\n            const [factor, offset] = this._compute_state();\n            return (xprime - offset) / factor;\n        }\n        v_invert(xprimes) {\n            const [factor, offset] = this._compute_state();\n            const result = new Float64Array(xprimes.length);\n            for (let i = 0; i < xprimes.length; i++)\n                result[i] = (xprimes[i] - offset) / factor;\n            return result;\n        }\n        /*protected*/ _compute_state() {\n            //\n            //  (t1 - t0)       (t1 - t0)\n            //  --------- * x - --------- * s0 + t0\n            //  (s1 - s0)       (s1 - s0)\n            //\n            // [  factor  ]     [    offset    ]\n            //\n            const source_start = this.source_range.start;\n            const source_end = this.source_range.end;\n            const target_start = this.target_range.start;\n            const target_end = this.target_range.end;\n            const factor = (target_end - target_start) / (source_end - source_start);\n            const offset = -(factor * source_start) + target_start;\n            return [factor, offset];\n        }\n    }\n    exports.LinearScale = LinearScale;\n    LinearScale.__name__ = \"LinearScale\";\n}\n","/* models/scales/scale.js */ function _(require, module, exports) {\n    const transforms_1 = require(115) /* ../transforms */;\n    const p = require(18) /* ../../core/properties */;\n    class Scale extends transforms_1.Transform {\n        constructor(attrs) {\n            super(attrs);\n        }\n        static init_Scale() {\n            this.internal({\n                source_range: [p.Any],\n                target_range: [p.Any],\n            });\n        }\n        r_compute(x0, x1) {\n            if (this.target_range.is_reversed)\n                return [this.compute(x1), this.compute(x0)];\n            else\n                return [this.compute(x0), this.compute(x1)];\n        }\n        r_invert(sx0, sx1) {\n            if (this.target_range.is_reversed)\n                return [this.invert(sx1), this.invert(sx0)];\n            else\n                return [this.invert(sx0), this.invert(sx1)];\n        }\n    }\n    exports.Scale = Scale;\n    Scale.__name__ = \"Scale\";\n    Scale.init_Scale();\n}\n","/* models/transforms/index.js */ function _(require, module, exports) {\n    var customjs_transform_1 = require(116) /* ./customjs_transform */;\n    exports.CustomJSTransform = customjs_transform_1.CustomJSTransform;\n    var dodge_1 = require(117) /* ./dodge */;\n    exports.Dodge = dodge_1.Dodge;\n    var interpolator_1 = require(118) /* ./interpolator */;\n    exports.Interpolator = interpolator_1.Interpolator;\n    var jitter_1 = require(119) /* ./jitter */;\n    exports.Jitter = jitter_1.Jitter;\n    var linear_interpolator_1 = require(120) /* ./linear_interpolator */;\n    exports.LinearInterpolator = linear_interpolator_1.LinearInterpolator;\n    var step_interpolator_1 = require(121) /* ./step_interpolator */;\n    exports.StepInterpolator = step_interpolator_1.StepInterpolator;\n    var transform_1 = require(112) /* ./transform */;\n    exports.Transform = transform_1.Transform;\n}\n","/* models/transforms/customjs_transform.js */ function _(require, module, exports) {\n    const transform_1 = require(112) /* ./transform */;\n    const p = require(18) /* ../../core/properties */;\n    const object_1 = require(22) /* ../../core/util/object */;\n    const string_1 = require(25) /* ../../core/util/string */;\n    class CustomJSTransform extends transform_1.Transform {\n        constructor(attrs) {\n            super(attrs);\n        }\n        static init_CustomJSTransform() {\n            this.define({\n                args: [p.Any, {}],\n                func: [p.String, \"\"],\n                v_func: [p.String, \"\"],\n                use_strict: [p.Boolean, false],\n            });\n        }\n        get names() {\n            return object_1.keys(this.args);\n        }\n        get values() {\n            return object_1.values(this.args);\n        }\n        _make_transform(name, func) {\n            const code = this.use_strict ? string_1.use_strict(func) : func;\n            return new Function(...this.names, name, \"require\", \"exports\", code);\n        }\n        get scalar_transform() {\n            return this._make_transform(\"x\", this.func);\n        }\n        get vector_transform() {\n            return this._make_transform(\"xs\", this.v_func);\n        }\n        compute(x) {\n            return this.scalar_transform(...this.values, x, require, {});\n        }\n        v_compute(xs) {\n            return this.vector_transform(...this.values, xs, require, {});\n        }\n    }\n    exports.CustomJSTransform = CustomJSTransform;\n    CustomJSTransform.__name__ = \"CustomJSTransform\";\n    CustomJSTransform.init_CustomJSTransform();\n}\n","/* models/transforms/dodge.js */ function _(require, module, exports) {\n    const transform_1 = require(112) /* ./transform */;\n    const factor_range_1 = require(82) /* ../ranges/factor_range */;\n    const p = require(18) /* ../../core/properties */;\n    const types_1 = require(7) /* ../../core/util/types */;\n    class Dodge extends transform_1.Transform {\n        constructor(attrs) {\n            super(attrs);\n        }\n        static init_Dodge() {\n            this.define({\n                value: [p.Number, 0],\n                range: [p.Instance],\n            });\n        }\n        // XXX: this is repeated in ./jitter.ts\n        v_compute(xs0) {\n            let xs;\n            if (this.range instanceof factor_range_1.FactorRange)\n                xs = this.range.v_synthetic(xs0);\n            else if (types_1.isArrayableOf(xs0, types_1.isNumber))\n                xs = xs0;\n            else\n                throw new Error(\"unexpected\");\n            const result = new Float64Array(xs.length);\n            for (let i = 0; i < xs.length; i++) {\n                const x = xs[i];\n                result[i] = this._compute(x);\n            }\n            return result;\n        }\n        compute(x) {\n            if (this.range instanceof factor_range_1.FactorRange)\n                return this._compute(this.range.synthetic(x));\n            else if (types_1.isNumber(x))\n                return this._compute(x);\n            else\n                throw new Error(\"unexpected\");\n        }\n        _compute(x) {\n            return x + this.value;\n        }\n    }\n    exports.Dodge = Dodge;\n    Dodge.__name__ = \"Dodge\";\n    Dodge.init_Dodge();\n}\n","/* models/transforms/interpolator.js */ function _(require, module, exports) {\n    const transform_1 = require(112) /* ./transform */;\n    const p = require(18) /* ../../core/properties */;\n    const array_1 = require(8) /* ../../core/util/array */;\n    const types_1 = require(7) /* ../../core/util/types */;\n    class Interpolator extends transform_1.Transform {\n        constructor(attrs) {\n            super(attrs);\n            this._sorted_dirty = true;\n        }\n        static init_Interpolator() {\n            this.define({\n                x: [p.Any],\n                y: [p.Any],\n                data: [p.Any],\n                clip: [p.Boolean, true],\n            });\n        }\n        connect_signals() {\n            super.connect_signals();\n            this.connect(this.change, () => this._sorted_dirty = true);\n        }\n        v_compute(xs) {\n            const result = new Float64Array(xs.length);\n            for (let i = 0; i < xs.length; i++) {\n                const x = xs[i];\n                result[i] = this.compute(x);\n            }\n            return result;\n        }\n        sort(descending = false) {\n            if (!this._sorted_dirty)\n                return;\n            let tsx;\n            let tsy;\n            if (types_1.isString(this.x) && types_1.isString(this.y) && this.data != null) {\n                const column_names = this.data.columns();\n                if (!array_1.includes(column_names, this.x))\n                    throw new Error(\"The x parameter does not correspond to a valid column name defined in the data parameter\");\n                if (!array_1.includes(column_names, this.y))\n                    throw new Error(\"The y parameter does not correspond to a valid column name defined in the data parameter\");\n                tsx = this.data.get_column(this.x);\n                tsy = this.data.get_column(this.y);\n            }\n            else if (types_1.isArray(this.x) && types_1.isArray(this.y)) {\n                tsx = this.x;\n                tsy = this.y;\n            }\n            else {\n                throw new Error(\"parameters 'x' and 'y' must be both either string fields or arrays\");\n            }\n            if (tsx.length !== tsy.length)\n                throw new Error(\"The length for x and y do not match\");\n            if (tsx.length < 2)\n                throw new Error(\"x and y must have at least two elements to support interpolation\");\n            // The following sorting code is referenced from:\n            // http://stackoverflow.com/questions/11499268/sort-two-arrays-the-same-way\n            const list = [];\n            for (const j in tsx) {\n                list.push({ x: tsx[j], y: tsy[j] });\n            }\n            if (descending)\n                list.sort((a, b) => a.x > b.x ? -1 : (a.x == b.x ? 0 : 1));\n            else\n                list.sort((a, b) => a.x < b.x ? -1 : (a.x == b.x ? 0 : 1));\n            this._x_sorted = [];\n            this._y_sorted = [];\n            for (const { x, y } of list) {\n                this._x_sorted.push(x);\n                this._y_sorted.push(y);\n            }\n            this._sorted_dirty = false;\n        }\n    }\n    exports.Interpolator = Interpolator;\n    Interpolator.__name__ = \"Interpolator\";\n    Interpolator.init_Interpolator();\n}\n","/* models/transforms/jitter.js */ function _(require, module, exports) {\n    const transform_1 = require(112) /* ./transform */;\n    const factor_range_1 = require(82) /* ../ranges/factor_range */;\n    const types_1 = require(7) /* ../../core/util/types */;\n    const p = require(18) /* ../../core/properties */;\n    const bokeh_math = require(9) /* ../../core/util/math */;\n    class Jitter extends transform_1.Transform {\n        constructor(attrs) {\n            super(attrs);\n        }\n        static init_Jitter() {\n            this.define({\n                mean: [p.Number, 0],\n                width: [p.Number, 1],\n                distribution: [p.Distribution, 'uniform'],\n                range: [p.Instance],\n            });\n            this.internal({\n                previous_values: [p.Array],\n            });\n        }\n        v_compute(xs0) {\n            if (this.previous_values != null && this.previous_values.length == xs0.length)\n                return this.previous_values;\n            let xs;\n            if (this.range instanceof factor_range_1.FactorRange)\n                xs = this.range.v_synthetic(xs0);\n            else if (types_1.isArrayableOf(xs0, types_1.isNumber))\n                xs = xs0;\n            else\n                throw new Error(\"unexpected\");\n            const result = new Float64Array(xs.length);\n            for (let i = 0; i < xs.length; i++) {\n                const x = xs[i];\n                result[i] = this._compute(x);\n            }\n            this.previous_values = result;\n            return result;\n        }\n        compute(x) {\n            if (this.range instanceof factor_range_1.FactorRange)\n                return this._compute(this.range.synthetic(x));\n            else if (types_1.isNumber(x))\n                return this._compute(x);\n            else\n                throw new Error(\"unexpected\");\n        }\n        _compute(x) {\n            switch (this.distribution) {\n                case \"uniform\":\n                    return x + this.mean + (bokeh_math.random() - 0.5) * this.width;\n                case \"normal\":\n                    return x + bokeh_math.rnorm(this.mean, this.width);\n            }\n        }\n    }\n    exports.Jitter = Jitter;\n    Jitter.__name__ = \"Jitter\";\n    Jitter.init_Jitter();\n}\n","/* models/transforms/linear_interpolator.js */ function _(require, module, exports) {\n    const array_1 = require(8) /* ../../core/util/array */;\n    const interpolator_1 = require(118) /* ./interpolator */;\n    class LinearInterpolator extends interpolator_1.Interpolator {\n        constructor(attrs) {\n            super(attrs);\n        }\n        compute(x) {\n            this.sort(false);\n            if (this.clip) {\n                if (x < this._x_sorted[0] || x > this._x_sorted[this._x_sorted.length - 1])\n                    return NaN;\n            }\n            else {\n                if (x < this._x_sorted[0])\n                    return this._y_sorted[0];\n                if (x > this._x_sorted[this._x_sorted.length - 1])\n                    return this._y_sorted[this._y_sorted.length - 1];\n            }\n            if (x == this._x_sorted[0])\n                return this._y_sorted[0];\n            const ind = array_1.find_last_index(this._x_sorted, num => num < x);\n            const x1 = this._x_sorted[ind];\n            const x2 = this._x_sorted[ind + 1];\n            const y1 = this._y_sorted[ind];\n            const y2 = this._y_sorted[ind + 1];\n            return y1 + (((x - x1) / (x2 - x1)) * (y2 - y1));\n        }\n    }\n    exports.LinearInterpolator = LinearInterpolator;\n    LinearInterpolator.__name__ = \"LinearInterpolator\";\n}\n","/* models/transforms/step_interpolator.js */ function _(require, module, exports) {\n    const interpolator_1 = require(118) /* ./interpolator */;\n    const p = require(18) /* ../../core/properties */;\n    const array_1 = require(8) /* ../../core/util/array */;\n    class StepInterpolator extends interpolator_1.Interpolator {\n        constructor(attrs) {\n            super(attrs);\n        }\n        static init_StepInterpolator() {\n            this.define({\n                mode: [p.StepMode, \"after\"],\n            });\n        }\n        compute(x) {\n            this.sort(false);\n            if (this.clip) {\n                if (x < this._x_sorted[0] || x > this._x_sorted[this._x_sorted.length - 1])\n                    return NaN;\n            }\n            else {\n                if (x < this._x_sorted[0])\n                    return this._y_sorted[0];\n                if (x > this._x_sorted[this._x_sorted.length - 1])\n                    return this._y_sorted[this._y_sorted.length - 1];\n            }\n            let ind;\n            switch (this.mode) {\n                case \"after\": {\n                    ind = array_1.find_last_index(this._x_sorted, num => x >= num);\n                    break;\n                }\n                case \"before\": {\n                    ind = array_1.find_index(this._x_sorted, num => x <= num);\n                    break;\n                }\n                case \"center\": {\n                    const diffs = this._x_sorted.map((tx) => Math.abs(tx - x));\n                    const mdiff = array_1.min(diffs);\n                    ind = array_1.find_index(diffs, num => mdiff === num);\n                    break;\n                }\n                default:\n                    throw new Error(`unknown mode: ${this.mode}`);\n            }\n            return ind != -1 ? this._y_sorted[ind] : NaN;\n        }\n    }\n    exports.StepInterpolator = StepInterpolator;\n    StepInterpolator.__name__ = \"StepInterpolator\";\n    StepInterpolator.init_StepInterpolator();\n}\n","/* models/scales/log_scale.js */ function _(require, module, exports) {\n    const scale_1 = require(114) /* ./scale */;\n    class LogScale extends scale_1.Scale {\n        constructor(attrs) {\n            super(attrs);\n        }\n        compute(x) {\n            const [factor, offset, inter_factor, inter_offset] = this._compute_state();\n            let value;\n            if (inter_factor == 0)\n                value = 0;\n            else {\n                const _x = (Math.log(x) - inter_offset) / inter_factor;\n                if (isFinite(_x))\n                    value = _x * factor + offset;\n                else\n                    value = NaN;\n            }\n            return value;\n        }\n        v_compute(xs) {\n            const [factor, offset, inter_factor, inter_offset] = this._compute_state();\n            const result = new Float64Array(xs.length);\n            if (inter_factor == 0) {\n                for (let i = 0; i < xs.length; i++)\n                    result[i] = 0;\n            }\n            else {\n                for (let i = 0; i < xs.length; i++) {\n                    const _x = (Math.log(xs[i]) - inter_offset) / inter_factor;\n                    let value;\n                    if (isFinite(_x))\n                        value = _x * factor + offset;\n                    else\n                        value = NaN;\n                    result[i] = value;\n                }\n            }\n            return result;\n        }\n        invert(xprime) {\n            const [factor, offset, inter_factor, inter_offset] = this._compute_state();\n            const value = (xprime - offset) / factor;\n            return Math.exp(inter_factor * value + inter_offset);\n        }\n        v_invert(xprimes) {\n            const [factor, offset, inter_factor, inter_offset] = this._compute_state();\n            const result = new Float64Array(xprimes.length);\n            for (let i = 0; i < xprimes.length; i++) {\n                const value = (xprimes[i] - offset) / factor;\n                result[i] = Math.exp(inter_factor * value + inter_offset);\n            }\n            return result;\n        }\n        _get_safe_factor(orig_start, orig_end) {\n            let start = orig_start < 0 ? 0 : orig_start;\n            let end = orig_end < 0 ? 0 : orig_end;\n            if (start == end) {\n                if (start == 0)\n                    [start, end] = [1, 10];\n                else {\n                    const log_val = Math.log(start) / Math.log(10);\n                    start = Math.pow(10, Math.floor(log_val));\n                    if (Math.ceil(log_val) != Math.floor(log_val))\n                        end = Math.pow(10, Math.ceil(log_val));\n                    else\n                        end = Math.pow(10, Math.ceil(log_val) + 1);\n                }\n            }\n            return [start, end];\n        }\n        /*protected*/ _compute_state() {\n            const source_start = this.source_range.start;\n            const source_end = this.source_range.end;\n            const target_start = this.target_range.start;\n            const target_end = this.target_range.end;\n            const screen_range = target_end - target_start;\n            const [start, end] = this._get_safe_factor(source_start, source_end);\n            let inter_factor;\n            let inter_offset;\n            if (start == 0) {\n                inter_factor = Math.log(end);\n                inter_offset = 0;\n            }\n            else {\n                inter_factor = Math.log(end) - Math.log(start);\n                inter_offset = Math.log(start);\n            }\n            const factor = screen_range;\n            const offset = target_start;\n            return [factor, offset, inter_factor, inter_offset];\n        }\n    }\n    exports.LogScale = LogScale;\n    LogScale.__name__ = \"LogScale\";\n}\n","/* models/ranges/range1d.js */ function _(require, module, exports) {\n    const range_1 = require(83) /* ./range */;\n    const p = require(18) /* ../../core/properties */;\n    class Range1d extends range_1.Range {\n        constructor(attrs) {\n            super(attrs);\n        }\n        static init_Range1d() {\n            this.define({\n                start: [p.Number, 0],\n                end: [p.Number, 1],\n                reset_start: [p.Number],\n                reset_end: [p.Number],\n            });\n        }\n        _set_auto_bounds() {\n            if (this.bounds == 'auto') {\n                const min = Math.min(this.reset_start, this.reset_end);\n                const max = Math.max(this.reset_start, this.reset_end);\n                this.setv({ bounds: [min, max] }, { silent: true });\n            }\n        }\n        initialize() {\n            super.initialize();\n            if (this.reset_start == null) {\n                this.reset_start = this.start;\n            }\n            if (this.reset_end == null) {\n                this.reset_end = this.end;\n            }\n            this._set_auto_bounds();\n        }\n        get min() {\n            return Math.min(this.start, this.end);\n        }\n        get max() {\n            return Math.max(this.start, this.end);\n        }\n        reset() {\n            this._set_auto_bounds();\n            if (this.start != this.reset_start || this.end != this.reset_end)\n                this.setv({ start: this.reset_start, end: this.reset_end });\n            else\n                this.change.emit();\n        }\n    }\n    exports.Range1d = Range1d;\n    Range1d.__name__ = \"Range1d\";\n    Range1d.init_Range1d();\n}\n","/* core/util/text.js */ function _(require, module, exports) {\n    const dom_1 = require(61) /* ../dom */;\n    const cache = {};\n    function measure_font(font) {\n        if (cache[font] != null)\n            return cache[font];\n        const text = dom_1.span({ style: { font } }, \"Hg\");\n        const block = dom_1.div({ style: { display: \"inline-block\", width: \"1px\", height: \"0px\" } });\n        const elem = dom_1.div({}, text, block);\n        document.body.appendChild(elem);\n        try {\n            block.style.verticalAlign = \"baseline\";\n            const ascent = dom_1.offset(block).top - dom_1.offset(text).top;\n            block.style.verticalAlign = \"bottom\";\n            const height = dom_1.offset(block).top - dom_1.offset(text).top;\n            const result = { height, ascent, descent: height - ascent };\n            cache[font] = result;\n            return result;\n        }\n        finally {\n            document.body.removeChild(elem);\n        }\n    }\n    exports.measure_font = measure_font;\n    const _cache = {};\n    function measure_text(text, font) {\n        const text_cache = _cache[font];\n        if (text_cache != null) {\n            const size = text_cache[text];\n            if (size != null)\n                return size;\n        }\n        else\n            _cache[font] = {};\n        const el = dom_1.div({ style: { display: \"inline-block\", \"white-space\": \"nowrap\", font } }, text);\n        document.body.appendChild(el);\n        try {\n            const { width, height } = el.getBoundingClientRect();\n            _cache[font][text] = { width, height };\n            return { width, height };\n        }\n        finally {\n            document.body.removeChild(el);\n        }\n    }\n    exports.measure_text = measure_text;\n}\n","/* models/annotations/label.js */ function _(require, module, exports) {\n    const text_annotation_1 = require(126) /* ./text_annotation */;\n    const dom_1 = require(61) /* ../../core/dom */;\n    const p = require(18) /* ../../core/properties */;\n    class LabelView extends text_annotation_1.TextAnnotationView {\n        initialize() {\n            super.initialize();\n            this.visuals.warm_cache();\n        }\n        _get_size() {\n            const { ctx } = this.plot_view.canvas_view;\n            this.visuals.text.set_value(ctx);\n            const { width, ascent } = ctx.measureText(this.model.text);\n            return { width, height: ascent };\n        }\n        render() {\n            if (!this.model.visible && this.model.render_mode == 'css')\n                dom_1.undisplay(this.el);\n            if (!this.model.visible)\n                return;\n            // Here because AngleSpec does units transform and label doesn't support specs\n            let angle;\n            switch (this.model.angle_units) {\n                case \"rad\": {\n                    angle = -this.model.angle;\n                    break;\n                }\n                case \"deg\": {\n                    angle = (-this.model.angle * Math.PI) / 180.0;\n                    break;\n                }\n                default:\n                    throw new Error(\"unreachable code\");\n            }\n            const panel = this.panel != null ? this.panel : this.plot_view.frame;\n            const xscale = this.plot_view.frame.xscales[this.model.x_range_name];\n            const yscale = this.plot_view.frame.yscales[this.model.y_range_name];\n            let sx = this.model.x_units == \"data\" ? xscale.compute(this.model.x) : panel.xview.compute(this.model.x);\n            let sy = this.model.y_units == \"data\" ? yscale.compute(this.model.y) : panel.yview.compute(this.model.y);\n            sx += this.model.x_offset;\n            sy -= this.model.y_offset;\n            const draw = this.model.render_mode == 'canvas' ? this._canvas_text.bind(this) : this._css_text.bind(this);\n            draw(this.plot_view.canvas_view.ctx, this.model.text, sx, sy, angle);\n        }\n    }\n    exports.LabelView = LabelView;\n    LabelView.__name__ = \"LabelView\";\n    class Label extends text_annotation_1.TextAnnotation {\n        constructor(attrs) {\n            super(attrs);\n        }\n        static init_Label() {\n            this.prototype.default_view = LabelView;\n            this.mixins(['text', 'line:border_', 'fill:background_']);\n            this.define({\n                x: [p.Number],\n                x_units: [p.SpatialUnits, 'data'],\n                y: [p.Number],\n                y_units: [p.SpatialUnits, 'data'],\n                text: [p.String],\n                angle: [p.Angle, 0],\n                angle_units: [p.AngleUnits, 'rad'],\n                x_offset: [p.Number, 0],\n                y_offset: [p.Number, 0],\n                x_range_name: [p.String, 'default'],\n                y_range_name: [p.String, 'default'],\n            });\n            this.override({\n                background_fill_color: null,\n                border_line_color: null,\n            });\n        }\n    }\n    exports.Label = Label;\n    Label.__name__ = \"Label\";\n    Label.init_Label();\n}\n","/* models/annotations/text_annotation.js */ function _(require, module, exports) {\n    const annotation_1 = require(29) /* ./annotation */;\n    const dom_1 = require(61) /* ../../core/dom */;\n    const p = require(18) /* ../../core/properties */;\n    const text_1 = require(124) /* ../../core/util/text */;\n    const annotations_1 = require(100) /* ../../styles/annotations */;\n    class TextAnnotationView extends annotation_1.AnnotationView {\n        constructor() {\n            super(...arguments);\n            this.rotate = true;\n        }\n        initialize() {\n            super.initialize();\n            if (this.model.render_mode == 'css') {\n                this.el.classList.add(annotations_1.bk_annotation);\n                this.plot_view.canvas_overlays.appendChild(this.el);\n            }\n        }\n        connect_signals() {\n            super.connect_signals();\n            if (this.model.render_mode == 'css') {\n                // dispatch CSS update immediately\n                this.connect(this.model.change, () => this.render());\n            }\n            else {\n                this.connect(this.model.change, () => this.plot_view.request_render());\n            }\n        }\n        _calculate_text_dimensions(ctx, text) {\n            const { width } = ctx.measureText(text);\n            const { height } = text_1.measure_font(this.visuals.text.font_value());\n            return [width, height];\n        }\n        _calculate_bounding_box_dimensions(ctx, text) {\n            const [width, height] = this._calculate_text_dimensions(ctx, text);\n            let x_offset;\n            switch (ctx.textAlign) {\n                case 'left':\n                    x_offset = 0;\n                    break;\n                case 'center':\n                    x_offset = -width / 2;\n                    break;\n                case 'right':\n                    x_offset = -width;\n                    break;\n                default:\n                    throw new Error(\"unreachable code\");\n            }\n            // guestimated from https://www.w3.org/TR/2dcontext/#dom-context-2d-textbaseline\n            let y_offset;\n            switch (ctx.textBaseline) {\n                case 'top':\n                    y_offset = 0.0;\n                    break;\n                case 'middle':\n                    y_offset = -0.5 * height;\n                    break;\n                case 'bottom':\n                    y_offset = -1.0 * height;\n                    break;\n                case 'alphabetic':\n                    y_offset = -0.8 * height;\n                    break;\n                case 'hanging':\n                    y_offset = -0.17 * height;\n                    break;\n                case 'ideographic':\n                    y_offset = -0.83 * height;\n                    break;\n                default:\n                    throw new Error(\"unreachable code\");\n            }\n            return [x_offset, y_offset, width, height];\n        }\n        _canvas_text(ctx, text, sx, sy, angle) {\n            this.visuals.text.set_value(ctx);\n            const bbox_dims = this._calculate_bounding_box_dimensions(ctx, text);\n            ctx.save();\n            ctx.beginPath();\n            ctx.translate(sx, sy);\n            if (angle)\n                ctx.rotate(angle);\n            ctx.rect(bbox_dims[0], bbox_dims[1], bbox_dims[2], bbox_dims[3]);\n            if (this.visuals.background_fill.doit) {\n                this.visuals.background_fill.set_value(ctx);\n                ctx.fill();\n            }\n            if (this.visuals.border_line.doit) {\n                this.visuals.border_line.set_value(ctx);\n                ctx.stroke();\n            }\n            if (this.visuals.text.doit) {\n                this.visuals.text.set_value(ctx);\n                ctx.fillText(text, 0, 0);\n            }\n            ctx.restore();\n        }\n        _css_text(ctx, text, sx, sy, angle) {\n            dom_1.undisplay(this.el);\n            this.visuals.text.set_value(ctx);\n            const bbox_dims = this._calculate_bounding_box_dimensions(ctx, text);\n            // attempt to support vector string-style (\"8 4 8\") line dashing for css mode\n            const ld = this.visuals.border_line.line_dash.value();\n            const line_dash = ld.length < 2 ? \"solid\" : \"dashed\";\n            this.visuals.border_line.set_value(ctx);\n            this.visuals.background_fill.set_value(ctx);\n            this.el.style.position = 'absolute';\n            this.el.style.left = `${sx + bbox_dims[0]}px`;\n            this.el.style.top = `${sy + bbox_dims[1]}px`;\n            this.el.style.color = `${this.visuals.text.text_color.value()}`;\n            this.el.style.opacity = `${this.visuals.text.text_alpha.value()}`;\n            this.el.style.font = `${this.visuals.text.font_value()}`;\n            this.el.style.lineHeight = \"normal\"; // needed to prevent ipynb css override\n            if (angle) {\n                this.el.style.transform = `rotate(${angle}rad)`;\n            }\n            if (this.visuals.background_fill.doit) {\n                this.el.style.backgroundColor = `${this.visuals.background_fill.color_value()}`;\n            }\n            if (this.visuals.border_line.doit) {\n                this.el.style.borderStyle = `${line_dash}`;\n                this.el.style.borderWidth = `${this.visuals.border_line.line_width.value()}px`;\n                this.el.style.borderColor = `${this.visuals.border_line.color_value()}`;\n            }\n            this.el.textContent = text;\n            dom_1.display(this.el);\n        }\n    }\n    exports.TextAnnotationView = TextAnnotationView;\n    TextAnnotationView.__name__ = \"TextAnnotationView\";\n    class TextAnnotation extends annotation_1.Annotation {\n        constructor(attrs) {\n            super(attrs);\n        }\n        static init_TextAnnotation() {\n            this.define({\n                render_mode: [p.RenderMode, \"canvas\"],\n            });\n        }\n    }\n    exports.TextAnnotation = TextAnnotation;\n    TextAnnotation.__name__ = \"TextAnnotation\";\n    TextAnnotation.init_TextAnnotation();\n}\n","/* models/annotations/label_set.js */ function _(require, module, exports) {\n    const text_annotation_1 = require(126) /* ./text_annotation */;\n    const column_data_source_1 = require(68) /* ../sources/column_data_source */;\n    const dom_1 = require(61) /* ../../core/dom */;\n    const p = require(18) /* ../../core/properties */;\n    const annotations_1 = require(100) /* ../../styles/annotations */;\n    class LabelSetView extends text_annotation_1.TextAnnotationView {\n        initialize() {\n            super.initialize();\n            this.set_data(this.model.source);\n            if (this.model.render_mode == 'css') {\n                for (let i = 0, end = this._text.length; i < end; i++) {\n                    const el = dom_1.div({ class: annotations_1.bk_annotation_child, style: { display: \"none\" } });\n                    this.el.appendChild(el);\n                }\n            }\n        }\n        connect_signals() {\n            super.connect_signals();\n            if (this.model.render_mode == 'css') {\n                // dispatch CSS update immediately\n                this.connect(this.model.change, () => {\n                    this.set_data(this.model.source);\n                    this.render();\n                });\n                this.connect(this.model.source.streaming, () => {\n                    this.set_data(this.model.source);\n                    this.render();\n                });\n                this.connect(this.model.source.patching, () => {\n                    this.set_data(this.model.source);\n                    this.render();\n                });\n                this.connect(this.model.source.change, () => {\n                    this.set_data(this.model.source);\n                    this.render();\n                });\n            }\n            else {\n                this.connect(this.model.change, () => {\n                    this.set_data(this.model.source);\n                    this.plot_view.request_render();\n                });\n                this.connect(this.model.source.streaming, () => {\n                    this.set_data(this.model.source);\n                    this.plot_view.request_render();\n                });\n                this.connect(this.model.source.patching, () => {\n                    this.set_data(this.model.source);\n                    this.plot_view.request_render();\n                });\n                this.connect(this.model.source.change, () => {\n                    this.set_data(this.model.source);\n                    this.plot_view.request_render();\n                });\n            }\n        }\n        set_data(source) {\n            super.set_data(source);\n            this.visuals.warm_cache(source);\n        }\n        _map_data() {\n            const xscale = this.plot_view.frame.xscales[this.model.x_range_name];\n            const yscale = this.plot_view.frame.yscales[this.model.y_range_name];\n            const panel = this.panel != null ? this.panel : this.plot_view.frame;\n            const sx = this.model.x_units == \"data\" ? xscale.v_compute(this._x) : panel.xview.v_compute(this._x);\n            const sy = this.model.y_units == \"data\" ? yscale.v_compute(this._y) : panel.yview.v_compute(this._y);\n            return [sx, sy];\n        }\n        render() {\n            if (!this.model.visible && this.model.render_mode == 'css')\n                dom_1.undisplay(this.el);\n            if (!this.model.visible)\n                return;\n            const draw = this.model.render_mode == 'canvas' ? this._v_canvas_text.bind(this) : this._v_css_text.bind(this);\n            const { ctx } = this.plot_view.canvas_view;\n            const [sx, sy] = this._map_data();\n            for (let i = 0, end = this._text.length; i < end; i++) {\n                draw(ctx, i, this._text[i], sx[i] + this._x_offset[i], sy[i] - this._y_offset[i], this._angle[i]);\n            }\n        }\n        _get_size() {\n            const { ctx } = this.plot_view.canvas_view;\n            this.visuals.text.set_value(ctx);\n            const { width, ascent } = ctx.measureText(this._text[0]);\n            return { width, height: ascent };\n        }\n        _v_canvas_text(ctx, i, text, sx, sy, angle) {\n            this.visuals.text.set_vectorize(ctx, i);\n            const bbox_dims = this._calculate_bounding_box_dimensions(ctx, text);\n            ctx.save();\n            ctx.beginPath();\n            ctx.translate(sx, sy);\n            ctx.rotate(angle);\n            ctx.rect(bbox_dims[0], bbox_dims[1], bbox_dims[2], bbox_dims[3]);\n            if (this.visuals.background_fill.doit) {\n                this.visuals.background_fill.set_vectorize(ctx, i);\n                ctx.fill();\n            }\n            if (this.visuals.border_line.doit) {\n                this.visuals.border_line.set_vectorize(ctx, i);\n                ctx.stroke();\n            }\n            if (this.visuals.text.doit) {\n                this.visuals.text.set_vectorize(ctx, i);\n                ctx.fillText(text, 0, 0);\n            }\n            ctx.restore();\n        }\n        _v_css_text(ctx, i, text, sx, sy, angle) {\n            const el = this.el.children[i];\n            el.textContent = text;\n            this.visuals.text.set_vectorize(ctx, i);\n            const bbox_dims = this._calculate_bounding_box_dimensions(ctx, text);\n            // attempt to support vector-style (\"8 4 8\") line dashing for css mode\n            const ld = this.visuals.border_line.line_dash.value();\n            const line_dash = ld.length < 2 ? \"solid\" : \"dashed\";\n            this.visuals.border_line.set_vectorize(ctx, i);\n            this.visuals.background_fill.set_vectorize(ctx, i);\n            el.style.position = 'absolute';\n            el.style.left = `${sx + bbox_dims[0]}px`;\n            el.style.top = `${sy + bbox_dims[1]}px`;\n            el.style.color = `${this.visuals.text.text_color.value()}`;\n            el.style.opacity = `${this.visuals.text.text_alpha.value()}`;\n            el.style.font = `${this.visuals.text.font_value()}`;\n            el.style.lineHeight = \"normal\"; // needed to prevent ipynb css override\n            if (angle) {\n                el.style.transform = `rotate(${angle}rad)`;\n            }\n            if (this.visuals.background_fill.doit) {\n                el.style.backgroundColor = `${this.visuals.background_fill.color_value()}`;\n            }\n            if (this.visuals.border_line.doit) {\n                el.style.borderStyle = `${line_dash}`;\n                el.style.borderWidth = `${this.visuals.border_line.line_width.value()}px`;\n                el.style.borderColor = `${this.visuals.border_line.color_value()}`;\n            }\n            dom_1.display(el);\n        }\n    }\n    exports.LabelSetView = LabelSetView;\n    LabelSetView.__name__ = \"LabelSetView\";\n    class LabelSet extends text_annotation_1.TextAnnotation {\n        constructor(attrs) {\n            super(attrs);\n        }\n        static init_LabelSet() {\n            this.prototype.default_view = LabelSetView;\n            this.mixins(['text', 'line:border_', 'fill:background_']);\n            this.define({\n                x: [p.NumberSpec],\n                y: [p.NumberSpec],\n                x_units: [p.SpatialUnits, 'data'],\n                y_units: [p.SpatialUnits, 'data'],\n                text: [p.StringSpec, { field: \"text\" }],\n                angle: [p.AngleSpec, 0],\n                x_offset: [p.NumberSpec, { value: 0 }],\n                y_offset: [p.NumberSpec, { value: 0 }],\n                source: [p.Instance, () => new column_data_source_1.ColumnDataSource()],\n                x_range_name: [p.String, 'default'],\n                y_range_name: [p.String, 'default'],\n            });\n            this.override({\n                background_fill_color: null,\n                border_line_color: null,\n            });\n        }\n    }\n    exports.LabelSet = LabelSet;\n    LabelSet.__name__ = \"LabelSet\";\n    LabelSet.init_LabelSet();\n}\n","/* models/annotations/legend.js */ function _(require, module, exports) {\n    const annotation_1 = require(29) /* ./annotation */;\n    const p = require(18) /* ../../core/properties */;\n    const signaling_1 = require(13) /* ../../core/signaling */;\n    const text_1 = require(124) /* ../../core/util/text */;\n    const bbox_1 = require(79) /* ../../core/util/bbox */;\n    const array_1 = require(8) /* ../../core/util/array */;\n    const object_1 = require(22) /* ../../core/util/object */;\n    const types_1 = require(7) /* ../../core/util/types */;\n    class LegendView extends annotation_1.AnnotationView {\n        cursor(_sx, _sy) {\n            return this.model.click_policy == \"none\" ? null : \"pointer\";\n        }\n        get legend_padding() {\n            return this.visuals.border_line.line_color.value() != null ? this.model.padding : 0;\n        }\n        connect_signals() {\n            super.connect_signals();\n            this.connect(this.model.change, () => this.plot_view.request_render());\n            this.connect(this.model.item_change, () => this.plot_view.request_render());\n        }\n        compute_legend_bbox() {\n            const legend_names = this.model.get_legend_names();\n            const { glyph_height, glyph_width } = this.model;\n            const { label_height, label_width } = this.model;\n            this.max_label_height = array_1.max([text_1.measure_font(this.visuals.label_text.font_value()).height, label_height, glyph_height]);\n            // this is to measure text properties\n            const { ctx } = this.plot_view.canvas_view;\n            ctx.save();\n            this.visuals.label_text.set_value(ctx);\n            this.text_widths = {};\n            for (const name of legend_names) {\n                this.text_widths[name] = array_1.max([ctx.measureText(name).width, label_width]);\n            }\n            this.visuals.title_text.set_value(ctx);\n            this.title_height = this.model.title ? text_1.measure_font(this.visuals.title_text.font_value()).height + this.model.title_standoff : 0;\n            this.title_width = this.model.title ? ctx.measureText(this.model.title).width : 0;\n            ctx.restore();\n            const max_label_width = Math.max(array_1.max(object_1.values(this.text_widths)), 0);\n            const legend_margin = this.model.margin;\n            const { legend_padding } = this;\n            const legend_spacing = this.model.spacing;\n            const { label_standoff } = this.model;\n            let legend_height, legend_width;\n            if (this.model.orientation == \"vertical\") {\n                legend_height = legend_names.length * this.max_label_height + Math.max(legend_names.length - 1, 0) * legend_spacing + 2 * legend_padding + this.title_height;\n                legend_width = array_1.max([(max_label_width + glyph_width + label_standoff + 2 * legend_padding), this.title_width + 2 * legend_padding]);\n            }\n            else {\n                let item_width = 2 * legend_padding + Math.max(legend_names.length - 1, 0) * legend_spacing;\n                for (const name in this.text_widths) {\n                    const width = this.text_widths[name];\n                    item_width += array_1.max([width, label_width]) + glyph_width + label_standoff;\n                }\n                legend_width = array_1.max([this.title_width + 2 * legend_padding, item_width]);\n                legend_height = this.max_label_height + this.title_height + 2 * legend_padding;\n            }\n            const panel = this.panel != null ? this.panel : this.plot_view.frame;\n            const [hr, vr] = panel.bbox.ranges;\n            const { location } = this.model;\n            let sx, sy;\n            if (types_1.isString(location)) {\n                switch (location) {\n                    case 'top_left':\n                        sx = hr.start + legend_margin;\n                        sy = vr.start + legend_margin;\n                        break;\n                    case 'top_center':\n                        sx = (hr.end + hr.start) / 2 - legend_width / 2;\n                        sy = vr.start + legend_margin;\n                        break;\n                    case 'top_right':\n                        sx = hr.end - legend_margin - legend_width;\n                        sy = vr.start + legend_margin;\n                        break;\n                    case 'bottom_right':\n                        sx = hr.end - legend_margin - legend_width;\n                        sy = vr.end - legend_margin - legend_height;\n                        break;\n                    case 'bottom_center':\n                        sx = (hr.end + hr.start) / 2 - legend_width / 2;\n                        sy = vr.end - legend_margin - legend_height;\n                        break;\n                    case 'bottom_left':\n                        sx = hr.start + legend_margin;\n                        sy = vr.end - legend_margin - legend_height;\n                        break;\n                    case 'center_left':\n                        sx = hr.start + legend_margin;\n                        sy = (vr.end + vr.start) / 2 - legend_height / 2;\n                        break;\n                    case 'center':\n                        sx = (hr.end + hr.start) / 2 - legend_width / 2;\n                        sy = (vr.end + vr.start) / 2 - legend_height / 2;\n                        break;\n                    case 'center_right':\n                        sx = hr.end - legend_margin - legend_width;\n                        sy = (vr.end + vr.start) / 2 - legend_height / 2;\n                        break;\n                    default:\n                        throw new Error(\"unreachable code\");\n                }\n            }\n            else if (types_1.isArray(location) && location.length == 2) {\n                const [vx, vy] = location;\n                sx = panel.xview.compute(vx);\n                sy = panel.yview.compute(vy) - legend_height;\n            }\n            else\n                throw new Error(\"unreachable code\");\n            return new bbox_1.BBox({ left: sx, top: sy, width: legend_width, height: legend_height });\n        }\n        interactive_bbox() {\n            return this.compute_legend_bbox();\n        }\n        interactive_hit(sx, sy) {\n            const bbox = this.interactive_bbox();\n            return bbox.contains(sx, sy);\n        }\n        on_hit(sx, sy) {\n            let yoffset;\n            const { glyph_width } = this.model;\n            const { legend_padding } = this;\n            const legend_spacing = this.model.spacing;\n            const { label_standoff } = this.model;\n            let xoffset = (yoffset = legend_padding);\n            const legend_bbox = this.compute_legend_bbox();\n            const vertical = this.model.orientation == \"vertical\";\n            for (const item of this.model.items) {\n                const labels = item.get_labels_list_from_label_prop();\n                for (const label of labels) {\n                    const x1 = legend_bbox.x + xoffset;\n                    const y1 = legend_bbox.y + yoffset + this.title_height;\n                    let w, h;\n                    if (vertical)\n                        [w, h] = [legend_bbox.width - 2 * legend_padding, this.max_label_height];\n                    else\n                        [w, h] = [this.text_widths[label] + glyph_width + label_standoff, this.max_label_height];\n                    const bbox = new bbox_1.BBox({ left: x1, top: y1, width: w, height: h });\n                    if (bbox.contains(sx, sy)) {\n                        switch (this.model.click_policy) {\n                            case \"hide\": {\n                                for (const r of item.renderers)\n                                    r.visible = !r.visible;\n                                break;\n                            }\n                            case \"mute\": {\n                                for (const r of item.renderers)\n                                    r.muted = !r.muted;\n                                break;\n                            }\n                        }\n                        return true;\n                    }\n                    if (vertical)\n                        yoffset += this.max_label_height + legend_spacing;\n                    else\n                        xoffset += this.text_widths[label] + glyph_width + label_standoff + legend_spacing;\n                }\n            }\n            return false;\n        }\n        render() {\n            if (!this.model.visible)\n                return;\n            if (this.model.items.length == 0)\n                return;\n            // set a backref on render so that items can later signal item_change upates\n            // on the model to trigger a re-render\n            for (const item of this.model.items) {\n                item.legend = this.model;\n            }\n            const { ctx } = this.plot_view.canvas_view;\n            const bbox = this.compute_legend_bbox();\n            ctx.save();\n            this._draw_legend_box(ctx, bbox);\n            this._draw_legend_items(ctx, bbox);\n            if (this.model.title)\n                this._draw_title(ctx, bbox);\n            ctx.restore();\n        }\n        _draw_legend_box(ctx, bbox) {\n            ctx.beginPath();\n            ctx.rect(bbox.x, bbox.y, bbox.width, bbox.height);\n            this.visuals.background_fill.set_value(ctx);\n            ctx.fill();\n            if (this.visuals.border_line.doit) {\n                this.visuals.border_line.set_value(ctx);\n                ctx.stroke();\n            }\n        }\n        _draw_legend_items(ctx, bbox) {\n            const { glyph_width, glyph_height } = this.model;\n            const { legend_padding } = this;\n            const legend_spacing = this.model.spacing;\n            const { label_standoff } = this.model;\n            let xoffset = legend_padding;\n            let yoffset = legend_padding;\n            const vertical = this.model.orientation == \"vertical\";\n            for (const item of this.model.items) {\n                const labels = item.get_labels_list_from_label_prop();\n                const field = item.get_field_from_label_prop();\n                if (labels.length == 0)\n                    continue;\n                const active = (() => {\n                    switch (this.model.click_policy) {\n                        case \"none\": return true;\n                        case \"hide\": return array_1.every(item.renderers, r => r.visible);\n                        case \"mute\": return array_1.every(item.renderers, r => !r.muted);\n                    }\n                })();\n                for (const label of labels) {\n                    const x1 = bbox.x + xoffset;\n                    const y1 = bbox.y + yoffset + this.title_height;\n                    const x2 = x1 + glyph_width;\n                    const y2 = y1 + glyph_height;\n                    if (vertical)\n                        yoffset += this.max_label_height + legend_spacing;\n                    else\n                        xoffset += this.text_widths[label] + glyph_width + label_standoff + legend_spacing;\n                    this.visuals.label_text.set_value(ctx);\n                    ctx.fillText(label, x2 + label_standoff, y1 + this.max_label_height / 2.0);\n                    for (const r of item.renderers) {\n                        const view = this.plot_view.renderer_views[r.id];\n                        view.draw_legend(ctx, x1, x2, y1, y2, field, label, item.index);\n                    }\n                    if (!active) {\n                        let w, h;\n                        if (vertical)\n                            [w, h] = [bbox.width - 2 * legend_padding, this.max_label_height];\n                        else\n                            [w, h] = [this.text_widths[label] + glyph_width + label_standoff, this.max_label_height];\n                        ctx.beginPath();\n                        ctx.rect(x1, y1, w, h);\n                        this.visuals.inactive_fill.set_value(ctx);\n                        ctx.fill();\n                    }\n                }\n            }\n        }\n        _draw_title(ctx, bbox) {\n            if (!this.visuals.title_text.doit)\n                return;\n            ctx.save();\n            ctx.translate(bbox.x0, bbox.y0 + this.title_height);\n            this.visuals.title_text.set_value(ctx);\n            ctx.fillText(this.model.title, this.legend_padding, this.legend_padding - this.model.title_standoff);\n            ctx.restore();\n        }\n        _get_size() {\n            const { width, height } = this.compute_legend_bbox();\n            return {\n                width: width + 2 * this.model.margin,\n                height: height + 2 * this.model.margin,\n            };\n        }\n    }\n    exports.LegendView = LegendView;\n    LegendView.__name__ = \"LegendView\";\n    class Legend extends annotation_1.Annotation {\n        constructor(attrs) {\n            super(attrs);\n        }\n        initialize() {\n            super.initialize();\n            this.item_change = new signaling_1.Signal0(this, \"item_change\");\n        }\n        static init_Legend() {\n            this.prototype.default_view = LegendView;\n            this.mixins([\n                'text:label_',\n                'text:title_',\n                'fill:inactive_',\n                'line:border_',\n                'fill:background_',\n            ]);\n            this.define({\n                orientation: [p.Orientation, 'vertical'],\n                location: [p.Any, 'top_right'],\n                title: [p.String],\n                title_standoff: [p.Number, 5],\n                label_standoff: [p.Number, 5],\n                glyph_height: [p.Number, 20],\n                glyph_width: [p.Number, 20],\n                label_height: [p.Number, 20],\n                label_width: [p.Number, 20],\n                margin: [p.Number, 10],\n                padding: [p.Number, 10],\n                spacing: [p.Number, 3],\n                items: [p.Array, []],\n                click_policy: [p.Any, \"none\"],\n            });\n            this.override({\n                border_line_color: \"#e5e5e5\",\n                border_line_alpha: 0.5,\n                border_line_width: 1,\n                background_fill_color: \"#ffffff\",\n                background_fill_alpha: 0.95,\n                inactive_fill_color: \"white\",\n                inactive_fill_alpha: 0.7,\n                label_text_font_size: \"10pt\",\n                label_text_baseline: \"middle\",\n                title_text_font_size: \"10pt\",\n                title_text_font_style: \"italic\",\n            });\n        }\n        get_legend_names() {\n            const legend_names = [];\n            for (const item of this.items) {\n                const labels = item.get_labels_list_from_label_prop();\n                legend_names.push(...labels);\n            }\n            return legend_names;\n        }\n    }\n    exports.Legend = Legend;\n    Legend.__name__ = \"Legend\";\n    Legend.init_Legend();\n}\n","/* models/annotations/legend_item.js */ function _(require, module, exports) {\n    const model_1 = require(64) /* ../../model */;\n    const columnar_data_source_1 = require(69) /* ../sources/columnar_data_source */;\n    const vectorization_1 = require(130) /* ../../core/vectorization */;\n    const p = require(18) /* ../../core/properties */;\n    const logging_1 = require(65) /* ../../core/logging */;\n    const array_1 = require(8) /* ../../core/util/array */;\n    class LegendItem extends model_1.Model {\n        constructor(attrs) {\n            super(attrs);\n        }\n        static init_LegendItem() {\n            this.define({\n                label: [p.StringSpec, null],\n                renderers: [p.Array, []],\n                index: [p.Number, null],\n            });\n        }\n        /*protected*/ _check_data_sources_on_renderers() {\n            const field = this.get_field_from_label_prop();\n            if (field != null) {\n                if (this.renderers.length < 1) {\n                    return false;\n                }\n                const source = this.renderers[0].data_source;\n                if (source != null) {\n                    for (const r of this.renderers) {\n                        if (r.data_source != source) {\n                            return false;\n                        }\n                    }\n                }\n            }\n            return true;\n        }\n        /*protected*/ _check_field_label_on_data_source() {\n            const field = this.get_field_from_label_prop();\n            if (field != null) {\n                if (this.renderers.length < 1) {\n                    return false;\n                }\n                const source = this.renderers[0].data_source;\n                if (source != null && !array_1.includes(source.columns(), field)) {\n                    return false;\n                }\n            }\n            return true;\n        }\n        initialize() {\n            super.initialize();\n            this.legend = null;\n            this.connect(this.change, () => {\n                if (this.legend != null)\n                    this.legend.item_change.emit();\n            });\n            // Validate data_sources match\n            const data_source_validation = this._check_data_sources_on_renderers();\n            if (!data_source_validation)\n                logging_1.logger.error(\"Non matching data sources on legend item renderers\");\n            // Validate label in data_source\n            const field_validation = this._check_field_label_on_data_source();\n            if (!field_validation)\n                logging_1.logger.error(`Bad column name on label: ${this.label}`);\n        }\n        get_field_from_label_prop() {\n            const { label } = this;\n            return vectorization_1.isField(label) ? label.field : null;\n        }\n        get_labels_list_from_label_prop() {\n            // Always return a list of the labels\n            if (vectorization_1.isValue(this.label)) {\n                const { value } = this.label;\n                return value != null ? [value] : [];\n            }\n            const field = this.get_field_from_label_prop();\n            if (field != null) {\n                let source;\n                if (this.renderers[0] && this.renderers[0].data_source != null)\n                    source = this.renderers[0].data_source;\n                else\n                    return [\"No source found\"];\n                if (source instanceof columnar_data_source_1.ColumnarDataSource) {\n                    const data = source.get_column(field);\n                    if (data != null)\n                        return array_1.uniq(Array.from(data));\n                    else\n                        return [\"Invalid field\"];\n                }\n            }\n            return [];\n        }\n    }\n    exports.LegendItem = LegendItem;\n    LegendItem.__name__ = \"LegendItem\";\n    LegendItem.init_LegendItem();\n}\n","/* core/vectorization.js */ function _(require, module, exports) {\n    const types_1 = require(7) /* ./util/types */;\n    function isValue(obj) {\n        return types_1.isPlainObject(obj) && \"value\" in obj;\n    }\n    exports.isValue = isValue;\n    function isField(obj) {\n        return types_1.isPlainObject(obj) && \"field\" in obj;\n    }\n    exports.isField = isField;\n}\n","/* models/annotations/poly_annotation.js */ function _(require, module, exports) {\n    const annotation_1 = require(29) /* ./annotation */;\n    const signaling_1 = require(13) /* ../../core/signaling */;\n    const p = require(18) /* ../../core/properties */;\n    class PolyAnnotationView extends annotation_1.AnnotationView {\n        connect_signals() {\n            super.connect_signals();\n            // need to respond to either normal BB change events or silent\n            // \"data only updates\" that tools might want to use\n            this.connect(this.model.change, () => this.plot_view.request_render());\n            this.connect(this.model.data_update, () => this.plot_view.request_render());\n        }\n        render() {\n            if (!this.model.visible)\n                return;\n            const { xs, ys } = this.model;\n            if (xs.length != ys.length)\n                return;\n            if (xs.length < 3 || ys.length < 3)\n                return;\n            const { frame } = this.plot_view;\n            const { ctx } = this.plot_view.canvas_view;\n            for (let i = 0, end = xs.length; i < end; i++) {\n                let sx;\n                if (this.model.xs_units == 'screen')\n                    sx = this.model.screen ? xs[i] : frame.xview.compute(xs[i]);\n                else\n                    throw new Error(\"not implemented\");\n                let sy;\n                if (this.model.ys_units == 'screen')\n                    sy = this.model.screen ? ys[i] : frame.yview.compute(ys[i]);\n                else\n                    throw new Error(\"not implemented\");\n                if (i == 0) {\n                    ctx.beginPath();\n                    ctx.moveTo(sx, sy);\n                }\n                else {\n                    ctx.lineTo(sx, sy);\n                }\n            }\n            ctx.closePath();\n            if (this.visuals.line.doit) {\n                this.visuals.line.set_value(ctx);\n                ctx.stroke();\n            }\n            if (this.visuals.fill.doit) {\n                this.visuals.fill.set_value(ctx);\n                ctx.fill();\n            }\n        }\n    }\n    exports.PolyAnnotationView = PolyAnnotationView;\n    PolyAnnotationView.__name__ = \"PolyAnnotationView\";\n    class PolyAnnotation extends annotation_1.Annotation {\n        constructor(attrs) {\n            super(attrs);\n        }\n        static init_PolyAnnotation() {\n            this.prototype.default_view = PolyAnnotationView;\n            this.mixins(['line', 'fill']);\n            this.define({\n                xs: [p.Array, []],\n                xs_units: [p.SpatialUnits, 'data'],\n                ys: [p.Array, []],\n                ys_units: [p.SpatialUnits, 'data'],\n                x_range_name: [p.String, 'default'],\n                y_range_name: [p.String, 'default'],\n            });\n            this.internal({\n                screen: [p.Boolean, false],\n            });\n            this.override({\n                fill_color: \"#fff9ba\",\n                fill_alpha: 0.4,\n                line_color: \"#cccccc\",\n                line_alpha: 0.3,\n            });\n        }\n        initialize() {\n            super.initialize();\n            this.data_update = new signaling_1.Signal0(this, \"data_update\");\n        }\n        update({ xs, ys }) {\n            this.setv({ xs, ys, screen: true }, { silent: true });\n            this.data_update.emit();\n        }\n    }\n    exports.PolyAnnotation = PolyAnnotation;\n    PolyAnnotation.__name__ = \"PolyAnnotation\";\n    PolyAnnotation.init_PolyAnnotation();\n}\n","/* models/annotations/slope.js */ function _(require, module, exports) {\n    const annotation_1 = require(29) /* ./annotation */;\n    const p = require(18) /* ../../core/properties */;\n    class SlopeView extends annotation_1.AnnotationView {\n        initialize() {\n            super.initialize();\n        }\n        connect_signals() {\n            super.connect_signals();\n            this.connect(this.model.change, () => this.plot_view.request_render());\n        }\n        render() {\n            if (!this.model.visible)\n                return;\n            this._draw_slope();\n        }\n        _draw_slope() {\n            const gradient = this.model.gradient;\n            const y_intercept = this.model.y_intercept;\n            if (gradient == null || y_intercept == null) {\n                return;\n            }\n            const { frame } = this.plot_view;\n            const xscale = frame.xscales[this.model.x_range_name];\n            const yscale = frame.yscales[this.model.y_range_name];\n            const sy_start = frame._top.value;\n            const sy_end = sy_start + frame._height.value;\n            const y_start = yscale.invert(sy_start);\n            const y_end = yscale.invert(sy_end);\n            const x_start = (y_start - y_intercept) / gradient;\n            const x_end = (y_end - y_intercept) / gradient;\n            const sx_start = xscale.compute(x_start);\n            const sx_end = xscale.compute(x_end);\n            const { ctx } = this.plot_view.canvas_view;\n            ctx.save();\n            ctx.beginPath();\n            this.visuals.line.set_value(ctx);\n            ctx.moveTo(sx_start, sy_start);\n            ctx.lineTo(sx_end, sy_end);\n            ctx.stroke();\n            ctx.restore();\n        }\n    }\n    exports.SlopeView = SlopeView;\n    SlopeView.__name__ = \"SlopeView\";\n    class Slope extends annotation_1.Annotation {\n        constructor(attrs) {\n            super(attrs);\n        }\n        static init_Slope() {\n            this.prototype.default_view = SlopeView;\n            this.mixins(['line']);\n            this.define({\n                gradient: [p.Number, null],\n                y_intercept: [p.Number, null],\n                x_range_name: [p.String, 'default'],\n                y_range_name: [p.String, 'default'],\n            });\n            this.override({\n                line_color: 'black',\n            });\n        }\n    }\n    exports.Slope = Slope;\n    Slope.__name__ = \"Slope\";\n    Slope.init_Slope();\n}\n","/* models/annotations/span.js */ function _(require, module, exports) {\n    const annotation_1 = require(29) /* ./annotation */;\n    const dom_1 = require(61) /* ../../core/dom */;\n    const p = require(18) /* ../../core/properties */;\n    class SpanView extends annotation_1.AnnotationView {\n        initialize() {\n            super.initialize();\n            this.plot_view.canvas_overlays.appendChild(this.el);\n            this.el.style.position = \"absolute\";\n            dom_1.undisplay(this.el);\n        }\n        connect_signals() {\n            super.connect_signals();\n            if (this.model.for_hover)\n                this.connect(this.model.properties.computed_location.change, () => this._draw_span());\n            else {\n                if (this.model.render_mode == 'canvas') {\n                    this.connect(this.model.change, () => this.plot_view.request_render());\n                    this.connect(this.model.properties.location.change, () => this.plot_view.request_render());\n                }\n                else {\n                    this.connect(this.model.change, () => this.render());\n                    this.connect(this.model.properties.location.change, () => this._draw_span());\n                }\n            }\n        }\n        render() {\n            if (!this.model.visible && this.model.render_mode == 'css')\n                dom_1.undisplay(this.el);\n            if (!this.model.visible)\n                return;\n            this._draw_span();\n        }\n        _draw_span() {\n            const loc = this.model.for_hover ? this.model.computed_location : this.model.location;\n            if (loc == null) {\n                dom_1.undisplay(this.el);\n                return;\n            }\n            const { frame } = this.plot_view;\n            const xscale = frame.xscales[this.model.x_range_name];\n            const yscale = frame.yscales[this.model.y_range_name];\n            const _calc_dim = (scale, view) => {\n                if (this.model.for_hover)\n                    return this.model.computed_location;\n                else {\n                    if (this.model.location_units == 'data')\n                        return scale.compute(loc);\n                    else\n                        return view.compute(loc);\n                }\n            };\n            let height, sleft, stop, width;\n            if (this.model.dimension == 'width') {\n                stop = _calc_dim(yscale, frame.yview);\n                sleft = frame._left.value;\n                width = frame._width.value;\n                height = this.model.properties.line_width.value();\n            }\n            else {\n                stop = frame._top.value;\n                sleft = _calc_dim(xscale, frame.xview);\n                width = this.model.properties.line_width.value();\n                height = frame._height.value;\n            }\n            if (this.model.render_mode == \"css\") {\n                this.el.style.top = `${stop}px`;\n                this.el.style.left = `${sleft}px`;\n                this.el.style.width = `${width}px`;\n                this.el.style.height = `${height}px`;\n                this.el.style.backgroundColor = this.model.properties.line_color.value();\n                this.el.style.opacity = this.model.properties.line_alpha.value();\n                dom_1.display(this.el);\n            }\n            else if (this.model.render_mode == \"canvas\") {\n                const { ctx } = this.plot_view.canvas_view;\n                ctx.save();\n                ctx.beginPath();\n                this.visuals.line.set_value(ctx);\n                ctx.moveTo(sleft, stop);\n                if (this.model.dimension == \"width\") {\n                    ctx.lineTo(sleft + width, stop);\n                }\n                else {\n                    ctx.lineTo(sleft, stop + height);\n                }\n                ctx.stroke();\n                ctx.restore();\n            }\n        }\n    }\n    exports.SpanView = SpanView;\n    SpanView.__name__ = \"SpanView\";\n    class Span extends annotation_1.Annotation {\n        constructor(attrs) {\n            super(attrs);\n        }\n        static init_Span() {\n            this.prototype.default_view = SpanView;\n            this.mixins(['line']);\n            this.define({\n                render_mode: [p.RenderMode, 'canvas'],\n                x_range_name: [p.String, 'default'],\n                y_range_name: [p.String, 'default'],\n                location: [p.Number, null],\n                location_units: [p.SpatialUnits, 'data'],\n                dimension: [p.Dimension, 'width'],\n            });\n            this.override({\n                line_color: 'black',\n            });\n            this.internal({\n                for_hover: [p.Boolean, false],\n                computed_location: [p.Number, null],\n            });\n        }\n    }\n    exports.Span = Span;\n    Span.__name__ = \"Span\";\n    Span.init_Span();\n}\n","/* models/annotations/title.js */ function _(require, module, exports) {\n    const text_annotation_1 = require(126) /* ./text_annotation */;\n    const dom_1 = require(61) /* ../../core/dom */;\n    const visuals_1 = require(63) /* ../../core/visuals */;\n    const p = require(18) /* ../../core/properties */;\n    class TitleView extends text_annotation_1.TextAnnotationView {\n        initialize() {\n            super.initialize();\n            this.visuals.text = new visuals_1.Text(this.model);\n        }\n        _get_location() {\n            const panel = this.panel;\n            const hmargin = this.model.offset;\n            const vmargin = 5;\n            let sx, sy;\n            switch (panel.side) {\n                case 'above':\n                case 'below': {\n                    switch (this.model.vertical_align) {\n                        case 'top':\n                            sy = panel._top.value + vmargin;\n                            break;\n                        case 'middle':\n                            sy = panel._vcenter.value;\n                            break;\n                        case 'bottom':\n                            sy = panel._bottom.value - vmargin;\n                            break;\n                        default: throw new Error(\"unreachable code\");\n                    }\n                    switch (this.model.align) {\n                        case 'left':\n                            sx = panel._left.value + hmargin;\n                            break;\n                        case 'center':\n                            sx = panel._hcenter.value;\n                            break;\n                        case 'right':\n                            sx = panel._right.value - hmargin;\n                            break;\n                        default: throw new Error(\"unreachable code\");\n                    }\n                    break;\n                }\n                case 'left': {\n                    switch (this.model.vertical_align) {\n                        case 'top':\n                            sx = panel._left.value - vmargin;\n                            break;\n                        case 'middle':\n                            sx = panel._hcenter.value;\n                            break;\n                        case 'bottom':\n                            sx = panel._right.value + vmargin;\n                            break;\n                        default: throw new Error(\"unreachable code\");\n                    }\n                    switch (this.model.align) {\n                        case 'left':\n                            sy = panel._bottom.value - hmargin;\n                            break;\n                        case 'center':\n                            sy = panel._vcenter.value;\n                            break;\n                        case 'right':\n                            sy = panel._top.value + hmargin;\n                            break;\n                        default: throw new Error(\"unreachable code\");\n                    }\n                    break;\n                }\n                case 'right': {\n                    switch (this.model.vertical_align) {\n                        case 'top':\n                            sx = panel._right.value - vmargin;\n                            break;\n                        case 'middle':\n                            sx = panel._hcenter.value;\n                            break;\n                        case 'bottom':\n                            sx = panel._left.value + vmargin;\n                            break;\n                        default: throw new Error(\"unreachable code\");\n                    }\n                    switch (this.model.align) {\n                        case 'left':\n                            sy = panel._top.value + hmargin;\n                            break;\n                        case 'center':\n                            sy = panel._vcenter.value;\n                            break;\n                        case 'right':\n                            sy = panel._bottom.value - hmargin;\n                            break;\n                        default: throw new Error(\"unreachable code\");\n                    }\n                    break;\n                }\n                default: throw new Error(\"unreachable code\");\n            }\n            return [sx, sy];\n        }\n        render() {\n            if (!this.model.visible) {\n                if (this.model.render_mode == 'css')\n                    dom_1.undisplay(this.el);\n                return;\n            }\n            const { text } = this.model;\n            if (text == null || text.length == 0)\n                return;\n            this.model.text_baseline = this.model.vertical_align;\n            this.model.text_align = this.model.align;\n            const [sx, sy] = this._get_location();\n            const angle = this.panel.get_label_angle_heuristic('parallel');\n            const draw = this.model.render_mode == 'canvas' ? this._canvas_text.bind(this) : this._css_text.bind(this);\n            draw(this.plot_view.canvas_view.ctx, text, sx, sy, angle);\n        }\n        _get_size() {\n            const { text } = this.model;\n            if (text == null || text.length == 0)\n                return { width: 0, height: 0 };\n            else {\n                this.visuals.text.set_value(this.ctx);\n                const { width, ascent } = this.ctx.measureText(text);\n                return { width, height: ascent * this.visuals.text.text_line_height.value() + 10 };\n            }\n        }\n    }\n    exports.TitleView = TitleView;\n    TitleView.__name__ = \"TitleView\";\n    class Title extends text_annotation_1.TextAnnotation {\n        constructor(attrs) {\n            super(attrs);\n        }\n        static init_Title() {\n            this.prototype.default_view = TitleView;\n            this.mixins(['line:border_', 'fill:background_']);\n            this.define({\n                text: [p.String],\n                text_font: [p.Font, 'helvetica'],\n                text_font_size: [p.FontSizeSpec, '10pt'],\n                text_font_style: [p.FontStyle, 'bold'],\n                text_color: [p.ColorSpec, '#444444'],\n                text_alpha: [p.NumberSpec, 1.0],\n                text_line_height: [p.Number, 1.0],\n                vertical_align: [p.VerticalAlign, 'bottom'],\n                align: [p.TextAlign, 'left'],\n                offset: [p.Number, 0],\n            });\n            this.override({\n                background_fill_color: null,\n                border_line_color: null,\n            });\n            this.internal({\n                text_align: [p.TextAlign, 'left'],\n                text_baseline: [p.TextBaseline, 'bottom'],\n            });\n        }\n    }\n    exports.Title = Title;\n    Title.__name__ = \"Title\";\n    Title.init_Title();\n}\n","/* models/annotations/toolbar_panel.js */ function _(require, module, exports) {\n    const annotation_1 = require(29) /* ./annotation */;\n    const build_views_1 = require(92) /* ../../core/build_views */;\n    const dom_1 = require(61) /* ../../core/dom */;\n    const p = require(18) /* ../../core/properties */;\n    class ToolbarPanelView extends annotation_1.AnnotationView {\n        constructor() {\n            super(...arguments);\n            this.rotate = true;\n        }\n        initialize() {\n            super.initialize();\n            this.plot_view.canvas_events.appendChild(this.el);\n            this._toolbar_views = {};\n            build_views_1.build_views(this._toolbar_views, [this.model.toolbar], { parent: this });\n            const toolbar_view = this._toolbar_views[this.model.toolbar.id];\n            this.plot_view.visibility_callbacks.push((visible) => toolbar_view.set_visibility(visible));\n        }\n        remove() {\n            build_views_1.remove_views(this._toolbar_views);\n            super.remove();\n        }\n        render() {\n            super.render();\n            if (!this.model.visible) {\n                dom_1.undisplay(this.el);\n                return;\n            }\n            this.el.style.position = \"absolute\";\n            this.el.style.overflow = \"hidden\";\n            dom_1.position(this.el, this.panel.bbox);\n            const toolbar_view = this._toolbar_views[this.model.toolbar.id];\n            toolbar_view.render();\n            dom_1.empty(this.el);\n            this.el.appendChild(toolbar_view.el);\n            dom_1.display(this.el);\n        }\n        _get_size() {\n            const { tools, logo } = this.model.toolbar;\n            return {\n                width: tools.length * 30 + (logo != null ? 25 : 0),\n                height: 30,\n            };\n        }\n    }\n    exports.ToolbarPanelView = ToolbarPanelView;\n    ToolbarPanelView.__name__ = \"ToolbarPanelView\";\n    class ToolbarPanel extends annotation_1.Annotation {\n        constructor(attrs) {\n            super(attrs);\n        }\n        static init_ToolbarPanel() {\n            this.prototype.default_view = ToolbarPanelView;\n            this.define({\n                toolbar: [p.Instance],\n            });\n        }\n    }\n    exports.ToolbarPanel = ToolbarPanel;\n    ToolbarPanel.__name__ = \"ToolbarPanel\";\n    ToolbarPanel.init_ToolbarPanel();\n}\n","/* models/annotations/tooltip.js */ function _(require, module, exports) {\n    const annotation_1 = require(29) /* ./annotation */;\n    const dom_1 = require(61) /* ../../core/dom */;\n    const p = require(18) /* ../../core/properties */;\n    const tooltips_1 = require(137) /* ../../styles/tooltips */;\n    const mixins_1 = require(138) /* ../../styles/mixins */;\n    function compute_side(attachment, sx, sy, hcenter, vcenter) {\n        switch (attachment) {\n            case \"horizontal\":\n                return sx < hcenter ? \"right\" : \"left\";\n            case \"vertical\":\n                return sy < vcenter ? \"below\" : \"above\";\n            default:\n                return attachment;\n        }\n    }\n    exports.compute_side = compute_side;\n    class TooltipView extends annotation_1.AnnotationView {\n        initialize() {\n            super.initialize();\n            // TODO (bev) really probably need multiple divs\n            this.plot_view.canvas_overlays.appendChild(this.el);\n            dom_1.undisplay(this.el);\n        }\n        connect_signals() {\n            super.connect_signals();\n            this.connect(this.model.properties.data.change, () => this._draw_tips());\n        }\n        css_classes() {\n            return super.css_classes().concat(tooltips_1.bk_tooltip);\n        }\n        render() {\n            if (!this.model.visible)\n                return;\n            this._draw_tips();\n        }\n        _draw_tips() {\n            const { data } = this.model;\n            dom_1.empty(this.el);\n            dom_1.undisplay(this.el);\n            if (this.model.custom)\n                this.el.classList.add(tooltips_1.bk_tooltip_custom);\n            else\n                this.el.classList.remove(tooltips_1.bk_tooltip_custom);\n            if (data.length == 0)\n                return;\n            const { frame } = this.plot_view;\n            for (const [sx, sy, content] of data) {\n                if (this.model.inner_only && !frame.bbox.contains(sx, sy))\n                    continue;\n                const tip = dom_1.div({}, content);\n                this.el.appendChild(tip);\n            }\n            const [sx, sy] = data[data.length - 1]; // XXX: this previously depended on {sx, sy} leaking from the for-loop\n            const side = compute_side(this.model.attachment, sx, sy, frame._hcenter.value, frame._vcenter.value);\n            this.el.classList.remove(mixins_1.bk_right);\n            this.el.classList.remove(mixins_1.bk_left);\n            this.el.classList.remove(mixins_1.bk_above);\n            this.el.classList.remove(mixins_1.bk_below);\n            const arrow_size = 10; // XXX: keep in sync with less\n            dom_1.display(this.el); // XXX: {offset,client}Width() gives 0 when display=\"none\"\n            // slightly confusing: side \"left\" (for example) is relative to point that\n            // is being annotated but CS class \".bk-left\" is relative to the tooltip itself\n            let left, top;\n            switch (side) {\n                case \"right\":\n                    this.el.classList.add(mixins_1.bk_left);\n                    left = sx + (this.el.offsetWidth - this.el.clientWidth) + arrow_size;\n                    top = sy - this.el.offsetHeight / 2;\n                    break;\n                case \"left\":\n                    this.el.classList.add(mixins_1.bk_right);\n                    left = sx - this.el.offsetWidth - arrow_size;\n                    top = sy - this.el.offsetHeight / 2;\n                    break;\n                case \"below\":\n                    this.el.classList.add(mixins_1.bk_above);\n                    top = sy + (this.el.offsetHeight - this.el.clientHeight) + arrow_size;\n                    left = Math.round(sx - this.el.offsetWidth / 2);\n                    break;\n                case \"above\":\n                    this.el.classList.add(mixins_1.bk_below);\n                    top = sy - this.el.offsetHeight - arrow_size;\n                    left = Math.round(sx - this.el.offsetWidth / 2);\n                    break;\n                default:\n                    throw new Error(\"unreachable code\");\n            }\n            if (this.model.show_arrow)\n                this.el.classList.add(tooltips_1.bk_tooltip_arrow);\n            // TODO (bev) this is not currently bulletproof. If there are\n            // two hits, not colocated and one is off the screen, that can\n            // be problematic\n            if (this.el.childNodes.length > 0) {\n                this.el.style.top = `${top}px`;\n                this.el.style.left = `${left}px`;\n            }\n            else\n                dom_1.undisplay(this.el);\n        }\n    }\n    exports.TooltipView = TooltipView;\n    TooltipView.__name__ = \"TooltipView\";\n    class Tooltip extends annotation_1.Annotation {\n        constructor(attrs) {\n            super(attrs);\n        }\n        static init_Tooltip() {\n            this.prototype.default_view = TooltipView;\n            this.define({\n                attachment: [p.TooltipAttachment, 'horizontal'],\n                inner_only: [p.Boolean, true],\n                show_arrow: [p.Boolean, true],\n            });\n            this.override({\n                level: 'overlay',\n            });\n            this.internal({\n                data: [p.Any, []],\n                custom: [p.Any],\n            });\n        }\n        clear() {\n            this.data = [];\n        }\n        add(sx, sy, content) {\n            this.data = this.data.concat([[sx, sy, content]]);\n        }\n    }\n    exports.Tooltip = Tooltip;\n    Tooltip.__name__ = \"Tooltip\";\n    Tooltip.init_Tooltip();\n}\n","/* styles/tooltips.js */ function _(require, module, exports) {\n    require(62) /* ./root */;\n    const _a = require(61) /* ../core/dom */;\n    _a.styles.append(\".bk-root {\\n  /* Same border color used everywhere */\\n  /* Gray of icons */\\n}\\n.bk-root .bk-tooltip {\\n  font-weight: 300;\\n  font-size: 12px;\\n  position: absolute;\\n  padding: 5px;\\n  border: 1px solid #e5e5e5;\\n  color: #2f2f2f;\\n  background-color: white;\\n  pointer-events: none;\\n  opacity: 0.95;\\n  z-index: 100;\\n}\\n.bk-root .bk-tooltip > div:not(:first-child) {\\n  /* gives space when multiple elements are being hovered over */\\n  margin-top: 5px;\\n  border-top: #e5e5e5 1px dashed;\\n}\\n.bk-root .bk-tooltip.bk-left.bk-tooltip-arrow::before {\\n  position: absolute;\\n  margin: -7px 0 0 0;\\n  top: 50%;\\n  width: 0;\\n  height: 0;\\n  border-style: solid;\\n  border-width: 7px 0 7px 0;\\n  border-color: transparent;\\n  content: \\\" \\\";\\n  display: block;\\n  left: -10px;\\n  border-right-width: 10px;\\n  border-right-color: #909599;\\n}\\n.bk-root .bk-tooltip.bk-left::before {\\n  left: -10px;\\n  border-right-width: 10px;\\n  border-right-color: #909599;\\n}\\n.bk-root .bk-tooltip.bk-right.bk-tooltip-arrow::after {\\n  position: absolute;\\n  margin: -7px 0 0 0;\\n  top: 50%;\\n  width: 0;\\n  height: 0;\\n  border-style: solid;\\n  border-width: 7px 0 7px 0;\\n  border-color: transparent;\\n  content: \\\" \\\";\\n  display: block;\\n  right: -10px;\\n  border-left-width: 10px;\\n  border-left-color: #909599;\\n}\\n.bk-root .bk-tooltip.bk-right::after {\\n  right: -10px;\\n  border-left-width: 10px;\\n  border-left-color: #909599;\\n}\\n.bk-root .bk-tooltip.bk-above::before {\\n  position: absolute;\\n  margin: 0 0 0 -7px;\\n  left: 50%;\\n  width: 0;\\n  height: 0;\\n  border-style: solid;\\n  border-width: 0 7px 0 7px;\\n  border-color: transparent;\\n  content: \\\" \\\";\\n  display: block;\\n  top: -10px;\\n  border-bottom-width: 10px;\\n  border-bottom-color: #909599;\\n}\\n.bk-root .bk-tooltip.bk-below::after {\\n  position: absolute;\\n  margin: 0 0 0 -7px;\\n  left: 50%;\\n  width: 0;\\n  height: 0;\\n  border-style: solid;\\n  border-width: 0 7px 0 7px;\\n  border-color: transparent;\\n  content: \\\" \\\";\\n  display: block;\\n  bottom: -10px;\\n  border-top-width: 10px;\\n  border-top-color: #909599;\\n}\\n.bk-root .bk-tooltip-row-label {\\n  text-align: right;\\n  color: #26aae1;\\n  /* blue from toolbar highlighting */\\n}\\n.bk-root .bk-tooltip-row-value {\\n  color: default;\\n  /* seems to be necessary for notebook */\\n}\\n.bk-root .bk-tooltip-color-block {\\n  width: 12px;\\n  height: 12px;\\n  margin-left: 5px;\\n  margin-right: 5px;\\n  outline: #dddddd solid 1px;\\n  display: inline-block;\\n}\\n\");\n    exports.bk_tooltip = \"bk-tooltip\";\n    exports.bk_tooltip_arrow = \"bk-tooltip-arrow\";\n    exports.bk_tooltip_custom = \"bk-tooltip-custom\";\n    exports.bk_tooltip_row_label = \"bk-tooltip-row-label\";\n    exports.bk_tooltip_row_value = \"bk-tooltip-row-value\";\n    exports.bk_tooltip_color_block = \"bk-tooltip-color-block\";\n}\n","/* styles/mixins.js */ function _(require, module, exports) {\n    const _a = require(61) /* ../core/dom */;\n    _a.styles.append(\"\");\n    exports.bk_active = \"bk-active\";\n    exports.bk_inline = \"bk-inline\";\n    exports.bk_left = \"bk-left\";\n    exports.bk_right = \"bk-right\";\n    exports.bk_above = \"bk-above\";\n    exports.bk_below = \"bk-below\";\n    exports.bk_up = \"bk-up\";\n    exports.bk_down = \"bk-down\";\n    function bk_side(side) {\n        switch (side) {\n            case \"above\": return exports.bk_above;\n            case \"below\": return exports.bk_below;\n            case \"left\": return exports.bk_left;\n            case \"right\": return exports.bk_right;\n        }\n    }\n    exports.bk_side = bk_side;\n}\n","/* models/annotations/whisker.js */ function _(require, module, exports) {\n    const annotation_1 = require(29) /* ./annotation */;\n    const column_data_source_1 = require(68) /* ../sources/column_data_source */;\n    const arrow_head_1 = require(67) /* ./arrow_head */;\n    const p = require(18) /* ../../core/properties */;\n    class WhiskerView extends annotation_1.AnnotationView {\n        initialize() {\n            super.initialize();\n            this.set_data(this.model.source);\n        }\n        connect_signals() {\n            super.connect_signals();\n            this.connect(this.model.source.streaming, () => this.set_data(this.model.source));\n            this.connect(this.model.source.patching, () => this.set_data(this.model.source));\n            this.connect(this.model.source.change, () => this.set_data(this.model.source));\n        }\n        set_data(source) {\n            super.set_data(source);\n            this.visuals.warm_cache(source);\n            this.plot_view.request_render();\n        }\n        _map_data() {\n            const { frame } = this.plot_view;\n            const dim = this.model.dimension;\n            const xscale = frame.xscales[this.model.x_range_name];\n            const yscale = frame.yscales[this.model.y_range_name];\n            const limit_scale = dim == \"height\" ? yscale : xscale;\n            const base_scale = dim == \"height\" ? xscale : yscale;\n            const limit_view = dim == \"height\" ? frame.yview : frame.xview;\n            const base_view = dim == \"height\" ? frame.xview : frame.yview;\n            let _lower_sx;\n            if (this.model.properties.lower.units == \"data\")\n                _lower_sx = limit_scale.v_compute(this._lower);\n            else\n                _lower_sx = limit_view.v_compute(this._lower);\n            let _upper_sx;\n            if (this.model.properties.upper.units == \"data\")\n                _upper_sx = limit_scale.v_compute(this._upper);\n            else\n                _upper_sx = limit_view.v_compute(this._upper);\n            let _base_sx;\n            if (this.model.properties.base.units == \"data\")\n                _base_sx = base_scale.v_compute(this._base);\n            else\n                _base_sx = base_view.v_compute(this._base);\n            const [i, j] = dim == 'height' ? [1, 0] : [0, 1];\n            const _lower = [_lower_sx, _base_sx];\n            const _upper = [_upper_sx, _base_sx];\n            this._lower_sx = _lower[i];\n            this._lower_sy = _lower[j];\n            this._upper_sx = _upper[i];\n            this._upper_sy = _upper[j];\n        }\n        render() {\n            if (!this.model.visible)\n                return;\n            this._map_data();\n            const { ctx } = this.plot_view.canvas_view;\n            if (this.visuals.line.doit) {\n                for (let i = 0, end = this._lower_sx.length; i < end; i++) {\n                    this.visuals.line.set_vectorize(ctx, i);\n                    ctx.beginPath();\n                    ctx.moveTo(this._lower_sx[i], this._lower_sy[i]);\n                    ctx.lineTo(this._upper_sx[i], this._upper_sy[i]);\n                    ctx.stroke();\n                }\n            }\n            const angle = this.model.dimension == \"height\" ? 0 : Math.PI / 2;\n            if (this.model.lower_head != null) {\n                for (let i = 0, end = this._lower_sx.length; i < end; i++) {\n                    ctx.save();\n                    ctx.translate(this._lower_sx[i], this._lower_sy[i]);\n                    ctx.rotate(angle + Math.PI);\n                    this.model.lower_head.render(ctx, i);\n                    ctx.restore();\n                }\n            }\n            if (this.model.upper_head != null) {\n                for (let i = 0, end = this._upper_sx.length; i < end; i++) {\n                    ctx.save();\n                    ctx.translate(this._upper_sx[i], this._upper_sy[i]);\n                    ctx.rotate(angle);\n                    this.model.upper_head.render(ctx, i);\n                    ctx.restore();\n                }\n            }\n        }\n    }\n    exports.WhiskerView = WhiskerView;\n    WhiskerView.__name__ = \"WhiskerView\";\n    class Whisker extends annotation_1.Annotation {\n        constructor(attrs) {\n            super(attrs);\n        }\n        static init_Whisker() {\n            this.prototype.default_view = WhiskerView;\n            this.mixins(['line']);\n            this.define({\n                lower: [p.DistanceSpec],\n                lower_head: [p.Instance, () => new arrow_head_1.TeeHead({ level: \"underlay\", size: 10 })],\n                upper: [p.DistanceSpec],\n                upper_head: [p.Instance, () => new arrow_head_1.TeeHead({ level: \"underlay\", size: 10 })],\n                base: [p.DistanceSpec],\n                dimension: [p.Dimension, 'height'],\n                source: [p.Instance, () => new column_data_source_1.ColumnDataSource()],\n                x_range_name: [p.String, 'default'],\n                y_range_name: [p.String, 'default'],\n            });\n            this.override({\n                level: 'underlay',\n            });\n        }\n    }\n    exports.Whisker = Whisker;\n    Whisker.__name__ = \"Whisker\";\n    Whisker.init_Whisker();\n}\n","/* models/axes/index.js */ function _(require, module, exports) {\n    var axis_1 = require(141) /* ./axis */;\n    exports.Axis = axis_1.Axis;\n    var categorical_axis_1 = require(143) /* ./categorical_axis */;\n    exports.CategoricalAxis = categorical_axis_1.CategoricalAxis;\n    var continuous_axis_1 = require(146) /* ./continuous_axis */;\n    exports.ContinuousAxis = continuous_axis_1.ContinuousAxis;\n    var datetime_axis_1 = require(147) /* ./datetime_axis */;\n    exports.DatetimeAxis = datetime_axis_1.DatetimeAxis;\n    var linear_axis_1 = require(148) /* ./linear_axis */;\n    exports.LinearAxis = linear_axis_1.LinearAxis;\n    var log_axis_1 = require(161) /* ./log_axis */;\n    exports.LogAxis = log_axis_1.LogAxis;\n    var mercator_axis_1 = require(164) /* ./mercator_axis */;\n    exports.MercatorAxis = mercator_axis_1.MercatorAxis;\n}\n","/* models/axes/axis.js */ function _(require, module, exports) {\n    const guide_renderer_1 = require(142) /* ../renderers/guide_renderer */;\n    const p = require(18) /* ../../core/properties */;\n    const array_1 = require(8) /* ../../core/util/array */;\n    const types_1 = require(7) /* ../../core/util/types */;\n    const factor_range_1 = require(82) /* ../ranges/factor_range */;\n    const { abs, min, max } = Math;\n    class AxisView extends guide_renderer_1.GuideRendererView {\n        constructor() {\n            super(...arguments);\n            this.rotate = true;\n        }\n        get panel() {\n            return this.layout;\n        }\n        render() {\n            if (!this.model.visible)\n                return;\n            const extents = {\n                tick: this._tick_extent(),\n                tick_label: this._tick_label_extents(),\n                axis_label: this._axis_label_extent(),\n            };\n            const tick_coords = this.tick_coords;\n            const ctx = this.plot_view.canvas_view.ctx;\n            ctx.save();\n            this._draw_rule(ctx, extents);\n            this._draw_major_ticks(ctx, extents, tick_coords);\n            this._draw_minor_ticks(ctx, extents, tick_coords);\n            this._draw_major_labels(ctx, extents, tick_coords);\n            this._draw_axis_label(ctx, extents, tick_coords);\n            if (this._render != null)\n                this._render(ctx, extents, tick_coords);\n            ctx.restore();\n        }\n        connect_signals() {\n            super.connect_signals();\n            this.connect(this.model.change, () => this.plot_view.request_paint());\n            const p = this.model.properties;\n            this.on_change(p.visible, () => this.plot_view.request_layout());\n        }\n        get_size() {\n            if (this.model.visible && this.model.fixed_location == null) {\n                const size = this._get_size();\n                return { width: 0 /* max */, height: Math.round(size) };\n            }\n            else\n                return { width: 0, height: 0 };\n        }\n        _get_size() {\n            return this._tick_extent() + this._tick_label_extent() + this._axis_label_extent();\n        }\n        get needs_clip() {\n            return this.model.fixed_location != null;\n        }\n        // drawing sub functions -----------------------------------------------------\n        _draw_rule(ctx, _extents) {\n            if (!this.visuals.axis_line.doit)\n                return;\n            const [xs, ys] = this.rule_coords;\n            const [sxs, sys] = this.plot_view.map_to_screen(xs, ys, this.model.x_range_name, this.model.y_range_name);\n            const [nx, ny] = this.normals;\n            const [xoff, yoff] = this.offsets;\n            this.visuals.axis_line.set_value(ctx);\n            ctx.beginPath();\n            ctx.moveTo(Math.round(sxs[0] + nx * xoff), Math.round(sys[0] + ny * yoff));\n            for (let i = 1; i < sxs.length; i++) {\n                const sx = Math.round(sxs[i] + nx * xoff);\n                const sy = Math.round(sys[i] + ny * yoff);\n                ctx.lineTo(sx, sy);\n            }\n            ctx.stroke();\n        }\n        _draw_major_ticks(ctx, _extents, tick_coords) {\n            const tin = this.model.major_tick_in;\n            const tout = this.model.major_tick_out;\n            const visuals = this.visuals.major_tick_line;\n            this._draw_ticks(ctx, tick_coords.major, tin, tout, visuals);\n        }\n        _draw_minor_ticks(ctx, _extents, tick_coords) {\n            const tin = this.model.minor_tick_in;\n            const tout = this.model.minor_tick_out;\n            const visuals = this.visuals.minor_tick_line;\n            this._draw_ticks(ctx, tick_coords.minor, tin, tout, visuals);\n        }\n        _draw_major_labels(ctx, extents, tick_coords) {\n            const coords = tick_coords.major;\n            const labels = this.compute_labels(coords[this.dimension]);\n            const orient = this.model.major_label_orientation;\n            const standoff = extents.tick + this.model.major_label_standoff;\n            const visuals = this.visuals.major_label_text;\n            this._draw_oriented_labels(ctx, labels, coords, orient, this.panel.side, standoff, visuals);\n        }\n        _draw_axis_label(ctx, extents, _tick_coords) {\n            if (this.model.axis_label == null || this.model.axis_label.length == 0 || this.model.fixed_location != null)\n                return;\n            let sx;\n            let sy;\n            switch (this.panel.side) {\n                case \"above\":\n                    sx = this.panel._hcenter.value;\n                    sy = this.panel._bottom.value;\n                    break;\n                case \"below\":\n                    sx = this.panel._hcenter.value;\n                    sy = this.panel._top.value;\n                    break;\n                case \"left\":\n                    sx = this.panel._right.value;\n                    sy = this.panel._vcenter.value;\n                    break;\n                case \"right\":\n                    sx = this.panel._left.value;\n                    sy = this.panel._vcenter.value;\n                    break;\n                default:\n                    throw new Error(`unknown side: ${this.panel.side}`);\n            }\n            const coords = [[sx], [sy]];\n            const standoff = extents.tick + array_1.sum(extents.tick_label) + this.model.axis_label_standoff;\n            const visuals = this.visuals.axis_label_text;\n            this._draw_oriented_labels(ctx, [this.model.axis_label], coords, 'parallel', this.panel.side, standoff, visuals, \"screen\");\n        }\n        _draw_ticks(ctx, coords, tin, tout, visuals) {\n            if (!visuals.doit)\n                return;\n            const [x, y] = coords;\n            const [sxs, sys] = this.plot_view.map_to_screen(x, y, this.model.x_range_name, this.model.y_range_name);\n            const [nx, ny] = this.normals;\n            const [xoff, yoff] = this.offsets;\n            const [nxin, nyin] = [nx * (xoff - tin), ny * (yoff - tin)];\n            const [nxout, nyout] = [nx * (xoff + tout), ny * (yoff + tout)];\n            visuals.set_value(ctx);\n            for (let i = 0; i < sxs.length; i++) {\n                const sx0 = Math.round(sxs[i] + nxout);\n                const sy0 = Math.round(sys[i] + nyout);\n                const sx1 = Math.round(sxs[i] + nxin);\n                const sy1 = Math.round(sys[i] + nyin);\n                ctx.beginPath();\n                ctx.moveTo(sx0, sy0);\n                ctx.lineTo(sx1, sy1);\n                ctx.stroke();\n            }\n        }\n        _draw_oriented_labels(ctx, labels, coords, orient, _side, standoff, visuals, units = \"data\") {\n            if (!visuals.doit || labels.length == 0)\n                return;\n            let sxs, sys;\n            let xoff, yoff;\n            if (units == \"screen\") {\n                [sxs, sys] = coords;\n                [xoff, yoff] = [0, 0];\n            }\n            else {\n                const [dxs, dys] = coords;\n                [sxs, sys] = this.plot_view.map_to_screen(dxs, dys, this.model.x_range_name, this.model.y_range_name);\n                [xoff, yoff] = this.offsets;\n            }\n            const [nx, ny] = this.normals;\n            const nxd = nx * (xoff + standoff);\n            const nyd = ny * (yoff + standoff);\n            visuals.set_value(ctx);\n            this.panel.apply_label_text_heuristics(ctx, orient);\n            let angle;\n            if (types_1.isString(orient))\n                angle = this.panel.get_label_angle_heuristic(orient);\n            else\n                angle = -orient;\n            for (let i = 0; i < sxs.length; i++) {\n                const sx = Math.round(sxs[i] + nxd);\n                const sy = Math.round(sys[i] + nyd);\n                ctx.translate(sx, sy);\n                ctx.rotate(angle);\n                ctx.fillText(labels[i], 0, 0);\n                ctx.rotate(-angle);\n                ctx.translate(-sx, -sy);\n            }\n        }\n        // extents sub functions -----------------------------------------------------\n        /*protected*/ _axis_label_extent() {\n            if (this.model.axis_label == null || this.model.axis_label == \"\")\n                return 0;\n            const standoff = this.model.axis_label_standoff;\n            const visuals = this.visuals.axis_label_text;\n            return this._oriented_labels_extent([this.model.axis_label], \"parallel\", this.panel.side, standoff, visuals);\n        }\n        /*protected*/ _tick_extent() {\n            return this.model.major_tick_out;\n        }\n        /*protected*/ _tick_label_extent() {\n            return array_1.sum(this._tick_label_extents());\n        }\n        _tick_label_extents() {\n            const coords = this.tick_coords.major;\n            const labels = this.compute_labels(coords[this.dimension]);\n            const orient = this.model.major_label_orientation;\n            const standoff = this.model.major_label_standoff;\n            const visuals = this.visuals.major_label_text;\n            return [this._oriented_labels_extent(labels, orient, this.panel.side, standoff, visuals)];\n        }\n        _oriented_labels_extent(labels, orient, side, standoff, visuals) {\n            if (labels.length == 0)\n                return 0;\n            const ctx = this.plot_view.canvas_view.ctx;\n            visuals.set_value(ctx);\n            let hscale;\n            let angle;\n            if (types_1.isString(orient)) {\n                hscale = 1;\n                angle = this.panel.get_label_angle_heuristic(orient);\n            }\n            else {\n                hscale = 2;\n                angle = -orient;\n            }\n            angle = Math.abs(angle);\n            const c = Math.cos(angle);\n            const s = Math.sin(angle);\n            let extent = 0;\n            for (let i = 0; i < labels.length; i++) {\n                const w = ctx.measureText(labels[i]).width * 1.1;\n                const h = ctx.measureText(labels[i]).ascent * 0.9;\n                let val;\n                if (side == \"above\" || side == \"below\")\n                    val = w * s + (h / hscale) * c;\n                else\n                    val = w * c + (h / hscale) * s;\n                // update extent if current value is larger\n                if (val > extent)\n                    extent = val;\n            }\n            // only apply the standoff if we already have non-zero extent\n            if (extent > 0)\n                extent += standoff;\n            return extent;\n        }\n        // {{{ TODO: state\n        get normals() {\n            return this.panel.normals;\n        }\n        get dimension() {\n            return this.panel.dimension;\n        }\n        compute_labels(ticks) {\n            const labels = this.model.formatter.doFormat(ticks, this);\n            for (let i = 0; i < ticks.length; i++) {\n                if (ticks[i] in this.model.major_label_overrides)\n                    labels[i] = this.model.major_label_overrides[ticks[i]];\n            }\n            return labels;\n        }\n        get offsets() {\n            // If we have a fixed_position then we should respect that exactly and\n            // not apply any offsets (https://github.com/bokeh/bokeh/issues/8552)\n            if (this.model.fixed_location != null)\n                return [0, 0];\n            const { frame } = this.plot_view;\n            let [xoff, yoff] = [0, 0];\n            switch (this.panel.side) {\n                case \"below\":\n                    yoff = abs(this.panel._top.value - frame._bottom.value);\n                    break;\n                case \"above\":\n                    yoff = abs(this.panel._bottom.value - frame._top.value);\n                    break;\n                case \"right\":\n                    xoff = abs(this.panel._left.value - frame._right.value);\n                    break;\n                case \"left\":\n                    xoff = abs(this.panel._right.value - frame._left.value);\n                    break;\n            }\n            return [xoff, yoff];\n        }\n        get ranges() {\n            const i = this.dimension;\n            const j = (i + 1) % 2;\n            const { frame } = this.plot_view;\n            const ranges = [\n                frame.x_ranges[this.model.x_range_name],\n                frame.y_ranges[this.model.y_range_name],\n            ];\n            return [ranges[i], ranges[j]];\n        }\n        get computed_bounds() {\n            const [range] = this.ranges;\n            const user_bounds = this.model.bounds; // XXX: ? 'auto'\n            const range_bounds = [range.min, range.max];\n            if (user_bounds == 'auto')\n                return [range.min, range.max];\n            else if (types_1.isArray(user_bounds)) {\n                let start;\n                let end;\n                const [user_start, user_end] = user_bounds;\n                const [range_start, range_end] = range_bounds;\n                if (abs(user_start - user_end) > abs(range_start - range_end)) {\n                    start = max(min(user_start, user_end), range_start);\n                    end = min(max(user_start, user_end), range_end);\n                }\n                else {\n                    start = min(user_start, user_end);\n                    end = max(user_start, user_end);\n                }\n                return [start, end];\n            }\n            else\n                throw new Error(`user bounds '${user_bounds}' not understood`);\n        }\n        get rule_coords() {\n            const i = this.dimension;\n            const j = (i + 1) % 2;\n            const [range] = this.ranges;\n            const [start, end] = this.computed_bounds;\n            const xs = new Array(2);\n            const ys = new Array(2);\n            const coords = [xs, ys];\n            coords[i][0] = Math.max(start, range.min);\n            coords[i][1] = Math.min(end, range.max);\n            if (coords[i][0] > coords[i][1])\n                coords[i][0] = coords[i][1] = NaN;\n            coords[j][0] = this.loc;\n            coords[j][1] = this.loc;\n            return coords;\n        }\n        get tick_coords() {\n            const i = this.dimension;\n            const j = (i + 1) % 2;\n            const [range] = this.ranges;\n            const [start, end] = this.computed_bounds;\n            const ticks = this.model.ticker.get_ticks(start, end, range, this.loc, {});\n            const majors = ticks.major;\n            const minors = ticks.minor;\n            const xs = [];\n            const ys = [];\n            const coords = [xs, ys];\n            const minor_xs = [];\n            const minor_ys = [];\n            const minor_coords = [minor_xs, minor_ys];\n            const [range_min, range_max] = [range.min, range.max];\n            for (let ii = 0; ii < majors.length; ii++) {\n                if (majors[ii] < range_min || majors[ii] > range_max)\n                    continue;\n                coords[i].push(majors[ii]);\n                coords[j].push(this.loc);\n            }\n            for (let ii = 0; ii < minors.length; ii++) {\n                if (minors[ii] < range_min || minors[ii] > range_max)\n                    continue;\n                minor_coords[i].push(minors[ii]);\n                minor_coords[j].push(this.loc);\n            }\n            return {\n                major: coords,\n                minor: minor_coords,\n            };\n        }\n        get loc() {\n            const { fixed_location } = this.model;\n            if (fixed_location != null) {\n                if (types_1.isNumber(fixed_location))\n                    return fixed_location;\n                const [, cross_range] = this.ranges;\n                if (cross_range instanceof factor_range_1.FactorRange)\n                    return cross_range.synthetic(fixed_location);\n                throw new Error(\"unexpected\");\n            }\n            const [, cross_range] = this.ranges;\n            switch (this.panel.side) {\n                case 'left':\n                case 'below':\n                    return cross_range.start;\n                case 'right':\n                case 'above':\n                    return cross_range.end;\n            }\n        }\n        // }}}\n        serializable_state() {\n            return Object.assign(Object.assign({}, super.serializable_state()), { bbox: this.layout.bbox.box });\n        }\n    }\n    exports.AxisView = AxisView;\n    AxisView.__name__ = \"AxisView\";\n    class Axis extends guide_renderer_1.GuideRenderer {\n        constructor(attrs) {\n            super(attrs);\n        }\n        static init_Axis() {\n            this.prototype.default_view = AxisView;\n            this.mixins([\n                'line:axis_',\n                'line:major_tick_',\n                'line:minor_tick_',\n                'text:major_label_',\n                'text:axis_label_',\n            ]);\n            this.define({\n                bounds: [p.Any, 'auto'],\n                ticker: [p.Instance],\n                formatter: [p.Instance],\n                x_range_name: [p.String, 'default'],\n                y_range_name: [p.String, 'default'],\n                axis_label: [p.String, ''],\n                axis_label_standoff: [p.Int, 5],\n                major_label_standoff: [p.Int, 5],\n                major_label_orientation: [p.Any, \"horizontal\"],\n                major_label_overrides: [p.Any, {}],\n                major_tick_in: [p.Number, 2],\n                major_tick_out: [p.Number, 6],\n                minor_tick_in: [p.Number, 0],\n                minor_tick_out: [p.Number, 4],\n                fixed_location: [p.Any, null],\n            });\n            this.override({\n                axis_line_color: 'black',\n                major_tick_line_color: 'black',\n                minor_tick_line_color: 'black',\n                major_label_text_font_size: \"8pt\",\n                major_label_text_align: \"center\",\n                major_label_text_baseline: \"alphabetic\",\n                axis_label_text_font_size: \"10pt\",\n                axis_label_text_font_style: \"italic\",\n            });\n        }\n    }\n    exports.Axis = Axis;\n    Axis.__name__ = \"Axis\";\n    Axis.init_Axis();\n}\n","/* models/renderers/guide_renderer.js */ function _(require, module, exports) {\n    const renderer_1 = require(58) /* ./renderer */;\n    class GuideRendererView extends renderer_1.RendererView {\n    }\n    exports.GuideRendererView = GuideRendererView;\n    GuideRendererView.__name__ = \"GuideRendererView\";\n    class GuideRenderer extends renderer_1.Renderer {\n        constructor(attrs) {\n            super(attrs);\n        }\n        static init_GuideRenderer() {\n            this.override({\n                level: \"overlay\",\n            });\n        }\n    }\n    exports.GuideRenderer = GuideRenderer;\n    GuideRenderer.__name__ = \"GuideRenderer\";\n    GuideRenderer.init_GuideRenderer();\n}\n","/* models/axes/categorical_axis.js */ function _(require, module, exports) {\n    const axis_1 = require(141) /* ./axis */;\n    const categorical_ticker_1 = require(144) /* ../tickers/categorical_ticker */;\n    const categorical_tick_formatter_1 = require(145) /* ../formatters/categorical_tick_formatter */;\n    const p = require(18) /* ../../core/properties */;\n    class CategoricalAxisView extends axis_1.AxisView {\n        _render(ctx, extents, tick_coords) {\n            this._draw_group_separators(ctx, extents, tick_coords);\n        }\n        _draw_group_separators(ctx, _extents, _tick_coords) {\n            const [range] = this.ranges;\n            const [start, end] = this.computed_bounds;\n            if (!range.tops || range.tops.length < 2 || !this.visuals.separator_line.doit)\n                return;\n            const dim = this.dimension;\n            const alt = (dim + 1) % 2;\n            const coords = [[], []];\n            let ind = 0;\n            for (let i = 0; i < range.tops.length - 1; i++) {\n                let first, last;\n                for (let j = ind; j < range.factors.length; j++) {\n                    if (range.factors[j][0] == range.tops[i + 1]) {\n                        [first, last] = [range.factors[j - 1], range.factors[j]];\n                        ind = j;\n                        break;\n                    }\n                }\n                const pt = (range.synthetic(first) + range.synthetic(last)) / 2;\n                if (pt > start && pt < end) {\n                    coords[dim].push(pt);\n                    coords[alt].push(this.loc);\n                }\n            }\n            const tex = this._tick_label_extent();\n            this._draw_ticks(ctx, coords, -3, (tex - 6), this.visuals.separator_line);\n        }\n        _draw_major_labels(ctx, extents, _tick_coords) {\n            const info = this._get_factor_info();\n            let standoff = extents.tick + this.model.major_label_standoff;\n            for (let i = 0; i < info.length; i++) {\n                const [labels, coords, orient, visuals] = info[i];\n                this._draw_oriented_labels(ctx, labels, coords, orient, this.panel.side, standoff, visuals);\n                standoff += extents.tick_label[i];\n            }\n        }\n        _tick_label_extents() {\n            const info = this._get_factor_info();\n            const extents = [];\n            for (const [labels, , orient, visuals] of info) {\n                const extent = this._oriented_labels_extent(labels, orient, this.panel.side, this.model.major_label_standoff, visuals);\n                extents.push(extent);\n            }\n            return extents;\n        }\n        _get_factor_info() {\n            const [range] = this.ranges;\n            const [start, end] = this.computed_bounds;\n            const loc = this.loc;\n            const ticks = this.model.ticker.get_ticks(start, end, range, loc, {});\n            const coords = this.tick_coords;\n            const info = [];\n            if (range.levels == 1) {\n                const major = ticks.major;\n                const labels = this.model.formatter.doFormat(major, this);\n                info.push([labels, coords.major, this.model.major_label_orientation, this.visuals.major_label_text]);\n            }\n            else if (range.levels == 2) {\n                const major = ticks.major.map((x) => x[1]);\n                const labels = this.model.formatter.doFormat(major, this);\n                info.push([labels, coords.major, this.model.major_label_orientation, this.visuals.major_label_text]);\n                info.push([ticks.tops, coords.tops, this.model.group_label_orientation, this.visuals.group_text]);\n            }\n            else if (range.levels == 3) {\n                const major = ticks.major.map((x) => x[2]);\n                const labels = this.model.formatter.doFormat(major, this);\n                const mid_labels = ticks.mids.map((x) => x[1]);\n                info.push([labels, coords.major, this.model.major_label_orientation, this.visuals.major_label_text]);\n                info.push([mid_labels, coords.mids, this.model.subgroup_label_orientation, this.visuals.subgroup_text]);\n                info.push([ticks.tops, coords.tops, this.model.group_label_orientation, this.visuals.group_text]);\n            }\n            return info;\n        }\n        // {{{ TODO: state\n        get tick_coords() {\n            const i = this.dimension;\n            const j = (i + 1) % 2;\n            const [range] = this.ranges;\n            const [start, end] = this.computed_bounds;\n            const ticks = this.model.ticker.get_ticks(start, end, range, this.loc, {});\n            const coords = {\n                major: [[], []],\n                mids: [[], []],\n                tops: [[], []],\n                minor: [[], []],\n            };\n            coords.major[i] = ticks.major;\n            coords.major[j] = ticks.major.map((_x) => this.loc);\n            if (range.levels == 3) {\n                coords.mids[i] = ticks.mids;\n                coords.mids[j] = ticks.mids.map((_x) => this.loc);\n            }\n            if (range.levels > 1) {\n                coords.tops[i] = ticks.tops;\n                coords.tops[j] = ticks.tops.map((_x) => this.loc);\n            }\n            return coords;\n        }\n    }\n    exports.CategoricalAxisView = CategoricalAxisView;\n    CategoricalAxisView.__name__ = \"CategoricalAxisView\";\n    class CategoricalAxis extends axis_1.Axis {\n        constructor(attrs) {\n            super(attrs);\n        }\n        static init_CategoricalAxis() {\n            this.prototype.default_view = CategoricalAxisView;\n            this.mixins([\n                \"line:separator_\",\n                \"text:group_\",\n                \"text:subgroup_\",\n            ]);\n            this.define({\n                group_label_orientation: [p.Any, \"parallel\"],\n                subgroup_label_orientation: [p.Any, \"parallel\"],\n            });\n            this.override({\n                ticker: () => new categorical_ticker_1.CategoricalTicker(),\n                formatter: () => new categorical_tick_formatter_1.CategoricalTickFormatter(),\n                separator_line_color: \"lightgrey\",\n                separator_line_width: 2,\n                group_text_font_style: \"bold\",\n                group_text_font_size: \"8pt\",\n                group_text_color: \"grey\",\n                subgroup_text_font_style: \"bold\",\n                subgroup_text_font_size: \"8pt\",\n            });\n        }\n    }\n    exports.CategoricalAxis = CategoricalAxis;\n    CategoricalAxis.__name__ = \"CategoricalAxis\";\n    CategoricalAxis.init_CategoricalAxis();\n}\n","/* models/tickers/categorical_ticker.js */ function _(require, module, exports) {\n    const ticker_1 = require(105) /* ./ticker */;\n    class CategoricalTicker extends ticker_1.Ticker {\n        constructor(attrs) {\n            super(attrs);\n        }\n        get_ticks(start, end, range, _cross_loc, _) {\n            const majors = this._collect(range.factors, range, start, end);\n            const tops = this._collect(range.tops || [], range, start, end);\n            const mids = this._collect(range.mids || [], range, start, end);\n            return {\n                major: majors,\n                minor: [],\n                tops,\n                mids,\n            };\n        }\n        _collect(factors, range, start, end) {\n            const result = [];\n            for (const factor of factors) {\n                const coord = range.synthetic(factor);\n                if (coord > start && coord < end)\n                    result.push(factor);\n            }\n            return result;\n        }\n    }\n    exports.CategoricalTicker = CategoricalTicker;\n    CategoricalTicker.__name__ = \"CategoricalTicker\";\n}\n","/* models/formatters/categorical_tick_formatter.js */ function _(require, module, exports) {\n    const tick_formatter_1 = require(107) /* ./tick_formatter */;\n    const array_1 = require(8) /* ../../core/util/array */;\n    class CategoricalTickFormatter extends tick_formatter_1.TickFormatter {\n        constructor(attrs) {\n            super(attrs);\n        }\n        doFormat(ticks, _opts) {\n            return array_1.copy(ticks);\n        }\n    }\n    exports.CategoricalTickFormatter = CategoricalTickFormatter;\n    CategoricalTickFormatter.__name__ = \"CategoricalTickFormatter\";\n}\n","/* models/axes/continuous_axis.js */ function _(require, module, exports) {\n    const axis_1 = require(141) /* ./axis */;\n    class ContinuousAxis extends axis_1.Axis {\n        constructor(attrs) {\n            super(attrs);\n        }\n    }\n    exports.ContinuousAxis = ContinuousAxis;\n    ContinuousAxis.__name__ = \"ContinuousAxis\";\n}\n","/* models/axes/datetime_axis.js */ function _(require, module, exports) {\n    const linear_axis_1 = require(148) /* ./linear_axis */;\n    const datetime_tick_formatter_1 = require(149) /* ../formatters/datetime_tick_formatter */;\n    const datetime_ticker_1 = require(154) /* ../tickers/datetime_ticker */;\n    class DatetimeAxisView extends linear_axis_1.LinearAxisView {\n    }\n    exports.DatetimeAxisView = DatetimeAxisView;\n    DatetimeAxisView.__name__ = \"DatetimeAxisView\";\n    class DatetimeAxis extends linear_axis_1.LinearAxis {\n        constructor(attrs) {\n            super(attrs);\n        }\n        static init_DatetimeAxis() {\n            this.prototype.default_view = DatetimeAxisView;\n            this.override({\n                ticker: () => new datetime_ticker_1.DatetimeTicker(),\n                formatter: () => new datetime_tick_formatter_1.DatetimeTickFormatter(),\n            });\n        }\n    }\n    exports.DatetimeAxis = DatetimeAxis;\n    DatetimeAxis.__name__ = \"DatetimeAxis\";\n    DatetimeAxis.init_DatetimeAxis();\n}\n","/* models/axes/linear_axis.js */ function _(require, module, exports) {\n    const axis_1 = require(141) /* ./axis */;\n    const continuous_axis_1 = require(146) /* ./continuous_axis */;\n    const basic_tick_formatter_1 = require(106) /* ../formatters/basic_tick_formatter */;\n    const basic_ticker_1 = require(102) /* ../tickers/basic_ticker */;\n    class LinearAxisView extends axis_1.AxisView {\n    }\n    exports.LinearAxisView = LinearAxisView;\n    LinearAxisView.__name__ = \"LinearAxisView\";\n    class LinearAxis extends continuous_axis_1.ContinuousAxis {\n        constructor(attrs) {\n            super(attrs);\n        }\n        static init_LinearAxis() {\n            this.prototype.default_view = LinearAxisView;\n            this.override({\n                ticker: () => new basic_ticker_1.BasicTicker(),\n                formatter: () => new basic_tick_formatter_1.BasicTickFormatter(),\n            });\n        }\n    }\n    exports.LinearAxis = LinearAxis;\n    LinearAxis.__name__ = \"LinearAxis\";\n    LinearAxis.init_LinearAxis();\n}\n","/* models/formatters/datetime_tick_formatter.js */ function _(require, module, exports) {\n    const tz = require(150) /* timezone */;\n    const tick_formatter_1 = require(107) /* ./tick_formatter */;\n    const logging_1 = require(65) /* ../../core/logging */;\n    const p = require(18) /* ../../core/properties */;\n    const templating_1 = require(151) /* ../../core/util/templating */;\n    const array_1 = require(8) /* ../../core/util/array */;\n    const types_1 = require(7) /* ../../core/util/types */;\n    function _us(t) {\n        // From double-precision unix (millisecond) timestamp get\n        // microsecond since last second. Precision seems to run\n        // out around the hundreds of nanoseconds scale, so rounding\n        // to the nearest microsecond should round to a nice\n        // microsecond / millisecond tick.\n        return Math.round(((t / 1000) % 1) * 1000000);\n    }\n    function _array(t) {\n        return tz(t, \"%Y %m %d %H %M %S\").split(/\\s+/).map(e => parseInt(e, 10));\n    }\n    function _strftime(t, format) {\n        if (types_1.isFunction(format)) {\n            return format(t);\n        }\n        else {\n            // Python's datetime library augments the microsecond directive %f, which is not\n            // supported by the javascript library timezone: http://bigeasy.github.io/timezone/.\n            // Use a regular expression to replace %f directive with microseconds.\n            // TODO: what should we do for negative microsecond strings?\n            const microsecond_replacement_string = templating_1.sprintf(\"$1%06d\", _us(t));\n            format = format.replace(/((^|[^%])(%%)*)%f/, microsecond_replacement_string);\n            if (format.indexOf(\"%\") == -1) {\n                // timezone seems to ignore any strings without any formatting directives,\n                // and just return the time argument back instead of the string argument.\n                // But we want the string argument, in case a user supplies a format string\n                // which doesn't contain a formatting directive or is only using %f.\n                return format;\n            }\n            return tz(t, format);\n        }\n    }\n    // Labels of time units, from finest to coarsest.\n    const format_order = [\n        'microseconds', 'milliseconds', 'seconds', 'minsec', 'minutes', 'hourmin', 'hours', 'days', 'months', 'years',\n    ];\n    class DatetimeTickFormatter extends tick_formatter_1.TickFormatter {\n        constructor(attrs) {\n            super(attrs);\n            // Whether or not to strip the leading zeros on tick labels.\n            this.strip_leading_zeros = true;\n        }\n        static init_DatetimeTickFormatter() {\n            this.define({\n                microseconds: [p.Array, ['%fus']],\n                milliseconds: [p.Array, ['%3Nms', '%S.%3Ns']],\n                seconds: [p.Array, ['%Ss']],\n                minsec: [p.Array, [':%M:%S']],\n                minutes: [p.Array, [':%M', '%Mm']],\n                hourmin: [p.Array, ['%H:%M']],\n                hours: [p.Array, ['%Hh', '%H:%M']],\n                days: [p.Array, ['%m/%d', '%a%d']],\n                months: [p.Array, ['%m/%Y', '%b %Y']],\n                years: [p.Array, ['%Y']],\n            });\n        }\n        initialize() {\n            super.initialize();\n            // TODO (bev) trigger update on format change\n            this._update_width_formats();\n        }\n        _update_width_formats() {\n            const now = +tz(new Date());\n            const _widths = function (fmt_strings) {\n                const sizes = fmt_strings.map((fmt_string) => _strftime(now, fmt_string).length);\n                const sorted = array_1.sort_by(array_1.zip(sizes, fmt_strings), ([size]) => size);\n                return array_1.unzip(sorted);\n            };\n            this._width_formats = {\n                microseconds: _widths(this.microseconds),\n                milliseconds: _widths(this.milliseconds),\n                seconds: _widths(this.seconds),\n                minsec: _widths(this.minsec),\n                minutes: _widths(this.minutes),\n                hourmin: _widths(this.hourmin),\n                hours: _widths(this.hours),\n                days: _widths(this.days),\n                months: _widths(this.months),\n                years: _widths(this.years),\n            };\n        }\n        // FIXME There is some unfortunate flicker when panning/zooming near the\n        // span boundaries.\n        // FIXME Rounding is weird at the 20-us scale and below.\n        _get_resolution_str(resolution_secs, span_secs) {\n            // Our resolution boundaries should not be round numbers, because we want\n            // them to fall between the possible tick intervals (which *are* round\n            // numbers, as we've worked hard to ensure).  Consequently, we adjust the\n            // resolution upwards a small amount (less than any possible step in\n            // scales) to make the effective boundaries slightly lower.\n            const adjusted_secs = resolution_secs * 1.1;\n            switch (false) {\n                case !(adjusted_secs < 1e-3): return \"microseconds\";\n                case !(adjusted_secs < 1.0): return \"milliseconds\";\n                case !(adjusted_secs < 60): return span_secs >= 60 ? \"minsec\" : \"seconds\";\n                case !(adjusted_secs < 3600): return span_secs >= 3600 ? \"hourmin\" : \"minutes\";\n                case !(adjusted_secs < (24 * 3600)): return \"hours\";\n                case !(adjusted_secs < (31 * 24 * 3600)): return \"days\";\n                case !(adjusted_secs < (365 * 24 * 3600)): return \"months\";\n                default: return \"years\";\n            }\n        }\n        doFormat(ticks, _opts) {\n            // In order to pick the right set of labels, we need to determine\n            // the resolution of the ticks.  We can do this using a ticker if\n            // it's provided, or by computing the resolution from the actual\n            // ticks we've been given.\n            if (ticks.length == 0)\n                return [];\n            const span = Math.abs(ticks[ticks.length - 1] - ticks[0]) / 1000.0;\n            const r = span / (ticks.length - 1);\n            const resol = this._get_resolution_str(r, span);\n            const [, [format]] = this._width_formats[resol];\n            // Apply the format to the tick values\n            const labels = [];\n            const resol_ndx = format_order.indexOf(resol);\n            // This dictionary maps the name of a time resolution (in @format_order)\n            // to its index in a time.localtime() timetuple.  The default is to map\n            // everything to index 0, which is year.  This is not ideal; it might cause\n            // a problem with the tick at midnight, january 1st, 0 a.d. being incorrectly\n            // promoted at certain tick resolutions.\n            const time_tuple_ndx_for_resol = {};\n            for (const fmt of format_order) {\n                time_tuple_ndx_for_resol[fmt] = 0;\n            }\n            time_tuple_ndx_for_resol.seconds = 5;\n            time_tuple_ndx_for_resol.minsec = 4;\n            time_tuple_ndx_for_resol.minutes = 4;\n            time_tuple_ndx_for_resol.hourmin = 3;\n            time_tuple_ndx_for_resol.hours = 3;\n            // As we format each tick, check to see if we are at a boundary of the\n            // next higher unit of time.  If so, replace the current format with one\n            // from that resolution.  This is not the best heuristic in the world,\n            // but it works!  There is some trickiness here due to having to deal\n            // with hybrid formats in a reasonable manner.\n            for (const t of ticks) {\n                let s, tm;\n                try {\n                    tm = _array(t);\n                    s = _strftime(t, format);\n                }\n                catch (error) {\n                    logging_1.logger.warn(`unable to format tick for timestamp value ${t}`);\n                    logging_1.logger.warn(` - ${error}`);\n                    labels.push(\"ERR\");\n                    continue;\n                }\n                let hybrid_handled = false;\n                let next_ndx = resol_ndx;\n                // The way to check that we are at the boundary of the next unit of\n                // time is by checking that we have 0 units of the resolution, i.e.\n                // we are at zero minutes, so display hours, or we are at zero seconds,\n                // so display minutes (and if that is zero as well, then display hours).\n                while (tm[time_tuple_ndx_for_resol[format_order[next_ndx]]] == 0) {\n                    let next_format;\n                    next_ndx += 1;\n                    if (next_ndx == format_order.length)\n                        break;\n                    if ((resol == \"minsec\" || resol == \"hourmin\") && !hybrid_handled) {\n                        if ((resol == \"minsec\" && tm[4] == 0 && tm[5] != 0) || (resol == \"hourmin\" && tm[3] == 0 && tm[4] != 0)) {\n                            next_format = this._width_formats[format_order[resol_ndx - 1]][1][0];\n                            s = _strftime(t, next_format);\n                            break;\n                        }\n                        else {\n                            hybrid_handled = true;\n                        }\n                    }\n                    next_format = this._width_formats[format_order[next_ndx]][1][0];\n                    s = _strftime(t, next_format);\n                }\n                // TODO: should expose this in api. %H, %d, etc use leading zeros and\n                // users might prefer to see them lined up correctly.\n                if (this.strip_leading_zeros) {\n                    let ss = s.replace(/^0+/g, \"\");\n                    if (ss != s && isNaN(parseInt(ss))) {\n                        // If the string can now be parsed as starting with an integer, then\n                        // leave all zeros stripped, otherwise start with a zero. Hence:\n                        // A label such as '000ms' should leave one zero.\n                        // A label such as '001ms' or '0-1ms' should not leave a leading zero.\n                        ss = `0${ss}`;\n                    }\n                    labels.push(ss);\n                }\n                else\n                    labels.push(s);\n            }\n            return labels;\n        }\n    }\n    exports.DatetimeTickFormatter = DatetimeTickFormatter;\n    DatetimeTickFormatter.__name__ = \"DatetimeTickFormatter\";\n    DatetimeTickFormatter.init_DatetimeTickFormatter();\n}\n","/* timezone/index.js */ function _(require, module, exports) {\n    !function (definition) {\n        if (typeof module == \"object\" && module.exports)\n            module.exports = definition();\n        else if (typeof define == \"function\")\n            define(definition);\n        else\n            this.tz = definition();\n    }(function () {\n        /*\n          function die () {\n            console.log.apply(console, __slice.call(arguments, 0));\n            return process.exit(1);\n          }\n        \n          function say () { return console.log.apply(console, __slice.call(arguments, 0)) }\n        */\n        function actualize(entry, rule, year) {\n            var actualized, date = rule.day[1];\n            do {\n                actualized = new Date(Date.UTC(year, rule.month, Math.abs(date++)));\n            } while (rule.day[0] < 7 && actualized.getUTCDay() != rule.day[0]);\n            actualized = {\n                clock: rule.clock,\n                sort: actualized.getTime(),\n                rule: rule,\n                save: rule.save * 6e4,\n                offset: entry.offset\n            };\n            actualized[actualized.clock] = actualized.sort + rule.time * 6e4;\n            if (actualized.posix) {\n                actualized.wallclock = actualized[actualized.clock] + (entry.offset + rule.saved);\n            }\n            else {\n                actualized.posix = actualized[actualized.clock] - (entry.offset + rule.saved);\n            }\n            return actualized;\n        }\n        function find(request, clock, time) {\n            var i, I, entry, found, zone = request[request.zone], actualized = [], abbrev, rules, j, year = new Date(time).getUTCFullYear(), off = 1;\n            for (i = 1, I = zone.length; i < I; i++)\n                if (zone[i][clock] <= time)\n                    break;\n            entry = zone[i];\n            if (entry.rules) {\n                rules = request[entry.rules];\n                for (j = year + 1; j >= year - off; --j)\n                    for (i = 0, I = rules.length; i < I; i++)\n                        if (rules[i].from <= j && j <= rules[i].to)\n                            actualized.push(actualize(entry, rules[i], j));\n                        else if (rules[i].to < j && off == 1)\n                            off = j - rules[i].to;\n                actualized.sort(function (a, b) { return a.sort - b.sort; });\n                for (i = 0, I = actualized.length; i < I; i++) {\n                    if (time >= actualized[i][clock] && actualized[i][actualized[i].clock] > entry[actualized[i].clock])\n                        found = actualized[i];\n                }\n            }\n            if (found) {\n                if (abbrev = /^(.*)\\/(.*)$/.exec(entry.format)) {\n                    found.abbrev = abbrev[found.save ? 2 : 1];\n                }\n                else {\n                    found.abbrev = entry.format.replace(/%s/, found.rule.letter);\n                }\n            }\n            return found || entry;\n        }\n        function convertToWallclock(request, posix) {\n            if (request.zone == \"UTC\")\n                return posix;\n            request.entry = find(request, \"posix\", posix);\n            return posix + request.entry.offset + request.entry.save;\n        }\n        function convertToPOSIX(request, wallclock) {\n            if (request.zone == \"UTC\")\n                return wallclock;\n            var entry, diff;\n            request.entry = entry = find(request, \"wallclock\", wallclock);\n            diff = wallclock - entry.wallclock;\n            return 0 < diff && diff < entry.save ? null : wallclock - entry.offset - entry.save;\n        }\n        function adjust(request, posix, match) {\n            var increment = +(match[1] + 1) // conversion necessary for week day addition\n            , offset = match[2] * increment, index = UNITS.indexOf(match[3].toLowerCase()), date;\n            if (index > 9) {\n                posix += offset * TIME[index - 10];\n            }\n            else {\n                date = new Date(convertToWallclock(request, posix));\n                if (index < 7) {\n                    while (offset) {\n                        date.setUTCDate(date.getUTCDate() + increment);\n                        if (date.getUTCDay() == index)\n                            offset -= increment;\n                    }\n                }\n                else if (index == 7) {\n                    date.setUTCFullYear(date.getUTCFullYear() + offset);\n                }\n                else if (index == 8) {\n                    date.setUTCMonth(date.getUTCMonth() + offset);\n                }\n                else {\n                    date.setUTCDate(date.getUTCDate() + offset);\n                }\n                if ((posix = convertToPOSIX(request, date.getTime())) == null) {\n                    posix = convertToPOSIX(request, date.getTime() + 864e5 * increment) - 864e5 * increment;\n                }\n            }\n            return posix;\n        }\n        function convert(vargs) {\n            if (!vargs.length)\n                return \"1.0.22\";\n            var request = Object.create(this), adjustments = [], i, I, $, argument, date;\n            for (i = 0; i < vargs.length; i++) { // leave the for loop alone, it works.\n                argument = vargs[i];\n                // https://twitter.com/bigeasy/status/215112186572439552\n                if (Array.isArray(argument)) {\n                    if (!i && !isNaN(argument[1])) {\n                        date = argument;\n                    }\n                    else {\n                        argument.splice.apply(vargs, [i--, 1].concat(argument));\n                    }\n                }\n                else if (isNaN(argument)) {\n                    $ = typeof argument;\n                    if ($ == \"string\") {\n                        if (~argument.indexOf(\"%\")) {\n                            request.format = argument;\n                        }\n                        else if (!i && argument == \"*\") {\n                            date = argument;\n                        }\n                        else if (!i && ($ = /^(\\d{4})-(\\d{2})-(\\d{2})(?:[T\\s](\\d{2}):(\\d{2})(?::(\\d{2})(?:\\.(\\d+))?)?(Z|(([+-])(\\d{2}(:\\d{2}){0,2})))?)?$/.exec(argument))) {\n                            date = [];\n                            date.push.apply(date, $.slice(1, 8));\n                            if ($[9]) {\n                                date.push($[10] + 1);\n                                date.push.apply(date, $[11].split(/:/));\n                            }\n                            else if ($[8]) {\n                                date.push(1);\n                            }\n                        }\n                        else if (/^\\w{2,3}_\\w{2}$/.test(argument)) {\n                            request.locale = argument;\n                        }\n                        else if ($ = UNIT_RE.exec(argument)) {\n                            adjustments.push($);\n                        }\n                        else {\n                            request.zone = argument;\n                        }\n                    }\n                    else if ($ == \"function\") {\n                        if ($ = argument.call(request))\n                            return $;\n                    }\n                    else if (/^\\w{2,3}_\\w{2}$/.test(argument.name)) {\n                        request[argument.name] = argument;\n                    }\n                    else if (argument.zones) {\n                        for ($ in argument.zones)\n                            request[$] = argument.zones[$];\n                        for ($ in argument.rules)\n                            request[$] = argument.rules[$];\n                    }\n                }\n                else if (!i) {\n                    date = argument;\n                }\n            }\n            if (!request[request.locale])\n                delete request.locale;\n            if (!request[request.zone])\n                delete request.zone;\n            if (date != null) {\n                if (date == \"*\") {\n                    date = request.clock();\n                }\n                else if (Array.isArray(date)) {\n                    $ = [];\n                    I = !date[7];\n                    for (i = 0; i < 11; i++)\n                        $[i] = +(date[i] || 0); // conversion necessary for decrement\n                    --$[1]; // Grr..\n                    date = Date.UTC.apply(Date.UTC, $) + -$[7] * ($[8] * 36e5 + $[9] * 6e4 + $[10] * 1e3);\n                }\n                else {\n                    date = Math.floor(date);\n                }\n                if (!isNaN(date)) {\n                    if (I)\n                        date = convertToPOSIX(request, date);\n                    if (date == null)\n                        return date;\n                    for (i = 0, I = adjustments.length; i < I; i++) {\n                        date = adjust(request, date, adjustments[i]);\n                    }\n                    if (!request.format)\n                        return date;\n                    $ = new Date(convertToWallclock(request, date));\n                    return request.format.replace(/%([-0_^]?)(:{0,3})(\\d*)(.)/g, function (value, flag, colons, padding, specifier) {\n                        var f, fill = \"0\", pad;\n                        if (f = request[specifier]) {\n                            value = String(f.call(request, $, date, flag, colons.length));\n                            if ((flag || f.style) == \"_\")\n                                fill = \" \";\n                            pad = flag == \"-\" ? 0 : f.pad || 0;\n                            while (value.length < pad)\n                                value = fill + value;\n                            pad = flag == \"-\" ? 0 : padding || f.pad;\n                            while (value.length < pad)\n                                value = fill + value;\n                            if (specifier == \"N\" && pad < value.length)\n                                value = value.slice(0, pad);\n                            if (flag == \"^\")\n                                value = value.toUpperCase();\n                        }\n                        return value;\n                    });\n                }\n            }\n            return function () { return request.convert(arguments); };\n        }\n        var context = { clock: function () { return +(new Date()); },\n            zone: \"UTC\",\n            entry: { abbrev: \"UTC\", offset: 0, save: 0 },\n            UTC: 1,\n            z: function (date, posix, flag, delimiters) {\n                var offset = this.entry.offset + this.entry.save, seconds = Math.abs(offset / 1000), parts = [], part = 3600, i, z;\n                for (i = 0; i < 3; i++) {\n                    parts.push((\"0\" + Math.floor(seconds / part)).slice(-2));\n                    seconds %= part;\n                    part /= 60;\n                }\n                if (flag == \"^\" && !offset)\n                    return \"Z\";\n                if (flag == \"^\")\n                    delimiters = 3;\n                if (delimiters == 3) {\n                    z = parts.join(\":\");\n                    z = z.replace(/:00$/, \"\");\n                    if (flag != \"^\")\n                        z = z.replace(/:00$/, \"\");\n                }\n                else if (delimiters) {\n                    z = parts.slice(0, delimiters + 1).join(\":\");\n                    if (flag == \"^\")\n                        z = z.replace(/:00$/, \"\");\n                }\n                else {\n                    z = parts.slice(0, 2).join(\"\");\n                }\n                z = (offset < 0 ? \"-\" : \"+\") + z;\n                z = z.replace(/([-+])(0)/, { \"_\": \" $1\", \"-\": \"$1\" }[flag] || \"$1$2\");\n                return z;\n            },\n            \"%\": function (date) { return \"%\"; },\n            n: function (date) { return \"\\n\"; },\n            t: function (date) { return \"\\t\"; },\n            U: function (date) { return weekOfYear(date, 0); },\n            W: function (date) { return weekOfYear(date, 1); },\n            V: function (date) { return isoWeek(date)[0]; },\n            G: function (date) { return isoWeek(date)[1]; },\n            g: function (date) { return isoWeek(date)[1] % 100; },\n            j: function (date) { return Math.floor((date.getTime() - Date.UTC(date.getUTCFullYear(), 0)) / 864e5) + 1; },\n            s: function (date) { return Math.floor(date.getTime() / 1000); },\n            C: function (date) { return Math.floor(date.getUTCFullYear() / 100); },\n            N: function (date) { return date.getTime() % 1000 * 1000000; },\n            m: function (date) { return date.getUTCMonth() + 1; },\n            Y: function (date) { return date.getUTCFullYear(); },\n            y: function (date) { return date.getUTCFullYear() % 100; },\n            H: function (date) { return date.getUTCHours(); },\n            M: function (date) { return date.getUTCMinutes(); },\n            S: function (date) { return date.getUTCSeconds(); },\n            e: function (date) { return date.getUTCDate(); },\n            d: function (date) { return date.getUTCDate(); },\n            u: function (date) { return date.getUTCDay() || 7; },\n            w: function (date) { return date.getUTCDay(); },\n            l: function (date) { return date.getUTCHours() % 12 || 12; },\n            I: function (date) { return date.getUTCHours() % 12 || 12; },\n            k: function (date) { return date.getUTCHours(); },\n            Z: function (date) { return this.entry.abbrev; },\n            a: function (date) { return this[this.locale].day.abbrev[date.getUTCDay()]; },\n            A: function (date) { return this[this.locale].day.full[date.getUTCDay()]; },\n            h: function (date) { return this[this.locale].month.abbrev[date.getUTCMonth()]; },\n            b: function (date) { return this[this.locale].month.abbrev[date.getUTCMonth()]; },\n            B: function (date) { return this[this.locale].month.full[date.getUTCMonth()]; },\n            P: function (date) { return this[this.locale].meridiem[Math.floor(date.getUTCHours() / 12)].toLowerCase(); },\n            p: function (date) { return this[this.locale].meridiem[Math.floor(date.getUTCHours() / 12)]; },\n            R: function (date, posix) { return this.convert([posix, \"%H:%M\"]); },\n            T: function (date, posix) { return this.convert([posix, \"%H:%M:%S\"]); },\n            D: function (date, posix) { return this.convert([posix, \"%m/%d/%y\"]); },\n            F: function (date, posix) { return this.convert([posix, \"%Y-%m-%d\"]); },\n            x: function (date, posix) { return this.convert([posix, this[this.locale].date]); },\n            r: function (date, posix) { return this.convert([posix, this[this.locale].time12 || '%I:%M:%S']); },\n            X: function (date, posix) { return this.convert([posix, this[this.locale].time24]); },\n            c: function (date, posix) { return this.convert([posix, this[this.locale].dateTime]); },\n            convert: convert,\n            locale: \"en_US\",\n            en_US: {\n                date: \"%m/%d/%Y\",\n                time24: \"%I:%M:%S %p\",\n                time12: \"%I:%M:%S %p\",\n                dateTime: \"%a %d %b %Y %I:%M:%S %p %Z\",\n                meridiem: [\"AM\", \"PM\"],\n                month: {\n                    abbrev: \"Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec\".split(\"|\"),\n                    full: \"January|February|March|April|May|June|July|August|September|October|November|December\".split(\"|\")\n                },\n                day: {\n                    abbrev: \"Sun|Mon|Tue|Wed|Thu|Fri|Sat\".split(\"|\"),\n                    full: \"Sunday|Monday|Tuesday|Wednesday|Thursday|Friday|Saturday\".split(\"|\")\n                }\n            }\n        };\n        var UNITS = \"Sunday|Monday|Tuesday|Wednesday|Thursday|Friday|Saturday|year|month|day|hour|minute|second|millisecond\", UNIT_RE = new RegExp(\"^\\\\s*([+-])(\\\\d+)\\\\s+(\" + UNITS + \")s?\\\\s*$\", \"i\"), TIME = [36e5, 6e4, 1e3, 1];\n        UNITS = UNITS.toLowerCase().split(\"|\");\n        \"delmHMSUWVgCIky\".replace(/./g, function (e) { context[e].pad = 2; });\n        context.N.pad = 9;\n        context.j.pad = 3;\n        context.k.style = \"_\";\n        context.l.style = \"_\";\n        context.e.style = \"_\";\n        function weekOfYear(date, startOfWeek) {\n            var diff, nyd, weekStart;\n            nyd = new Date(Date.UTC(date.getUTCFullYear(), 0));\n            diff = Math.floor((date.getTime() - nyd.getTime()) / 864e5);\n            if (nyd.getUTCDay() == startOfWeek) {\n                weekStart = 0;\n            }\n            else {\n                weekStart = 7 - nyd.getUTCDay() + startOfWeek;\n                if (weekStart == 8) {\n                    weekStart = 1;\n                }\n            }\n            return diff >= weekStart ? Math.floor((diff - weekStart) / 7) + 1 : 0;\n        }\n        function isoWeek(date) {\n            var nyd, nyy, week;\n            nyy = date.getUTCFullYear();\n            nyd = new Date(Date.UTC(nyy, 0)).getUTCDay();\n            week = weekOfYear(date, 1) + (nyd > 1 && nyd <= 4 ? 1 : 0);\n            if (!week) {\n                nyy = date.getUTCFullYear() - 1;\n                nyd = new Date(Date.UTC(nyy, 0)).getUTCDay();\n                week = nyd == 4 || (nyd == 3 && new Date(nyy, 1, 29).getDate() == 29) ? 53 : 52;\n                return [week, date.getUTCFullYear() - 1];\n            }\n            else if (week == 53 && !(nyd == 4 || (nyd == 3 && new Date(nyy, 1, 29).getDate() == 29))) {\n                return [1, date.getUTCFullYear() + 1];\n            }\n            else {\n                return [week, date.getUTCFullYear()];\n            }\n        }\n        return function () { return context.convert(arguments); };\n    });\n}\n","/* core/util/templating.js */ function _(require, module, exports) {\n    const sprintf_js_1 = require(152) /* sprintf-js */;\n    const Numbro = require(153) /* numbro */;\n    const tz = require(150) /* timezone */;\n    const string_1 = require(25) /* ./string */;\n    const types_1 = require(7) /* ./types */;\n    function sprintf(format, ...args) {\n        return sprintf_js_1.sprintf(format, ...args);\n    }\n    exports.sprintf = sprintf;\n    exports.DEFAULT_FORMATTERS = {\n        numeral: (value, format, _special_vars) => Numbro.format(value, format),\n        datetime: (value, format, _special_vars) => tz(value, format),\n        printf: (value, format, _special_vars) => sprintf(format, value),\n    };\n    function basic_formatter(value, _format, _special_vars) {\n        if (types_1.isNumber(value)) {\n            const format = (() => {\n                switch (false) {\n                    case Math.floor(value) != value:\n                        return \"%d\";\n                    case !(Math.abs(value) > 0.1) || !(Math.abs(value) < 1000):\n                        return \"%0.3f\";\n                    default:\n                        return \"%0.3e\";\n                }\n            })();\n            return sprintf(format, value);\n        }\n        else\n            return `${value}`; // get strings for categorical types\n    }\n    exports.basic_formatter = basic_formatter;\n    function get_formatter(name, raw_spec, format, formatters) {\n        // no format, use default built in formatter\n        if (format == null)\n            return basic_formatter;\n        // format spec in the formatters dict, use that\n        if (formatters != null && (name in formatters || raw_spec in formatters)) {\n            // some day (Bokeh 2.0) we can get rid of the check for name, and just check the raw spec\n            // keep it now for compatibility but do not demonstrate it anywhere\n            const key = raw_spec in formatters ? raw_spec : name;\n            const formatter = formatters[key];\n            if (types_1.isString(formatter)) {\n                if (formatter in exports.DEFAULT_FORMATTERS)\n                    return exports.DEFAULT_FORMATTERS[formatter];\n                else\n                    throw new Error(`Unknown tooltip field formatter type '${formatter}'`);\n            }\n            return function (value, format, special_vars) {\n                return formatter.format(value, format, special_vars);\n            };\n        }\n        // otherwise use \"numeral\" as default\n        return exports.DEFAULT_FORMATTERS.numeral;\n    }\n    exports.get_formatter = get_formatter;\n    function get_value(name, data_source, i, special_vars) {\n        if (name[0] == \"$\") {\n            if (name.substring(1) in special_vars)\n                return special_vars[name.substring(1)];\n            else\n                throw new Error(`Unknown special variable '${name}'`);\n        }\n        const column = data_source.get_column(name);\n        // missing column\n        if (column == null)\n            return null;\n        // typical (non-image) index\n        if (types_1.isNumber(i))\n            return column[i];\n        // image index\n        const data = column[i.index];\n        if (types_1.isTypedArray(data) || types_1.isArray(data)) {\n            // inspect array of arrays\n            if (types_1.isArray(data[0])) {\n                const row = data[i.dim2];\n                return row[i.dim1];\n            }\n            else\n                return data[i.flat_index]; // inspect flat array\n        }\n        else\n            return data; // inspect per-image scalar data\n    }\n    exports.get_value = get_value;\n    function replace_placeholders(str, data_source, i, formatters, special_vars = {}) {\n        // this extracts the $x, @x, @{x} without any trailing {format}\n        const raw_spec = str.replace(/(?:^|[^@])([@|\\$](?:\\w+|{[^{}]+}))(?:{[^{}]+})?/g, (_match, raw_spec, _format) => `${raw_spec}`);\n        // this handles the special case @$name, replacing it with an @var corresponding to special_vars.name\n        str = str.replace(/@\\$name/g, (_match) => `@{${special_vars.name}}`);\n        // this prepends special vars with \"@\", e.g \"$x\" becomes \"@$x\", so subsequent processing is simpler\n        str = str.replace(/(^|[^\\$])\\$(\\w+)/g, (_match, prefix, name) => `${prefix}@$${name}`);\n        str = str.replace(/(^|[^@])@(?:(\\$?\\w+)|{([^{}]+)})(?:{([^{}]+)})?/g, (_match, prefix, name, long_name, format) => {\n            name = long_name != null ? long_name : name;\n            const value = get_value(name, data_source, i, special_vars);\n            // missing value, return ???\n            if (value == null)\n                return `${prefix}${string_1.escape(\"???\")}`;\n            // 'safe' format, return the value as-is\n            if (format == 'safe')\n                return `${prefix}${value}`;\n            // format and escape everything else\n            const formatter = get_formatter(name, raw_spec, format, formatters);\n            return `${prefix}${string_1.escape(formatter(value, format, special_vars))}`;\n        });\n        return str;\n    }\n    exports.replace_placeholders = replace_placeholders;\n}\n","/* sprintf-js/src/sprintf.js */ function _(require, module, exports) {\n    /* global window, exports, define */\n    !function () {\n        'use strict';\n        var re = {\n            not_string: /[^s]/,\n            not_bool: /[^t]/,\n            not_type: /[^T]/,\n            not_primitive: /[^v]/,\n            number: /[diefg]/,\n            numeric_arg: /[bcdiefguxX]/,\n            json: /[j]/,\n            not_json: /[^j]/,\n            text: /^[^\\x25]+/,\n            modulo: /^\\x25{2}/,\n            placeholder: /^\\x25(?:([1-9]\\d*)\\$|\\(([^)]+)\\))?(\\+)?(0|'[^$])?(-)?(\\d+)?(?:\\.(\\d+))?([b-gijostTuvxX])/,\n            key: /^([a-z_][a-z_\\d]*)/i,\n            key_access: /^\\.([a-z_][a-z_\\d]*)/i,\n            index_access: /^\\[(\\d+)\\]/,\n            sign: /^[+-]/\n        };\n        function sprintf(key) {\n            // `arguments` is not an array, but should be fine for this call\n            return sprintf_format(sprintf_parse(key), arguments);\n        }\n        function vsprintf(fmt, argv) {\n            return sprintf.apply(null, [fmt].concat(argv || []));\n        }\n        function sprintf_format(parse_tree, argv) {\n            var cursor = 1, tree_length = parse_tree.length, arg, output = '', i, k, ph, pad, pad_character, pad_length, is_positive, sign;\n            for (i = 0; i < tree_length; i++) {\n                if (typeof parse_tree[i] === 'string') {\n                    output += parse_tree[i];\n                }\n                else if (typeof parse_tree[i] === 'object') {\n                    ph = parse_tree[i]; // convenience purposes only\n                    if (ph.keys) { // keyword argument\n                        arg = argv[cursor];\n                        for (k = 0; k < ph.keys.length; k++) {\n                            if (arg == undefined) {\n                                throw new Error(sprintf('[sprintf] Cannot access property \"%s\" of undefined value \"%s\"', ph.keys[k], ph.keys[k - 1]));\n                            }\n                            arg = arg[ph.keys[k]];\n                        }\n                    }\n                    else if (ph.param_no) { // positional argument (explicit)\n                        arg = argv[ph.param_no];\n                    }\n                    else { // positional argument (implicit)\n                        arg = argv[cursor++];\n                    }\n                    if (re.not_type.test(ph.type) && re.not_primitive.test(ph.type) && arg instanceof Function) {\n                        arg = arg();\n                    }\n                    if (re.numeric_arg.test(ph.type) && (typeof arg !== 'number' && isNaN(arg))) {\n                        throw new TypeError(sprintf('[sprintf] expecting number but found %T', arg));\n                    }\n                    if (re.number.test(ph.type)) {\n                        is_positive = arg >= 0;\n                    }\n                    switch (ph.type) {\n                        case 'b':\n                            arg = parseInt(arg, 10).toString(2);\n                            break;\n                        case 'c':\n                            arg = String.fromCharCode(parseInt(arg, 10));\n                            break;\n                        case 'd':\n                        case 'i':\n                            arg = parseInt(arg, 10);\n                            break;\n                        case 'j':\n                            arg = JSON.stringify(arg, null, ph.width ? parseInt(ph.width) : 0);\n                            break;\n                        case 'e':\n                            arg = ph.precision ? parseFloat(arg).toExponential(ph.precision) : parseFloat(arg).toExponential();\n                            break;\n                        case 'f':\n                            arg = ph.precision ? parseFloat(arg).toFixed(ph.precision) : parseFloat(arg);\n                            break;\n                        case 'g':\n                            arg = ph.precision ? String(Number(arg.toPrecision(ph.precision))) : parseFloat(arg);\n                            break;\n                        case 'o':\n                            arg = (parseInt(arg, 10) >>> 0).toString(8);\n                            break;\n                        case 's':\n                            arg = String(arg);\n                            arg = (ph.precision ? arg.substring(0, ph.precision) : arg);\n                            break;\n                        case 't':\n                            arg = String(!!arg);\n                            arg = (ph.precision ? arg.substring(0, ph.precision) : arg);\n                            break;\n                        case 'T':\n                            arg = Object.prototype.toString.call(arg).slice(8, -1).toLowerCase();\n                            arg = (ph.precision ? arg.substring(0, ph.precision) : arg);\n                            break;\n                        case 'u':\n                            arg = parseInt(arg, 10) >>> 0;\n                            break;\n                        case 'v':\n                            arg = arg.valueOf();\n                            arg = (ph.precision ? arg.substring(0, ph.precision) : arg);\n                            break;\n                        case 'x':\n                            arg = (parseInt(arg, 10) >>> 0).toString(16);\n                            break;\n                        case 'X':\n                            arg = (parseInt(arg, 10) >>> 0).toString(16).toUpperCase();\n                            break;\n                    }\n                    if (re.json.test(ph.type)) {\n                        output += arg;\n                    }\n                    else {\n                        if (re.number.test(ph.type) && (!is_positive || ph.sign)) {\n                            sign = is_positive ? '+' : '-';\n                            arg = arg.toString().replace(re.sign, '');\n                        }\n                        else {\n                            sign = '';\n                        }\n                        pad_character = ph.pad_char ? ph.pad_char === '0' ? '0' : ph.pad_char.charAt(1) : ' ';\n                        pad_length = ph.width - (sign + arg).length;\n                        pad = ph.width ? (pad_length > 0 ? pad_character.repeat(pad_length) : '') : '';\n                        output += ph.align ? sign + arg + pad : (pad_character === '0' ? sign + pad + arg : pad + sign + arg);\n                    }\n                }\n            }\n            return output;\n        }\n        var sprintf_cache = Object.create(null);\n        function sprintf_parse(fmt) {\n            if (sprintf_cache[fmt]) {\n                return sprintf_cache[fmt];\n            }\n            var _fmt = fmt, match, parse_tree = [], arg_names = 0;\n            while (_fmt) {\n                if ((match = re.text.exec(_fmt)) !== null) {\n                    parse_tree.push(match[0]);\n                }\n                else if ((match = re.modulo.exec(_fmt)) !== null) {\n                    parse_tree.push('%');\n                }\n                else if ((match = re.placeholder.exec(_fmt)) !== null) {\n                    if (match[2]) {\n                        arg_names |= 1;\n                        var field_list = [], replacement_field = match[2], field_match = [];\n                        if ((field_match = re.key.exec(replacement_field)) !== null) {\n                            field_list.push(field_match[1]);\n                            while ((replacement_field = replacement_field.substring(field_match[0].length)) !== '') {\n                                if ((field_match = re.key_access.exec(replacement_field)) !== null) {\n                                    field_list.push(field_match[1]);\n                                }\n                                else if ((field_match = re.index_access.exec(replacement_field)) !== null) {\n                                    field_list.push(field_match[1]);\n                                }\n                                else {\n                                    throw new SyntaxError('[sprintf] failed to parse named argument key');\n                                }\n                            }\n                        }\n                        else {\n                            throw new SyntaxError('[sprintf] failed to parse named argument key');\n                        }\n                        match[2] = field_list;\n                    }\n                    else {\n                        arg_names |= 2;\n                    }\n                    if (arg_names === 3) {\n                        throw new Error('[sprintf] mixing positional and named placeholders is not (yet) supported');\n                    }\n                    parse_tree.push({\n                        placeholder: match[0],\n                        param_no: match[1],\n                        keys: match[2],\n                        sign: match[3],\n                        pad_char: match[4],\n                        align: match[5],\n                        width: match[6],\n                        precision: match[7],\n                        type: match[8]\n                    });\n                }\n                else {\n                    throw new SyntaxError('[sprintf] unexpected placeholder');\n                }\n                _fmt = _fmt.substring(match[0].length);\n            }\n            return sprintf_cache[fmt] = parse_tree;\n        }\n        /**\n         * export to either browser or node.js\n         */\n        /* eslint-disable quote-props */\n        if (typeof exports !== 'undefined') {\n            exports['sprintf'] = sprintf;\n            exports['vsprintf'] = vsprintf;\n        }\n        if (typeof window !== 'undefined') {\n            window['sprintf'] = sprintf;\n            window['vsprintf'] = vsprintf;\n            if (typeof define === 'function' && define['amd']) {\n                define(function () {\n                    return {\n                        'sprintf': sprintf,\n                        'vsprintf': vsprintf\n                    };\n                });\n            }\n        }\n        /* eslint-enable quote-props */\n    }(); // eslint-disable-line\n}\n","/* numbro/numbro.js */ function _(require, module, exports) {\n    /*!\n     * numbro.js\n     * version : 1.6.2\n     * author : Fretagsplatsen AB\n     * license : MIT\n     * http://www.foretagsplatsen.se\n     */\n    /************************************\n        Constants\n    ************************************/\n    var numbro, VERSION = '1.6.2', \n    // internal storage for culture config files\n    cultures = {}, \n    // Todo: Remove in 2.0.0\n    languages = cultures, currentCulture = 'en-US', zeroFormat = null, defaultFormat = '0,0', defaultCurrencyFormat = '0$', \n    // check for nodeJS\n    hasModule = (typeof module !== 'undefined' && module.exports), \n    // default culture\n    enUS = {\n        delimiters: {\n            thousands: ',',\n            decimal: '.'\n        },\n        abbreviations: {\n            thousand: 'k',\n            million: 'm',\n            billion: 'b',\n            trillion: 't'\n        },\n        ordinal: function (number) {\n            var b = number % 10;\n            return (~~(number % 100 / 10) === 1) ? 'th' :\n                (b === 1) ? 'st' :\n                    (b === 2) ? 'nd' :\n                        (b === 3) ? 'rd' : 'th';\n        },\n        currency: {\n            symbol: '$',\n            position: 'prefix'\n        },\n        defaults: {\n            currencyFormat: ',0000 a'\n        },\n        formats: {\n            fourDigits: '0000 a',\n            fullWithTwoDecimals: '$ ,0.00',\n            fullWithTwoDecimalsNoCurrency: ',0.00'\n        }\n    };\n    /************************************\n        Constructors\n    ************************************/\n    // Numbro prototype object\n    function Numbro(number) {\n        this._value = number;\n    }\n    function zeroes(count) {\n        var i, ret = '';\n        for (i = 0; i < count; i++) {\n            ret += '0';\n        }\n        return ret;\n    }\n    /**\n     * Implementation of toFixed() for numbers with exponent > 21\n     *\n     *\n     */\n    function toFixedLarge(value, precision) {\n        var mantissa, beforeDec, afterDec, exponent, str;\n        str = value.toString();\n        mantissa = str.split('e')[0];\n        exponent = str.split('e')[1];\n        beforeDec = mantissa.split('.')[0];\n        afterDec = mantissa.split('.')[1] || '';\n        str = beforeDec + afterDec + zeroes(exponent - afterDec.length);\n        if (precision > 0) {\n            str += '.' + zeroes(precision);\n        }\n        return str;\n    }\n    /**\n     * Implementation of toFixed() that treats floats more like decimals\n     *\n     * Fixes binary rounding issues (eg. (0.615).toFixed(2) === '0.61') that present\n     * problems for accounting- and finance-related software.\n     */\n    function toFixed(value, precision, roundingFunction, optionals) {\n        var power = Math.pow(10, precision), optionalsRegExp, output;\n        if (value.toFixed(0).search('e') > -1) {\n            // Above 1e21, toFixed returns scientific notation, which\n            // is useless and unexpected\n            output = toFixedLarge(value, precision);\n        }\n        else {\n            //roundingFunction = (roundingFunction !== undefined ? roundingFunction : Math.round);\n            // Multiply up by precision, round accurately, then divide and use native toFixed():\n            output = (roundingFunction(value * power) / power).toFixed(precision);\n        }\n        if (optionals) {\n            optionalsRegExp = new RegExp('0{1,' + optionals + '}$');\n            output = output.replace(optionalsRegExp, '');\n        }\n        return output;\n    }\n    /************************************\n        Formatting\n    ************************************/\n    // determine what type of formatting we need to do\n    function formatNumbro(value, format, roundingFunction) {\n        var output;\n        // TODO: do something with `language`\n        // figure out what kind of format we are dealing with\n        if (format.indexOf('$') > -1) { // currency!!!!!\n            output = formatCurrency(value, format, roundingFunction);\n        }\n        else if (format.indexOf('%') > -1) { // percentage\n            output = formatPercentage(value, format, roundingFunction);\n        }\n        else if (format.indexOf(':') > -1) { // time\n            output = formatTime(value);\n        }\n        else { // plain ol' numbers or bytes\n            output = formatNumber(value, format, roundingFunction);\n        }\n        // return string\n        return output;\n    }\n    function formatCurrency(value, originalFormat, roundingFunction) {\n        var format = originalFormat, symbolIndex = format.indexOf('$'), openParenIndex = format.indexOf('('), plusSignIndex = format.indexOf('+'), minusSignIndex = format.indexOf('-'), space = '', decimalSeparator = '', spliceIndex, output;\n        if (format.indexOf('$') === -1) {\n            // Use defaults instead of the format provided\n            if (cultures[currentCulture].currency.position === 'infix') {\n                decimalSeparator = cultures[currentCulture].currency.symbol;\n                if (cultures[currentCulture].currency.spaceSeparated) {\n                    decimalSeparator = ' ' + decimalSeparator + ' ';\n                }\n            }\n            else if (cultures[currentCulture].currency.spaceSeparated) {\n                space = ' ';\n            }\n        }\n        else {\n            // check for space before or after currency\n            if (format.indexOf(' $') > -1) {\n                space = ' ';\n                format = format.replace(' $', '');\n            }\n            else if (format.indexOf('$ ') > -1) {\n                space = ' ';\n                format = format.replace('$ ', '');\n            }\n            else {\n                format = format.replace('$', '');\n            }\n        }\n        // Format The Number\n        output = formatNumber(value, format, roundingFunction, decimalSeparator);\n        if (originalFormat.indexOf('$') === -1) {\n            // Use defaults instead of the format provided\n            switch (cultures[currentCulture].currency.position) {\n                case 'postfix':\n                    if (output.indexOf(')') > -1) {\n                        output = output.split('');\n                        output.splice(-1, 0, space + cultures[currentCulture].currency.symbol);\n                        output = output.join('');\n                    }\n                    else {\n                        output = output + space + cultures[currentCulture].currency.symbol;\n                    }\n                    break;\n                case 'infix':\n                    break;\n                case 'prefix':\n                    if (output.indexOf('(') > -1 || output.indexOf('-') > -1) {\n                        output = output.split('');\n                        spliceIndex = Math.max(openParenIndex, minusSignIndex) + 1;\n                        output.splice(spliceIndex, 0, cultures[currentCulture].currency.symbol + space);\n                        output = output.join('');\n                    }\n                    else {\n                        output = cultures[currentCulture].currency.symbol + space + output;\n                    }\n                    break;\n                default:\n                    throw Error('Currency position should be among [\"prefix\", \"infix\", \"postfix\"]');\n            }\n        }\n        else {\n            // position the symbol\n            if (symbolIndex <= 1) {\n                if (output.indexOf('(') > -1 || output.indexOf('+') > -1 || output.indexOf('-') > -1) {\n                    output = output.split('');\n                    spliceIndex = 1;\n                    if (symbolIndex < openParenIndex || symbolIndex < plusSignIndex || symbolIndex < minusSignIndex) {\n                        // the symbol appears before the \"(\", \"+\" or \"-\"\n                        spliceIndex = 0;\n                    }\n                    output.splice(spliceIndex, 0, cultures[currentCulture].currency.symbol + space);\n                    output = output.join('');\n                }\n                else {\n                    output = cultures[currentCulture].currency.symbol + space + output;\n                }\n            }\n            else {\n                if (output.indexOf(')') > -1) {\n                    output = output.split('');\n                    output.splice(-1, 0, space + cultures[currentCulture].currency.symbol);\n                    output = output.join('');\n                }\n                else {\n                    output = output + space + cultures[currentCulture].currency.symbol;\n                }\n            }\n        }\n        return output;\n    }\n    function formatPercentage(value, format, roundingFunction) {\n        var space = '', output;\n        value = value * 100;\n        // check for space before %\n        if (format.indexOf(' %') > -1) {\n            space = ' ';\n            format = format.replace(' %', '');\n        }\n        else {\n            format = format.replace('%', '');\n        }\n        output = formatNumber(value, format, roundingFunction);\n        if (output.indexOf(')') > -1) {\n            output = output.split('');\n            output.splice(-1, 0, space + '%');\n            output = output.join('');\n        }\n        else {\n            output = output + space + '%';\n        }\n        return output;\n    }\n    function formatTime(value) {\n        var hours = Math.floor(value / 60 / 60), minutes = Math.floor((value - (hours * 60 * 60)) / 60), seconds = Math.round(value - (hours * 60 * 60) - (minutes * 60));\n        return hours + ':' +\n            ((minutes < 10) ? '0' + minutes : minutes) + ':' +\n            ((seconds < 10) ? '0' + seconds : seconds);\n    }\n    function formatNumber(value, format, roundingFunction, sep) {\n        var negP = false, signed = false, optDec = false, abbr = '', i, abbrK = false, // force abbreviation to thousands\n        abbrM = false, // force abbreviation to millions\n        abbrB = false, // force abbreviation to billions\n        abbrT = false, // force abbreviation to trillions\n        abbrForce = false, // force abbreviation\n        bytes = '', ord = '', abs = Math.abs(value), binarySuffixes = ['B', 'KiB', 'MiB', 'GiB', 'TiB', 'PiB', 'EiB', 'ZiB', 'YiB'], decimalSuffixes = ['B', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'], min, max, power, totalLength, length, minimumPrecision, pow, w, intPrecision, precision, prefix, postfix, thousands, d = '', forcedNeg = false, neg = false, indexOpenP, size, indexMinus, paren = '', minlen;\n        // check if number is zero and a custom zero format has been set\n        if (value === 0 && zeroFormat !== null) {\n            return zeroFormat;\n        }\n        if (!isFinite(value)) {\n            return '' + value;\n        }\n        if (format.indexOf('{') === 0) {\n            var end = format.indexOf('}');\n            if (end === -1) {\n                throw Error('Format should also contain a \"}\"');\n            }\n            prefix = format.slice(1, end);\n            format = format.slice(end + 1);\n        }\n        else {\n            prefix = '';\n        }\n        if (format.indexOf('}') === format.length - 1) {\n            var start = format.indexOf('{');\n            if (start === -1) {\n                throw Error('Format should also contain a \"{\"');\n            }\n            postfix = format.slice(start + 1, -1);\n            format = format.slice(0, start + 1);\n        }\n        else {\n            postfix = '';\n        }\n        // check for min length\n        var info;\n        if (format.indexOf('.') === -1) {\n            info = format.match(/([0-9]+).*/);\n        }\n        else {\n            info = format.match(/([0-9]+)\\..*/);\n        }\n        minlen = info === null ? -1 : info[1].length;\n        // see if we should use parentheses for negative number or if we should prefix with a sign\n        // if both are present we default to parentheses\n        if (format.indexOf('-') !== -1) {\n            forcedNeg = true;\n        }\n        if (format.indexOf('(') > -1) {\n            negP = true;\n            format = format.slice(1, -1);\n        }\n        else if (format.indexOf('+') > -1) {\n            signed = true;\n            format = format.replace(/\\+/g, '');\n        }\n        // see if abbreviation is wanted\n        if (format.indexOf('a') > -1) {\n            intPrecision = format.split('.')[0].match(/[0-9]+/g) || ['0'];\n            intPrecision = parseInt(intPrecision[0], 10);\n            // check if abbreviation is specified\n            abbrK = format.indexOf('aK') >= 0;\n            abbrM = format.indexOf('aM') >= 0;\n            abbrB = format.indexOf('aB') >= 0;\n            abbrT = format.indexOf('aT') >= 0;\n            abbrForce = abbrK || abbrM || abbrB || abbrT;\n            // check for space before abbreviation\n            if (format.indexOf(' a') > -1) {\n                abbr = ' ';\n                format = format.replace(' a', '');\n            }\n            else {\n                format = format.replace('a', '');\n            }\n            totalLength = Math.floor(Math.log(abs) / Math.LN10) + 1;\n            minimumPrecision = totalLength % 3;\n            minimumPrecision = minimumPrecision === 0 ? 3 : minimumPrecision;\n            if (intPrecision && abs !== 0) {\n                length = Math.floor(Math.log(abs) / Math.LN10) + 1 - intPrecision;\n                pow = 3 * ~~((Math.min(intPrecision, totalLength) - minimumPrecision) / 3);\n                abs = abs / Math.pow(10, pow);\n                if (format.indexOf('.') === -1 && intPrecision > 3) {\n                    format += '[.]';\n                    size = length === 0 ? 0 : 3 * ~~(length / 3) - length;\n                    size = size < 0 ? size + 3 : size;\n                    for (i = 0; i < size; i++) {\n                        format += '0';\n                    }\n                }\n            }\n            if (Math.floor(Math.log(Math.abs(value)) / Math.LN10) + 1 !== intPrecision) {\n                if (abs >= Math.pow(10, 12) && !abbrForce || abbrT) {\n                    // trillion\n                    abbr = abbr + cultures[currentCulture].abbreviations.trillion;\n                    value = value / Math.pow(10, 12);\n                }\n                else if (abs < Math.pow(10, 12) && abs >= Math.pow(10, 9) && !abbrForce || abbrB) {\n                    // billion\n                    abbr = abbr + cultures[currentCulture].abbreviations.billion;\n                    value = value / Math.pow(10, 9);\n                }\n                else if (abs < Math.pow(10, 9) && abs >= Math.pow(10, 6) && !abbrForce || abbrM) {\n                    // million\n                    abbr = abbr + cultures[currentCulture].abbreviations.million;\n                    value = value / Math.pow(10, 6);\n                }\n                else if (abs < Math.pow(10, 6) && abs >= Math.pow(10, 3) && !abbrForce || abbrK) {\n                    // thousand\n                    abbr = abbr + cultures[currentCulture].abbreviations.thousand;\n                    value = value / Math.pow(10, 3);\n                }\n            }\n        }\n        // see if we are formatting binary bytes\n        if (format.indexOf('b') > -1) {\n            // check for space before\n            if (format.indexOf(' b') > -1) {\n                bytes = ' ';\n                format = format.replace(' b', '');\n            }\n            else {\n                format = format.replace('b', '');\n            }\n            for (power = 0; power <= binarySuffixes.length; power++) {\n                min = Math.pow(1024, power);\n                max = Math.pow(1024, power + 1);\n                if (value >= min && value < max) {\n                    bytes = bytes + binarySuffixes[power];\n                    if (min > 0) {\n                        value = value / min;\n                    }\n                    break;\n                }\n            }\n        }\n        // see if we are formatting decimal bytes\n        if (format.indexOf('d') > -1) {\n            // check for space before\n            if (format.indexOf(' d') > -1) {\n                bytes = ' ';\n                format = format.replace(' d', '');\n            }\n            else {\n                format = format.replace('d', '');\n            }\n            for (power = 0; power <= decimalSuffixes.length; power++) {\n                min = Math.pow(1000, power);\n                max = Math.pow(1000, power + 1);\n                if (value >= min && value < max) {\n                    bytes = bytes + decimalSuffixes[power];\n                    if (min > 0) {\n                        value = value / min;\n                    }\n                    break;\n                }\n            }\n        }\n        // see if ordinal is wanted\n        if (format.indexOf('o') > -1) {\n            // check for space before\n            if (format.indexOf(' o') > -1) {\n                ord = ' ';\n                format = format.replace(' o', '');\n            }\n            else {\n                format = format.replace('o', '');\n            }\n            if (cultures[currentCulture].ordinal) {\n                ord = ord + cultures[currentCulture].ordinal(value);\n            }\n        }\n        if (format.indexOf('[.]') > -1) {\n            optDec = true;\n            format = format.replace('[.]', '.');\n        }\n        w = value.toString().split('.')[0];\n        precision = format.split('.')[1];\n        thousands = format.indexOf(',');\n        if (precision) {\n            if (precision.indexOf('*') !== -1) {\n                d = toFixed(value, value.toString().split('.')[1].length, roundingFunction);\n            }\n            else {\n                if (precision.indexOf('[') > -1) {\n                    precision = precision.replace(']', '');\n                    precision = precision.split('[');\n                    d = toFixed(value, (precision[0].length + precision[1].length), roundingFunction, precision[1].length);\n                }\n                else {\n                    d = toFixed(value, precision.length, roundingFunction);\n                }\n            }\n            w = d.split('.')[0];\n            if (d.split('.')[1].length) {\n                var p = sep ? abbr + sep : cultures[currentCulture].delimiters.decimal;\n                d = p + d.split('.')[1];\n            }\n            else {\n                d = '';\n            }\n            if (optDec && Number(d.slice(1)) === 0) {\n                d = '';\n            }\n        }\n        else {\n            w = toFixed(value, null, roundingFunction);\n        }\n        // format number\n        if (w.indexOf('-') > -1) {\n            w = w.slice(1);\n            neg = true;\n        }\n        if (w.length < minlen) {\n            w = new Array(minlen - w.length + 1).join('0') + w;\n        }\n        if (thousands > -1) {\n            w = w.toString().replace(/(\\d)(?=(\\d{3})+(?!\\d))/g, '$1' +\n                cultures[currentCulture].delimiters.thousands);\n        }\n        if (format.indexOf('.') === 0) {\n            w = '';\n        }\n        indexOpenP = format.indexOf('(');\n        indexMinus = format.indexOf('-');\n        if (indexOpenP < indexMinus) {\n            paren = ((negP && neg) ? '(' : '') + (((forcedNeg && neg) || (!negP && neg)) ? '-' : '');\n        }\n        else {\n            paren = (((forcedNeg && neg) || (!negP && neg)) ? '-' : '') + ((negP && neg) ? '(' : '');\n        }\n        return prefix +\n            paren + ((!neg && signed && value !== 0) ? '+' : '') +\n            w + d +\n            ((ord) ? ord : '') +\n            ((abbr && !sep) ? abbr : '') +\n            ((bytes) ? bytes : '') +\n            ((negP && neg) ? ')' : '') +\n            postfix;\n    }\n    /************************************\n        Top Level Functions\n    ************************************/\n    numbro = function (input) {\n        if (numbro.isNumbro(input)) {\n            input = input.value();\n        }\n        else if (input === 0 || typeof input === 'undefined') {\n            input = 0;\n        }\n        else if (!Number(input)) {\n            input = numbro.fn.unformat(input);\n        }\n        return new Numbro(Number(input));\n    };\n    // version number\n    numbro.version = VERSION;\n    // compare numbro object\n    numbro.isNumbro = function (obj) {\n        return obj instanceof Numbro;\n    };\n    /**\n     * This function allow the user to set a new language with a fallback if\n     * the language does not exist. If no fallback language is provided,\n     * it fallbacks to english.\n     *\n     * @deprecated Since in version 1.6.0. It will be deleted in version 2.0\n     * `setCulture` should be used instead.\n     */\n    numbro.setLanguage = function (newLanguage, fallbackLanguage) {\n        console.warn('`setLanguage` is deprecated since version 1.6.0. Use `setCulture` instead');\n        var key = newLanguage, prefix = newLanguage.split('-')[0], matchingLanguage = null;\n        if (!languages[key]) {\n            Object.keys(languages).forEach(function (language) {\n                if (!matchingLanguage && language.split('-')[0] === prefix) {\n                    matchingLanguage = language;\n                }\n            });\n            key = matchingLanguage || fallbackLanguage || 'en-US';\n        }\n        chooseCulture(key);\n    };\n    /**\n     * This function allow the user to set a new culture with a fallback if\n     * the culture does not exist. If no fallback culture is provided,\n     * it fallbacks to \"en-US\".\n     */\n    numbro.setCulture = function (newCulture, fallbackCulture) {\n        var key = newCulture, suffix = newCulture.split('-')[1], matchingCulture = null;\n        if (!cultures[key]) {\n            if (suffix) {\n                Object.keys(cultures).forEach(function (language) {\n                    if (!matchingCulture && language.split('-')[1] === suffix) {\n                        matchingCulture = language;\n                    }\n                });\n            }\n            key = matchingCulture || fallbackCulture || 'en-US';\n        }\n        chooseCulture(key);\n    };\n    /**\n     * This function will load languages and then set the global language.  If\n     * no arguments are passed in, it will simply return the current global\n     * language key.\n     *\n     * @deprecated Since in version 1.6.0. It will be deleted in version 2.0\n     * `culture` should be used instead.\n     */\n    numbro.language = function (key, values) {\n        console.warn('`language` is deprecated since version 1.6.0. Use `culture` instead');\n        if (!key) {\n            return currentCulture;\n        }\n        if (key && !values) {\n            if (!languages[key]) {\n                throw new Error('Unknown language : ' + key);\n            }\n            chooseCulture(key);\n        }\n        if (values || !languages[key]) {\n            setCulture(key, values);\n        }\n        return numbro;\n    };\n    /**\n     * This function will load cultures and then set the global culture.  If\n     * no arguments are passed in, it will simply return the current global\n     * culture code.\n     */\n    numbro.culture = function (code, values) {\n        if (!code) {\n            return currentCulture;\n        }\n        if (code && !values) {\n            if (!cultures[code]) {\n                throw new Error('Unknown culture : ' + code);\n            }\n            chooseCulture(code);\n        }\n        if (values || !cultures[code]) {\n            setCulture(code, values);\n        }\n        return numbro;\n    };\n    /**\n     * This function provides access to the loaded language data.  If\n     * no arguments are passed in, it will simply return the current\n     * global language object.\n     *\n     * @deprecated Since in version 1.6.0. It will be deleted in version 2.0\n     * `culture` should be used instead.\n     */\n    numbro.languageData = function (key) {\n        console.warn('`languageData` is deprecated since version 1.6.0. Use `cultureData` instead');\n        if (!key) {\n            return languages[currentCulture];\n        }\n        if (!languages[key]) {\n            throw new Error('Unknown language : ' + key);\n        }\n        return languages[key];\n    };\n    /**\n     * This function provides access to the loaded culture data.  If\n     * no arguments are passed in, it will simply return the current\n     * global culture object.\n     */\n    numbro.cultureData = function (code) {\n        if (!code) {\n            return cultures[currentCulture];\n        }\n        if (!cultures[code]) {\n            throw new Error('Unknown culture : ' + code);\n        }\n        return cultures[code];\n    };\n    numbro.culture('en-US', enUS);\n    /**\n     * @deprecated Since in version 1.6.0. It will be deleted in version 2.0\n     * `cultures` should be used instead.\n     */\n    numbro.languages = function () {\n        console.warn('`languages` is deprecated since version 1.6.0. Use `cultures` instead');\n        return languages;\n    };\n    numbro.cultures = function () {\n        return cultures;\n    };\n    numbro.zeroFormat = function (format) {\n        zeroFormat = typeof (format) === 'string' ? format : null;\n    };\n    numbro.defaultFormat = function (format) {\n        defaultFormat = typeof (format) === 'string' ? format : '0.0';\n    };\n    numbro.defaultCurrencyFormat = function (format) {\n        defaultCurrencyFormat = typeof (format) === 'string' ? format : '0$';\n    };\n    numbro.validate = function (val, culture) {\n        var _decimalSep, _thousandSep, _currSymbol, _valArray, _abbrObj, _thousandRegEx, cultureData, temp;\n        //coerce val to string\n        if (typeof val !== 'string') {\n            val += '';\n            if (console.warn) {\n                console.warn('Numbro.js: Value is not string. It has been co-erced to: ', val);\n            }\n        }\n        //trim whitespaces from either sides\n        val = val.trim();\n        //if val is just digits return true\n        if (!!val.match(/^\\d+$/)) {\n            return true;\n        }\n        //if val is empty return false\n        if (val === '') {\n            return false;\n        }\n        //get the decimal and thousands separator from numbro.cultureData\n        try {\n            //check if the culture is understood by numbro. if not, default it to current culture\n            cultureData = numbro.cultureData(culture);\n        }\n        catch (e) {\n            cultureData = numbro.cultureData(numbro.culture());\n        }\n        //setup the delimiters and currency symbol based on culture\n        _currSymbol = cultureData.currency.symbol;\n        _abbrObj = cultureData.abbreviations;\n        _decimalSep = cultureData.delimiters.decimal;\n        if (cultureData.delimiters.thousands === '.') {\n            _thousandSep = '\\\\.';\n        }\n        else {\n            _thousandSep = cultureData.delimiters.thousands;\n        }\n        // validating currency symbol\n        temp = val.match(/^[^\\d]+/);\n        if (temp !== null) {\n            val = val.substr(1);\n            if (temp[0] !== _currSymbol) {\n                return false;\n            }\n        }\n        //validating abbreviation symbol\n        temp = val.match(/[^\\d]+$/);\n        if (temp !== null) {\n            val = val.slice(0, -1);\n            if (temp[0] !== _abbrObj.thousand && temp[0] !== _abbrObj.million &&\n                temp[0] !== _abbrObj.billion && temp[0] !== _abbrObj.trillion) {\n                return false;\n            }\n        }\n        _thousandRegEx = new RegExp(_thousandSep + '{2}');\n        if (!val.match(/[^\\d.,]/g)) {\n            _valArray = val.split(_decimalSep);\n            if (_valArray.length > 2) {\n                return false;\n            }\n            else {\n                if (_valArray.length < 2) {\n                    return (!!_valArray[0].match(/^\\d+.*\\d$/) && !_valArray[0].match(_thousandRegEx));\n                }\n                else {\n                    if (_valArray[0].length === 1) {\n                        return (!!_valArray[0].match(/^\\d+$/) &&\n                            !_valArray[0].match(_thousandRegEx) &&\n                            !!_valArray[1].match(/^\\d+$/));\n                    }\n                    else {\n                        return (!!_valArray[0].match(/^\\d+.*\\d$/) &&\n                            !_valArray[0].match(_thousandRegEx) &&\n                            !!_valArray[1].match(/^\\d+$/));\n                    }\n                }\n            }\n        }\n        return false;\n    };\n    /************************************\n        Helpers\n    ************************************/\n    function setCulture(code, values) {\n        cultures[code] = values;\n    }\n    function chooseCulture(code) {\n        currentCulture = code;\n        var defaults = cultures[code].defaults;\n        if (defaults && defaults.format) {\n            numbro.defaultFormat(defaults.format);\n        }\n        if (defaults && defaults.currencyFormat) {\n            numbro.defaultCurrencyFormat(defaults.currencyFormat);\n        }\n    }\n    function format(input, formatString, language, roundingFunction) {\n        if (language != null && language !== numbro.culture()) {\n            numbro.setCulture(language);\n        }\n        return formatNumbro(Number(input), formatString != null ? formatString : defaultFormat, roundingFunction == null ? Math.round : roundingFunction);\n    }\n    module.exports = { \"format\": format };\n}\n","/* models/tickers/datetime_ticker.js */ function _(require, module, exports) {\n    const array_1 = require(8) /* ../../core/util/array */;\n    const adaptive_ticker_1 = require(103) /* ./adaptive_ticker */;\n    const composite_ticker_1 = require(155) /* ./composite_ticker */;\n    const days_ticker_1 = require(156) /* ./days_ticker */;\n    const months_ticker_1 = require(159) /* ./months_ticker */;\n    const years_ticker_1 = require(160) /* ./years_ticker */;\n    const util_1 = require(158) /* ./util */;\n    class DatetimeTicker extends composite_ticker_1.CompositeTicker {\n        constructor(attrs) {\n            super(attrs);\n        }\n        static init_DatetimeTicker() {\n            this.override({\n                num_minor_ticks: 0,\n                tickers: () => [\n                    // Sub-second.\n                    new adaptive_ticker_1.AdaptiveTicker({\n                        mantissas: [1, 2, 5],\n                        base: 10,\n                        min_interval: 0,\n                        max_interval: 500 * util_1.ONE_MILLI,\n                        num_minor_ticks: 0,\n                    }),\n                    // Seconds, minutes.\n                    new adaptive_ticker_1.AdaptiveTicker({\n                        mantissas: [1, 2, 5, 10, 15, 20, 30],\n                        base: 60,\n                        min_interval: util_1.ONE_SECOND,\n                        max_interval: 30 * util_1.ONE_MINUTE,\n                        num_minor_ticks: 0,\n                    }),\n                    // Hours.\n                    new adaptive_ticker_1.AdaptiveTicker({\n                        mantissas: [1, 2, 4, 6, 8, 12],\n                        base: 24.0,\n                        min_interval: util_1.ONE_HOUR,\n                        max_interval: 12 * util_1.ONE_HOUR,\n                        num_minor_ticks: 0,\n                    }),\n                    // Days.\n                    new days_ticker_1.DaysTicker({ days: array_1.range(1, 32) }),\n                    new days_ticker_1.DaysTicker({ days: array_1.range(1, 31, 3) }),\n                    new days_ticker_1.DaysTicker({ days: [1, 8, 15, 22] }),\n                    new days_ticker_1.DaysTicker({ days: [1, 15] }),\n                    // Months.\n                    new months_ticker_1.MonthsTicker({ months: array_1.range(0, 12, 1) }),\n                    new months_ticker_1.MonthsTicker({ months: array_1.range(0, 12, 2) }),\n                    new months_ticker_1.MonthsTicker({ months: array_1.range(0, 12, 4) }),\n                    new months_ticker_1.MonthsTicker({ months: array_1.range(0, 12, 6) }),\n                    // Years\n                    new years_ticker_1.YearsTicker({}),\n                ],\n            });\n        }\n    }\n    exports.DatetimeTicker = DatetimeTicker;\n    DatetimeTicker.__name__ = \"DatetimeTicker\";\n    DatetimeTicker.init_DatetimeTicker();\n}\n","/* models/tickers/composite_ticker.js */ function _(require, module, exports) {\n    const continuous_ticker_1 = require(104) /* ./continuous_ticker */;\n    const p = require(18) /* ../../core/properties */;\n    const array_1 = require(8) /* ../../core/util/array */;\n    const object_1 = require(22) /* ../../core/util/object */;\n    class CompositeTicker extends continuous_ticker_1.ContinuousTicker {\n        constructor(attrs) {\n            super(attrs);\n        }\n        static init_CompositeTicker() {\n            this.define({\n                tickers: [p.Array, []],\n            });\n        }\n        // The tickers should be in order of increasing interval size; specifically,\n        // if S comes before T, then it should be the case that\n        // S.get_max_interval() < T.get_min_interval().\n        // FIXME Enforce this automatically.\n        get min_intervals() {\n            return this.tickers.map((ticker) => ticker.get_min_interval());\n        }\n        get max_intervals() {\n            return this.tickers.map((ticker) => ticker.get_max_interval());\n        }\n        get min_interval() {\n            return this.min_intervals[0];\n        }\n        get max_interval() {\n            return this.max_intervals[0];\n        }\n        get_best_ticker(data_low, data_high, desired_n_ticks) {\n            const data_range = data_high - data_low;\n            const ideal_interval = this.get_ideal_interval(data_low, data_high, desired_n_ticks);\n            const ticker_ndxs = [\n                array_1.sorted_index(this.min_intervals, ideal_interval) - 1,\n                array_1.sorted_index(this.max_intervals, ideal_interval),\n            ];\n            const intervals = [\n                this.min_intervals[ticker_ndxs[0]],\n                this.max_intervals[ticker_ndxs[1]],\n            ];\n            const errors = intervals.map((interval) => {\n                return Math.abs(desired_n_ticks - (data_range / interval));\n            });\n            let best_ticker;\n            if (object_1.isEmpty(errors.filter((e) => !isNaN(e)))) {\n                // this can happen if the data isn't loaded yet, we just default to the first scale\n                best_ticker = this.tickers[0];\n            }\n            else {\n                const best_index = array_1.argmin(errors);\n                const best_ticker_ndx = ticker_ndxs[best_index];\n                best_ticker = this.tickers[best_ticker_ndx];\n            }\n            return best_ticker;\n        }\n        get_interval(data_low, data_high, desired_n_ticks) {\n            const best_ticker = this.get_best_ticker(data_low, data_high, desired_n_ticks);\n            return best_ticker.get_interval(data_low, data_high, desired_n_ticks);\n        }\n        get_ticks_no_defaults(data_low, data_high, cross_loc, desired_n_ticks) {\n            const best_ticker = this.get_best_ticker(data_low, data_high, desired_n_ticks);\n            return best_ticker.get_ticks_no_defaults(data_low, data_high, cross_loc, desired_n_ticks);\n        }\n    }\n    exports.CompositeTicker = CompositeTicker;\n    CompositeTicker.__name__ = \"CompositeTicker\";\n    CompositeTicker.init_CompositeTicker();\n}\n","/* models/tickers/days_ticker.js */ function _(require, module, exports) {\n    const single_interval_ticker_1 = require(157) /* ./single_interval_ticker */;\n    const util_1 = require(158) /* ./util */;\n    const p = require(18) /* ../../core/properties */;\n    const array_1 = require(8) /* ../../core/util/array */;\n    // Given a start and end time in millis, returns the shortest array of\n    // consecutive months (as Dates) that surrounds both times.\n    function date_range_by_month(start_time, end_time) {\n        const start_date = util_1.last_month_no_later_than(new Date(start_time));\n        const end_date = util_1.last_month_no_later_than(new Date(end_time));\n        // XXX This is not a reliable technique in general, but it should be\n        // safe when the day of the month is 1.  (The problem case is this:\n        // Mar 31 -> Apr 31, which becomes May 1.)\n        end_date.setUTCMonth(end_date.getUTCMonth() + 1);\n        const dates = [];\n        const date = start_date;\n        while (true) {\n            dates.push(util_1.copy_date(date));\n            date.setUTCMonth(date.getUTCMonth() + 1);\n            if (date > end_date)\n                break;\n        }\n        return dates;\n    }\n    class DaysTicker extends single_interval_ticker_1.SingleIntervalTicker {\n        constructor(attrs) {\n            super(attrs);\n        }\n        static init_DaysTicker() {\n            this.define({\n                days: [p.Array, []],\n            });\n            this.override({\n                num_minor_ticks: 0,\n            });\n        }\n        initialize() {\n            super.initialize();\n            const days = this.days;\n            if (days.length > 1)\n                this.interval = (days[1] - days[0]) * util_1.ONE_DAY;\n            else\n                this.interval = 31 * util_1.ONE_DAY;\n        }\n        get_ticks_no_defaults(data_low, data_high, _cross_loc, _desired_n_ticks) {\n            const month_dates = date_range_by_month(data_low, data_high);\n            const days = this.days;\n            const days_of_month = (month_date, interval) => {\n                const current_month = month_date.getUTCMonth();\n                const dates = [];\n                for (const day of days) {\n                    const day_date = util_1.copy_date(month_date);\n                    day_date.setUTCDate(day);\n                    // We can't use all of the values in this.days, because they may not\n                    // fall within the current month.  In fact, if, e.g., our month is 28 days\n                    // and we're marking every third day, we don't want day 28 to show up\n                    // because it'll be right next to the 1st of the next month.  So we\n                    // make sure we have a bit of room before we include a day.\n                    // TODO (bev) The above description does not exactly work because JS Date\n                    // is broken and will happily consider \"Feb 28 + 3*ONE_DAY\" to have month \"2\"\n                    const future_date = new Date(day_date.getTime() + (interval / 2));\n                    if (future_date.getUTCMonth() == current_month)\n                        dates.push(day_date);\n                }\n                return dates;\n            };\n            const interval = this.interval;\n            const day_dates = array_1.concat(month_dates.map((date) => days_of_month(date, interval)));\n            const all_ticks = day_dates.map((day_date) => day_date.getTime());\n            const ticks_in_range = all_ticks.filter((tick) => data_low <= tick && tick <= data_high);\n            return {\n                major: ticks_in_range,\n                minor: [],\n            };\n        }\n    }\n    exports.DaysTicker = DaysTicker;\n    DaysTicker.__name__ = \"DaysTicker\";\n    DaysTicker.init_DaysTicker();\n}\n","/* models/tickers/single_interval_ticker.js */ function _(require, module, exports) {\n    const continuous_ticker_1 = require(104) /* ./continuous_ticker */;\n    const p = require(18) /* ../../core/properties */;\n    class SingleIntervalTicker extends continuous_ticker_1.ContinuousTicker {\n        constructor(attrs) {\n            super(attrs);\n        }\n        static init_SingleIntervalTicker() {\n            this.define({\n                interval: [p.Number],\n            });\n        }\n        get_interval(_data_low, _data_high, _n_desired_ticks) {\n            return this.interval;\n        }\n        get min_interval() {\n            return this.interval;\n        }\n        get max_interval() {\n            return this.interval;\n        }\n    }\n    exports.SingleIntervalTicker = SingleIntervalTicker;\n    SingleIntervalTicker.__name__ = \"SingleIntervalTicker\";\n    SingleIntervalTicker.init_SingleIntervalTicker();\n}\n","/* models/tickers/util.js */ function _(require, module, exports) {\n    // Some time constants, in milliseconds.\n    exports.ONE_MILLI = 1.0;\n    exports.ONE_SECOND = 1000.0;\n    exports.ONE_MINUTE = 60.0 * exports.ONE_SECOND;\n    exports.ONE_HOUR = 60 * exports.ONE_MINUTE;\n    exports.ONE_DAY = 24 * exports.ONE_HOUR;\n    exports.ONE_MONTH = 30 * exports.ONE_DAY; // An approximation, obviously.\n    exports.ONE_YEAR = 365 * exports.ONE_DAY;\n    // ---------------------------------------------------------------------------\n    // Date/time utility functions\n    // ---------------------------------------------------------------------------\n    // Makes a copy of a date object.\n    function copy_date(date) {\n        return new Date(date.getTime());\n    }\n    exports.copy_date = copy_date;\n    // Rounds a date down to the month.\n    function last_month_no_later_than(date) {\n        const new_date = copy_date(date);\n        new_date.setUTCDate(1);\n        new_date.setUTCHours(0);\n        new_date.setUTCMinutes(0);\n        new_date.setUTCSeconds(0);\n        new_date.setUTCMilliseconds(0);\n        return new_date;\n    }\n    exports.last_month_no_later_than = last_month_no_later_than;\n    // Rounds a date down to the year.\n    function last_year_no_later_than(date) {\n        const new_date = last_month_no_later_than(date);\n        new_date.setUTCMonth(0);\n        return new_date;\n    }\n    exports.last_year_no_later_than = last_year_no_later_than;\n}\n","/* models/tickers/months_ticker.js */ function _(require, module, exports) {\n    const single_interval_ticker_1 = require(157) /* ./single_interval_ticker */;\n    const util_1 = require(158) /* ./util */;\n    const p = require(18) /* ../../core/properties */;\n    const array_1 = require(8) /* ../../core/util/array */;\n    // Given a start and end time in millis, returns the shortest array of\n    // consecutive years (as Dates) that surrounds both times.\n    function date_range_by_year(start_time, end_time) {\n        const start_date = util_1.last_year_no_later_than(new Date(start_time));\n        const end_date = util_1.last_year_no_later_than(new Date(end_time));\n        end_date.setUTCFullYear(end_date.getUTCFullYear() + 1);\n        const dates = [];\n        const date = start_date;\n        while (true) {\n            dates.push(util_1.copy_date(date));\n            date.setUTCFullYear(date.getUTCFullYear() + 1);\n            if (date > end_date)\n                break;\n        }\n        return dates;\n    }\n    class MonthsTicker extends single_interval_ticker_1.SingleIntervalTicker {\n        constructor(attrs) {\n            super(attrs);\n        }\n        static init_MonthsTicker() {\n            this.define({\n                months: [p.Array, []],\n            });\n        }\n        initialize() {\n            super.initialize();\n            const months = this.months;\n            if (months.length > 1)\n                this.interval = (months[1] - months[0]) * util_1.ONE_MONTH;\n            else\n                this.interval = 12 * util_1.ONE_MONTH;\n        }\n        get_ticks_no_defaults(data_low, data_high, _cross_loc, _desired_n_ticks) {\n            const year_dates = date_range_by_year(data_low, data_high);\n            const months = this.months;\n            const months_of_year = (year_date) => {\n                return months.map((month) => {\n                    const month_date = util_1.copy_date(year_date);\n                    month_date.setUTCMonth(month);\n                    return month_date;\n                });\n            };\n            const month_dates = array_1.concat(year_dates.map(months_of_year));\n            const all_ticks = month_dates.map((month_date) => month_date.getTime());\n            const ticks_in_range = all_ticks.filter((tick) => data_low <= tick && tick <= data_high);\n            return {\n                major: ticks_in_range,\n                minor: [],\n            };\n        }\n    }\n    exports.MonthsTicker = MonthsTicker;\n    MonthsTicker.__name__ = \"MonthsTicker\";\n    MonthsTicker.init_MonthsTicker();\n}\n","/* models/tickers/years_ticker.js */ function _(require, module, exports) {\n    const basic_ticker_1 = require(102) /* ./basic_ticker */;\n    const single_interval_ticker_1 = require(157) /* ./single_interval_ticker */;\n    const util_1 = require(158) /* ./util */;\n    class YearsTicker extends single_interval_ticker_1.SingleIntervalTicker {\n        constructor(attrs) {\n            super(attrs);\n        }\n        initialize() {\n            super.initialize();\n            this.interval = util_1.ONE_YEAR;\n            this.basic_ticker = new basic_ticker_1.BasicTicker({ num_minor_ticks: 0 });\n        }\n        get_ticks_no_defaults(data_low, data_high, cross_loc, desired_n_ticks) {\n            const start_year = util_1.last_year_no_later_than(new Date(data_low)).getUTCFullYear();\n            const end_year = util_1.last_year_no_later_than(new Date(data_high)).getUTCFullYear();\n            const years = this.basic_ticker.get_ticks_no_defaults(start_year, end_year, cross_loc, desired_n_ticks).major;\n            const all_ticks = years.map((year) => Date.UTC(year, 0, 1));\n            const ticks_in_range = all_ticks.filter((tick) => data_low <= tick && tick <= data_high);\n            return {\n                major: ticks_in_range,\n                minor: [],\n            };\n        }\n    }\n    exports.YearsTicker = YearsTicker;\n    YearsTicker.__name__ = \"YearsTicker\";\n}\n","/* models/axes/log_axis.js */ function _(require, module, exports) {\n    const axis_1 = require(141) /* ./axis */;\n    const continuous_axis_1 = require(146) /* ./continuous_axis */;\n    const log_tick_formatter_1 = require(162) /* ../formatters/log_tick_formatter */;\n    const log_ticker_1 = require(163) /* ../tickers/log_ticker */;\n    class LogAxisView extends axis_1.AxisView {\n    }\n    exports.LogAxisView = LogAxisView;\n    LogAxisView.__name__ = \"LogAxisView\";\n    class LogAxis extends continuous_axis_1.ContinuousAxis {\n        constructor(attrs) {\n            super(attrs);\n        }\n        static init_LogAxis() {\n            this.prototype.default_view = LogAxisView;\n            this.override({\n                ticker: () => new log_ticker_1.LogTicker(),\n                formatter: () => new log_tick_formatter_1.LogTickFormatter(),\n            });\n        }\n    }\n    exports.LogAxis = LogAxis;\n    LogAxis.__name__ = \"LogAxis\";\n    LogAxis.init_LogAxis();\n}\n","/* models/formatters/log_tick_formatter.js */ function _(require, module, exports) {\n    const tick_formatter_1 = require(107) /* ./tick_formatter */;\n    const basic_tick_formatter_1 = require(106) /* ./basic_tick_formatter */;\n    const logging_1 = require(65) /* ../../core/logging */;\n    const p = require(18) /* ../../core/properties */;\n    class LogTickFormatter extends tick_formatter_1.TickFormatter {\n        constructor(attrs) {\n            super(attrs);\n        }\n        static init_LogTickFormatter() {\n            this.define({\n                ticker: [p.Instance, null],\n            });\n        }\n        initialize() {\n            super.initialize();\n            this.basic_formatter = new basic_tick_formatter_1.BasicTickFormatter();\n            if (this.ticker == null)\n                logging_1.logger.warn(\"LogTickFormatter not configured with a ticker, using default base of 10 (labels will be incorrect if ticker base is not 10)\");\n        }\n        doFormat(ticks, opts) {\n            if (ticks.length == 0)\n                return [];\n            const base = this.ticker != null ? this.ticker.base : 10;\n            let small_interval = false;\n            const labels = new Array(ticks.length);\n            for (let i = 0, end = ticks.length; i < end; i++) {\n                labels[i] = `${base}^${Math.round(Math.log(ticks[i]) / Math.log(base))}`;\n                if (i > 0 && labels[i] == labels[i - 1]) {\n                    small_interval = true;\n                    break;\n                }\n            }\n            if (small_interval)\n                return this.basic_formatter.doFormat(ticks, opts);\n            else\n                return labels;\n        }\n    }\n    exports.LogTickFormatter = LogTickFormatter;\n    LogTickFormatter.__name__ = \"LogTickFormatter\";\n    LogTickFormatter.init_LogTickFormatter();\n}\n","/* models/tickers/log_ticker.js */ function _(require, module, exports) {\n    const adaptive_ticker_1 = require(103) /* ./adaptive_ticker */;\n    const array_1 = require(8) /* ../../core/util/array */;\n    class LogTicker extends adaptive_ticker_1.AdaptiveTicker {\n        constructor(attrs) {\n            super(attrs);\n        }\n        static init_LogTicker() {\n            this.override({\n                mantissas: [1, 5],\n            });\n        }\n        get_ticks_no_defaults(data_low, data_high, _cross_loc, desired_n_ticks) {\n            const num_minor_ticks = this.num_minor_ticks;\n            const minor_ticks = [];\n            const base = this.base;\n            const log_low = Math.log(data_low) / Math.log(base);\n            const log_high = Math.log(data_high) / Math.log(base);\n            const log_interval = log_high - log_low;\n            let ticks;\n            if (!isFinite(log_interval)) {\n                ticks = [];\n            }\n            else if (log_interval < 2) { // treat as linear ticker\n                const interval = this.get_interval(data_low, data_high, desired_n_ticks);\n                const start_factor = Math.floor(data_low / interval);\n                const end_factor = Math.ceil(data_high / interval);\n                ticks = array_1.range(start_factor, end_factor + 1)\n                    .filter((factor) => factor != 0)\n                    .map((factor) => factor * interval)\n                    .filter((tick) => data_low <= tick && tick <= data_high);\n                if (num_minor_ticks > 0 && ticks.length > 0) {\n                    const minor_interval = interval / num_minor_ticks;\n                    const minor_offsets = array_1.range(0, num_minor_ticks).map((i) => i * minor_interval);\n                    for (const x of minor_offsets.slice(1)) {\n                        minor_ticks.push(ticks[0] - x);\n                    }\n                    for (const tick of ticks) {\n                        for (const x of minor_offsets) {\n                            minor_ticks.push(tick + x);\n                        }\n                    }\n                }\n            }\n            else {\n                const startlog = Math.ceil(log_low * 0.999999);\n                const endlog = Math.floor(log_high * 1.000001);\n                const interval = Math.ceil((endlog - startlog) / 9.0);\n                ticks = array_1.range(startlog - 1, endlog + 1, interval)\n                    .map((i) => Math.pow(base, i));\n                if (num_minor_ticks > 0 && ticks.length > 0) {\n                    const minor_interval = Math.pow(base, interval) / num_minor_ticks;\n                    const minor_offsets = array_1.range(1, num_minor_ticks + 1).map((i) => i * minor_interval);\n                    for (const x of minor_offsets) {\n                        minor_ticks.push(ticks[0] / x);\n                    }\n                    minor_ticks.push(ticks[0]);\n                    for (const tick of ticks) {\n                        for (const x of minor_offsets) {\n                            minor_ticks.push(tick * x);\n                        }\n                    }\n                }\n            }\n            return {\n                major: ticks.filter((tick) => data_low <= tick && tick <= data_high),\n                minor: minor_ticks.filter((tick) => data_low <= tick && tick <= data_high),\n            };\n        }\n    }\n    exports.LogTicker = LogTicker;\n    LogTicker.__name__ = \"LogTicker\";\n    LogTicker.init_LogTicker();\n}\n","/* models/axes/mercator_axis.js */ function _(require, module, exports) {\n    const axis_1 = require(141) /* ./axis */;\n    const linear_axis_1 = require(148) /* ./linear_axis */;\n    const mercator_tick_formatter_1 = require(165) /* ../formatters/mercator_tick_formatter */;\n    const mercator_ticker_1 = require(166) /* ../tickers/mercator_ticker */;\n    class MercatorAxisView extends axis_1.AxisView {\n    }\n    exports.MercatorAxisView = MercatorAxisView;\n    MercatorAxisView.__name__ = \"MercatorAxisView\";\n    class MercatorAxis extends linear_axis_1.LinearAxis {\n        constructor(attrs) {\n            super(attrs);\n        }\n        static init_MercatorAxis() {\n            this.prototype.default_view = MercatorAxisView;\n            this.override({\n                ticker: () => new mercator_ticker_1.MercatorTicker({ dimension: \"lat\" }),\n                formatter: () => new mercator_tick_formatter_1.MercatorTickFormatter({ dimension: \"lat\" }),\n            });\n        }\n    }\n    exports.MercatorAxis = MercatorAxis;\n    MercatorAxis.__name__ = \"MercatorAxis\";\n    MercatorAxis.init_MercatorAxis();\n}\n","/* models/formatters/mercator_tick_formatter.js */ function _(require, module, exports) {\n    const basic_tick_formatter_1 = require(106) /* ./basic_tick_formatter */;\n    const p = require(18) /* ../../core/properties */;\n    const projections_1 = require(30) /* ../../core/util/projections */;\n    class MercatorTickFormatter extends basic_tick_formatter_1.BasicTickFormatter {\n        constructor(attrs) {\n            super(attrs);\n        }\n        static init_MercatorTickFormatter() {\n            this.define({\n                dimension: [p.LatLon],\n            });\n        }\n        doFormat(ticks, opts) {\n            if (this.dimension == null)\n                throw new Error(\"MercatorTickFormatter.dimension not configured\");\n            if (ticks.length == 0)\n                return [];\n            const n = ticks.length;\n            const proj_ticks = new Array(n);\n            if (this.dimension == \"lon\") {\n                for (let i = 0; i < n; i++) {\n                    const [lon] = projections_1.wgs84_mercator.inverse([ticks[i], opts.loc]);\n                    proj_ticks[i] = lon;\n                }\n            }\n            else {\n                for (let i = 0; i < n; i++) {\n                    const [, lat] = projections_1.wgs84_mercator.inverse([opts.loc, ticks[i]]);\n                    proj_ticks[i] = lat;\n                }\n            }\n            return super.doFormat(proj_ticks, opts);\n        }\n    }\n    exports.MercatorTickFormatter = MercatorTickFormatter;\n    MercatorTickFormatter.__name__ = \"MercatorTickFormatter\";\n    MercatorTickFormatter.init_MercatorTickFormatter();\n}\n","/* models/tickers/mercator_ticker.js */ function _(require, module, exports) {\n    const basic_ticker_1 = require(102) /* ./basic_ticker */;\n    const p = require(18) /* ../../core/properties */;\n    const projections_1 = require(30) /* ../../core/util/projections */;\n    class MercatorTicker extends basic_ticker_1.BasicTicker {\n        constructor(attrs) {\n            super(attrs);\n        }\n        static init_MercatorTicker() {\n            this.define({\n                dimension: [p.LatLon],\n            });\n        }\n        get_ticks_no_defaults(data_low, data_high, cross_loc, desired_n_ticks) {\n            if (this.dimension == null) {\n                throw new Error(\"MercatorTicker.dimension not configured\");\n            }\n            [data_low, data_high] = projections_1.clip_mercator(data_low, data_high, this.dimension);\n            let proj_low, proj_high, proj_cross_loc;\n            if (this.dimension === \"lon\") {\n                [proj_low, proj_cross_loc] = projections_1.wgs84_mercator.inverse([data_low, cross_loc]);\n                [proj_high, proj_cross_loc] = projections_1.wgs84_mercator.inverse([data_high, cross_loc]);\n            }\n            else {\n                [proj_cross_loc, proj_low] = projections_1.wgs84_mercator.inverse([cross_loc, data_low]);\n                [proj_cross_loc, proj_high] = projections_1.wgs84_mercator.inverse([cross_loc, data_high]);\n            }\n            const proj_ticks = super.get_ticks_no_defaults(proj_low, proj_high, cross_loc, desired_n_ticks);\n            const major = [];\n            const minor = [];\n            if (this.dimension === \"lon\") {\n                for (const tick of proj_ticks.major) {\n                    if (projections_1.in_bounds(tick, 'lon')) {\n                        const [lon] = projections_1.wgs84_mercator.forward([tick, proj_cross_loc]);\n                        major.push(lon);\n                    }\n                }\n                for (const tick of proj_ticks.minor) {\n                    if (projections_1.in_bounds(tick, 'lon')) {\n                        const [lon] = projections_1.wgs84_mercator.forward([tick, proj_cross_loc]);\n                        minor.push(lon);\n                    }\n                }\n            }\n            else {\n                for (const tick of proj_ticks.major) {\n                    if (projections_1.in_bounds(tick, 'lat')) {\n                        const [, lat] = projections_1.wgs84_mercator.forward([proj_cross_loc, tick]);\n                        major.push(lat);\n                    }\n                }\n                for (const tick of proj_ticks.minor) {\n                    if (projections_1.in_bounds(tick, 'lat')) {\n                        const [, lat] = projections_1.wgs84_mercator.forward([proj_cross_loc, tick]);\n                        minor.push(lat);\n                    }\n                }\n            }\n            return { major, minor };\n        }\n    }\n    exports.MercatorTicker = MercatorTicker;\n    MercatorTicker.__name__ = \"MercatorTicker\";\n    MercatorTicker.init_MercatorTicker();\n}\n","/* models/callbacks/index.js */ function _(require, module, exports) {\n    var customjs_1 = require(168) /* ./customjs */;\n    exports.CustomJS = customjs_1.CustomJS;\n    var open_url_1 = require(170) /* ./open_url */;\n    exports.OpenURL = open_url_1.OpenURL;\n}\n","/* models/callbacks/customjs.js */ function _(require, module, exports) {\n    const callback_1 = require(169) /* ./callback */;\n    const p = require(18) /* ../../core/properties */;\n    const object_1 = require(22) /* ../../core/util/object */;\n    const string_1 = require(25) /* ../../core/util/string */;\n    class CustomJS extends callback_1.Callback {\n        constructor(attrs) {\n            super(attrs);\n        }\n        static init_CustomJS() {\n            this.define({\n                args: [p.Any, {}],\n                code: [p.String, ''],\n                use_strict: [p.Boolean, false],\n            });\n        }\n        get names() {\n            return object_1.keys(this.args);\n        }\n        get values() {\n            return object_1.values(this.args);\n        }\n        get func() {\n            const code = this.use_strict ? string_1.use_strict(this.code) : this.code;\n            return new Function(...this.names, \"cb_obj\", \"cb_data\", \"require\", \"exports\", code);\n        }\n        execute(cb_obj, cb_data = {}) {\n            return this.func.apply(cb_obj, this.values.concat(cb_obj, cb_data, require, {}));\n        }\n    }\n    exports.CustomJS = CustomJS;\n    CustomJS.__name__ = \"CustomJS\";\n    CustomJS.init_CustomJS();\n}\n","/* models/callbacks/callback.js */ function _(require, module, exports) {\n    const model_1 = require(64) /* ../../model */;\n    class Callback extends model_1.Model {\n        constructor(attrs) {\n            super(attrs);\n        }\n    }\n    exports.Callback = Callback;\n    Callback.__name__ = \"Callback\";\n}\n","/* models/callbacks/open_url.js */ function _(require, module, exports) {\n    const callback_1 = require(169) /* ./callback */;\n    const templating_1 = require(151) /* ../../core/util/templating */;\n    const p = require(18) /* ../../core/properties */;\n    class OpenURL extends callback_1.Callback {\n        constructor(attrs) {\n            super(attrs);\n        }\n        static init_OpenURL() {\n            this.define({\n                url: [p.String, 'http://'],\n                same_tab: [p.Boolean, false],\n            });\n        }\n        execute(_cb_obj, { source }) {\n            const open_url = (i) => {\n                const url = templating_1.replace_placeholders(this.url, source, i);\n                if (this.same_tab)\n                    window.location.href = url;\n                else\n                    window.open(url);\n            };\n            const { selected } = source;\n            for (const i of selected.indices)\n                open_url(i);\n            for (const i of selected.line_indices)\n                open_url(i);\n            // TODO: multiline_indices: {[key: string]: number[]}\n        }\n    }\n    exports.OpenURL = OpenURL;\n    OpenURL.__name__ = \"OpenURL\";\n    OpenURL.init_OpenURL();\n}\n","/* models/canvas/index.js */ function _(require, module, exports) {\n    var canvas_1 = require(172) /* ./canvas */;\n    exports.Canvas = canvas_1.Canvas;\n    var cartesian_frame_1 = require(176) /* ./cartesian_frame */;\n    exports.CartesianFrame = cartesian_frame_1.CartesianFrame;\n}\n","/* models/canvas/canvas.js */ function _(require, module, exports) {\n    const has_props_1 = require(12) /* ../../core/has_props */;\n    const dom_view_1 = require(59) /* ../../core/dom_view */;\n    const logging_1 = require(65) /* ../../core/logging */;\n    const p = require(18) /* ../../core/properties */;\n    const dom_1 = require(61) /* ../../core/dom */;\n    const bbox_1 = require(79) /* ../../core/util/bbox */;\n    const compat_1 = require(95) /* ../../core/util/compat */;\n    const canvas_1 = require(173) /* ../../core/util/canvas */;\n    const canvas_2 = require(174) /* ../../styles/canvas */;\n    // fixes up a problem with some versions of IE11\n    // ref: http://stackoverflow.com/questions/22062313/imagedata-set-in-internetexplorer\n    if (compat_1.is_ie && typeof CanvasPixelArray !== \"undefined\") {\n        CanvasPixelArray.prototype.set = function (arr) {\n            for (let i = 0; i < this.length; i++) {\n                this[i] = arr[i];\n            }\n        };\n    }\n    const canvas2svg = require(175) /* canvas2svg */;\n    class CanvasView extends dom_view_1.DOMView {\n        get ctx() {\n            return this._ctx;\n        }\n        initialize() {\n            super.initialize();\n            this.map_el = this.model.map ? this.el.appendChild(dom_1.div({ class: canvas_2.bk_canvas_map })) : null;\n            const style = {\n                position: \"absolute\",\n                top: \"0\",\n                left: \"0\",\n                width: \"100%\",\n                height: \"100%\",\n            };\n            switch (this.model.output_backend) {\n                case \"canvas\":\n                case \"webgl\": {\n                    this.canvas_el = this.el.appendChild(dom_1.canvas({ class: canvas_2.bk_canvas, style }));\n                    const ctx = this.canvas_el.getContext('2d');\n                    if (ctx == null)\n                        throw new Error(\"unable to obtain 2D rendering context\");\n                    this._ctx = ctx;\n                    break;\n                }\n                case \"svg\": {\n                    const ctx = new canvas2svg();\n                    this._ctx = ctx;\n                    this.canvas_el = this.el.appendChild(ctx.getSvg());\n                    break;\n                }\n            }\n            this.overlays_el = this.el.appendChild(dom_1.div({ class: canvas_2.bk_canvas_overlays, style }));\n            this.events_el = this.el.appendChild(dom_1.div({ class: canvas_2.bk_canvas_events, style }));\n            canvas_1.fixup_ctx(this._ctx);\n            logging_1.logger.debug(\"CanvasView initialized\");\n        }\n        get_canvas_element() {\n            return this.canvas_el;\n        }\n        prepare_canvas(width, height) {\n            // Ensure canvas has the correct size, taking HIDPI into account\n            this.bbox = new bbox_1.BBox({ left: 0, top: 0, width, height });\n            this.el.style.width = `${width}px`;\n            this.el.style.height = `${height}px`;\n            const pixel_ratio = canvas_1.get_scale_ratio(this.ctx, this.model.use_hidpi, this.model.output_backend);\n            this.model.pixel_ratio = pixel_ratio;\n            this.canvas_el.style.width = `${width}px`;\n            this.canvas_el.style.height = `${height}px`;\n            // XXX: io.export and canvas2svg don't like this\n            // this.canvas_el.width = width*pixel_ratio\n            // this.canvas_el.height = height*pixel_ratio\n            this.canvas_el.setAttribute(\"width\", `${width * pixel_ratio}`);\n            this.canvas_el.setAttribute(\"height\", `${height * pixel_ratio}`);\n            logging_1.logger.debug(`Rendering CanvasView with width: ${width}, height: ${height}, pixel ratio: ${pixel_ratio}`);\n        }\n    }\n    exports.CanvasView = CanvasView;\n    CanvasView.__name__ = \"CanvasView\";\n    class Canvas extends has_props_1.HasProps {\n        constructor(attrs) {\n            super(attrs);\n        }\n        static init_Canvas() {\n            this.prototype.default_view = CanvasView;\n            this.internal({\n                map: [p.Boolean, false],\n                use_hidpi: [p.Boolean, true],\n                pixel_ratio: [p.Number, 1],\n                output_backend: [p.OutputBackend, \"canvas\"],\n            });\n        }\n    }\n    exports.Canvas = Canvas;\n    Canvas.__name__ = \"Canvas\";\n    Canvas.init_Canvas();\n}\n","/* core/util/canvas.js */ function _(require, module, exports) {\n    function fixup_line_dash(ctx) {\n        if (!ctx.setLineDash) {\n            ctx.setLineDash = (dash) => {\n                ctx.mozDash = dash;\n                ctx.webkitLineDash = dash;\n            };\n        }\n        if (!ctx.getLineDash) {\n            ctx.getLineDash = () => {\n                return ctx.mozDash;\n            };\n        }\n    }\n    function fixup_line_dash_offset(ctx) {\n        ctx.setLineDashOffset = (offset) => {\n            ctx.lineDashOffset = offset;\n            ctx.mozDashOffset = offset;\n            ctx.webkitLineDashOffset = offset;\n        };\n        ctx.getLineDashOffset = () => {\n            return ctx.mozDashOffset;\n        };\n    }\n    function fixup_image_smoothing(ctx) {\n        ctx.setImageSmoothingEnabled = (value) => {\n            ctx.imageSmoothingEnabled = value;\n            ctx.mozImageSmoothingEnabled = value;\n            ctx.oImageSmoothingEnabled = value;\n            ctx.webkitImageSmoothingEnabled = value;\n            ctx.msImageSmoothingEnabled = value;\n        };\n        ctx.getImageSmoothingEnabled = () => {\n            const val = ctx.imageSmoothingEnabled;\n            return val != null ? val : true;\n        };\n    }\n    function fixup_measure_text(ctx) {\n        if (ctx.measureText && ctx.html5MeasureText == null) {\n            ctx.html5MeasureText = ctx.measureText;\n            ctx.measureText = (text) => {\n                const textMetrics = ctx.html5MeasureText(text);\n                // fake it til you make it\n                textMetrics.ascent = ctx.html5MeasureText(\"m\").width * 1.6;\n                return textMetrics;\n            };\n        }\n    }\n    function fixup_ellipse(ctx) {\n        // implementing the ctx.ellipse function with bezier curves\n        // we don't implement the startAngle, endAngle and anticlockwise arguments.\n        function ellipse_bezier(x, y, radiusX, radiusY, rotation, _startAngle, _endAngle, anticlockwise = false) {\n            const c = 0.551784; // see http://www.tinaja.com/glib/ellipse4.pdf\n            ctx.translate(x, y);\n            ctx.rotate(rotation);\n            let rx = radiusX;\n            let ry = radiusY;\n            if (anticlockwise) {\n                rx = -radiusX;\n                ry = -radiusY;\n            }\n            ctx.moveTo(-rx, 0); // start point of first curve\n            ctx.bezierCurveTo(-rx, ry * c, -rx * c, ry, 0, ry);\n            ctx.bezierCurveTo(rx * c, ry, rx, ry * c, rx, 0);\n            ctx.bezierCurveTo(rx, -ry * c, rx * c, -ry, 0, -ry);\n            ctx.bezierCurveTo(-rx * c, -ry, -rx, -ry * c, -rx, 0);\n            ctx.rotate(-rotation);\n            ctx.translate(-x, -y);\n        }\n        if (!ctx.ellipse)\n            ctx.ellipse = ellipse_bezier;\n    }\n    function fixup_ctx(ctx) {\n        fixup_line_dash(ctx);\n        fixup_line_dash_offset(ctx);\n        fixup_image_smoothing(ctx);\n        fixup_measure_text(ctx);\n        fixup_ellipse(ctx);\n    }\n    exports.fixup_ctx = fixup_ctx;\n    function get_scale_ratio(ctx, hidpi, backend) {\n        if (backend == \"svg\")\n            return 1;\n        else if (hidpi) {\n            const devicePixelRatio = window.devicePixelRatio || 1;\n            const backingStoreRatio = ctx.webkitBackingStorePixelRatio ||\n                ctx.mozBackingStorePixelRatio ||\n                ctx.msBackingStorePixelRatio ||\n                ctx.oBackingStorePixelRatio ||\n                ctx.backingStorePixelRatio || 1;\n            return devicePixelRatio / backingStoreRatio;\n        }\n        else\n            return 1;\n    }\n    exports.get_scale_ratio = get_scale_ratio;\n}\n","/* styles/canvas.js */ function _(require, module, exports) {\n    require(62) /* ./root */;\n    exports.bk_canvas = \"bk-canvas\";\n    exports.bk_canvas_map = \"bk-canvas-map\";\n    exports.bk_canvas_overlays = \"bk-canvas-overlays\";\n    exports.bk_canvas_events = \"bk-canvas-events\";\n}\n","/* canvas2svg/canvas2svg.js */ function _(require, module, exports) {\n    /*!!\n     *  Canvas 2 Svg v1.0.21\n     *  A low level canvas to SVG converter. Uses a mock canvas context to build an SVG document.\n     *\n     *  Licensed under the MIT license:\n     *  http://www.opensource.org/licenses/mit-license.php\n     *\n     *  Author:\n     *  Kerry Liu\n     *\n     *  Copyright (c) 2014 Gliffy Inc.\n     */\n    ;\n    (function () {\n        \"use strict\";\n        var STYLES, ctx, CanvasGradient, CanvasPattern, namedEntities;\n        //helper function to format a string\n        function format(str, args) {\n            var keys = Object.keys(args), i;\n            for (i = 0; i < keys.length; i++) {\n                str = str.replace(new RegExp(\"\\\\{\" + keys[i] + \"\\\\}\", \"gi\"), args[keys[i]]);\n            }\n            return str;\n        }\n        //helper function that generates a random string\n        function randomString(holder) {\n            var chars, randomstring, i;\n            if (!holder) {\n                throw new Error(\"cannot create a random attribute name for an undefined object\");\n            }\n            chars = \"ABCDEFGHIJKLMNOPQRSTUVWXTZabcdefghiklmnopqrstuvwxyz\";\n            randomstring = \"\";\n            do {\n                randomstring = \"\";\n                for (i = 0; i < 12; i++) {\n                    randomstring += chars[Math.floor(Math.random() * chars.length)];\n                }\n            } while (holder[randomstring]);\n            return randomstring;\n        }\n        //helper function to map named to numbered entities\n        function createNamedToNumberedLookup(items, radix) {\n            var i, entity, lookup = {}, base10, base16;\n            items = items.split(',');\n            radix = radix || 10;\n            // Map from named to numbered entities.\n            for (i = 0; i < items.length; i += 2) {\n                entity = '&' + items[i + 1] + ';';\n                base10 = parseInt(items[i], radix);\n                lookup[entity] = '&#' + base10 + ';';\n            }\n            //FF and IE need to create a regex from hex values ie &nbsp; == \\xa0\n            lookup[\"\\\\xa0\"] = '&#160;';\n            return lookup;\n        }\n        //helper function to map canvas-textAlign to svg-textAnchor\n        function getTextAnchor(textAlign) {\n            //TODO: support rtl languages\n            var mapping = { \"left\": \"start\", \"right\": \"end\", \"center\": \"middle\", \"start\": \"start\", \"end\": \"end\" };\n            return mapping[textAlign] || mapping.start;\n        }\n        //helper function to map canvas-textBaseline to svg-dominantBaseline\n        function getDominantBaseline(textBaseline) {\n            //INFO: not supported in all browsers\n            var mapping = { \"alphabetic\": \"alphabetic\", \"hanging\": \"hanging\", \"top\": \"text-before-edge\", \"bottom\": \"text-after-edge\", \"middle\": \"central\" };\n            return mapping[textBaseline] || mapping.alphabetic;\n        }\n        // Unpack entities lookup where the numbers are in radix 32 to reduce the size\n        // entity mapping courtesy of tinymce\n        namedEntities = createNamedToNumberedLookup('50,nbsp,51,iexcl,52,cent,53,pound,54,curren,55,yen,56,brvbar,57,sect,58,uml,59,copy,' +\n            '5a,ordf,5b,laquo,5c,not,5d,shy,5e,reg,5f,macr,5g,deg,5h,plusmn,5i,sup2,5j,sup3,5k,acute,' +\n            '5l,micro,5m,para,5n,middot,5o,cedil,5p,sup1,5q,ordm,5r,raquo,5s,frac14,5t,frac12,5u,frac34,' +\n            '5v,iquest,60,Agrave,61,Aacute,62,Acirc,63,Atilde,64,Auml,65,Aring,66,AElig,67,Ccedil,' +\n            '68,Egrave,69,Eacute,6a,Ecirc,6b,Euml,6c,Igrave,6d,Iacute,6e,Icirc,6f,Iuml,6g,ETH,6h,Ntilde,' +\n            '6i,Ograve,6j,Oacute,6k,Ocirc,6l,Otilde,6m,Ouml,6n,times,6o,Oslash,6p,Ugrave,6q,Uacute,' +\n            '6r,Ucirc,6s,Uuml,6t,Yacute,6u,THORN,6v,szlig,70,agrave,71,aacute,72,acirc,73,atilde,74,auml,' +\n            '75,aring,76,aelig,77,ccedil,78,egrave,79,eacute,7a,ecirc,7b,euml,7c,igrave,7d,iacute,7e,icirc,' +\n            '7f,iuml,7g,eth,7h,ntilde,7i,ograve,7j,oacute,7k,ocirc,7l,otilde,7m,ouml,7n,divide,7o,oslash,' +\n            '7p,ugrave,7q,uacute,7r,ucirc,7s,uuml,7t,yacute,7u,thorn,7v,yuml,ci,fnof,sh,Alpha,si,Beta,' +\n            'sj,Gamma,sk,Delta,sl,Epsilon,sm,Zeta,sn,Eta,so,Theta,sp,Iota,sq,Kappa,sr,Lambda,ss,Mu,' +\n            'st,Nu,su,Xi,sv,Omicron,t0,Pi,t1,Rho,t3,Sigma,t4,Tau,t5,Upsilon,t6,Phi,t7,Chi,t8,Psi,' +\n            't9,Omega,th,alpha,ti,beta,tj,gamma,tk,delta,tl,epsilon,tm,zeta,tn,eta,to,theta,tp,iota,' +\n            'tq,kappa,tr,lambda,ts,mu,tt,nu,tu,xi,tv,omicron,u0,pi,u1,rho,u2,sigmaf,u3,sigma,u4,tau,' +\n            'u5,upsilon,u6,phi,u7,chi,u8,psi,u9,omega,uh,thetasym,ui,upsih,um,piv,812,bull,816,hellip,' +\n            '81i,prime,81j,Prime,81u,oline,824,frasl,88o,weierp,88h,image,88s,real,892,trade,89l,alefsym,' +\n            '8cg,larr,8ch,uarr,8ci,rarr,8cj,darr,8ck,harr,8dl,crarr,8eg,lArr,8eh,uArr,8ei,rArr,8ej,dArr,' +\n            '8ek,hArr,8g0,forall,8g2,part,8g3,exist,8g5,empty,8g7,nabla,8g8,isin,8g9,notin,8gb,ni,8gf,prod,' +\n            '8gh,sum,8gi,minus,8gn,lowast,8gq,radic,8gt,prop,8gu,infin,8h0,ang,8h7,and,8h8,or,8h9,cap,8ha,cup,' +\n            '8hb,int,8hk,there4,8hs,sim,8i5,cong,8i8,asymp,8j0,ne,8j1,equiv,8j4,le,8j5,ge,8k2,sub,8k3,sup,8k4,' +\n            'nsub,8k6,sube,8k7,supe,8kl,oplus,8kn,otimes,8l5,perp,8m5,sdot,8o8,lceil,8o9,rceil,8oa,lfloor,8ob,' +\n            'rfloor,8p9,lang,8pa,rang,9ea,loz,9j0,spades,9j3,clubs,9j5,hearts,9j6,diams,ai,OElig,aj,oelig,b0,' +\n            'Scaron,b1,scaron,bo,Yuml,m6,circ,ms,tilde,802,ensp,803,emsp,809,thinsp,80c,zwnj,80d,zwj,80e,lrm,' +\n            '80f,rlm,80j,ndash,80k,mdash,80o,lsquo,80p,rsquo,80q,sbquo,80s,ldquo,80t,rdquo,80u,bdquo,810,dagger,' +\n            '811,Dagger,81g,permil,81p,lsaquo,81q,rsaquo,85c,euro', 32);\n        //Some basic mappings for attributes and default values.\n        STYLES = {\n            \"strokeStyle\": {\n                svgAttr: \"stroke\",\n                canvas: \"#000000\",\n                svg: \"none\",\n                apply: \"stroke\" //apply on stroke() or fill()\n            },\n            \"fillStyle\": {\n                svgAttr: \"fill\",\n                canvas: \"#000000\",\n                svg: null,\n                apply: \"fill\"\n            },\n            \"lineCap\": {\n                svgAttr: \"stroke-linecap\",\n                canvas: \"butt\",\n                svg: \"butt\",\n                apply: \"stroke\"\n            },\n            \"lineJoin\": {\n                svgAttr: \"stroke-linejoin\",\n                canvas: \"miter\",\n                svg: \"miter\",\n                apply: \"stroke\"\n            },\n            \"miterLimit\": {\n                svgAttr: \"stroke-miterlimit\",\n                canvas: 10,\n                svg: 4,\n                apply: \"stroke\"\n            },\n            \"lineWidth\": {\n                svgAttr: \"stroke-width\",\n                canvas: 1,\n                svg: 1,\n                apply: \"stroke\"\n            },\n            \"globalAlpha\": {\n                svgAttr: \"opacity\",\n                canvas: 1,\n                svg: 1,\n                apply: \"fill stroke\"\n            },\n            \"font\": {\n                //font converts to multiple svg attributes, there is custom logic for this\n                canvas: \"10px sans-serif\"\n            },\n            \"shadowColor\": {\n                canvas: \"#000000\"\n            },\n            \"shadowOffsetX\": {\n                canvas: 0\n            },\n            \"shadowOffsetY\": {\n                canvas: 0\n            },\n            \"shadowBlur\": {\n                canvas: 0\n            },\n            \"textAlign\": {\n                canvas: \"start\"\n            },\n            \"textBaseline\": {\n                canvas: \"alphabetic\"\n            },\n            \"lineDash\": {\n                svgAttr: \"stroke-dasharray\",\n                canvas: [],\n                svg: null,\n                apply: \"stroke\"\n            }\n        };\n        /**\n         *\n         * @param gradientNode - reference to the gradient\n         * @constructor\n         */\n        CanvasGradient = function (gradientNode, ctx) {\n            this.__root = gradientNode;\n            this.__ctx = ctx;\n        };\n        /**\n         * Adds a color stop to the gradient root\n         */\n        CanvasGradient.prototype.addColorStop = function (offset, color) {\n            var stop = this.__ctx.__createElement(\"stop\"), regex, matches;\n            stop.setAttribute(\"offset\", offset);\n            if (color.indexOf(\"rgba\") !== -1) {\n                //separate alpha value, since webkit can't handle it\n                regex = /rgba\\(\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d?\\.?\\d*)\\s*\\)/gi;\n                matches = regex.exec(color);\n                stop.setAttribute(\"stop-color\", format(\"rgb({r},{g},{b})\", { r: matches[1], g: matches[2], b: matches[3] }));\n                stop.setAttribute(\"stop-opacity\", matches[4]);\n            }\n            else {\n                stop.setAttribute(\"stop-color\", color);\n            }\n            this.__root.appendChild(stop);\n        };\n        CanvasPattern = function (pattern, ctx) {\n            this.__root = pattern;\n            this.__ctx = ctx;\n        };\n        /**\n         * The mock canvas context\n         * @param o - options include:\n         * ctx - existing Context2D to wrap around\n         * width - width of your canvas (defaults to 500)\n         * height - height of your canvas (defaults to 500)\n         * enableMirroring - enables canvas mirroring (get image data) (defaults to false)\n         * document - the document object (defaults to the current document)\n         */\n        ctx = function (o) {\n            var defaultOptions = { width: 500, height: 500, enableMirroring: false }, options;\n            //keep support for this way of calling C2S: new C2S(width,height)\n            if (arguments.length > 1) {\n                options = defaultOptions;\n                options.width = arguments[0];\n                options.height = arguments[1];\n            }\n            else if (!o) {\n                options = defaultOptions;\n            }\n            else {\n                options = o;\n            }\n            if (!(this instanceof ctx)) {\n                //did someone call this without new?\n                return new ctx(options);\n            }\n            //setup options\n            this.width = options.width || defaultOptions.width;\n            this.height = options.height || defaultOptions.height;\n            this.enableMirroring = options.enableMirroring !== undefined ? options.enableMirroring : defaultOptions.enableMirroring;\n            this.canvas = this; ///point back to this instance!\n            this.__document = options.document || document;\n            // allow passing in an existing context to wrap around\n            // if a context is passed in, we know a canvas already exist\n            if (options.ctx) {\n                this.__ctx = options.ctx;\n            }\n            else {\n                this.__canvas = this.__document.createElement(\"canvas\");\n                this.__ctx = this.__canvas.getContext(\"2d\");\n            }\n            this.__setDefaultStyles();\n            this.__stack = [this.__getStyleState()];\n            this.__groupStack = [];\n            //the root svg element\n            this.__root = this.__document.createElementNS(\"http://www.w3.org/2000/svg\", \"svg\");\n            this.__root.setAttribute(\"version\", 1.1);\n            this.__root.setAttribute(\"xmlns\", \"http://www.w3.org/2000/svg\");\n            this.__root.setAttributeNS(\"http://www.w3.org/2000/xmlns/\", \"xmlns:xlink\", \"http://www.w3.org/1999/xlink\");\n            this.__root.setAttribute(\"width\", this.width);\n            this.__root.setAttribute(\"height\", this.height);\n            //make sure we don't generate the same ids in defs\n            this.__ids = {};\n            //defs tag\n            this.__defs = this.__document.createElementNS(\"http://www.w3.org/2000/svg\", \"defs\");\n            this.__root.appendChild(this.__defs);\n            //also add a group child. the svg element can't use the transform attribute\n            this.__currentElement = this.__document.createElementNS(\"http://www.w3.org/2000/svg\", \"g\");\n            this.__root.appendChild(this.__currentElement);\n        };\n        /**\n         * Creates the specified svg element\n         * @private\n         */\n        ctx.prototype.__createElement = function (elementName, properties, resetFill) {\n            if (typeof properties === \"undefined\") {\n                properties = {};\n            }\n            var element = this.__document.createElementNS(\"http://www.w3.org/2000/svg\", elementName), keys = Object.keys(properties), i, key;\n            if (resetFill) {\n                //if fill or stroke is not specified, the svg element should not display. By default SVG's fill is black.\n                element.setAttribute(\"fill\", \"none\");\n                element.setAttribute(\"stroke\", \"none\");\n            }\n            for (i = 0; i < keys.length; i++) {\n                key = keys[i];\n                element.setAttribute(key, properties[key]);\n            }\n            return element;\n        };\n        /**\n         * Applies default canvas styles to the context\n         * @private\n         */\n        ctx.prototype.__setDefaultStyles = function () {\n            //default 2d canvas context properties see:http://www.w3.org/TR/2dcontext/\n            var keys = Object.keys(STYLES), i, key;\n            for (i = 0; i < keys.length; i++) {\n                key = keys[i];\n                this[key] = STYLES[key].canvas;\n            }\n        };\n        /**\n         * Applies styles on restore\n         * @param styleState\n         * @private\n         */\n        ctx.prototype.__applyStyleState = function (styleState) {\n            var keys = Object.keys(styleState), i, key;\n            for (i = 0; i < keys.length; i++) {\n                key = keys[i];\n                this[key] = styleState[key];\n            }\n        };\n        /**\n         * Gets the current style state\n         * @return {Object}\n         * @private\n         */\n        ctx.prototype.__getStyleState = function () {\n            var i, styleState = {}, keys = Object.keys(STYLES), key;\n            for (i = 0; i < keys.length; i++) {\n                key = keys[i];\n                styleState[key] = this[key];\n            }\n            return styleState;\n        };\n        /**\n         * Apples the current styles to the current SVG element. On \"ctx.fill\" or \"ctx.stroke\"\n         * @param type\n         * @private\n         */\n        ctx.prototype.__applyStyleToCurrentElement = function (type) {\n            var currentElement = this.__currentElement;\n            var currentStyleGroup = this.__currentElementsToStyle;\n            if (currentStyleGroup) {\n                currentElement.setAttribute(type, \"\");\n                currentElement = currentStyleGroup.element;\n                currentStyleGroup.children.forEach(function (node) {\n                    node.setAttribute(type, \"\");\n                });\n            }\n            var keys = Object.keys(STYLES), i, style, value, id, regex, matches;\n            for (i = 0; i < keys.length; i++) {\n                style = STYLES[keys[i]];\n                value = this[keys[i]];\n                if (style.apply) {\n                    //is this a gradient or pattern?\n                    if (value instanceof CanvasPattern) {\n                        //pattern\n                        if (value.__ctx) {\n                            //copy over defs\n                            while (value.__ctx.__defs.childNodes.length) {\n                                id = value.__ctx.__defs.childNodes[0].getAttribute(\"id\");\n                                this.__ids[id] = id;\n                                this.__defs.appendChild(value.__ctx.__defs.childNodes[0]);\n                            }\n                        }\n                        currentElement.setAttribute(style.apply, format(\"url(#{id})\", { id: value.__root.getAttribute(\"id\") }));\n                    }\n                    else if (value instanceof CanvasGradient) {\n                        //gradient\n                        currentElement.setAttribute(style.apply, format(\"url(#{id})\", { id: value.__root.getAttribute(\"id\") }));\n                    }\n                    else if (style.apply.indexOf(type) !== -1 && style.svg !== value) {\n                        if ((style.svgAttr === \"stroke\" || style.svgAttr === \"fill\") && value.indexOf(\"rgba\") !== -1) {\n                            //separate alpha value, since illustrator can't handle it\n                            regex = /rgba\\(\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d?\\.?\\d*)\\s*\\)/gi;\n                            matches = regex.exec(value);\n                            currentElement.setAttribute(style.svgAttr, format(\"rgb({r},{g},{b})\", { r: matches[1], g: matches[2], b: matches[3] }));\n                            //should take globalAlpha here\n                            var opacity = matches[4];\n                            var globalAlpha = this.globalAlpha;\n                            if (globalAlpha != null) {\n                                opacity *= globalAlpha;\n                            }\n                            currentElement.setAttribute(style.svgAttr + \"-opacity\", opacity);\n                        }\n                        else {\n                            var attr = style.svgAttr;\n                            if (keys[i] === 'globalAlpha') {\n                                attr = type + '-' + style.svgAttr;\n                                if (currentElement.getAttribute(attr)) {\n                                    //fill-opacity or stroke-opacity has already been set by stroke or fill.\n                                    continue;\n                                }\n                            }\n                            //otherwise only update attribute if right type, and not svg default\n                            currentElement.setAttribute(attr, value);\n                        }\n                    }\n                }\n            }\n        };\n        /**\n         * Will return the closest group or svg node. May return the current element.\n         * @private\n         */\n        ctx.prototype.__closestGroupOrSvg = function (node) {\n            node = node || this.__currentElement;\n            if (node.nodeName === \"g\" || node.nodeName === \"svg\") {\n                return node;\n            }\n            else {\n                return this.__closestGroupOrSvg(node.parentNode);\n            }\n        };\n        /**\n         * Returns the serialized value of the svg so far\n         * @param fixNamedEntities - Standalone SVG doesn't support named entities, which document.createTextNode encodes.\n         *                           If true, we attempt to find all named entities and encode it as a numeric entity.\n         * @return serialized svg\n         */\n        ctx.prototype.getSerializedSvg = function (fixNamedEntities) {\n            var serialized = new XMLSerializer().serializeToString(this.__root), keys, i, key, value, regexp, xmlns;\n            //IE search for a duplicate xmnls because they didn't implement setAttributeNS correctly\n            xmlns = /xmlns=\"http:\\/\\/www\\.w3\\.org\\/2000\\/svg\".+xmlns=\"http:\\/\\/www\\.w3\\.org\\/2000\\/svg/gi;\n            if (xmlns.test(serialized)) {\n                serialized = serialized.replace('xmlns=\"http://www.w3.org/2000/svg', 'xmlns:xlink=\"http://www.w3.org/1999/xlink');\n            }\n            if (fixNamedEntities) {\n                keys = Object.keys(namedEntities);\n                //loop over each named entity and replace with the proper equivalent.\n                for (i = 0; i < keys.length; i++) {\n                    key = keys[i];\n                    value = namedEntities[key];\n                    regexp = new RegExp(key, \"gi\");\n                    if (regexp.test(serialized)) {\n                        serialized = serialized.replace(regexp, value);\n                    }\n                }\n            }\n            return serialized;\n        };\n        /**\n         * Returns the root svg\n         * @return\n         */\n        ctx.prototype.getSvg = function () {\n            return this.__root;\n        };\n        /**\n         * Will generate a group tag.\n         */\n        ctx.prototype.save = function () {\n            var group = this.__createElement(\"g\");\n            var parent = this.__closestGroupOrSvg();\n            this.__groupStack.push(parent);\n            parent.appendChild(group);\n            this.__currentElement = group;\n            this.__stack.push(this.__getStyleState());\n        };\n        /**\n         * Sets current element to parent, or just root if already root\n         */\n        ctx.prototype.restore = function () {\n            this.__currentElement = this.__groupStack.pop();\n            this.__currentElementsToStyle = null;\n            //Clearing canvas will make the poped group invalid, currentElement is set to the root group node.\n            if (!this.__currentElement) {\n                this.__currentElement = this.__root.childNodes[1];\n            }\n            var state = this.__stack.pop();\n            this.__applyStyleState(state);\n        };\n        /**\n         * Helper method to add transform\n         * @private\n         */\n        ctx.prototype.__addTransform = function (t) {\n            //if the current element has siblings, add another group\n            var parent = this.__closestGroupOrSvg();\n            if (parent.childNodes.length > 0) {\n                if (this.__currentElement.nodeName === \"path\") {\n                    if (!this.__currentElementsToStyle)\n                        this.__currentElementsToStyle = { element: parent, children: [] };\n                    this.__currentElementsToStyle.children.push(this.__currentElement);\n                    this.__applyCurrentDefaultPath();\n                }\n                var group = this.__createElement(\"g\");\n                parent.appendChild(group);\n                this.__currentElement = group;\n            }\n            var transform = this.__currentElement.getAttribute(\"transform\");\n            if (transform) {\n                transform += \" \";\n            }\n            else {\n                transform = \"\";\n            }\n            transform += t;\n            this.__currentElement.setAttribute(\"transform\", transform);\n        };\n        /**\n         *  scales the current element\n         */\n        ctx.prototype.scale = function (x, y) {\n            if (y === undefined) {\n                y = x;\n            }\n            this.__addTransform(format(\"scale({x},{y})\", { x: x, y: y }));\n        };\n        /**\n         * rotates the current element\n         */\n        ctx.prototype.rotate = function (angle) {\n            var degrees = (angle * 180 / Math.PI);\n            this.__addTransform(format(\"rotate({angle},{cx},{cy})\", { angle: degrees, cx: 0, cy: 0 }));\n        };\n        /**\n         * translates the current element\n         */\n        ctx.prototype.translate = function (x, y) {\n            this.__addTransform(format(\"translate({x},{y})\", { x: x, y: y }));\n        };\n        /**\n         * applies a transform to the current element\n         */\n        ctx.prototype.transform = function (a, b, c, d, e, f) {\n            this.__addTransform(format(\"matrix({a},{b},{c},{d},{e},{f})\", { a: a, b: b, c: c, d: d, e: e, f: f }));\n        };\n        /**\n         * Create a new Path Element\n         */\n        ctx.prototype.beginPath = function () {\n            var path, parent;\n            // Note that there is only one current default path, it is not part of the drawing state.\n            // See also: https://html.spec.whatwg.org/multipage/scripting.html#current-default-path\n            this.__currentDefaultPath = \"\";\n            this.__currentPosition = {};\n            path = this.__createElement(\"path\", {}, true);\n            parent = this.__closestGroupOrSvg();\n            parent.appendChild(path);\n            this.__currentElement = path;\n        };\n        /**\n         * Helper function to apply currentDefaultPath to current path element\n         * @private\n         */\n        ctx.prototype.__applyCurrentDefaultPath = function () {\n            var currentElement = this.__currentElement;\n            if (currentElement.nodeName === \"path\") {\n                currentElement.setAttribute(\"d\", this.__currentDefaultPath);\n            }\n            else {\n                console.error(\"Attempted to apply path command to node\", currentElement.nodeName);\n            }\n        };\n        /**\n         * Helper function to add path command\n         * @private\n         */\n        ctx.prototype.__addPathCommand = function (command) {\n            this.__currentDefaultPath += \" \";\n            this.__currentDefaultPath += command;\n        };\n        /**\n         * Adds the move command to the current path element,\n         * if the currentPathElement is not empty create a new path element\n         */\n        ctx.prototype.moveTo = function (x, y) {\n            if (this.__currentElement.nodeName !== \"path\") {\n                this.beginPath();\n            }\n            // creates a new subpath with the given point\n            this.__currentPosition = { x: x, y: y };\n            this.__addPathCommand(format(\"M {x} {y}\", { x: x, y: y }));\n        };\n        /**\n         * Closes the current path\n         */\n        ctx.prototype.closePath = function () {\n            if (this.__currentDefaultPath) {\n                this.__addPathCommand(\"Z\");\n            }\n        };\n        /**\n         * Adds a line to command\n         */\n        ctx.prototype.lineTo = function (x, y) {\n            this.__currentPosition = { x: x, y: y };\n            if (this.__currentDefaultPath.indexOf('M') > -1) {\n                this.__addPathCommand(format(\"L {x} {y}\", { x: x, y: y }));\n            }\n            else {\n                this.__addPathCommand(format(\"M {x} {y}\", { x: x, y: y }));\n            }\n        };\n        /**\n         * Add a bezier command\n         */\n        ctx.prototype.bezierCurveTo = function (cp1x, cp1y, cp2x, cp2y, x, y) {\n            this.__currentPosition = { x: x, y: y };\n            this.__addPathCommand(format(\"C {cp1x} {cp1y} {cp2x} {cp2y} {x} {y}\", { cp1x: cp1x, cp1y: cp1y, cp2x: cp2x, cp2y: cp2y, x: x, y: y }));\n        };\n        /**\n         * Adds a quadratic curve to command\n         */\n        ctx.prototype.quadraticCurveTo = function (cpx, cpy, x, y) {\n            this.__currentPosition = { x: x, y: y };\n            this.__addPathCommand(format(\"Q {cpx} {cpy} {x} {y}\", { cpx: cpx, cpy: cpy, x: x, y: y }));\n        };\n        /**\n         * Return a new normalized vector of given vector\n         */\n        var normalize = function (vector) {\n            var len = Math.sqrt(vector[0] * vector[0] + vector[1] * vector[1]);\n            return [vector[0] / len, vector[1] / len];\n        };\n        /**\n         * Adds the arcTo to the current path\n         *\n         * @see http://www.w3.org/TR/2015/WD-2dcontext-20150514/#dom-context-2d-arcto\n         */\n        ctx.prototype.arcTo = function (x1, y1, x2, y2, radius) {\n            // Let the point (x0, y0) be the last point in the subpath.\n            var x0 = this.__currentPosition && this.__currentPosition.x;\n            var y0 = this.__currentPosition && this.__currentPosition.y;\n            // First ensure there is a subpath for (x1, y1).\n            if (typeof x0 == \"undefined\" || typeof y0 == \"undefined\") {\n                return;\n            }\n            // Negative values for radius must cause the implementation to throw an IndexSizeError exception.\n            if (radius < 0) {\n                throw new Error(\"IndexSizeError: The radius provided (\" + radius + \") is negative.\");\n            }\n            // If the point (x0, y0) is equal to the point (x1, y1),\n            // or if the point (x1, y1) is equal to the point (x2, y2),\n            // or if the radius radius is zero,\n            // then the method must add the point (x1, y1) to the subpath,\n            // and connect that point to the previous point (x0, y0) by a straight line.\n            if (((x0 === x1) && (y0 === y1))\n                || ((x1 === x2) && (y1 === y2))\n                || (radius === 0)) {\n                this.lineTo(x1, y1);\n                return;\n            }\n            // Otherwise, if the points (x0, y0), (x1, y1), and (x2, y2) all lie on a single straight line,\n            // then the method must add the point (x1, y1) to the subpath,\n            // and connect that point to the previous point (x0, y0) by a straight line.\n            var unit_vec_p1_p0 = normalize([x0 - x1, y0 - y1]);\n            var unit_vec_p1_p2 = normalize([x2 - x1, y2 - y1]);\n            if (unit_vec_p1_p0[0] * unit_vec_p1_p2[1] === unit_vec_p1_p0[1] * unit_vec_p1_p2[0]) {\n                this.lineTo(x1, y1);\n                return;\n            }\n            // Otherwise, let The Arc be the shortest arc given by circumference of the circle that has radius radius,\n            // and that has one point tangent to the half-infinite line that crosses the point (x0, y0) and ends at the point (x1, y1),\n            // and that has a different point tangent to the half-infinite line that ends at the point (x1, y1), and crosses the point (x2, y2).\n            // The points at which this circle touches these two lines are called the start and end tangent points respectively.\n            // note that both vectors are unit vectors, so the length is 1\n            var cos = (unit_vec_p1_p0[0] * unit_vec_p1_p2[0] + unit_vec_p1_p0[1] * unit_vec_p1_p2[1]);\n            var theta = Math.acos(Math.abs(cos));\n            // Calculate origin\n            var unit_vec_p1_origin = normalize([\n                unit_vec_p1_p0[0] + unit_vec_p1_p2[0],\n                unit_vec_p1_p0[1] + unit_vec_p1_p2[1]\n            ]);\n            var len_p1_origin = radius / Math.sin(theta / 2);\n            var x = x1 + len_p1_origin * unit_vec_p1_origin[0];\n            var y = y1 + len_p1_origin * unit_vec_p1_origin[1];\n            // Calculate start angle and end angle\n            // rotate 90deg clockwise (note that y axis points to its down)\n            var unit_vec_origin_start_tangent = [\n                -unit_vec_p1_p0[1],\n                unit_vec_p1_p0[0]\n            ];\n            // rotate 90deg counter clockwise (note that y axis points to its down)\n            var unit_vec_origin_end_tangent = [\n                unit_vec_p1_p2[1],\n                -unit_vec_p1_p2[0]\n            ];\n            var getAngle = function (vector) {\n                // get angle (clockwise) between vector and (1, 0)\n                var x = vector[0];\n                var y = vector[1];\n                if (y >= 0) { // note that y axis points to its down\n                    return Math.acos(x);\n                }\n                else {\n                    return -Math.acos(x);\n                }\n            };\n            var startAngle = getAngle(unit_vec_origin_start_tangent);\n            var endAngle = getAngle(unit_vec_origin_end_tangent);\n            // Connect the point (x0, y0) to the start tangent point by a straight line\n            this.lineTo(x + unit_vec_origin_start_tangent[0] * radius, y + unit_vec_origin_start_tangent[1] * radius);\n            // Connect the start tangent point to the end tangent point by arc\n            // and adding the end tangent point to the subpath.\n            this.arc(x, y, radius, startAngle, endAngle);\n        };\n        /**\n         * Sets the stroke property on the current element\n         */\n        ctx.prototype.stroke = function () {\n            if (this.__currentElement.nodeName === \"path\") {\n                this.__currentElement.setAttribute(\"paint-order\", \"fill stroke markers\");\n            }\n            this.__applyCurrentDefaultPath();\n            this.__applyStyleToCurrentElement(\"stroke\");\n        };\n        /**\n         * Sets fill properties on the current element\n         */\n        ctx.prototype.fill = function () {\n            if (this.__currentElement.nodeName === \"path\") {\n                this.__currentElement.setAttribute(\"paint-order\", \"stroke fill markers\");\n            }\n            this.__applyCurrentDefaultPath();\n            this.__applyStyleToCurrentElement(\"fill\");\n        };\n        /**\n         *  Adds a rectangle to the path.\n         */\n        ctx.prototype.rect = function (x, y, width, height) {\n            if (this.__currentElement.nodeName !== \"path\") {\n                this.beginPath();\n            }\n            this.moveTo(x, y);\n            this.lineTo(x + width, y);\n            this.lineTo(x + width, y + height);\n            this.lineTo(x, y + height);\n            this.lineTo(x, y);\n            this.closePath();\n        };\n        /**\n         * adds a rectangle element\n         */\n        ctx.prototype.fillRect = function (x, y, width, height) {\n            var rect, parent;\n            rect = this.__createElement(\"rect\", {\n                x: x,\n                y: y,\n                width: width,\n                height: height\n            }, true);\n            parent = this.__closestGroupOrSvg();\n            parent.appendChild(rect);\n            this.__currentElement = rect;\n            this.__applyStyleToCurrentElement(\"fill\");\n        };\n        /**\n         * Draws a rectangle with no fill\n         * @param x\n         * @param y\n         * @param width\n         * @param height\n         */\n        ctx.prototype.strokeRect = function (x, y, width, height) {\n            var rect, parent;\n            rect = this.__createElement(\"rect\", {\n                x: x,\n                y: y,\n                width: width,\n                height: height\n            }, true);\n            parent = this.__closestGroupOrSvg();\n            parent.appendChild(rect);\n            this.__currentElement = rect;\n            this.__applyStyleToCurrentElement(\"stroke\");\n        };\n        /**\n         * Clear entire canvas:\n         * 1. save current transforms\n         * 2. remove all the childNodes of the root g element\n         */\n        ctx.prototype.__clearCanvas = function () {\n            var current = this.__closestGroupOrSvg(), transform = current.getAttribute(\"transform\");\n            var rootGroup = this.__root.childNodes[1];\n            var childNodes = rootGroup.childNodes;\n            for (var i = childNodes.length - 1; i >= 0; i--) {\n                if (childNodes[i]) {\n                    rootGroup.removeChild(childNodes[i]);\n                }\n            }\n            this.__currentElement = rootGroup;\n            //reset __groupStack as all the child group nodes are all removed.\n            this.__groupStack = [];\n            if (transform) {\n                this.__addTransform(transform);\n            }\n        };\n        /**\n         * \"Clears\" a canvas by just drawing a white rectangle in the current group.\n         */\n        ctx.prototype.clearRect = function (x, y, width, height) {\n            //clear entire canvas\n            if (x === 0 && y === 0 && width === this.width && height === this.height) {\n                this.__clearCanvas();\n                return;\n            }\n            var rect, parent = this.__closestGroupOrSvg();\n            rect = this.__createElement(\"rect\", {\n                x: x,\n                y: y,\n                width: width,\n                height: height,\n                fill: \"#FFFFFF\"\n            }, true);\n            parent.appendChild(rect);\n        };\n        /**\n         * Adds a linear gradient to a defs tag.\n         * Returns a canvas gradient object that has a reference to it's parent def\n         */\n        ctx.prototype.createLinearGradient = function (x1, y1, x2, y2) {\n            var grad = this.__createElement(\"linearGradient\", {\n                id: randomString(this.__ids),\n                x1: x1 + \"px\",\n                x2: x2 + \"px\",\n                y1: y1 + \"px\",\n                y2: y2 + \"px\",\n                \"gradientUnits\": \"userSpaceOnUse\"\n            }, false);\n            this.__defs.appendChild(grad);\n            return new CanvasGradient(grad, this);\n        };\n        /**\n         * Adds a radial gradient to a defs tag.\n         * Returns a canvas gradient object that has a reference to it's parent def\n         */\n        ctx.prototype.createRadialGradient = function (x0, y0, r0, x1, y1, r1) {\n            var grad = this.__createElement(\"radialGradient\", {\n                id: randomString(this.__ids),\n                cx: x1 + \"px\",\n                cy: y1 + \"px\",\n                r: r1 + \"px\",\n                fx: x0 + \"px\",\n                fy: y0 + \"px\",\n                \"gradientUnits\": \"userSpaceOnUse\"\n            }, false);\n            this.__defs.appendChild(grad);\n            return new CanvasGradient(grad, this);\n        };\n        /**\n         * Parses the font string and returns svg mapping\n         * @private\n         */\n        ctx.prototype.__parseFont = function () {\n            var regex = /^\\s*(?=(?:(?:[-a-z]+\\s*){0,2}(italic|oblique))?)(?=(?:(?:[-a-z]+\\s*){0,2}(small-caps))?)(?=(?:(?:[-a-z]+\\s*){0,2}(bold(?:er)?|lighter|[1-9]00))?)(?:(?:normal|\\1|\\2|\\3)\\s*){0,3}((?:xx?-)?(?:small|large)|medium|smaller|larger|[.\\d]+(?:\\%|in|[cem]m|ex|p[ctx]))(?:\\s*\\/\\s*(normal|[.\\d]+(?:\\%|in|[cem]m|ex|p[ctx])))?\\s*([-,\\'\\\"\\sa-z0-9]+?)\\s*$/i;\n            var fontPart = regex.exec(this.font);\n            var data = {\n                style: fontPart[1] || 'normal',\n                size: fontPart[4] || '10px',\n                family: fontPart[6] || 'sans-serif',\n                weight: fontPart[3] || 'normal',\n                decoration: fontPart[2] || 'normal',\n                href: null\n            };\n            //canvas doesn't support underline natively, but we can pass this attribute\n            if (this.__fontUnderline === \"underline\") {\n                data.decoration = \"underline\";\n            }\n            //canvas also doesn't support linking, but we can pass this as well\n            if (this.__fontHref) {\n                data.href = this.__fontHref;\n            }\n            return data;\n        };\n        /**\n         * Helper to link text fragments\n         * @param font\n         * @param element\n         * @return {*}\n         * @private\n         */\n        ctx.prototype.__wrapTextLink = function (font, element) {\n            if (font.href) {\n                var a = this.__createElement(\"a\");\n                a.setAttributeNS(\"http://www.w3.org/1999/xlink\", \"xlink:href\", font.href);\n                a.appendChild(element);\n                return a;\n            }\n            return element;\n        };\n        /**\n         * Fills or strokes text\n         * @param text\n         * @param x\n         * @param y\n         * @param action - stroke or fill\n         * @private\n         */\n        ctx.prototype.__applyText = function (text, x, y, action) {\n            var font = this.__parseFont(), parent = this.__closestGroupOrSvg(), textElement = this.__createElement(\"text\", {\n                \"font-family\": font.family,\n                \"font-size\": font.size,\n                \"font-style\": font.style,\n                \"font-weight\": font.weight,\n                \"text-decoration\": font.decoration,\n                \"x\": x,\n                \"y\": y,\n                \"text-anchor\": getTextAnchor(this.textAlign),\n                \"dominant-baseline\": getDominantBaseline(this.textBaseline)\n            }, true);\n            textElement.appendChild(this.__document.createTextNode(text));\n            this.__currentElement = textElement;\n            this.__applyStyleToCurrentElement(action);\n            parent.appendChild(this.__wrapTextLink(font, textElement));\n        };\n        /**\n         * Creates a text element\n         * @param text\n         * @param x\n         * @param y\n         */\n        ctx.prototype.fillText = function (text, x, y) {\n            this.__applyText(text, x, y, \"fill\");\n        };\n        /**\n         * Strokes text\n         * @param text\n         * @param x\n         * @param y\n         */\n        ctx.prototype.strokeText = function (text, x, y) {\n            this.__applyText(text, x, y, \"stroke\");\n        };\n        /**\n         * No need to implement this for svg.\n         * @param text\n         * @return {TextMetrics}\n         */\n        ctx.prototype.measureText = function (text) {\n            this.__ctx.font = this.font;\n            return this.__ctx.measureText(text);\n        };\n        /**\n         *  Arc command!\n         */\n        ctx.prototype.arc = function (x, y, radius, startAngle, endAngle, counterClockwise) {\n            // in canvas no circle is drawn if no angle is provided.\n            if (startAngle === endAngle) {\n                return;\n            }\n            startAngle = startAngle % (2 * Math.PI);\n            endAngle = endAngle % (2 * Math.PI);\n            if (startAngle === endAngle) {\n                //circle time! subtract some of the angle so svg is happy (svg elliptical arc can't draw a full circle)\n                endAngle = ((endAngle + (2 * Math.PI)) - 0.001 * (counterClockwise ? -1 : 1)) % (2 * Math.PI);\n            }\n            var endX = x + radius * Math.cos(endAngle), endY = y + radius * Math.sin(endAngle), startX = x + radius * Math.cos(startAngle), startY = y + radius * Math.sin(startAngle), sweepFlag = counterClockwise ? 0 : 1, largeArcFlag = 0, diff = endAngle - startAngle;\n            // https://github.com/gliffy/canvas2svg/issues/4\n            if (diff < 0) {\n                diff += 2 * Math.PI;\n            }\n            if (counterClockwise) {\n                largeArcFlag = diff > Math.PI ? 0 : 1;\n            }\n            else {\n                largeArcFlag = diff > Math.PI ? 1 : 0;\n            }\n            this.lineTo(startX, startY);\n            this.__addPathCommand(format(\"A {rx} {ry} {xAxisRotation} {largeArcFlag} {sweepFlag} {endX} {endY}\", { rx: radius, ry: radius, xAxisRotation: 0, largeArcFlag: largeArcFlag, sweepFlag: sweepFlag, endX: endX, endY: endY }));\n            this.__currentPosition = { x: endX, y: endY };\n        };\n        /**\n         * Generates a ClipPath from the clip command.\n         */\n        ctx.prototype.clip = function () {\n            var group = this.__closestGroupOrSvg(), clipPath = this.__createElement(\"clipPath\"), id = randomString(this.__ids), newGroup = this.__createElement(\"g\");\n            this.__applyCurrentDefaultPath();\n            group.removeChild(this.__currentElement);\n            clipPath.setAttribute(\"id\", id);\n            clipPath.appendChild(this.__currentElement);\n            this.__defs.appendChild(clipPath);\n            //set the clip path to this group\n            group.setAttribute(\"clip-path\", format(\"url(#{id})\", { id: id }));\n            //clip paths can be scaled and transformed, we need to add another wrapper group to avoid later transformations\n            // to this path\n            group.appendChild(newGroup);\n            this.__currentElement = newGroup;\n        };\n        /**\n         * Draws a canvas, image or mock context to this canvas.\n         * Note that all svg dom manipulation uses node.childNodes rather than node.children for IE support.\n         * http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#dom-context-2d-drawimage\n         */\n        ctx.prototype.drawImage = function () {\n            //convert arguments to a real array\n            var args = Array.prototype.slice.call(arguments), image = args[0], dx, dy, dw, dh, sx = 0, sy = 0, sw, sh, parent, svg, defs, group, currentElement, svgImage, canvas, context, id;\n            if (args.length === 3) {\n                dx = args[1];\n                dy = args[2];\n                sw = image.width;\n                sh = image.height;\n                dw = sw;\n                dh = sh;\n            }\n            else if (args.length === 5) {\n                dx = args[1];\n                dy = args[2];\n                dw = args[3];\n                dh = args[4];\n                sw = image.width;\n                sh = image.height;\n            }\n            else if (args.length === 9) {\n                sx = args[1];\n                sy = args[2];\n                sw = args[3];\n                sh = args[4];\n                dx = args[5];\n                dy = args[6];\n                dw = args[7];\n                dh = args[8];\n            }\n            else {\n                throw new Error(\"Inavlid number of arguments passed to drawImage: \" + arguments.length);\n            }\n            parent = this.__closestGroupOrSvg();\n            currentElement = this.__currentElement;\n            var translateDirective = \"translate(\" + dx + \", \" + dy + \")\";\n            if (image instanceof ctx) {\n                //canvas2svg mock canvas context. In the future we may want to clone nodes instead.\n                //also I'm currently ignoring dw, dh, sw, sh, sx, sy for a mock context.\n                svg = image.getSvg().cloneNode(true);\n                if (svg.childNodes && svg.childNodes.length > 1) {\n                    defs = svg.childNodes[0];\n                    while (defs.childNodes.length) {\n                        id = defs.childNodes[0].getAttribute(\"id\");\n                        this.__ids[id] = id;\n                        this.__defs.appendChild(defs.childNodes[0]);\n                    }\n                    group = svg.childNodes[1];\n                    if (group) {\n                        //save original transform\n                        var originTransform = group.getAttribute(\"transform\");\n                        var transformDirective;\n                        if (originTransform) {\n                            transformDirective = originTransform + \" \" + translateDirective;\n                        }\n                        else {\n                            transformDirective = translateDirective;\n                        }\n                        group.setAttribute(\"transform\", transformDirective);\n                        parent.appendChild(group);\n                    }\n                }\n            }\n            else if (image.nodeName === \"IMG\") {\n                svgImage = this.__createElement(\"image\");\n                svgImage.setAttribute(\"width\", dw);\n                svgImage.setAttribute(\"height\", dh);\n                svgImage.setAttribute(\"preserveAspectRatio\", \"none\");\n                if (sx || sy || sw !== image.width || sh !== image.height) {\n                    //crop the image using a temporary canvas\n                    canvas = this.__document.createElement(\"canvas\");\n                    canvas.width = dw;\n                    canvas.height = dh;\n                    context = canvas.getContext(\"2d\");\n                    context.drawImage(image, sx, sy, sw, sh, 0, 0, dw, dh);\n                    image = canvas;\n                }\n                svgImage.setAttribute(\"transform\", translateDirective);\n                svgImage.setAttributeNS(\"http://www.w3.org/1999/xlink\", \"xlink:href\", image.nodeName === \"CANVAS\" ? image.toDataURL() : image.getAttribute(\"src\"));\n                parent.appendChild(svgImage);\n            }\n            else if (image.nodeName === \"CANVAS\") {\n                svgImage = this.__createElement(\"image\");\n                svgImage.setAttribute(\"width\", dw);\n                svgImage.setAttribute(\"height\", dh);\n                svgImage.setAttribute(\"preserveAspectRatio\", \"none\");\n                // draw canvas onto temporary canvas so that smoothing can be handled\n                canvas = this.__document.createElement(\"canvas\");\n                canvas.width = dw;\n                canvas.height = dh;\n                context = canvas.getContext(\"2d\");\n                context.imageSmoothingEnabled = false;\n                context.mozImageSmoothingEnabled = false;\n                context.oImageSmoothingEnabled = false;\n                context.webkitImageSmoothingEnabled = false;\n                context.drawImage(image, sx, sy, sw, sh, 0, 0, dw, dh);\n                image = canvas;\n                svgImage.setAttribute(\"transform\", translateDirective);\n                svgImage.setAttributeNS(\"http://www.w3.org/1999/xlink\", \"xlink:href\", image.toDataURL());\n                parent.appendChild(svgImage);\n            }\n        };\n        /**\n         * Generates a pattern tag\n         */\n        ctx.prototype.createPattern = function (image, repetition) {\n            var pattern = this.__document.createElementNS(\"http://www.w3.org/2000/svg\", \"pattern\"), id = randomString(this.__ids), img;\n            pattern.setAttribute(\"id\", id);\n            pattern.setAttribute(\"width\", image.width);\n            pattern.setAttribute(\"height\", image.height);\n            if (image.nodeName === \"CANVAS\" || image.nodeName === \"IMG\") {\n                img = this.__document.createElementNS(\"http://www.w3.org/2000/svg\", \"image\");\n                img.setAttribute(\"width\", image.width);\n                img.setAttribute(\"height\", image.height);\n                img.setAttributeNS(\"http://www.w3.org/1999/xlink\", \"xlink:href\", image.nodeName === \"CANVAS\" ? image.toDataURL() : image.getAttribute(\"src\"));\n                pattern.appendChild(img);\n                this.__defs.appendChild(pattern);\n            }\n            else if (image instanceof ctx) {\n                pattern.appendChild(image.__root.childNodes[1]);\n                this.__defs.appendChild(pattern);\n            }\n            return new CanvasPattern(pattern, this);\n        };\n        ctx.prototype.setLineDash = function (dashArray) {\n            if (dashArray && dashArray.length > 0) {\n                this.lineDash = dashArray.join(\",\");\n            }\n            else {\n                this.lineDash = null;\n            }\n        };\n        /**\n         * Not yet implemented\n         */\n        ctx.prototype.drawFocusRing = function () { };\n        ctx.prototype.createImageData = function () { };\n        ctx.prototype.getImageData = function () { };\n        ctx.prototype.putImageData = function () { };\n        ctx.prototype.globalCompositeOperation = function () { };\n        ctx.prototype.setTransform = function () { };\n        //add options for alternative namespace\n        if (typeof window === \"object\") {\n            window.C2S = ctx;\n        }\n        // CommonJS/Browserify\n        if (typeof module === \"object\" && typeof module.exports === \"object\") {\n            module.exports = ctx;\n        }\n    }());\n}\n","/* models/canvas/cartesian_frame.js */ function _(require, module, exports) {\n    const categorical_scale_1 = require(177) /* ../scales/categorical_scale */;\n    const linear_scale_1 = require(113) /* ../scales/linear_scale */;\n    const log_scale_1 = require(122) /* ../scales/log_scale */;\n    const range1d_1 = require(123) /* ../ranges/range1d */;\n    const data_range1d_1 = require(178) /* ../ranges/data_range1d */;\n    const factor_range_1 = require(82) /* ../ranges/factor_range */;\n    const layout_1 = require(180) /* ../../core/layout */;\n    class CartesianFrame extends layout_1.LayoutItem {\n        constructor(x_scale, y_scale, x_range, y_range, extra_x_ranges = {}, extra_y_ranges = {}) {\n            super();\n            this.x_scale = x_scale;\n            this.y_scale = y_scale;\n            this.x_range = x_range;\n            this.y_range = y_range;\n            this.extra_x_ranges = extra_x_ranges;\n            this.extra_y_ranges = extra_y_ranges;\n            this._configure_scales();\n        }\n        map_to_screen(x, y, x_name = \"default\", y_name = \"default\") {\n            const sx = this.xscales[x_name].v_compute(x);\n            const sy = this.yscales[y_name].v_compute(y);\n            return [sx, sy];\n        }\n        _get_ranges(range, extra_ranges) {\n            const ranges = {};\n            ranges.default = range;\n            if (extra_ranges != null) {\n                for (const name in extra_ranges)\n                    ranges[name] = extra_ranges[name];\n            }\n            return ranges;\n        }\n        /*protected*/ _get_scales(scale, ranges, frame_range) {\n            const scales = {};\n            for (const name in ranges) {\n                const range = ranges[name];\n                if (range instanceof data_range1d_1.DataRange1d || range instanceof range1d_1.Range1d) {\n                    if (!(scale instanceof log_scale_1.LogScale) && !(scale instanceof linear_scale_1.LinearScale))\n                        throw new Error(`Range ${range.type} is incompatible is Scale ${scale.type}`);\n                    // XXX: special case because CategoricalScale is a subclass of LinearScale, should be removed in future\n                    if (scale instanceof categorical_scale_1.CategoricalScale)\n                        throw new Error(`Range ${range.type} is incompatible is Scale ${scale.type}`);\n                }\n                if (range instanceof factor_range_1.FactorRange) {\n                    if (!(scale instanceof categorical_scale_1.CategoricalScale))\n                        throw new Error(`Range ${range.type} is incompatible is Scale ${scale.type}`);\n                }\n                if (scale instanceof log_scale_1.LogScale && range instanceof data_range1d_1.DataRange1d)\n                    range.scale_hint = \"log\";\n                const s = scale.clone();\n                s.setv({ source_range: range, target_range: frame_range });\n                scales[name] = s;\n            }\n            return scales;\n        }\n        _configure_frame_ranges() {\n            // data to/from screen space transform (left-bottom <-> left-top origin)\n            this._h_target = new range1d_1.Range1d({ start: this._left.value, end: this._right.value });\n            this._v_target = new range1d_1.Range1d({ start: this._bottom.value, end: this._top.value });\n        }\n        _configure_scales() {\n            this._configure_frame_ranges();\n            this._x_ranges = this._get_ranges(this.x_range, this.extra_x_ranges);\n            this._y_ranges = this._get_ranges(this.y_range, this.extra_y_ranges);\n            this._xscales = this._get_scales(this.x_scale, this._x_ranges, this._h_target);\n            this._yscales = this._get_scales(this.y_scale, this._y_ranges, this._v_target);\n        }\n        _update_scales() {\n            this._configure_frame_ranges();\n            for (const name in this._xscales) {\n                const scale = this._xscales[name];\n                scale.target_range = this._h_target;\n            }\n            for (const name in this._yscales) {\n                const scale = this._yscales[name];\n                scale.target_range = this._v_target;\n            }\n        }\n        _set_geometry(outer, inner) {\n            super._set_geometry(outer, inner);\n            this._update_scales();\n        }\n        get x_ranges() {\n            return this._x_ranges;\n        }\n        get y_ranges() {\n            return this._y_ranges;\n        }\n        get xscales() {\n            return this._xscales;\n        }\n        get yscales() {\n            return this._yscales;\n        }\n    }\n    exports.CartesianFrame = CartesianFrame;\n    CartesianFrame.__name__ = \"CartesianFrame\";\n}\n","/* models/scales/categorical_scale.js */ function _(require, module, exports) {\n    const linear_scale_1 = require(113) /* ./linear_scale */;\n    class CategoricalScale extends linear_scale_1.LinearScale {\n        constructor(attrs) {\n            super(attrs);\n        }\n        compute(x) {\n            return super.compute(this.source_range.synthetic(x));\n        }\n        v_compute(xs) {\n            return super.v_compute(this.source_range.v_synthetic(xs));\n        }\n    }\n    exports.CategoricalScale = CategoricalScale;\n    CategoricalScale.__name__ = \"CategoricalScale\";\n}\n","/* models/ranges/data_range1d.js */ function _(require, module, exports) {\n    const data_range_1 = require(179) /* ./data_range */;\n    const glyph_renderer_1 = require(73) /* ../renderers/glyph_renderer */;\n    const logging_1 = require(65) /* ../../core/logging */;\n    const p = require(18) /* ../../core/properties */;\n    const bbox = require(79) /* ../../core/util/bbox */;\n    const array_1 = require(8) /* ../../core/util/array */;\n    class DataRange1d extends data_range_1.DataRange {\n        constructor(attrs) {\n            super(attrs);\n            this._plot_bounds = {};\n            this.have_updated_interactively = false;\n        }\n        static init_DataRange1d() {\n            this.define({\n                start: [p.Number],\n                end: [p.Number],\n                range_padding: [p.Number, 0.1],\n                range_padding_units: [p.PaddingUnits, \"percent\"],\n                flipped: [p.Boolean, false],\n                follow: [p.StartEnd],\n                follow_interval: [p.Number],\n                default_span: [p.Number, 2],\n                only_visible: [p.Boolean, false],\n            });\n            this.internal({\n                scale_hint: [p.String, 'auto'],\n            });\n        }\n        initialize() {\n            super.initialize();\n            this._initial_start = this.start;\n            this._initial_end = this.end;\n            this._initial_range_padding = this.range_padding;\n            this._initial_range_padding_units = this.range_padding_units;\n            this._initial_follow = this.follow;\n            this._initial_follow_interval = this.follow_interval;\n            this._initial_default_span = this.default_span;\n        }\n        get min() {\n            return Math.min(this.start, this.end);\n        }\n        get max() {\n            return Math.max(this.start, this.end);\n        }\n        computed_renderers() {\n            // TODO (bev) check that renderers actually configured with this range\n            const names = this.names;\n            let renderers = this.renderers;\n            if (renderers.length == 0) {\n                for (const plot of this.plots) {\n                    const rs = plot.renderers.filter((r) => r instanceof glyph_renderer_1.GlyphRenderer);\n                    renderers = renderers.concat(rs);\n                }\n            }\n            if (names.length > 0)\n                renderers = renderers.filter((r) => array_1.includes(names, r.name));\n            logging_1.logger.debug(`computed ${renderers.length} renderers for DataRange1d ${this.id}`);\n            for (const r of renderers) {\n                logging_1.logger.trace(` - ${r.type} ${r.id}`);\n            }\n            return renderers;\n        }\n        /*protected*/ _compute_plot_bounds(renderers, bounds) {\n            let result = bbox.empty();\n            for (const r of renderers) {\n                if (bounds[r.id] != null && (r.visible || !this.only_visible))\n                    result = bbox.union(result, bounds[r.id]);\n            }\n            return result;\n        }\n        adjust_bounds_for_aspect(bounds, ratio) {\n            const result = bbox.empty();\n            let width = bounds.x1 - bounds.x0;\n            if (width <= 0) {\n                width = 1.0;\n            }\n            let height = bounds.y1 - bounds.y0;\n            if (height <= 0) {\n                height = 1.0;\n            }\n            const xcenter = 0.5 * (bounds.x1 + bounds.x0);\n            const ycenter = 0.5 * (bounds.y1 + bounds.y0);\n            if (width < ratio * height) {\n                width = ratio * height;\n            }\n            else {\n                height = width / ratio;\n            }\n            result.x1 = xcenter + 0.5 * width;\n            result.x0 = xcenter - 0.5 * width;\n            result.y1 = ycenter + 0.5 * height;\n            result.y0 = ycenter - 0.5 * height;\n            return result;\n        }\n        /*protected*/ _compute_min_max(plot_bounds, dimension) {\n            let overall = bbox.empty();\n            for (const k in plot_bounds) {\n                const v = plot_bounds[k];\n                overall = bbox.union(overall, v);\n            }\n            let min, max;\n            if (dimension == 0)\n                [min, max] = [overall.x0, overall.x1];\n            else\n                [min, max] = [overall.y0, overall.y1];\n            return [min, max];\n        }\n        /*protected*/ _compute_range(min, max) {\n            const range_padding = this.range_padding; // XXX: ? 0\n            let start, end;\n            if (this.scale_hint == \"log\") {\n                if (isNaN(min) || !isFinite(min) || min <= 0) {\n                    if (isNaN(max) || !isFinite(max) || max <= 0)\n                        min = 0.1;\n                    else\n                        min = max / 100;\n                    logging_1.logger.warn(`could not determine minimum data value for log axis, DataRange1d using value ${min}`);\n                }\n                if (isNaN(max) || !isFinite(max) || max <= 0) {\n                    if (isNaN(min) || !isFinite(min) || min <= 0)\n                        max = 10;\n                    else\n                        max = min * 100;\n                    logging_1.logger.warn(`could not determine maximum data value for log axis, DataRange1d using value ${max}`);\n                }\n                let center, span;\n                if (max == min) {\n                    span = this.default_span + 0.001;\n                    center = Math.log(min) / Math.log(10);\n                }\n                else {\n                    let log_min, log_max;\n                    if (this.range_padding_units == \"percent\") {\n                        log_min = Math.log(min) / Math.log(10);\n                        log_max = Math.log(max) / Math.log(10);\n                        span = (log_max - log_min) * (1 + range_padding);\n                    }\n                    else {\n                        log_min = Math.log(min - range_padding) / Math.log(10);\n                        log_max = Math.log(max + range_padding) / Math.log(10);\n                        span = log_max - log_min;\n                    }\n                    center = (log_min + log_max) / 2.0;\n                }\n                start = Math.pow(10, center - span / 2.0);\n                end = Math.pow(10, center + span / 2.0);\n            }\n            else {\n                let span;\n                if (max == min)\n                    span = this.default_span;\n                else {\n                    if (this.range_padding_units == \"percent\")\n                        span = (max - min) * (1 + range_padding);\n                    else\n                        span = (max - min) + 2 * range_padding;\n                }\n                const center = (max + min) / 2.0;\n                start = center - span / 2.0;\n                end = center + span / 2.0;\n            }\n            let follow_sign = +1;\n            if (this.flipped) {\n                [start, end] = [end, start];\n                follow_sign = -1;\n            }\n            const follow_interval = this.follow_interval;\n            if (follow_interval != null && Math.abs(start - end) > follow_interval) {\n                if (this.follow == 'start')\n                    end = start + follow_sign * follow_interval;\n                else if (this.follow == 'end')\n                    start = end - follow_sign * follow_interval;\n            }\n            return [start, end];\n        }\n        update(bounds, dimension, bounds_id, ratio) {\n            if (this.have_updated_interactively)\n                return;\n            const renderers = this.computed_renderers();\n            // update the raw data bounds for all renderers we care about\n            let total_bounds = this._compute_plot_bounds(renderers, bounds);\n            if (ratio != null)\n                total_bounds = this.adjust_bounds_for_aspect(total_bounds, ratio);\n            this._plot_bounds[bounds_id] = total_bounds;\n            // compute the min/mix for our specified dimension\n            const [min, max] = this._compute_min_max(this._plot_bounds, dimension);\n            // derive start, end from bounds and data range config\n            let [start, end] = this._compute_range(min, max);\n            if (this._initial_start != null) {\n                if (this.scale_hint == \"log\") {\n                    if (this._initial_start > 0)\n                        start = this._initial_start;\n                }\n                else\n                    start = this._initial_start;\n            }\n            if (this._initial_end != null) {\n                if (this.scale_hint == \"log\") {\n                    if (this._initial_end > 0)\n                        end = this._initial_end;\n                }\n                else\n                    end = this._initial_end;\n            }\n            // only trigger updates when there are changes\n            const [_start, _end] = [this.start, this.end];\n            if (start != _start || end != _end) {\n                const new_range = {};\n                if (start != _start)\n                    new_range.start = start;\n                if (end != _end)\n                    new_range.end = end;\n                this.setv(new_range);\n            }\n            if (this.bounds == 'auto')\n                this.setv({ bounds: [start, end] }, { silent: true });\n            this.change.emit();\n        }\n        reset() {\n            this.have_updated_interactively = false;\n            // change events silenced as PlotView.update_dataranges triggers property callbacks\n            this.setv({\n                range_padding: this._initial_range_padding,\n                range_padding_units: this._initial_range_padding_units,\n                follow: this._initial_follow,\n                follow_interval: this._initial_follow_interval,\n                default_span: this._initial_default_span,\n            }, { silent: true });\n            this.change.emit();\n        }\n    }\n    exports.DataRange1d = DataRange1d;\n    DataRange1d.__name__ = \"DataRange1d\";\n    DataRange1d.init_DataRange1d();\n}\n","/* models/ranges/data_range.js */ function _(require, module, exports) {\n    const range_1 = require(83) /* ./range */;\n    const p = require(18) /* ../../core/properties */;\n    class DataRange extends range_1.Range {\n        constructor(attrs) {\n            super(attrs);\n        }\n        static init_DataRange() {\n            this.define({\n                names: [p.Array, []],\n                renderers: [p.Array, []],\n            });\n        }\n    }\n    exports.DataRange = DataRange;\n    DataRange.__name__ = \"DataRange\";\n    DataRange.init_DataRange();\n}\n","/* core/layout/index.js */ function _(require, module, exports) {\n    var types_1 = require(181) /* ./types */;\n    exports.Sizeable = types_1.Sizeable;\n    var layoutable_1 = require(182) /* ./layoutable */;\n    exports.Layoutable = layoutable_1.Layoutable;\n    exports.LayoutItem = layoutable_1.LayoutItem;\n    var alignments_1 = require(183) /* ./alignments */;\n    exports.HStack = alignments_1.HStack;\n    exports.VStack = alignments_1.VStack;\n    exports.AnchorLayout = alignments_1.AnchorLayout;\n    var grid_1 = require(184) /* ./grid */;\n    exports.Grid = grid_1.Grid;\n    exports.Row = grid_1.Row;\n    exports.Column = grid_1.Column;\n    var html_1 = require(185) /* ./html */;\n    exports.ContentBox = html_1.ContentBox;\n    exports.VariadicBox = html_1.VariadicBox;\n}\n","/* core/layout/types.js */ function _(require, module, exports) {\n    const { min, max } = Math;\n    class Sizeable {\n        constructor(size = {}) {\n            this.width = size.width != null ? size.width : 0;\n            this.height = size.height != null ? size.height : 0;\n        }\n        bounded_to({ width, height }) {\n            return new Sizeable({\n                width: this.width == Infinity && width != null ? width : this.width,\n                height: this.height == Infinity && height != null ? height : this.height,\n            });\n        }\n        expanded_to({ width, height }) {\n            return new Sizeable({\n                width: width != Infinity ? max(this.width, width) : this.width,\n                height: height != Infinity ? max(this.height, height) : this.height,\n            });\n        }\n        expand_to({ width, height }) {\n            this.width = max(this.width, width);\n            this.height = max(this.height, height);\n        }\n        narrowed_to({ width, height }) {\n            return new Sizeable({\n                width: min(this.width, width),\n                height: min(this.height, height),\n            });\n        }\n        narrow_to({ width, height }) {\n            this.width = min(this.width, width);\n            this.height = min(this.height, height);\n        }\n        grow_by({ left, right, top, bottom }) {\n            const width = this.width + left + right;\n            const height = this.height + top + bottom;\n            return new Sizeable({ width, height });\n        }\n        shrink_by({ left, right, top, bottom }) {\n            const width = max(this.width - left - right, 0);\n            const height = max(this.height - top - bottom, 0);\n            return new Sizeable({ width, height });\n        }\n        map(w_fn, h_fn) {\n            return new Sizeable({\n                width: w_fn(this.width),\n                height: (h_fn != null ? h_fn : w_fn)(this.height),\n            });\n        }\n    }\n    exports.Sizeable = Sizeable;\n    Sizeable.__name__ = \"Sizeable\";\n}\n","/* core/layout/layoutable.js */ function _(require, module, exports) {\n    const types_1 = require(181) /* ./types */;\n    const bbox_1 = require(79) /* ../util/bbox */;\n    const { min, max, round } = Math;\n    class Layoutable {\n        constructor() {\n            this._bbox = new bbox_1.BBox();\n            this._inner_bbox = new bbox_1.BBox();\n            const layout = this;\n            this._top = { get value() { return layout.bbox.top; } };\n            this._left = { get value() { return layout.bbox.left; } };\n            this._width = { get value() { return layout.bbox.width; } };\n            this._height = { get value() { return layout.bbox.height; } };\n            this._right = { get value() { return layout.bbox.right; } };\n            this._bottom = { get value() { return layout.bbox.bottom; } };\n            this._hcenter = { get value() { return layout.bbox.hcenter; } };\n            this._vcenter = { get value() { return layout.bbox.vcenter; } };\n        }\n        get bbox() {\n            return this._bbox;\n        }\n        get inner_bbox() {\n            return this._inner_bbox;\n        }\n        get sizing() {\n            return this._sizing;\n        }\n        set_sizing(sizing) {\n            const width_policy = sizing.width_policy || \"fit\";\n            const width = sizing.width;\n            const min_width = sizing.min_width != null ? sizing.min_width : 0;\n            const max_width = sizing.max_width != null ? sizing.max_width : Infinity;\n            const height_policy = sizing.height_policy || \"fit\";\n            const height = sizing.height;\n            const min_height = sizing.min_height != null ? sizing.min_height : 0;\n            const max_height = sizing.max_height != null ? sizing.max_height : Infinity;\n            const aspect = sizing.aspect;\n            const margin = sizing.margin || { top: 0, right: 0, bottom: 0, left: 0 };\n            const visible = sizing.visible !== false;\n            const halign = sizing.halign || \"start\";\n            const valign = sizing.valign || \"start\";\n            this._sizing = {\n                width_policy, min_width, width, max_width,\n                height_policy, min_height, height, max_height,\n                aspect,\n                margin,\n                visible,\n                halign,\n                valign,\n                size: { width, height },\n                min_size: { width: min_width, height: min_height },\n                max_size: { width: max_width, height: max_height },\n            };\n            this._init();\n        }\n        _init() { }\n        _set_geometry(outer, inner) {\n            this._bbox = outer;\n            this._inner_bbox = inner;\n        }\n        set_geometry(outer, inner) {\n            this._set_geometry(outer, inner || outer);\n        }\n        is_width_expanding() {\n            return this.sizing.width_policy == \"max\";\n        }\n        is_height_expanding() {\n            return this.sizing.height_policy == \"max\";\n        }\n        apply_aspect(viewport, { width, height }) {\n            const { aspect } = this.sizing;\n            if (aspect != null) {\n                const { width_policy, height_policy } = this.sizing;\n                const gt = (width, height) => {\n                    const policies = { max: 4, fit: 3, min: 2, fixed: 1 };\n                    return policies[width] > policies[height];\n                };\n                if (width_policy != \"fixed\" && height_policy != \"fixed\") {\n                    if (width_policy == height_policy) {\n                        const w_width = width;\n                        const w_height = round(width / aspect);\n                        const h_width = round(height * aspect);\n                        const h_height = height;\n                        const w_diff = Math.abs(viewport.width - w_width) + Math.abs(viewport.height - w_height);\n                        const h_diff = Math.abs(viewport.width - h_width) + Math.abs(viewport.height - h_height);\n                        if (w_diff <= h_diff) {\n                            width = w_width;\n                            height = w_height;\n                        }\n                        else {\n                            width = h_width;\n                            height = h_height;\n                        }\n                    }\n                    else if (gt(width_policy, height_policy)) {\n                        height = round(width / aspect);\n                    }\n                    else {\n                        width = round(height * aspect);\n                    }\n                }\n                else if (width_policy == \"fixed\") {\n                    height = round(width / aspect);\n                }\n                else if (height_policy == \"fixed\") {\n                    width = round(height * aspect);\n                }\n            }\n            return { width, height };\n        }\n        measure(viewport_size) {\n            if (!this.sizing.visible)\n                return { width: 0, height: 0 };\n            const exact_width = (width) => {\n                return this.sizing.width_policy == \"fixed\" && this.sizing.width != null ? this.sizing.width : width;\n            };\n            const exact_height = (height) => {\n                return this.sizing.height_policy == \"fixed\" && this.sizing.height != null ? this.sizing.height : height;\n            };\n            const viewport = new types_1.Sizeable(viewport_size)\n                .shrink_by(this.sizing.margin)\n                .map(exact_width, exact_height);\n            const computed = this._measure(viewport);\n            const clipped = this.clip_size(computed);\n            const width = exact_width(clipped.width);\n            const height = exact_height(clipped.height);\n            const size = this.apply_aspect(viewport, { width, height });\n            return Object.assign(Object.assign({}, computed), size);\n        }\n        compute(viewport = {}) {\n            const size_hint = this.measure({\n                width: viewport.width != null && this.is_width_expanding() ? viewport.width : Infinity,\n                height: viewport.height != null && this.is_height_expanding() ? viewport.height : Infinity,\n            });\n            const { width, height } = size_hint;\n            const outer = new bbox_1.BBox({ left: 0, top: 0, width, height });\n            let inner = undefined;\n            if (size_hint.inner != null) {\n                const { left, top, right, bottom } = size_hint.inner;\n                inner = new bbox_1.BBox({ left, top, right: width - right, bottom: height - bottom });\n            }\n            this.set_geometry(outer, inner);\n        }\n        get xview() {\n            return this.bbox.xview;\n        }\n        get yview() {\n            return this.bbox.yview;\n        }\n        clip_width(width) {\n            return max(this.sizing.min_width, min(width, this.sizing.max_width));\n        }\n        clip_height(height) {\n            return max(this.sizing.min_height, min(height, this.sizing.max_height));\n        }\n        clip_size({ width, height }) {\n            return {\n                width: this.clip_width(width),\n                height: this.clip_height(height),\n            };\n        }\n    }\n    exports.Layoutable = Layoutable;\n    Layoutable.__name__ = \"Layoutable\";\n    class LayoutItem extends Layoutable {\n        /*\n        constructor(readonly measure_fn: (viewport: Size) => Size) {\n          super()\n        }\n        protected _measure(viewport: Size): SizeHint {\n          return this.measure_fn(viewport)\n        }\n        protected _measure(viewport: Size): SizeHint {\n          return {\n            width: viewport.width != Infinity ? viewport.width : this.sizing.min_width,\n            height: viewport.height != Infinity ? viewport.height : this.sizing.min_width,\n          }\n        }\n        */\n        _measure(viewport) {\n            const { width_policy, height_policy } = this.sizing;\n            let width;\n            if (viewport.width == Infinity) {\n                width = this.sizing.width != null ? this.sizing.width : 0;\n            }\n            else {\n                if (width_policy == \"fixed\")\n                    width = this.sizing.width != null ? this.sizing.width : 0;\n                else if (width_policy == \"min\")\n                    width = this.sizing.width != null ? min(viewport.width, this.sizing.width) : 0;\n                else if (width_policy == \"fit\")\n                    width = this.sizing.width != null ? min(viewport.width, this.sizing.width) : viewport.width;\n                else if (width_policy == \"max\")\n                    width = this.sizing.width != null ? max(viewport.width, this.sizing.width) : viewport.width;\n                else\n                    throw new Error(\"unrechable\");\n            }\n            let height;\n            if (viewport.height == Infinity) {\n                height = this.sizing.height != null ? this.sizing.height : 0;\n            }\n            else {\n                if (height_policy == \"fixed\")\n                    height = this.sizing.height != null ? this.sizing.height : 0;\n                else if (height_policy == \"min\")\n                    height = this.sizing.height != null ? min(viewport.height, this.sizing.height) : 0;\n                else if (height_policy == \"fit\")\n                    height = this.sizing.height != null ? min(viewport.height, this.sizing.height) : viewport.height;\n                else if (height_policy == \"max\")\n                    height = this.sizing.height != null ? max(viewport.height, this.sizing.height) : viewport.height;\n                else\n                    throw new Error(\"unrechable\");\n            }\n            return { width, height };\n        }\n    }\n    exports.LayoutItem = LayoutItem;\n    LayoutItem.__name__ = \"LayoutItem\";\n    class ContentLayoutable extends Layoutable {\n        _measure(viewport) {\n            const content_size = this._content_size();\n            const bounds = viewport\n                .bounded_to(this.sizing.size)\n                .bounded_to(content_size);\n            const width = (() => {\n                switch (this.sizing.width_policy) {\n                    case \"fixed\":\n                        return this.sizing.width != null ? this.sizing.width : content_size.width;\n                    case \"min\":\n                        return content_size.width;\n                    case \"fit\":\n                        return bounds.width;\n                    case \"max\":\n                        return Math.max(content_size.width, bounds.width);\n                    default:\n                        throw new Error(\"unexpected\");\n                }\n            })();\n            const height = (() => {\n                switch (this.sizing.height_policy) {\n                    case \"fixed\":\n                        return this.sizing.height != null ? this.sizing.height : content_size.height;\n                    case \"min\":\n                        return content_size.height;\n                    case \"fit\":\n                        return bounds.height;\n                    case \"max\":\n                        return Math.max(content_size.height, bounds.height);\n                    default:\n                        throw new Error(\"unexpected\");\n                }\n            })();\n            return { width, height };\n        }\n    }\n    exports.ContentLayoutable = ContentLayoutable;\n    ContentLayoutable.__name__ = \"ContentLayoutable\";\n}\n","/* core/layout/alignments.js */ function _(require, module, exports) {\n    const layoutable_1 = require(182) /* ./layoutable */;\n    const bbox_1 = require(79) /* ../util/bbox */;\n    class Stack extends layoutable_1.Layoutable {\n        constructor() {\n            super(...arguments);\n            this.children = [];\n        }\n    }\n    exports.Stack = Stack;\n    Stack.__name__ = \"Stack\";\n    class HStack extends Stack {\n        _measure(_viewport) {\n            let width = 0;\n            let height = 0;\n            for (const child of this.children) {\n                const size_hint = child.measure({ width: 0, height: 0 });\n                width += size_hint.width;\n                height = Math.max(height, size_hint.height);\n            }\n            return { width, height };\n        }\n        _set_geometry(outer, inner) {\n            super._set_geometry(outer, inner);\n            const { top, bottom } = outer;\n            let { left } = outer;\n            for (const child of this.children) {\n                const { width } = child.measure({ width: 0, height: 0 });\n                child.set_geometry(new bbox_1.BBox({ left, width, top, bottom }));\n                left += width;\n            }\n        }\n    }\n    exports.HStack = HStack;\n    HStack.__name__ = \"HStack\";\n    class VStack extends Stack {\n        _measure(_viewport) {\n            let width = 0;\n            let height = 0;\n            for (const child of this.children) {\n                const size_hint = child.measure({ width: 0, height: 0 });\n                width = Math.max(width, size_hint.width);\n                height += size_hint.height;\n            }\n            return { width, height };\n        }\n        _set_geometry(outer, inner) {\n            super._set_geometry(outer, inner);\n            const { left, right } = outer;\n            let { top } = outer;\n            for (const child of this.children) {\n                const { height } = child.measure({ width: 0, height: 0 });\n                child.set_geometry(new bbox_1.BBox({ top, height, left, right }));\n                top += height;\n            }\n        }\n    }\n    exports.VStack = VStack;\n    VStack.__name__ = \"VStack\";\n    class AnchorLayout extends layoutable_1.Layoutable {\n        constructor() {\n            super(...arguments);\n            this.children = [];\n        }\n        _measure(viewport) {\n            let width = 0;\n            let height = 0;\n            for (const { layout } of this.children) {\n                const size_hint = layout.measure(viewport);\n                width = Math.max(width, size_hint.width);\n                height = Math.max(height, size_hint.height);\n            }\n            return { width, height };\n        }\n        _set_geometry(outer, inner) {\n            super._set_geometry(outer, inner);\n            for (const { layout, anchor, margin } of this.children) {\n                const { left, right, top, bottom, hcenter, vcenter } = outer;\n                const { width, height } = layout.measure(outer);\n                let bbox;\n                switch (anchor) {\n                    case 'top_left':\n                        bbox = new bbox_1.BBox({ left: left + margin, top: top + margin, width, height });\n                        break;\n                    case 'top_center':\n                        bbox = new bbox_1.BBox({ hcenter, top: top + margin, width, height });\n                        break;\n                    case 'top_right':\n                        bbox = new bbox_1.BBox({ right: right - margin, top: top + margin, width, height });\n                        break;\n                    case 'bottom_right':\n                        bbox = new bbox_1.BBox({ right: right - margin, bottom: bottom - margin, width, height });\n                        break;\n                    case 'bottom_center':\n                        bbox = new bbox_1.BBox({ hcenter, bottom: bottom - margin, width, height });\n                        break;\n                    case 'bottom_left':\n                        bbox = new bbox_1.BBox({ left: left + margin, bottom: bottom - margin, width, height });\n                        break;\n                    case 'center_left':\n                        bbox = new bbox_1.BBox({ left: left + margin, vcenter, width, height });\n                        break;\n                    case 'center':\n                        bbox = new bbox_1.BBox({ hcenter, vcenter, width, height });\n                        break;\n                    case 'center_right':\n                        bbox = new bbox_1.BBox({ right: right - margin, vcenter, width, height });\n                        break;\n                    default:\n                        throw new Error(\"unreachable\");\n                }\n                layout.set_geometry(bbox);\n            }\n        }\n    }\n    exports.AnchorLayout = AnchorLayout;\n    AnchorLayout.__name__ = \"AnchorLayout\";\n}\n","/* core/layout/grid.js */ function _(require, module, exports) {\n    const types_1 = require(181) /* ./types */;\n    const layoutable_1 = require(182) /* ./layoutable */;\n    const types_2 = require(7) /* ../util/types */;\n    const bbox_1 = require(79) /* ../util/bbox */;\n    const array_1 = require(8) /* ../util/array */;\n    const { max, round } = Math;\n    class DefaultMap {\n        constructor(def) {\n            this.def = def;\n            this._map = new Map();\n        }\n        get(key) {\n            let value = this._map.get(key);\n            if (value === undefined) {\n                value = this.def();\n                this._map.set(key, value);\n            }\n            return value;\n        }\n        apply(key, fn) {\n            const value = this.get(key);\n            this._map.set(key, fn(value));\n        }\n    }\n    DefaultMap.__name__ = \"DefaultMap\";\n    class Container {\n        constructor() {\n            this._items = [];\n            this._nrows = 0;\n            this._ncols = 0;\n        }\n        get nrows() {\n            return this._nrows;\n        }\n        get ncols() {\n            return this._ncols;\n        }\n        add(span, data) {\n            const { r1, c1 } = span;\n            this._nrows = max(this._nrows, r1 + 1);\n            this._ncols = max(this._ncols, c1 + 1);\n            this._items.push({ span, data });\n        }\n        at(r, c) {\n            const selected = this._items.filter(({ span }) => {\n                return span.r0 <= r && r <= span.r1 &&\n                    span.c0 <= c && c <= span.c1;\n            });\n            return selected.map(({ data }) => data);\n        }\n        row(r) {\n            const selected = this._items.filter(({ span }) => span.r0 <= r && r <= span.r1);\n            return selected.map(({ data }) => data);\n        }\n        col(c) {\n            const selected = this._items.filter(({ span }) => span.c0 <= c && c <= span.c1);\n            return selected.map(({ data }) => data);\n        }\n        foreach(fn) {\n            for (const { span, data } of this._items) {\n                fn(span, data);\n            }\n        }\n        map(fn) {\n            const result = new Container();\n            for (const { span, data } of this._items) {\n                result.add(span, fn(span, data));\n            }\n            return result;\n        }\n    }\n    Container.__name__ = \"Container\";\n    class Grid extends layoutable_1.Layoutable {\n        constructor(items = []) {\n            super();\n            this.items = items;\n            this.rows = \"auto\";\n            this.cols = \"auto\";\n            this.spacing = 0;\n            this.absolute = false;\n        }\n        is_width_expanding() {\n            if (super.is_width_expanding())\n                return true;\n            if (this.sizing.width_policy == \"fixed\")\n                return false;\n            const { cols } = this._state;\n            return array_1.some(cols, (col) => col.policy == \"max\");\n        }\n        is_height_expanding() {\n            if (super.is_height_expanding())\n                return true;\n            if (this.sizing.height_policy == \"fixed\")\n                return false;\n            const { rows } = this._state;\n            return array_1.some(rows, (row) => row.policy == \"max\");\n        }\n        _init() {\n            super._init();\n            const items = new Container();\n            for (const { layout, row, col, row_span, col_span } of this.items) {\n                if (layout.sizing.visible) {\n                    const r0 = row;\n                    const c0 = col;\n                    const r1 = row + (row_span != null ? row_span : 1) - 1;\n                    const c1 = col + (col_span != null ? col_span : 1) - 1;\n                    items.add({ r0, c0, r1, c1 }, layout);\n                }\n            }\n            const { nrows, ncols } = items;\n            const rows = new Array(nrows);\n            for (let y = 0; y < nrows; y++) {\n                const row = (() => {\n                    const sizing = types_2.isPlainObject(this.rows) ? this.rows[y] || this.rows[\"*\"] : this.rows;\n                    if (sizing == null)\n                        return { policy: \"auto\" };\n                    else if (types_2.isNumber(sizing))\n                        return { policy: \"fixed\", height: sizing };\n                    else if (types_2.isString(sizing))\n                        return { policy: sizing };\n                    else\n                        return sizing;\n                })();\n                const align = row.align || \"auto\";\n                if (row.policy == \"fixed\")\n                    rows[y] = { policy: \"fixed\", height: row.height, align };\n                else if (row.policy == \"min\")\n                    rows[y] = { policy: \"min\", align };\n                else if (row.policy == \"fit\" || row.policy == \"max\")\n                    rows[y] = { policy: row.policy, flex: row.flex || 1, align };\n                else if (row.policy == \"auto\") {\n                    if (array_1.some(items.row(y), (layout) => layout.is_height_expanding()))\n                        rows[y] = { policy: \"max\", flex: 1, align };\n                    else\n                        rows[y] = { policy: \"min\", align };\n                }\n                else\n                    throw new Error(\"unrechable\");\n            }\n            const cols = new Array(ncols);\n            for (let x = 0; x < ncols; x++) {\n                const col = (() => {\n                    const sizing = types_2.isPlainObject(this.cols) ? this.cols[x] || this.cols[\"*\"] : this.cols;\n                    if (sizing == null)\n                        return { policy: \"auto\" };\n                    else if (types_2.isNumber(sizing))\n                        return { policy: \"fixed\", width: sizing };\n                    else if (types_2.isString(sizing))\n                        return { policy: sizing };\n                    else\n                        return sizing;\n                })();\n                const align = col.align || \"auto\";\n                if (col.policy == \"fixed\")\n                    cols[x] = { policy: \"fixed\", width: col.width, align };\n                else if (col.policy == \"min\")\n                    cols[x] = { policy: \"min\", align };\n                else if (col.policy == \"fit\" || col.policy == \"max\")\n                    cols[x] = { policy: col.policy, flex: col.flex || 1, align };\n                else if (col.policy == \"auto\") {\n                    if (array_1.some(items.col(x), (layout) => layout.is_width_expanding()))\n                        cols[x] = { policy: \"max\", flex: 1, align };\n                    else\n                        cols[x] = { policy: \"min\", align };\n                }\n                else\n                    throw new Error(\"unrechable\");\n            }\n            const [rspacing, cspacing] = types_2.isNumber(this.spacing) ? [this.spacing, this.spacing] : this.spacing;\n            this._state = { items, nrows, ncols, rows, cols, rspacing, cspacing };\n        }\n        _measure_totals(row_heights, col_widths) {\n            const { nrows, ncols, rspacing, cspacing } = this._state;\n            return {\n                height: array_1.sum(row_heights) + (nrows - 1) * rspacing,\n                width: array_1.sum(col_widths) + (ncols - 1) * cspacing,\n            };\n        }\n        _measure_cells(cell_viewport) {\n            const { items, nrows, ncols, rows, cols, rspacing, cspacing } = this._state;\n            const row_heights = new Array(nrows);\n            for (let r = 0; r < nrows; r++) {\n                const row = rows[r];\n                row_heights[r] = row.policy == \"fixed\" ? row.height : 0;\n            }\n            const col_widths = new Array(ncols);\n            for (let c = 0; c < ncols; c++) {\n                const col = cols[c];\n                col_widths[c] = col.policy == \"fixed\" ? col.width : 0;\n            }\n            const size_hints = new Container();\n            items.foreach((span, layout) => {\n                const { r0, c0, r1, c1 } = span;\n                const rspace = (r1 - r0) * rspacing;\n                const cspace = (c1 - c0) * cspacing;\n                let height = 0;\n                for (let r = r0; r <= r1; r++) {\n                    height += cell_viewport(r, c0).height;\n                }\n                height += rspace;\n                let width = 0;\n                for (let c = c0; c <= c1; c++) {\n                    width += cell_viewport(r0, c).width;\n                }\n                width += cspace;\n                const size_hint = layout.measure({ width, height });\n                size_hints.add(span, { layout, size_hint });\n                const size = new types_1.Sizeable(size_hint).grow_by(layout.sizing.margin);\n                size.height -= rspace;\n                size.width -= cspace;\n                const radjustable = [];\n                for (let r = r0; r <= r1; r++) {\n                    const row = rows[r];\n                    if (row.policy == \"fixed\")\n                        size.height -= row.height;\n                    else\n                        radjustable.push(r);\n                }\n                if (size.height > 0) {\n                    const rheight = round(size.height / radjustable.length);\n                    for (const r of radjustable) {\n                        row_heights[r] = max(row_heights[r], rheight);\n                    }\n                }\n                const cadjustable = [];\n                for (let c = c0; c <= c1; c++) {\n                    const col = cols[c];\n                    if (col.policy == \"fixed\")\n                        size.width -= col.width;\n                    else\n                        cadjustable.push(c);\n                }\n                if (size.width > 0) {\n                    const cwidth = round(size.width / cadjustable.length);\n                    for (const c of cadjustable) {\n                        col_widths[c] = max(col_widths[c], cwidth);\n                    }\n                }\n            });\n            const size = this._measure_totals(row_heights, col_widths);\n            return { size, row_heights, col_widths, size_hints };\n        }\n        _measure_grid(viewport) {\n            const { nrows, ncols, rows, cols, rspacing, cspacing } = this._state;\n            const preferred = this._measure_cells((y, x) => {\n                const row = rows[y];\n                const col = cols[x];\n                return {\n                    width: col.policy == \"fixed\" ? col.width : Infinity,\n                    height: row.policy == \"fixed\" ? row.height : Infinity,\n                };\n            });\n            let available_height;\n            if (this.sizing.height_policy == \"fixed\" && this.sizing.height != null)\n                available_height = this.sizing.height;\n            else if (viewport.height != Infinity && this.is_height_expanding())\n                available_height = viewport.height;\n            else\n                available_height = preferred.size.height;\n            let height_flex = 0;\n            for (let y = 0; y < nrows; y++) {\n                const row = rows[y];\n                if (row.policy == \"fit\" || row.policy == \"max\")\n                    height_flex += row.flex;\n                else\n                    available_height -= preferred.row_heights[y];\n            }\n            available_height -= (nrows - 1) * rspacing;\n            if (height_flex != 0 && available_height > 0) {\n                for (let y = 0; y < nrows; y++) {\n                    const row = rows[y];\n                    if (row.policy == \"fit\" || row.policy == \"max\") {\n                        const height = round(available_height * (row.flex / height_flex));\n                        available_height -= height;\n                        preferred.row_heights[y] = height;\n                        height_flex -= row.flex;\n                    }\n                }\n            }\n            else if (available_height < 0) {\n                let nadjustable = 0;\n                for (let y = 0; y < nrows; y++) {\n                    const row = rows[y];\n                    if (row.policy != \"fixed\")\n                        nadjustable++;\n                }\n                let overflow_height = -available_height;\n                for (let y = 0; y < nrows; y++) {\n                    const row = rows[y];\n                    if (row.policy != \"fixed\") {\n                        const height = preferred.row_heights[y];\n                        const cutoff = round(overflow_height / nadjustable);\n                        preferred.row_heights[y] = max(height - cutoff, 0);\n                        overflow_height -= cutoff > height ? height : cutoff;\n                        nadjustable--;\n                    }\n                }\n            }\n            let available_width;\n            if (this.sizing.width_policy == \"fixed\" && this.sizing.width != null)\n                available_width = this.sizing.width;\n            else if (viewport.width != Infinity && this.is_width_expanding())\n                available_width = viewport.width;\n            else\n                available_width = preferred.size.width;\n            let width_flex = 0;\n            for (let x = 0; x < ncols; x++) {\n                const col = cols[x];\n                if (col.policy == \"fit\" || col.policy == \"max\")\n                    width_flex += col.flex;\n                else\n                    available_width -= preferred.col_widths[x];\n            }\n            available_width -= (ncols - 1) * cspacing;\n            if (width_flex != 0 && available_width > 0) {\n                for (let x = 0; x < ncols; x++) {\n                    const col = cols[x];\n                    if (col.policy == \"fit\" || col.policy == \"max\") {\n                        const width = round(available_width * (col.flex / width_flex));\n                        available_width -= width;\n                        preferred.col_widths[x] = width;\n                        width_flex -= col.flex;\n                    }\n                }\n            }\n            else if (available_width < 0) {\n                let nadjustable = 0;\n                for (let x = 0; x < ncols; x++) {\n                    const col = cols[x];\n                    if (col.policy != \"fixed\")\n                        nadjustable++;\n                }\n                let overflow_width = -available_width;\n                for (let x = 0; x < ncols; x++) {\n                    const col = cols[x];\n                    if (col.policy != \"fixed\") {\n                        const width = preferred.col_widths[x];\n                        const cutoff = round(overflow_width / nadjustable);\n                        preferred.col_widths[x] = max(width - cutoff, 0);\n                        overflow_width -= cutoff > width ? width : cutoff;\n                        nadjustable--;\n                    }\n                }\n            }\n            const { row_heights, col_widths, size_hints } = this._measure_cells((y, x) => {\n                return {\n                    width: preferred.col_widths[x],\n                    height: preferred.row_heights[y],\n                };\n            });\n            const size = this._measure_totals(row_heights, col_widths);\n            return { size, row_heights, col_widths, size_hints };\n        }\n        _measure(viewport) {\n            const { size } = this._measure_grid(viewport);\n            return size;\n        }\n        _set_geometry(outer, inner) {\n            super._set_geometry(outer, inner);\n            const { nrows, ncols, rspacing, cspacing } = this._state;\n            const { row_heights, col_widths, size_hints } = this._measure_grid(outer);\n            const rows = this._state.rows.map((row, r) => {\n                return Object.assign(Object.assign({}, row), { top: 0, height: row_heights[r], get bottom() { return this.top + this.height; } });\n            });\n            const cols = this._state.cols.map((col, c) => {\n                return Object.assign(Object.assign({}, col), { left: 0, width: col_widths[c], get right() { return this.left + this.width; } });\n            });\n            const items = size_hints.map((_, item) => {\n                return Object.assign(Object.assign({}, item), { outer: new bbox_1.BBox(), inner: new bbox_1.BBox() });\n            });\n            for (let r = 0, top = !this.absolute ? 0 : outer.top; r < nrows; r++) {\n                const row = rows[r];\n                row.top = top;\n                top += row.height + rspacing;\n            }\n            for (let c = 0, left = !this.absolute ? 0 : outer.left; c < ncols; c++) {\n                const col = cols[c];\n                col.left = left;\n                left += col.width + cspacing;\n            }\n            function span_width(c0, c1) {\n                let width = (c1 - c0) * cspacing;\n                for (let c = c0; c <= c1; c++) {\n                    width += cols[c].width;\n                }\n                return width;\n            }\n            function span_height(r0, r1) {\n                let height = (r1 - r0) * rspacing;\n                for (let r = r0; r <= r1; r++) {\n                    height += rows[r].height;\n                }\n                return height;\n            }\n            items.foreach(({ r0, c0, r1, c1 }, item) => {\n                const { layout, size_hint } = item;\n                const { sizing } = layout;\n                const { width, height } = size_hint;\n                const span = {\n                    width: span_width(c0, c1),\n                    height: span_height(r0, r1),\n                };\n                const halign = c0 == c1 && cols[c0].align != \"auto\" ? cols[c0].align : sizing.halign;\n                const valign = r0 == r1 && rows[r0].align != \"auto\" ? rows[r0].align : sizing.valign;\n                let left = cols[c0].left;\n                if (halign == \"start\")\n                    left += sizing.margin.left;\n                else if (halign == \"center\")\n                    left += round((span.width - width) / 2);\n                else if (halign == \"end\")\n                    left += span.width - sizing.margin.right - width;\n                let top = rows[r0].top;\n                if (valign == \"start\")\n                    top += sizing.margin.top;\n                else if (valign == \"center\")\n                    top += round((span.height - height) / 2);\n                else if (valign == \"end\")\n                    top += span.height - sizing.margin.bottom - height;\n                item.outer = new bbox_1.BBox({ left, top, width, height });\n            });\n            const row_aligns = rows.map(() => {\n                return {\n                    start: new DefaultMap(() => 0),\n                    end: new DefaultMap(() => 0),\n                };\n            });\n            const col_aligns = cols.map(() => {\n                return {\n                    start: new DefaultMap(() => 0),\n                    end: new DefaultMap(() => 0),\n                };\n            });\n            items.foreach(({ r0, c0, r1, c1 }, { size_hint, outer }) => {\n                const { inner } = size_hint;\n                if (inner != null) {\n                    row_aligns[r0].start.apply(outer.top, (v) => max(v, inner.top));\n                    row_aligns[r1].end.apply(rows[r1].bottom - outer.bottom, (v) => max(v, inner.bottom));\n                    col_aligns[c0].start.apply(outer.left, (v) => max(v, inner.left));\n                    col_aligns[c1].end.apply(cols[c1].right - outer.right, (v) => max(v, inner.right));\n                }\n            });\n            items.foreach(({ r0, c0, r1, c1 }, item) => {\n                const { size_hint, outer } = item;\n                function inner_bbox({ left, right, top, bottom }) {\n                    const width = outer.width - left - right;\n                    const height = outer.height - top - bottom;\n                    return new bbox_1.BBox({ left, top, width, height });\n                }\n                if (size_hint.inner != null) {\n                    let inner = inner_bbox(size_hint.inner);\n                    if (size_hint.align !== false) {\n                        const top = row_aligns[r0].start.get(outer.top);\n                        const bottom = row_aligns[r1].end.get(rows[r1].bottom - outer.bottom);\n                        const left = col_aligns[c0].start.get(outer.left);\n                        const right = col_aligns[c1].end.get(cols[c1].right - outer.right);\n                        try {\n                            inner = inner_bbox({ top, bottom, left, right });\n                        }\n                        catch (_a) { }\n                    }\n                    item.inner = inner;\n                }\n                else\n                    item.inner = outer;\n            });\n            items.foreach((_, { layout, outer, inner }) => {\n                layout.set_geometry(outer, inner);\n            });\n        }\n    }\n    exports.Grid = Grid;\n    Grid.__name__ = \"Grid\";\n    class Row extends Grid {\n        constructor(items) {\n            super();\n            this.items = items.map((item, i) => ({ layout: item, row: 0, col: i }));\n            this.rows = \"fit\";\n        }\n    }\n    exports.Row = Row;\n    Row.__name__ = \"Row\";\n    class Column extends Grid {\n        constructor(items) {\n            super();\n            this.items = items.map((item, i) => ({ layout: item, row: i, col: 0 }));\n            this.cols = \"fit\";\n        }\n    }\n    exports.Column = Column;\n    Column.__name__ = \"Column\";\n}\n","/* core/layout/html.js */ function _(require, module, exports) {\n    const layoutable_1 = require(182) /* ./layoutable */;\n    const types_1 = require(181) /* ./types */;\n    const dom_1 = require(61) /* ../dom */;\n    class ContentBox extends layoutable_1.ContentLayoutable {\n        constructor(el) {\n            super();\n            this.content_size = dom_1.unsized(el, () => new types_1.Sizeable(dom_1.size(el)));\n        }\n        _content_size() {\n            return this.content_size;\n        }\n    }\n    exports.ContentBox = ContentBox;\n    ContentBox.__name__ = \"ContentBox\";\n    class VariadicBox extends layoutable_1.Layoutable {\n        constructor(el) {\n            super();\n            this.el = el;\n        }\n        _measure(viewport) {\n            const bounded = new types_1.Sizeable(viewport).bounded_to(this.sizing.size);\n            return dom_1.sized(this.el, bounded, () => {\n                const content = new types_1.Sizeable(dom_1.content_size(this.el));\n                const { border, padding } = dom_1.extents(this.el);\n                return content.grow_by(border).grow_by(padding).map(Math.ceil);\n            });\n        }\n    }\n    exports.VariadicBox = VariadicBox;\n    VariadicBox.__name__ = \"VariadicBox\";\n}\n","/* models/expressions/index.js */ function _(require, module, exports) {\n    var expression_1 = require(187) /* ./expression */;\n    exports.Expression = expression_1.Expression;\n    var stack_1 = require(188) /* ./stack */;\n    exports.Stack = stack_1.Stack;\n    var cumsum_1 = require(189) /* ./cumsum */;\n    exports.CumSum = cumsum_1.CumSum;\n}\n","/* models/expressions/expression.js */ function _(require, module, exports) {\n    const model_1 = require(64) /* ../../model */;\n    class Expression extends model_1.Model {\n        constructor(attrs) {\n            super(attrs);\n            this._connected = {};\n            this._result = {};\n        }\n        initialize() {\n            super.initialize();\n            this._connected = {};\n            this._result = {};\n        }\n        v_compute(source) {\n            if (this._connected[source.id] == null) {\n                this.connect(source.change, () => delete this._result[source.id]);\n                this.connect(source.patching, () => delete this._result[source.id]);\n                this.connect(source.streaming, () => delete this._result[source.id]);\n                this._connected[source.id] = true;\n            }\n            let result = this._result[source.id];\n            if (result == null)\n                this._result[source.id] = result = this._v_compute(source);\n            return result;\n        }\n    }\n    exports.Expression = Expression;\n    Expression.__name__ = \"Expression\";\n}\n","/* models/expressions/stack.js */ function _(require, module, exports) {\n    const expression_1 = require(187) /* ./expression */;\n    const p = require(18) /* ../../core/properties */;\n    class Stack extends expression_1.Expression {\n        constructor(attrs) {\n            super(attrs);\n        }\n        static init_Stack() {\n            this.define({\n                fields: [p.Array, []],\n            });\n        }\n        _v_compute(source) {\n            const n = source.get_length() || 0; // TODO: use ?? in TS 3.7\n            const result = new Float64Array(n);\n            for (const f of this.fields) {\n                const column = source.data[f];\n                if (column != null) {\n                    for (let i = 0, k = Math.min(n, column.length); i < k; i++) {\n                        result[i] += column[i];\n                    }\n                }\n            }\n            return result;\n        }\n    }\n    exports.Stack = Stack;\n    Stack.__name__ = \"Stack\";\n    Stack.init_Stack();\n}\n","/* models/expressions/cumsum.js */ function _(require, module, exports) {\n    const expression_1 = require(187) /* ./expression */;\n    const p = require(18) /* ../../core/properties */;\n    class CumSum extends expression_1.Expression {\n        constructor(attrs) {\n            super(attrs);\n        }\n        static init_CumSum() {\n            this.define({\n                field: [p.String],\n                include_zero: [p.Boolean, false],\n            });\n        }\n        _v_compute(source) {\n            const result = new Float64Array(source.get_length() || 0);\n            const col = source.data[this.field];\n            const offset = this.include_zero ? 1 : 0;\n            result[0] = this.include_zero ? 0 : col[0];\n            for (let i = 1; i < result.length; i++) {\n                result[i] = result[i - 1] + col[i - offset];\n            }\n            return result;\n        }\n    }\n    exports.CumSum = CumSum;\n    CumSum.__name__ = \"CumSum\";\n    CumSum.init_CumSum();\n}\n","/* models/filters/index.js */ function _(require, module, exports) {\n    var boolean_filter_1 = require(191) /* ./boolean_filter */;\n    exports.BooleanFilter = boolean_filter_1.BooleanFilter;\n    var customjs_filter_1 = require(193) /* ./customjs_filter */;\n    exports.CustomJSFilter = customjs_filter_1.CustomJSFilter;\n    var filter_1 = require(192) /* ./filter */;\n    exports.Filter = filter_1.Filter;\n    var group_filter_1 = require(194) /* ./group_filter */;\n    exports.GroupFilter = group_filter_1.GroupFilter;\n    var index_filter_1 = require(195) /* ./index_filter */;\n    exports.IndexFilter = index_filter_1.IndexFilter;\n}\n","/* models/filters/boolean_filter.js */ function _(require, module, exports) {\n    const filter_1 = require(192) /* ./filter */;\n    const p = require(18) /* ../../core/properties */;\n    const logging_1 = require(65) /* ../../core/logging */;\n    const array_1 = require(8) /* ../../core/util/array */;\n    const types_1 = require(7) /* ../../core/util/types */;\n    class BooleanFilter extends filter_1.Filter {\n        constructor(attrs) {\n            super(attrs);\n        }\n        static init_BooleanFilter() {\n            this.define({\n                booleans: [p.Array, null],\n            });\n        }\n        compute_indices(source) {\n            const booleans = this.booleans;\n            if (booleans != null && booleans.length > 0) {\n                if (array_1.every(booleans, types_1.isBoolean)) {\n                    if (booleans.length !== source.get_length()) {\n                        logging_1.logger.warn(`BooleanFilter ${this.id}: length of booleans doesn't match data source`);\n                    }\n                    return array_1.range(0, booleans.length).filter((i) => booleans[i] === true);\n                }\n                else {\n                    logging_1.logger.warn(`BooleanFilter ${this.id}: booleans should be array of booleans, defaulting to no filtering`);\n                    return null;\n                }\n            }\n            else {\n                if (booleans != null && booleans.length == 0)\n                    logging_1.logger.warn(`BooleanFilter ${this.id}: booleans is empty, defaulting to no filtering`);\n                else\n                    logging_1.logger.warn(`BooleanFilter ${this.id}: booleans was not set, defaulting to no filtering`);\n                return null;\n            }\n        }\n    }\n    exports.BooleanFilter = BooleanFilter;\n    BooleanFilter.__name__ = \"BooleanFilter\";\n    BooleanFilter.init_BooleanFilter();\n}\n","/* models/filters/filter.js */ function _(require, module, exports) {\n    const model_1 = require(64) /* ../../model */;\n    const p = require(18) /* ../../core/properties */;\n    const types_1 = require(7) /* ../../core/util/types */;\n    const array_1 = require(8) /* ../../core/util/array */;\n    const logging_1 = require(65) /* ../../core/logging */;\n    class Filter extends model_1.Model {\n        constructor(attrs) {\n            super(attrs);\n        }\n        static init_Filter() {\n            this.define({\n                filter: [p.Array, null],\n            });\n        }\n        compute_indices(_source) {\n            const filter = this.filter;\n            if (filter != null && filter.length >= 0) {\n                if (types_1.isArrayOf(filter, types_1.isBoolean)) {\n                    return array_1.range(0, filter.length).filter((i) => filter[i] === true);\n                }\n                if (types_1.isArrayOf(filter, types_1.isInteger)) {\n                    return filter;\n                }\n                logging_1.logger.warn(`Filter ${this.id}: filter should either be array of only booleans or only integers, defaulting to no filtering`);\n                return null;\n            }\n            else {\n                logging_1.logger.warn(`Filter ${this.id}: filter was not set to be an array, defaulting to no filtering`);\n                return null;\n            }\n        }\n    }\n    exports.Filter = Filter;\n    Filter.__name__ = \"Filter\";\n    Filter.init_Filter();\n}\n","/* models/filters/customjs_filter.js */ function _(require, module, exports) {\n    const filter_1 = require(192) /* ./filter */;\n    const p = require(18) /* ../../core/properties */;\n    const object_1 = require(22) /* ../../core/util/object */;\n    const string_1 = require(25) /* ../../core/util/string */;\n    class CustomJSFilter extends filter_1.Filter {\n        constructor(attrs) {\n            super(attrs);\n        }\n        static init_CustomJSFilter() {\n            this.define({\n                args: [p.Any, {}],\n                code: [p.String, ''],\n                use_strict: [p.Boolean, false],\n            });\n        }\n        get names() {\n            return object_1.keys(this.args);\n        }\n        get values() {\n            return object_1.values(this.args);\n        }\n        get func() {\n            const code = this.use_strict ? string_1.use_strict(this.code) : this.code;\n            return new Function(...this.names, \"source\", \"require\", \"exports\", code);\n        }\n        compute_indices(source) {\n            this.filter = this.func(...this.values, source, require, {});\n            return super.compute_indices(source);\n        }\n    }\n    exports.CustomJSFilter = CustomJSFilter;\n    CustomJSFilter.__name__ = \"CustomJSFilter\";\n    CustomJSFilter.init_CustomJSFilter();\n}\n","/* models/filters/group_filter.js */ function _(require, module, exports) {\n    const filter_1 = require(192) /* ./filter */;\n    const p = require(18) /* ../../core/properties */;\n    const logging_1 = require(65) /* ../../core/logging */;\n    const array_1 = require(8) /* ../../core/util/array */;\n    class GroupFilter extends filter_1.Filter {\n        constructor(attrs) {\n            super(attrs);\n            this.indices = null;\n        }\n        static init_GroupFilter() {\n            this.define({\n                column_name: [p.String],\n                group: [p.String],\n            });\n        }\n        compute_indices(source) {\n            const column = source.get_column(this.column_name);\n            if (column == null) {\n                logging_1.logger.warn(\"group filter: groupby column not found in data source\");\n                return null;\n            }\n            else {\n                this.indices = array_1.range(0, source.get_length() || 0).filter((i) => column[i] === this.group);\n                if (this.indices.length === 0) {\n                    logging_1.logger.warn(`group filter: group '${this.group}' did not match any values in column '${this.column_name}'`);\n                }\n                return this.indices;\n            }\n        }\n    }\n    exports.GroupFilter = GroupFilter;\n    GroupFilter.__name__ = \"GroupFilter\";\n    GroupFilter.init_GroupFilter();\n}\n","/* models/filters/index_filter.js */ function _(require, module, exports) {\n    const filter_1 = require(192) /* ./filter */;\n    const p = require(18) /* ../../core/properties */;\n    const logging_1 = require(65) /* ../../core/logging */;\n    const types_1 = require(7) /* ../../core/util/types */;\n    const array_1 = require(8) /* ../../core/util/array */;\n    class IndexFilter extends filter_1.Filter {\n        constructor(attrs) {\n            super(attrs);\n        }\n        static init_IndexFilter() {\n            this.define({\n                indices: [p.Array, null],\n            });\n        }\n        compute_indices(_source) {\n            if (this.indices != null && this.indices.length >= 0) {\n                if (array_1.every(this.indices, types_1.isInteger))\n                    return this.indices;\n                else {\n                    logging_1.logger.warn(`IndexFilter ${this.id}: indices should be array of integers, defaulting to no filtering`);\n                    return null;\n                }\n            }\n            else {\n                logging_1.logger.warn(`IndexFilter ${this.id}: indices was not set, defaulting to no filtering`);\n                return null;\n            }\n        }\n    }\n    exports.IndexFilter = IndexFilter;\n    IndexFilter.__name__ = \"IndexFilter\";\n    IndexFilter.init_IndexFilter();\n}\n","/* models/formatters/index.js */ function _(require, module, exports) {\n    var basic_tick_formatter_1 = require(106) /* ./basic_tick_formatter */;\n    exports.BasicTickFormatter = basic_tick_formatter_1.BasicTickFormatter;\n    var categorical_tick_formatter_1 = require(145) /* ./categorical_tick_formatter */;\n    exports.CategoricalTickFormatter = categorical_tick_formatter_1.CategoricalTickFormatter;\n    var datetime_tick_formatter_1 = require(149) /* ./datetime_tick_formatter */;\n    exports.DatetimeTickFormatter = datetime_tick_formatter_1.DatetimeTickFormatter;\n    var func_tick_formatter_1 = require(197) /* ./func_tick_formatter */;\n    exports.FuncTickFormatter = func_tick_formatter_1.FuncTickFormatter;\n    var log_tick_formatter_1 = require(162) /* ./log_tick_formatter */;\n    exports.LogTickFormatter = log_tick_formatter_1.LogTickFormatter;\n    var mercator_tick_formatter_1 = require(165) /* ./mercator_tick_formatter */;\n    exports.MercatorTickFormatter = mercator_tick_formatter_1.MercatorTickFormatter;\n    var numeral_tick_formatter_1 = require(198) /* ./numeral_tick_formatter */;\n    exports.NumeralTickFormatter = numeral_tick_formatter_1.NumeralTickFormatter;\n    var printf_tick_formatter_1 = require(199) /* ./printf_tick_formatter */;\n    exports.PrintfTickFormatter = printf_tick_formatter_1.PrintfTickFormatter;\n    var tick_formatter_1 = require(107) /* ./tick_formatter */;\n    exports.TickFormatter = tick_formatter_1.TickFormatter;\n}\n","/* models/formatters/func_tick_formatter.js */ function _(require, module, exports) {\n    const tick_formatter_1 = require(107) /* ./tick_formatter */;\n    const p = require(18) /* ../../core/properties */;\n    const object_1 = require(22) /* ../../core/util/object */;\n    const string_1 = require(25) /* ../../core/util/string */;\n    class FuncTickFormatter extends tick_formatter_1.TickFormatter {\n        constructor(attrs) {\n            super(attrs);\n        }\n        static init_FuncTickFormatter() {\n            this.define({\n                args: [p.Any, {}],\n                code: [p.String, ''],\n                use_strict: [p.Boolean, false],\n            });\n        }\n        get names() {\n            return object_1.keys(this.args);\n        }\n        get values() {\n            return object_1.values(this.args);\n        }\n        /*protected*/ _make_func() {\n            const code = this.use_strict ? string_1.use_strict(this.code) : this.code;\n            return new Function(\"tick\", \"index\", \"ticks\", ...this.names, \"require\", \"exports\", code);\n        }\n        doFormat(ticks, _opts) {\n            const cache = {};\n            const func = this._make_func().bind(cache);\n            return ticks.map((tick, index, ticks) => func(tick, index, ticks, ...this.values, require, {}));\n        }\n    }\n    exports.FuncTickFormatter = FuncTickFormatter;\n    FuncTickFormatter.__name__ = \"FuncTickFormatter\";\n    FuncTickFormatter.init_FuncTickFormatter();\n}\n","/* models/formatters/numeral_tick_formatter.js */ function _(require, module, exports) {\n    const Numbro = require(153) /* numbro */;\n    const tick_formatter_1 = require(107) /* ./tick_formatter */;\n    const p = require(18) /* ../../core/properties */;\n    class NumeralTickFormatter extends tick_formatter_1.TickFormatter {\n        constructor(attrs) {\n            super(attrs);\n        }\n        static init_NumeralTickFormatter() {\n            this.define({\n                // TODO (bev) all of these could be tightened up\n                format: [p.String, '0,0'],\n                language: [p.String, 'en'],\n                rounding: [p.RoundingFunction, 'round'],\n            });\n        }\n        get _rounding_fn() {\n            switch (this.rounding) {\n                case \"round\":\n                case \"nearest\":\n                    return Math.round;\n                case \"floor\":\n                case \"rounddown\":\n                    return Math.floor;\n                case \"ceil\":\n                case \"roundup\":\n                    return Math.ceil;\n            }\n        }\n        doFormat(ticks, _opts) {\n            const { format, language, _rounding_fn } = this;\n            return ticks.map((tick) => Numbro.format(tick, format, language, _rounding_fn));\n        }\n    }\n    exports.NumeralTickFormatter = NumeralTickFormatter;\n    NumeralTickFormatter.__name__ = \"NumeralTickFormatter\";\n    NumeralTickFormatter.init_NumeralTickFormatter();\n}\n","/* models/formatters/printf_tick_formatter.js */ function _(require, module, exports) {\n    const tick_formatter_1 = require(107) /* ./tick_formatter */;\n    const templating_1 = require(151) /* ../../core/util/templating */;\n    const p = require(18) /* ../../core/properties */;\n    class PrintfTickFormatter extends tick_formatter_1.TickFormatter {\n        constructor(attrs) {\n            super(attrs);\n        }\n        static init_PrintfTickFormatter() {\n            this.define({\n                format: [p.String, '%s'],\n            });\n        }\n        doFormat(ticks, _opts) {\n            return ticks.map((tick) => templating_1.sprintf(this.format, tick));\n        }\n    }\n    exports.PrintfTickFormatter = PrintfTickFormatter;\n    PrintfTickFormatter.__name__ = \"PrintfTickFormatter\";\n    PrintfTickFormatter.init_PrintfTickFormatter();\n}\n","/* models/glyphs/index.js */ function _(require, module, exports) {\n    var annular_wedge_1 = require(201) /* ./annular_wedge */;\n    exports.AnnularWedge = annular_wedge_1.AnnularWedge;\n    var annulus_1 = require(202) /* ./annulus */;\n    exports.Annulus = annulus_1.Annulus;\n    var arc_1 = require(203) /* ./arc */;\n    exports.Arc = arc_1.Arc;\n    var bezier_1 = require(204) /* ./bezier */;\n    exports.Bezier = bezier_1.Bezier;\n    var circle_1 = require(205) /* ./circle */;\n    exports.Circle = circle_1.Circle;\n    var center_rotatable_1 = require(206) /* ./center_rotatable */;\n    exports.CenterRotatable = center_rotatable_1.CenterRotatable;\n    var ellipse_1 = require(207) /* ./ellipse */;\n    exports.Ellipse = ellipse_1.Ellipse;\n    var ellipse_oval_1 = require(208) /* ./ellipse_oval */;\n    exports.EllipseOval = ellipse_oval_1.EllipseOval;\n    var glyph_1 = require(80) /* ./glyph */;\n    exports.Glyph = glyph_1.Glyph;\n    var harea_1 = require(86) /* ./harea */;\n    exports.HArea = harea_1.HArea;\n    var hbar_1 = require(209) /* ./hbar */;\n    exports.HBar = hbar_1.HBar;\n    var hex_tile_1 = require(211) /* ./hex_tile */;\n    exports.HexTile = hex_tile_1.HexTile;\n    var image_1 = require(212) /* ./image */;\n    exports.Image = image_1.Image;\n    var image_rgba_1 = require(214) /* ./image_rgba */;\n    exports.ImageRGBA = image_rgba_1.ImageRGBA;\n    var image_url_1 = require(215) /* ./image_url */;\n    exports.ImageURL = image_url_1.ImageURL;\n    var line_1 = require(75) /* ./line */;\n    exports.Line = line_1.Line;\n    var multi_line_1 = require(217) /* ./multi_line */;\n    exports.MultiLine = multi_line_1.MultiLine;\n    var multi_polygons_1 = require(218) /* ./multi_polygons */;\n    exports.MultiPolygons = multi_polygons_1.MultiPolygons;\n    var oval_1 = require(219) /* ./oval */;\n    exports.Oval = oval_1.Oval;\n    var patch_1 = require(85) /* ./patch */;\n    exports.Patch = patch_1.Patch;\n    var patches_1 = require(220) /* ./patches */;\n    exports.Patches = patches_1.Patches;\n    var quad_1 = require(221) /* ./quad */;\n    exports.Quad = quad_1.Quad;\n    var quadratic_1 = require(222) /* ./quadratic */;\n    exports.Quadratic = quadratic_1.Quadratic;\n    var ray_1 = require(223) /* ./ray */;\n    exports.Ray = ray_1.Ray;\n    var rect_1 = require(224) /* ./rect */;\n    exports.Rect = rect_1.Rect;\n    var segment_1 = require(225) /* ./segment */;\n    exports.Segment = segment_1.Segment;\n    var step_1 = require(226) /* ./step */;\n    exports.Step = step_1.Step;\n    var text_1 = require(227) /* ./text */;\n    exports.Text = text_1.Text;\n    var varea_1 = require(88) /* ./varea */;\n    exports.VArea = varea_1.VArea;\n    var vbar_1 = require(228) /* ./vbar */;\n    exports.VBar = vbar_1.VBar;\n    var wedge_1 = require(229) /* ./wedge */;\n    exports.Wedge = wedge_1.Wedge;\n    var xy_glyph_1 = require(76) /* ./xy_glyph */;\n    exports.XYGlyph = xy_glyph_1.XYGlyph;\n}\n","/* models/glyphs/annular_wedge.js */ function _(require, module, exports) {\n    const xy_glyph_1 = require(76) /* ./xy_glyph */;\n    const utils_1 = require(84) /* ./utils */;\n    const hittest = require(81) /* ../../core/hittest */;\n    const p = require(18) /* ../../core/properties */;\n    const math_1 = require(9) /* ../../core/util/math */;\n    class AnnularWedgeView extends xy_glyph_1.XYGlyphView {\n        _map_data() {\n            if (this.model.properties.inner_radius.units == \"data\")\n                this.sinner_radius = this.sdist(this.renderer.xscale, this._x, this._inner_radius);\n            else\n                this.sinner_radius = this._inner_radius;\n            if (this.model.properties.outer_radius.units == \"data\")\n                this.souter_radius = this.sdist(this.renderer.xscale, this._x, this._outer_radius);\n            else\n                this.souter_radius = this._outer_radius;\n            this._angle = new Float32Array(this._start_angle.length);\n            for (let i = 0, end = this._start_angle.length; i < end; i++) {\n                this._angle[i] = this._end_angle[i] - this._start_angle[i];\n            }\n        }\n        _render(ctx, indices, { sx, sy, _start_angle, _angle, sinner_radius, souter_radius }) {\n            const direction = this.model.properties.direction.value();\n            for (const i of indices) {\n                if (isNaN(sx[i] + sy[i] + sinner_radius[i] + souter_radius[i] + _start_angle[i] + _angle[i]))\n                    continue;\n                ctx.translate(sx[i], sy[i]);\n                ctx.rotate(_start_angle[i]);\n                ctx.moveTo(souter_radius[i], 0);\n                ctx.beginPath();\n                ctx.arc(0, 0, souter_radius[i], 0, _angle[i], direction);\n                ctx.rotate(_angle[i]);\n                ctx.lineTo(sinner_radius[i], 0);\n                ctx.arc(0, 0, sinner_radius[i], 0, -_angle[i], !direction);\n                ctx.closePath();\n                ctx.rotate(-_angle[i] - _start_angle[i]);\n                ctx.translate(-sx[i], -sy[i]);\n                if (this.visuals.fill.doit) {\n                    this.visuals.fill.set_vectorize(ctx, i);\n                    ctx.fill();\n                }\n                if (this.visuals.line.doit) {\n                    this.visuals.line.set_vectorize(ctx, i);\n                    ctx.stroke();\n                }\n            }\n        }\n        _hit_point(geometry) {\n            const { sx, sy } = geometry;\n            const x = this.renderer.xscale.invert(sx);\n            const y = this.renderer.yscale.invert(sy);\n            // check radius first\n            let x0, y0;\n            let x1, y1;\n            if (this.model.properties.outer_radius.units == \"data\") {\n                x0 = x - this.max_outer_radius;\n                x1 = x + this.max_outer_radius;\n                y0 = y - this.max_outer_radius;\n                y1 = y + this.max_outer_radius;\n            }\n            else {\n                const sx0 = sx - this.max_outer_radius;\n                const sx1 = sx + this.max_outer_radius;\n                [x0, x1] = this.renderer.xscale.r_invert(sx0, sx1);\n                const sy0 = sy - this.max_outer_radius;\n                const sy1 = sy + this.max_outer_radius;\n                [y0, y1] = this.renderer.yscale.r_invert(sy0, sy1);\n            }\n            const candidates = [];\n            for (const i of this.index.indices({ x0, x1, y0, y1 })) {\n                const or2 = Math.pow(this.souter_radius[i], 2);\n                const ir2 = Math.pow(this.sinner_radius[i], 2);\n                const [sx0, sx1] = this.renderer.xscale.r_compute(x, this._x[i]);\n                const [sy0, sy1] = this.renderer.yscale.r_compute(y, this._y[i]);\n                const dist = Math.pow(sx0 - sx1, 2) + Math.pow(sy0 - sy1, 2);\n                if (dist <= or2 && dist >= ir2)\n                    candidates.push([i, dist]);\n            }\n            const direction = this.model.properties.direction.value();\n            const hits = [];\n            for (const [i, dist] of candidates) {\n                // NOTE: minus the angle because JS uses non-mathy convention for angles\n                const angle = Math.atan2(sy - this.sy[i], sx - this.sx[i]);\n                if (math_1.angle_between(-angle, -this._start_angle[i], -this._end_angle[i], direction)) {\n                    hits.push([i, dist]);\n                }\n            }\n            return hittest.create_hit_test_result_from_hits(hits);\n        }\n        draw_legend_for_index(ctx, bbox, index) {\n            utils_1.generic_area_legend(this.visuals, ctx, bbox, index);\n        }\n        _scenterxy(i) {\n            const r = (this.sinner_radius[i] + this.souter_radius[i]) / 2;\n            const a = (this._start_angle[i] + this._end_angle[i]) / 2;\n            return { x: this.sx[i] + (r * Math.cos(a)), y: this.sy[i] + (r * Math.sin(a)) };\n        }\n        scenterx(i) {\n            return this._scenterxy(i).x;\n        }\n        scentery(i) {\n            return this._scenterxy(i).y;\n        }\n    }\n    exports.AnnularWedgeView = AnnularWedgeView;\n    AnnularWedgeView.__name__ = \"AnnularWedgeView\";\n    class AnnularWedge extends xy_glyph_1.XYGlyph {\n        constructor(attrs) {\n            super(attrs);\n        }\n        static init_AnnularWedge() {\n            this.prototype.default_view = AnnularWedgeView;\n            this.mixins(['line', 'fill']);\n            this.define({\n                direction: [p.Direction, 'anticlock'],\n                inner_radius: [p.DistanceSpec],\n                outer_radius: [p.DistanceSpec],\n                start_angle: [p.AngleSpec],\n                end_angle: [p.AngleSpec],\n            });\n        }\n    }\n    exports.AnnularWedge = AnnularWedge;\n    AnnularWedge.__name__ = \"AnnularWedge\";\n    AnnularWedge.init_AnnularWedge();\n}\n","/* models/glyphs/annulus.js */ function _(require, module, exports) {\n    const xy_glyph_1 = require(76) /* ./xy_glyph */;\n    const hittest = require(81) /* ../../core/hittest */;\n    const p = require(18) /* ../../core/properties */;\n    const compat_1 = require(95) /* ../../core/util/compat */;\n    class AnnulusView extends xy_glyph_1.XYGlyphView {\n        _map_data() {\n            if (this.model.properties.inner_radius.units == \"data\")\n                this.sinner_radius = this.sdist(this.renderer.xscale, this._x, this._inner_radius);\n            else\n                this.sinner_radius = this._inner_radius;\n            if (this.model.properties.outer_radius.units == \"data\")\n                this.souter_radius = this.sdist(this.renderer.xscale, this._x, this._outer_radius);\n            else\n                this.souter_radius = this._outer_radius;\n        }\n        _render(ctx, indices, { sx, sy, sinner_radius, souter_radius }) {\n            for (const i of indices) {\n                if (isNaN(sx[i] + sy[i] + sinner_radius[i] + souter_radius[i]))\n                    continue;\n                // Because this visual has a whole in it, it proved \"challenging\"\n                // for some browsers to render if drawn in one go --- i.e. it did not\n                // work on IE. If we render in two parts (upper and lower part),\n                // it is unambiguous what part should be filled. The line is\n                // better drawn in one go though, otherwise the part where the pieces\n                // meet will not be fully closed due to aa.\n                if (this.visuals.fill.doit) {\n                    this.visuals.fill.set_vectorize(ctx, i);\n                    ctx.beginPath();\n                    if (compat_1.is_ie) {\n                        // Draw two halves of the donut. Works on IE, but causes an aa line on Safari.\n                        for (const clockwise of [false, true]) {\n                            ctx.arc(sx[i], sy[i], sinner_radius[i], 0, Math.PI, clockwise);\n                            ctx.arc(sx[i], sy[i], souter_radius[i], Math.PI, 0, !clockwise);\n                        }\n                    }\n                    else {\n                        // Draw donut in one go. Does not work on iE.\n                        ctx.arc(sx[i], sy[i], sinner_radius[i], 0, 2 * Math.PI, true);\n                        ctx.arc(sx[i], sy[i], souter_radius[i], 2 * Math.PI, 0, false);\n                    }\n                    ctx.fill();\n                }\n                if (this.visuals.line.doit) {\n                    this.visuals.line.set_vectorize(ctx, i);\n                    ctx.beginPath();\n                    ctx.arc(sx[i], sy[i], sinner_radius[i], 0, 2 * Math.PI);\n                    ctx.moveTo(sx[i] + souter_radius[i], sy[i]);\n                    ctx.arc(sx[i], sy[i], souter_radius[i], 0, 2 * Math.PI);\n                    ctx.stroke();\n                }\n            }\n        }\n        _hit_point(geometry) {\n            const { sx, sy } = geometry;\n            const x = this.renderer.xscale.invert(sx);\n            const y = this.renderer.yscale.invert(sy);\n            let x0, y0;\n            let x1, y1;\n            if (this.model.properties.outer_radius.units == \"data\") {\n                x0 = x - this.max_outer_radius;\n                x1 = x + this.max_outer_radius;\n                y0 = y - this.max_outer_radius;\n                y1 = y + this.max_outer_radius;\n            }\n            else {\n                const sx0 = sx - this.max_outer_radius;\n                const sx1 = sx + this.max_outer_radius;\n                [x0, x1] = this.renderer.xscale.r_invert(sx0, sx1);\n                const sy0 = sy - this.max_outer_radius;\n                const sy1 = sy + this.max_outer_radius;\n                [y0, y1] = this.renderer.yscale.r_invert(sy0, sy1);\n            }\n            const hits = [];\n            for (const i of this.index.indices({ x0, x1, y0, y1 })) {\n                const or2 = Math.pow(this.souter_radius[i], 2);\n                const ir2 = Math.pow(this.sinner_radius[i], 2);\n                const [sx0, sx1] = this.renderer.xscale.r_compute(x, this._x[i]);\n                const [sy0, sy1] = this.renderer.yscale.r_compute(y, this._y[i]);\n                const dist = Math.pow(sx0 - sx1, 2) + Math.pow(sy0 - sy1, 2);\n                if (dist <= or2 && dist >= ir2)\n                    hits.push([i, dist]);\n            }\n            return hittest.create_hit_test_result_from_hits(hits);\n        }\n        draw_legend_for_index(ctx, { x0, y0, x1, y1 }, index) {\n            const len = index + 1;\n            const sx = new Array(len);\n            sx[index] = (x0 + x1) / 2;\n            const sy = new Array(len);\n            sy[index] = (y0 + y1) / 2;\n            const r = Math.min(Math.abs(x1 - x0), Math.abs(y1 - y0)) * 0.5;\n            const sinner_radius = new Array(len);\n            sinner_radius[index] = r * 0.4;\n            const souter_radius = new Array(len);\n            souter_radius[index] = r * 0.8;\n            this._render(ctx, [index], { sx, sy, sinner_radius, souter_radius }); // XXX\n        }\n    }\n    exports.AnnulusView = AnnulusView;\n    AnnulusView.__name__ = \"AnnulusView\";\n    class Annulus extends xy_glyph_1.XYGlyph {\n        constructor(attrs) {\n            super(attrs);\n        }\n        static init_Annulus() {\n            this.prototype.default_view = AnnulusView;\n            this.mixins(['line', 'fill']);\n            this.define({\n                inner_radius: [p.DistanceSpec],\n                outer_radius: [p.DistanceSpec],\n            });\n        }\n    }\n    exports.Annulus = Annulus;\n    Annulus.__name__ = \"Annulus\";\n    Annulus.init_Annulus();\n}\n","/* models/glyphs/arc.js */ function _(require, module, exports) {\n    const xy_glyph_1 = require(76) /* ./xy_glyph */;\n    const utils_1 = require(84) /* ./utils */;\n    const p = require(18) /* ../../core/properties */;\n    class ArcView extends xy_glyph_1.XYGlyphView {\n        _map_data() {\n            if (this.model.properties.radius.units == \"data\")\n                this.sradius = this.sdist(this.renderer.xscale, this._x, this._radius);\n            else\n                this.sradius = this._radius;\n        }\n        _render(ctx, indices, { sx, sy, sradius, _start_angle, _end_angle }) {\n            if (this.visuals.line.doit) {\n                const direction = this.model.properties.direction.value();\n                for (const i of indices) {\n                    if (isNaN(sx[i] + sy[i] + sradius[i] + _start_angle[i] + _end_angle[i]))\n                        continue;\n                    ctx.beginPath();\n                    ctx.arc(sx[i], sy[i], sradius[i], _start_angle[i], _end_angle[i], direction);\n                    this.visuals.line.set_vectorize(ctx, i);\n                    ctx.stroke();\n                }\n            }\n        }\n        draw_legend_for_index(ctx, bbox, index) {\n            utils_1.generic_line_legend(this.visuals, ctx, bbox, index);\n        }\n    }\n    exports.ArcView = ArcView;\n    ArcView.__name__ = \"ArcView\";\n    class Arc extends xy_glyph_1.XYGlyph {\n        constructor(attrs) {\n            super(attrs);\n        }\n        static init_Arc() {\n            this.prototype.default_view = ArcView;\n            this.mixins(['line']);\n            this.define({\n                direction: [p.Direction, 'anticlock'],\n                radius: [p.DistanceSpec],\n                start_angle: [p.AngleSpec],\n                end_angle: [p.AngleSpec],\n            });\n        }\n    }\n    exports.Arc = Arc;\n    Arc.__name__ = \"Arc\";\n    Arc.init_Arc();\n}\n","/* models/glyphs/bezier.js */ function _(require, module, exports) {\n    const spatial_1 = require(77) /* ../../core/util/spatial */;\n    const glyph_1 = require(80) /* ./glyph */;\n    const utils_1 = require(84) /* ./utils */;\n    // algorithm adapted from http://stackoverflow.com/a/14429749/3406693\n    function _cbb(x0, y0, x1, y1, x2, y2, x3, y3) {\n        const tvalues = [];\n        const bounds = [[], []];\n        for (let i = 0; i <= 2; i++) {\n            let a, b, c;\n            if (i === 0) {\n                b = ((6 * x0) - (12 * x1)) + (6 * x2);\n                a = (((-3 * x0) + (9 * x1)) - (9 * x2)) + (3 * x3);\n                c = (3 * x1) - (3 * x0);\n            }\n            else {\n                b = ((6 * y0) - (12 * y1)) + (6 * y2);\n                a = (((-3 * y0) + (9 * y1)) - (9 * y2)) + (3 * y3);\n                c = (3 * y1) - (3 * y0);\n            }\n            if (Math.abs(a) < 1e-12) { // Numerical robustness\n                if (Math.abs(b) < 1e-12) // Numerical robustness\n                    continue;\n                const t = -c / b;\n                if (0 < t && t < 1)\n                    tvalues.push(t);\n                continue;\n            }\n            const b2ac = (b * b) - (4 * c * a);\n            const sqrtb2ac = Math.sqrt(b2ac);\n            if (b2ac < 0)\n                continue;\n            const t1 = (-b + sqrtb2ac) / (2 * a);\n            if (0 < t1 && t1 < 1)\n                tvalues.push(t1);\n            const t2 = (-b - sqrtb2ac) / (2 * a);\n            if (0 < t2 && t2 < 1)\n                tvalues.push(t2);\n        }\n        let j = tvalues.length;\n        const jlen = j;\n        while (j--) {\n            const t = tvalues[j];\n            const mt = 1 - t;\n            const x = (mt * mt * mt * x0) + (3 * mt * mt * t * x1) + (3 * mt * t * t * x2) + (t * t * t * x3);\n            bounds[0][j] = x;\n            const y = (mt * mt * mt * y0) + (3 * mt * mt * t * y1) + (3 * mt * t * t * y2) + (t * t * t * y3);\n            bounds[1][j] = y;\n        }\n        bounds[0][jlen] = x0;\n        bounds[1][jlen] = y0;\n        bounds[0][jlen + 1] = x3;\n        bounds[1][jlen + 1] = y3;\n        return [\n            Math.min(...bounds[0]),\n            Math.max(...bounds[1]),\n            Math.max(...bounds[0]),\n            Math.min(...bounds[1]),\n        ];\n    }\n    class BezierView extends glyph_1.GlyphView {\n        _index_data() {\n            const points = [];\n            for (let i = 0, end = this._x0.length; i < end; i++) {\n                if (isNaN(this._x0[i] + this._x1[i] + this._y0[i] + this._y1[i] + this._cx0[i] + this._cy0[i] + this._cx1[i] + this._cy1[i]))\n                    continue;\n                const [x0, y0, x1, y1] = _cbb(this._x0[i], this._y0[i], this._x1[i], this._y1[i], this._cx0[i], this._cy0[i], this._cx1[i], this._cy1[i]);\n                points.push({ x0, y0, x1, y1, i });\n            }\n            return new spatial_1.SpatialIndex(points);\n        }\n        _render(ctx, indices, { sx0, sy0, sx1, sy1, scx0, scy0, scx1, scy1 }) {\n            if (this.visuals.line.doit) {\n                for (const i of indices) {\n                    if (isNaN(sx0[i] + sy0[i] + sx1[i] + sy1[i] + scx0[i] + scy0[i] + scx1[i] + scy1[i]))\n                        continue;\n                    ctx.beginPath();\n                    ctx.moveTo(sx0[i], sy0[i]);\n                    ctx.bezierCurveTo(scx0[i], scy0[i], scx1[i], scy1[i], sx1[i], sy1[i]);\n                    this.visuals.line.set_vectorize(ctx, i);\n                    ctx.stroke();\n                }\n            }\n        }\n        draw_legend_for_index(ctx, bbox, index) {\n            utils_1.generic_line_legend(this.visuals, ctx, bbox, index);\n        }\n        scenterx() {\n            throw new Error(\"not implemented\");\n        }\n        scentery() {\n            throw new Error(\"not implemented\");\n        }\n    }\n    exports.BezierView = BezierView;\n    BezierView.__name__ = \"BezierView\";\n    class Bezier extends glyph_1.Glyph {\n        constructor(attrs) {\n            super(attrs);\n        }\n        static init_Bezier() {\n            this.prototype.default_view = BezierView;\n            this.coords([['x0', 'y0'], ['x1', 'y1'], ['cx0', 'cy0'], ['cx1', 'cy1']]);\n            this.mixins(['line']);\n        }\n    }\n    exports.Bezier = Bezier;\n    Bezier.__name__ = \"Bezier\";\n    Bezier.init_Bezier();\n}\n","/* models/glyphs/circle.js */ function _(require, module, exports) {\n    const xy_glyph_1 = require(76) /* ./xy_glyph */;\n    const hittest = require(81) /* ../../core/hittest */;\n    const p = require(18) /* ../../core/properties */;\n    const array_1 = require(8) /* ../../core/util/array */;\n    const arrayable_1 = require(11) /* ../../core/util/arrayable */;\n    class CircleView extends xy_glyph_1.XYGlyphView {\n        _map_data() {\n            // XXX: Order is important here: size is always present (at least\n            // a default), but radius is only present if a user specifies it.\n            if (this._radius != null) {\n                if (this.model.properties.radius.spec.units == \"data\") {\n                    const rd = this.model.properties.radius_dimension.spec.value;\n                    switch (rd) {\n                        case \"x\": {\n                            this.sradius = this.sdist(this.renderer.xscale, this._x, this._radius);\n                            break;\n                        }\n                        case \"y\": {\n                            this.sradius = this.sdist(this.renderer.yscale, this._y, this._radius);\n                            break;\n                        }\n                        case \"max\": {\n                            const sradius_x = this.sdist(this.renderer.xscale, this._x, this._radius);\n                            const sradius_y = this.sdist(this.renderer.yscale, this._y, this._radius);\n                            this.sradius = arrayable_1.map(sradius_x, (s, i) => Math.max(s, sradius_y[i]));\n                            break;\n                        }\n                        case \"min\": {\n                            const sradius_x = this.sdist(this.renderer.xscale, this._x, this._radius);\n                            const sradius_y = this.sdist(this.renderer.yscale, this._y, this._radius);\n                            this.sradius = arrayable_1.map(sradius_x, (s, i) => Math.min(s, sradius_y[i]));\n                            break;\n                        }\n                    }\n                }\n                else {\n                    this.sradius = this._radius;\n                    this.max_size = 2 * this.max_radius;\n                }\n            }\n            else\n                this.sradius = arrayable_1.map(this._size, (s) => s / 2);\n        }\n        _mask_data() {\n            const [hr, vr] = this.renderer.plot_view.frame.bbox.ranges;\n            let x0, y0;\n            let x1, y1;\n            if (this._radius != null && this.model.properties.radius.units == \"data\") {\n                const sx0 = hr.start;\n                const sx1 = hr.end;\n                [x0, x1] = this.renderer.xscale.r_invert(sx0, sx1);\n                x0 -= this.max_radius;\n                x1 += this.max_radius;\n                const sy0 = vr.start;\n                const sy1 = vr.end;\n                [y0, y1] = this.renderer.yscale.r_invert(sy0, sy1);\n                y0 -= this.max_radius;\n                y1 += this.max_radius;\n            }\n            else {\n                const sx0 = hr.start - this.max_size;\n                const sx1 = hr.end + this.max_size;\n                [x0, x1] = this.renderer.xscale.r_invert(sx0, sx1);\n                const sy0 = vr.start - this.max_size;\n                const sy1 = vr.end + this.max_size;\n                [y0, y1] = this.renderer.yscale.r_invert(sy0, sy1);\n            }\n            return this.index.indices({ x0, x1, y0, y1 });\n        }\n        _render(ctx, indices, { sx, sy, sradius }) {\n            for (const i of indices) {\n                if (isNaN(sx[i] + sy[i] + sradius[i]))\n                    continue;\n                ctx.beginPath();\n                ctx.arc(sx[i], sy[i], sradius[i], 0, 2 * Math.PI, false);\n                if (this.visuals.fill.doit) {\n                    this.visuals.fill.set_vectorize(ctx, i);\n                    ctx.fill();\n                }\n                if (this.visuals.line.doit) {\n                    this.visuals.line.set_vectorize(ctx, i);\n                    ctx.stroke();\n                }\n            }\n        }\n        _hit_point(geometry) {\n            let dist, r2, sx0, sx1, sy0, sy1, x0, x1, y0, y1;\n            const { sx, sy } = geometry;\n            const x = this.renderer.xscale.invert(sx);\n            const y = this.renderer.yscale.invert(sy);\n            // check radius first\n            if ((this._radius != null) && (this.model.properties.radius.units == \"data\")) {\n                x0 = x - this.max_radius;\n                x1 = x + this.max_radius;\n                y0 = y - this.max_radius;\n                y1 = y + this.max_radius;\n            }\n            else {\n                sx0 = sx - this.max_size;\n                sx1 = sx + this.max_size;\n                [x0, x1] = this.renderer.xscale.r_invert(sx0, sx1);\n                [x0, x1] = [Math.min(x0, x1), Math.max(x0, x1)];\n                sy0 = sy - this.max_size;\n                sy1 = sy + this.max_size;\n                [y0, y1] = this.renderer.yscale.r_invert(sy0, sy1);\n                [y0, y1] = [Math.min(y0, y1), Math.max(y0, y1)];\n            }\n            const candidates = this.index.indices({ x0, x1, y0, y1 });\n            const hits = [];\n            if ((this._radius != null) && (this.model.properties.radius.units == \"data\")) {\n                for (const i of candidates) {\n                    r2 = Math.pow(this.sradius[i], 2);\n                    [sx0, sx1] = this.renderer.xscale.r_compute(x, this._x[i]);\n                    [sy0, sy1] = this.renderer.yscale.r_compute(y, this._y[i]);\n                    dist = Math.pow(sx0 - sx1, 2) + Math.pow(sy0 - sy1, 2);\n                    if (dist <= r2) {\n                        hits.push([i, dist]);\n                    }\n                }\n            }\n            else {\n                for (const i of candidates) {\n                    r2 = Math.pow(this.sradius[i], 2);\n                    dist = Math.pow(this.sx[i] - sx, 2) + Math.pow(this.sy[i] - sy, 2);\n                    if (dist <= r2) {\n                        hits.push([i, dist]);\n                    }\n                }\n            }\n            return hittest.create_hit_test_result_from_hits(hits);\n        }\n        _hit_span(geometry) {\n            const { sx, sy } = geometry;\n            const bounds = this.bounds();\n            const result = hittest.create_empty_hit_test_result();\n            let x0, x1, y0, y1;\n            if (geometry.direction == 'h') {\n                // use circle bounds instead of current pointer y coordinates\n                let sx0, sx1;\n                y0 = bounds.y0;\n                y1 = bounds.y1;\n                if (this._radius != null && this.model.properties.radius.units == \"data\") {\n                    sx0 = sx - this.max_radius;\n                    sx1 = sx + this.max_radius;\n                    [x0, x1] = this.renderer.xscale.r_invert(sx0, sx1);\n                }\n                else {\n                    const ms = this.max_size / 2;\n                    sx0 = sx - ms;\n                    sx1 = sx + ms;\n                    [x0, x1] = this.renderer.xscale.r_invert(sx0, sx1);\n                }\n            }\n            else {\n                // use circle bounds instead of current pointer x coordinates\n                let sy0, sy1;\n                x0 = bounds.x0;\n                x1 = bounds.x1;\n                if (this._radius != null && this.model.properties.radius.units == \"data\") {\n                    sy0 = sy - this.max_radius;\n                    sy1 = sy + this.max_radius;\n                    [y0, y1] = this.renderer.yscale.r_invert(sy0, sy1);\n                }\n                else {\n                    const ms = this.max_size / 2;\n                    sy0 = sy - ms;\n                    sy1 = sy + ms;\n                    [y0, y1] = this.renderer.yscale.r_invert(sy0, sy1);\n                }\n            }\n            const hits = this.index.indices({ x0, x1, y0, y1 });\n            result.indices = hits;\n            return result;\n        }\n        _hit_rect(geometry) {\n            const { sx0, sx1, sy0, sy1 } = geometry;\n            const [x0, x1] = this.renderer.xscale.r_invert(sx0, sx1);\n            const [y0, y1] = this.renderer.yscale.r_invert(sy0, sy1);\n            const result = hittest.create_empty_hit_test_result();\n            result.indices = this.index.indices({ x0, x1, y0, y1 });\n            return result;\n        }\n        _hit_poly(geometry) {\n            const { sx, sy } = geometry;\n            // TODO (bev) use spatial index to pare candidate list\n            const candidates = array_1.range(0, this.sx.length);\n            const hits = [];\n            for (let i = 0, end = candidates.length; i < end; i++) {\n                const idx = candidates[i];\n                if (hittest.point_in_poly(this.sx[i], this.sy[i], sx, sy)) {\n                    hits.push(idx);\n                }\n            }\n            const result = hittest.create_empty_hit_test_result();\n            result.indices = hits;\n            return result;\n        }\n        // circle does not inherit from marker (since it also accepts radius) so we\n        // must supply a draw_legend for it  here\n        draw_legend_for_index(ctx, { x0, y0, x1, y1 }, index) {\n            // using objects like this seems a little wonky, since the keys are coerced to\n            // stings, but it works\n            const len = index + 1;\n            const sx = new Array(len);\n            sx[index] = (x0 + x1) / 2;\n            const sy = new Array(len);\n            sy[index] = (y0 + y1) / 2;\n            const sradius = new Array(len);\n            sradius[index] = Math.min(Math.abs(x1 - x0), Math.abs(y1 - y0)) * 0.2;\n            this._render(ctx, [index], { sx, sy, sradius }); // XXX\n        }\n    }\n    exports.CircleView = CircleView;\n    CircleView.__name__ = \"CircleView\";\n    class Circle extends xy_glyph_1.XYGlyph {\n        constructor(attrs) {\n            super(attrs);\n        }\n        static init_Circle() {\n            this.prototype.default_view = CircleView;\n            this.mixins(['line', 'fill']);\n            this.define({\n                angle: [p.AngleSpec, 0],\n                size: [p.DistanceSpec, { units: \"screen\", value: 4 }],\n                radius: [p.DistanceSpec],\n                radius_dimension: [p.RadiusDimension, 'x'],\n            });\n        }\n        initialize() {\n            super.initialize();\n            this.properties.radius.optional = true;\n        }\n    }\n    exports.Circle = Circle;\n    Circle.__name__ = \"Circle\";\n    Circle.init_Circle();\n}\n","/* models/glyphs/center_rotatable.js */ function _(require, module, exports) {\n    const xy_glyph_1 = require(76) /* ./xy_glyph */;\n    const p = require(18) /* ../../core/properties */;\n    class CenterRotatableView extends xy_glyph_1.XYGlyphView {\n    }\n    exports.CenterRotatableView = CenterRotatableView;\n    CenterRotatableView.__name__ = \"CenterRotatableView\";\n    class CenterRotatable extends xy_glyph_1.XYGlyph {\n        constructor(attrs) {\n            super(attrs);\n        }\n        static init_CenterRotatable() {\n            this.mixins(['line', 'fill']);\n            this.define({\n                angle: [p.AngleSpec, 0],\n                width: [p.DistanceSpec],\n                height: [p.DistanceSpec],\n            });\n        }\n    }\n    exports.CenterRotatable = CenterRotatable;\n    CenterRotatable.__name__ = \"CenterRotatable\";\n    CenterRotatable.init_CenterRotatable();\n}\n","/* models/glyphs/ellipse.js */ function _(require, module, exports) {\n    const ellipse_oval_1 = require(208) /* ./ellipse_oval */;\n    class EllipseView extends ellipse_oval_1.EllipseOvalView {\n    }\n    exports.EllipseView = EllipseView;\n    EllipseView.__name__ = \"EllipseView\";\n    class Ellipse extends ellipse_oval_1.EllipseOval {\n        constructor(attrs) {\n            super(attrs);\n        }\n        static init_Ellipse() {\n            this.prototype.default_view = EllipseView;\n        }\n    }\n    exports.Ellipse = Ellipse;\n    Ellipse.__name__ = \"Ellipse\";\n    Ellipse.init_Ellipse();\n}\n","/* models/glyphs/ellipse_oval.js */ function _(require, module, exports) {\n    const center_rotatable_1 = require(206) /* ./center_rotatable */;\n    const hittest = require(81) /* ../../core/hittest */;\n    class EllipseOvalView extends center_rotatable_1.CenterRotatableView {\n        _set_data() {\n            this.max_w2 = 0;\n            if (this.model.properties.width.units == \"data\")\n                this.max_w2 = this.max_width / 2;\n            this.max_h2 = 0;\n            if (this.model.properties.height.units == \"data\")\n                this.max_h2 = this.max_height / 2;\n        }\n        _map_data() {\n            if (this.model.properties.width.units == \"data\")\n                this.sw = this.sdist(this.renderer.xscale, this._x, this._width, 'center');\n            else\n                this.sw = this._width;\n            if (this.model.properties.height.units == \"data\")\n                this.sh = this.sdist(this.renderer.yscale, this._y, this._height, 'center');\n            else\n                this.sh = this._height;\n        }\n        _render(ctx, indices, { sx, sy, sw, sh, _angle }) {\n            for (const i of indices) {\n                if (isNaN(sx[i] + sy[i] + sw[i] + sh[i] + _angle[i]))\n                    continue;\n                ctx.beginPath();\n                ctx.ellipse(sx[i], sy[i], sw[i] / 2.0, sh[i] / 2.0, _angle[i], 0, 2 * Math.PI);\n                if (this.visuals.fill.doit) {\n                    this.visuals.fill.set_vectorize(ctx, i);\n                    ctx.fill();\n                }\n                if (this.visuals.line.doit) {\n                    this.visuals.line.set_vectorize(ctx, i);\n                    ctx.stroke();\n                }\n            }\n        }\n        _hit_point(geometry) {\n            let x0, x1, y0, y1, cond, dist, sx0, sx1, sy0, sy1;\n            const { sx, sy } = geometry;\n            const x = this.renderer.xscale.invert(sx);\n            const y = this.renderer.yscale.invert(sy);\n            if (this.model.properties.width.units == \"data\") {\n                x0 = x - this.max_width;\n                x1 = x + this.max_width;\n            }\n            else {\n                sx0 = sx - this.max_width;\n                sx1 = sx + this.max_width;\n                [x0, x1] = this.renderer.xscale.r_invert(sx0, sx1);\n            }\n            if (this.model.properties.height.units == \"data\") {\n                y0 = y - this.max_height;\n                y1 = y + this.max_height;\n            }\n            else {\n                sy0 = sy - this.max_height;\n                sy1 = sy + this.max_height;\n                [y0, y1] = this.renderer.yscale.r_invert(sy0, sy1);\n            }\n            const candidates = this.index.indices({ x0, x1, y0, y1 });\n            const hits = [];\n            for (const i of candidates) {\n                cond = hittest.point_in_ellipse(sx, sy, this._angle[i], this.sh[i] / 2, this.sw[i] / 2, this.sx[i], this.sy[i]);\n                if (cond) {\n                    [sx0, sx1] = this.renderer.xscale.r_compute(x, this._x[i]);\n                    [sy0, sy1] = this.renderer.yscale.r_compute(y, this._y[i]);\n                    dist = Math.pow(sx0 - sx1, 2) + Math.pow(sy0 - sy1, 2);\n                    hits.push([i, dist]);\n                }\n            }\n            return hittest.create_hit_test_result_from_hits(hits);\n        }\n        draw_legend_for_index(ctx, { x0, y0, x1, y1 }, index) {\n            const len = index + 1;\n            const sx = new Array(len);\n            sx[index] = (x0 + x1) / 2;\n            const sy = new Array(len);\n            sy[index] = (y0 + y1) / 2;\n            const scale = this.sw[index] / this.sh[index];\n            const d = Math.min(Math.abs(x1 - x0), Math.abs(y1 - y0)) * 0.8;\n            const sw = new Array(len);\n            const sh = new Array(len);\n            if (scale > 1) {\n                sw[index] = d;\n                sh[index] = d / scale;\n            }\n            else {\n                sw[index] = d * scale;\n                sh[index] = d;\n            }\n            this._render(ctx, [index], { sx, sy, sw, sh, _angle: [0] }); // XXX\n        }\n        _bounds({ x0, x1, y0, y1 }) {\n            return {\n                x0: x0 - this.max_w2,\n                x1: x1 + this.max_w2,\n                y0: y0 - this.max_h2,\n                y1: y1 + this.max_h2,\n            };\n        }\n    }\n    exports.EllipseOvalView = EllipseOvalView;\n    EllipseOvalView.__name__ = \"EllipseOvalView\";\n    class EllipseOval extends center_rotatable_1.CenterRotatable {\n        constructor(attrs) {\n            super(attrs);\n        }\n    }\n    exports.EllipseOval = EllipseOval;\n    EllipseOval.__name__ = \"EllipseOval\";\n}\n","/* models/glyphs/hbar.js */ function _(require, module, exports) {\n    const box_1 = require(210) /* ./box */;\n    const p = require(18) /* ../../core/properties */;\n    class HBarView extends box_1.BoxView {\n        scenterx(i) {\n            return (this.sleft[i] + this.sright[i]) / 2;\n        }\n        scentery(i) {\n            return this.sy[i];\n        }\n        _index_data() {\n            return this._index_box(this._y.length);\n        }\n        _lrtb(i) {\n            const l = Math.min(this._left[i], this._right[i]);\n            const r = Math.max(this._left[i], this._right[i]);\n            const t = this._y[i] + 0.5 * this._height[i];\n            const b = this._y[i] - 0.5 * this._height[i];\n            return [l, r, t, b];\n        }\n        _map_data() {\n            this.sy = this.renderer.yscale.v_compute(this._y);\n            this.sh = this.sdist(this.renderer.yscale, this._y, this._height, \"center\");\n            this.sleft = this.renderer.xscale.v_compute(this._left);\n            this.sright = this.renderer.xscale.v_compute(this._right);\n            const n = this.sy.length;\n            this.stop = new Float64Array(n);\n            this.sbottom = new Float64Array(n);\n            for (let i = 0; i < n; i++) {\n                this.stop[i] = this.sy[i] - this.sh[i] / 2;\n                this.sbottom[i] = this.sy[i] + this.sh[i] / 2;\n            }\n            this._clamp_viewport();\n        }\n    }\n    exports.HBarView = HBarView;\n    HBarView.__name__ = \"HBarView\";\n    class HBar extends box_1.Box {\n        constructor(attrs) {\n            super(attrs);\n        }\n        static init_HBar() {\n            this.prototype.default_view = HBarView;\n            this.coords([['left', 'y']]);\n            this.define({\n                height: [p.NumberSpec],\n                right: [p.CoordinateSpec],\n            });\n            this.override({ left: 0 });\n        }\n    }\n    exports.HBar = HBar;\n    HBar.__name__ = \"HBar\";\n    HBar.init_HBar();\n}\n","/* models/glyphs/box.js */ function _(require, module, exports) {\n    const spatial_1 = require(77) /* ../../core/util/spatial */;\n    const glyph_1 = require(80) /* ./glyph */;\n    const utils_1 = require(84) /* ./utils */;\n    const hittest = require(81) /* ../../core/hittest */;\n    class BoxView extends glyph_1.GlyphView {\n        get_anchor_point(anchor, i, _spt) {\n            const left = Math.min(this.sleft[i], this.sright[i]);\n            const right = Math.max(this.sright[i], this.sleft[i]);\n            const top = Math.min(this.stop[i], this.sbottom[i]); // screen coordinates !!!\n            const bottom = Math.max(this.sbottom[i], this.stop[i]); //\n            switch (anchor) {\n                case \"top_left\": return { x: left, y: top };\n                case \"top_center\": return { x: (left + right) / 2, y: top };\n                case \"top_right\": return { x: right, y: top };\n                case \"bottom_left\": return { x: left, y: bottom };\n                case \"bottom_center\": return { x: (left + right) / 2, y: bottom };\n                case \"bottom_right\": return { x: right, y: bottom };\n                case \"center_left\": return { x: left, y: (top + bottom) / 2 };\n                case \"center\": return { x: (left + right) / 2, y: (top + bottom) / 2 };\n                case \"center_right\": return { x: right, y: (top + bottom) / 2 };\n                default: return null;\n            }\n        }\n        _index_box(len) {\n            const points = [];\n            for (let i = 0; i < len; i++) {\n                const [l, r, t, b] = this._lrtb(i);\n                if (isNaN(l + r + t + b) || !isFinite(l + r + t + b))\n                    continue;\n                points.push({\n                    x0: Math.min(l, r),\n                    y0: Math.min(t, b),\n                    x1: Math.max(r, l),\n                    y1: Math.max(t, b),\n                    i,\n                });\n            }\n            return new spatial_1.SpatialIndex(points);\n        }\n        _render(ctx, indices, { sleft, sright, stop, sbottom }) {\n            for (const i of indices) {\n                if (isNaN(sleft[i] + stop[i] + sright[i] + sbottom[i]))\n                    continue;\n                ctx.rect(sleft[i], stop[i], sright[i] - sleft[i], sbottom[i] - stop[i]);\n                if (this.visuals.fill.doit) {\n                    this.visuals.fill.set_vectorize(ctx, i);\n                    ctx.beginPath();\n                    ctx.rect(sleft[i], stop[i], sright[i] - sleft[i], sbottom[i] - stop[i]);\n                    ctx.fill();\n                }\n                this.visuals.hatch.doit2(ctx, i, () => {\n                    ctx.beginPath();\n                    ctx.rect(sleft[i], stop[i], sright[i] - sleft[i], sbottom[i] - stop[i]);\n                    ctx.fill();\n                }, () => this.renderer.request_render());\n                if (this.visuals.line.doit) {\n                    this.visuals.line.set_vectorize(ctx, i);\n                    ctx.beginPath();\n                    ctx.rect(sleft[i], stop[i], sright[i] - sleft[i], sbottom[i] - stop[i]);\n                    ctx.stroke();\n                }\n            }\n        }\n        // We need to clamp the endpoints inside the viewport, because various browser canvas\n        // implementations have issues drawing rects with enpoints far outside the viewport\n        _clamp_viewport() {\n            const hr = this.renderer.plot_view.frame.bbox.h_range;\n            const vr = this.renderer.plot_view.frame.bbox.v_range;\n            const n = this.stop.length;\n            for (let i = 0; i < n; i++) {\n                this.stop[i] = Math.max(this.stop[i], vr.start);\n                this.sbottom[i] = Math.min(this.sbottom[i], vr.end);\n                this.sleft[i] = Math.max(this.sleft[i], hr.start);\n                this.sright[i] = Math.min(this.sright[i], hr.end);\n            }\n        }\n        _hit_rect(geometry) {\n            return this._hit_rect_against_index(geometry);\n        }\n        _hit_point(geometry) {\n            const { sx, sy } = geometry;\n            const x = this.renderer.xscale.invert(sx);\n            const y = this.renderer.yscale.invert(sy);\n            const hits = this.index.indices({ x0: x, y0: y, x1: x, y1: y });\n            const result = hittest.create_empty_hit_test_result();\n            result.indices = hits;\n            return result;\n        }\n        _hit_span(geometry) {\n            const { sx, sy } = geometry;\n            let hits;\n            if (geometry.direction == 'v') {\n                const y = this.renderer.yscale.invert(sy);\n                const hr = this.renderer.plot_view.frame.bbox.h_range;\n                const [x0, x1] = this.renderer.xscale.r_invert(hr.start, hr.end);\n                hits = this.index.indices({ x0, y0: y, x1, y1: y });\n            }\n            else {\n                const x = this.renderer.xscale.invert(sx);\n                const vr = this.renderer.plot_view.frame.bbox.v_range;\n                const [y0, y1] = this.renderer.yscale.r_invert(vr.start, vr.end);\n                hits = this.index.indices({ x0: x, y0, x1: x, y1 });\n            }\n            const result = hittest.create_empty_hit_test_result();\n            result.indices = hits;\n            return result;\n        }\n        draw_legend_for_index(ctx, bbox, index) {\n            utils_1.generic_area_legend(this.visuals, ctx, bbox, index);\n        }\n    }\n    exports.BoxView = BoxView;\n    BoxView.__name__ = \"BoxView\";\n    class Box extends glyph_1.Glyph {\n        constructor(attrs) {\n            super(attrs);\n        }\n        static init_Box() {\n            this.mixins(['line', 'fill', 'hatch']);\n        }\n    }\n    exports.Box = Box;\n    Box.__name__ = \"Box\";\n    Box.init_Box();\n}\n","/* models/glyphs/hex_tile.js */ function _(require, module, exports) {\n    const glyph_1 = require(80) /* ./glyph */;\n    const hittest = require(81) /* ../../core/hittest */;\n    const p = require(18) /* ../../core/properties */;\n    const spatial_1 = require(77) /* ../../core/util/spatial */;\n    const utils_1 = require(84) /* ./utils */;\n    class HexTileView extends glyph_1.GlyphView {\n        scenterx(i) { return this.sx[i]; }\n        scentery(i) { return this.sy[i]; }\n        _set_data() {\n            const n = this._q.length;\n            const size = this.model.size;\n            const aspect_scale = this.model.aspect_scale;\n            this._x = new Float64Array(n);\n            this._y = new Float64Array(n);\n            if (this.model.orientation == \"pointytop\") {\n                for (let i = 0; i < n; i++) {\n                    this._x[i] = size * Math.sqrt(3) * (this._q[i] + this._r[i] / 2) / aspect_scale;\n                    this._y[i] = -size * 3 / 2 * this._r[i];\n                }\n            }\n            else {\n                for (let i = 0; i < n; i++) {\n                    this._x[i] = size * 3 / 2 * this._q[i];\n                    this._y[i] = -size * Math.sqrt(3) * (this._r[i] + this._q[i] / 2) * aspect_scale;\n                }\n            }\n        }\n        _index_data() {\n            let ysize = this.model.size;\n            let xsize = Math.sqrt(3) * ysize / 2;\n            if (this.model.orientation == \"flattop\") {\n                [xsize, ysize] = [ysize, xsize];\n                ysize *= this.model.aspect_scale;\n            }\n            else\n                xsize /= this.model.aspect_scale;\n            const points = [];\n            for (let i = 0; i < this._x.length; i++) {\n                const x = this._x[i];\n                const y = this._y[i];\n                if (isNaN(x + y) || !isFinite(x + y))\n                    continue;\n                points.push({ x0: x - xsize, y0: y - ysize, x1: x + xsize, y1: y + ysize, i });\n            }\n            return new spatial_1.SpatialIndex(points);\n        }\n        // overriding map_data instead of _map_data because the default automatic mappings\n        // for other glyphs (with cartesian coordinates) is not useful\n        map_data() {\n            [this.sx, this.sy] = this.map_to_screen(this._x, this._y);\n            [this.svx, this.svy] = this._get_unscaled_vertices();\n        }\n        _get_unscaled_vertices() {\n            const size = this.model.size;\n            const aspect_scale = this.model.aspect_scale;\n            if (this.model.orientation == \"pointytop\") {\n                const rscale = this.renderer.yscale;\n                const hscale = this.renderer.xscale;\n                const r = Math.abs(rscale.compute(0) - rscale.compute(size)); // assumes linear scale\n                const h = Math.sqrt(3) / 2 * Math.abs(hscale.compute(0) - hscale.compute(size)) / aspect_scale; // assumes linear scale\n                const r2 = r / 2.0;\n                const svx = [0, -h, -h, 0, h, h];\n                const svy = [r, r2, -r2, -r, -r2, r2];\n                return [svx, svy];\n            }\n            else {\n                const rscale = this.renderer.xscale;\n                const hscale = this.renderer.yscale;\n                const r = Math.abs(rscale.compute(0) - rscale.compute(size)); // assumes linear scale\n                const h = Math.sqrt(3) / 2 * Math.abs(hscale.compute(0) - hscale.compute(size)) * aspect_scale; // assumes linear scale\n                const r2 = r / 2.0;\n                const svx = [r, r2, -r2, -r, -r2, r2];\n                const svy = [0, -h, -h, 0, h, h];\n                return [svx, svy];\n            }\n        }\n        _render(ctx, indices, { sx, sy, svx, svy, _scale }) {\n            for (const i of indices) {\n                if (isNaN(sx[i] + sy[i] + _scale[i]))\n                    continue;\n                ctx.translate(sx[i], sy[i]);\n                ctx.beginPath();\n                for (let j = 0; j < 6; j++) {\n                    ctx.lineTo(svx[j] * _scale[i], svy[j] * _scale[i]);\n                }\n                ctx.closePath();\n                ctx.translate(-sx[i], -sy[i]);\n                if (this.visuals.fill.doit) {\n                    this.visuals.fill.set_vectorize(ctx, i);\n                    ctx.fill();\n                }\n                if (this.visuals.line.doit) {\n                    this.visuals.line.set_vectorize(ctx, i);\n                    ctx.stroke();\n                }\n            }\n        }\n        _hit_point(geometry) {\n            const { sx, sy } = geometry;\n            const x = this.renderer.xscale.invert(sx);\n            const y = this.renderer.yscale.invert(sy);\n            const candidates = this.index.indices({ x0: x, y0: y, x1: x, y1: y });\n            const hits = [];\n            for (const i of candidates) {\n                if (hittest.point_in_poly(sx - this.sx[i], sy - this.sy[i], this.svx, this.svy)) {\n                    hits.push(i);\n                }\n            }\n            const result = hittest.create_empty_hit_test_result();\n            result.indices = hits;\n            return result;\n        }\n        _hit_span(geometry) {\n            const { sx, sy } = geometry;\n            let hits;\n            if (geometry.direction == 'v') {\n                const y = this.renderer.yscale.invert(sy);\n                const hr = this.renderer.plot_view.frame.bbox.h_range;\n                const [x0, x1] = this.renderer.xscale.r_invert(hr.start, hr.end);\n                hits = this.index.indices({ x0, y0: y, x1, y1: y });\n            }\n            else {\n                const x = this.renderer.xscale.invert(sx);\n                const vr = this.renderer.plot_view.frame.bbox.v_range;\n                const [y0, y1] = this.renderer.yscale.r_invert(vr.start, vr.end);\n                hits = this.index.indices({ x0: x, y0, x1: x, y1 });\n            }\n            const result = hittest.create_empty_hit_test_result();\n            result.indices = hits;\n            return result;\n        }\n        _hit_rect(geometry) {\n            const { sx0, sx1, sy0, sy1 } = geometry;\n            const [x0, x1] = this.renderer.xscale.r_invert(sx0, sx1);\n            const [y0, y1] = this.renderer.yscale.r_invert(sy0, sy1);\n            const result = hittest.create_empty_hit_test_result();\n            result.indices = this.index.indices({ x0, x1, y0, y1 });\n            return result;\n        }\n        draw_legend_for_index(ctx, bbox, index) {\n            utils_1.generic_area_legend(this.visuals, ctx, bbox, index);\n        }\n    }\n    exports.HexTileView = HexTileView;\n    HexTileView.__name__ = \"HexTileView\";\n    class HexTile extends glyph_1.Glyph {\n        constructor(attrs) {\n            super(attrs);\n        }\n        static init_HexTile() {\n            this.prototype.default_view = HexTileView;\n            this.coords([['r', 'q']]);\n            this.mixins(['line', 'fill']);\n            this.define({\n                size: [p.Number, 1.0],\n                aspect_scale: [p.Number, 1.0],\n                scale: [p.NumberSpec, 1.0],\n                orientation: [p.HexTileOrientation, \"pointytop\"],\n            });\n            this.override({ line_color: null });\n        }\n    }\n    exports.HexTile = HexTile;\n    HexTile.__name__ = \"HexTile\";\n    HexTile.init_HexTile();\n}\n","/* models/glyphs/image.js */ function _(require, module, exports) {\n    const image_base_1 = require(213) /* ./image_base */;\n    const linear_color_mapper_1 = require(108) /* ../mappers/linear_color_mapper */;\n    const p = require(18) /* ../../core/properties */;\n    const array_1 = require(8) /* ../../core/util/array */;\n    class ImageView extends image_base_1.ImageBaseView {\n        initialize() {\n            super.initialize();\n            this.connect(this.model.color_mapper.change, () => this._update_image());\n            this.connect(this.model.properties.global_alpha.change, () => this.renderer.request_render());\n        }\n        _update_image() {\n            // Only reset image_data if already initialized\n            if (this.image_data != null) {\n                this._set_data();\n                this.renderer.plot_view.request_render();\n            }\n        }\n        _set_data() {\n            this._set_width_heigh_data();\n            const cmap = this.model.color_mapper.rgba_mapper;\n            for (let i = 0, end = this._image.length; i < end; i++) {\n                let img;\n                if (this._image_shape != null && this._image_shape[i].length > 0) {\n                    img = this._image[i];\n                    const shape = this._image_shape[i];\n                    this._height[i] = shape[0];\n                    this._width[i] = shape[1];\n                }\n                else {\n                    const _image = this._image[i];\n                    img = array_1.concat(_image);\n                    this._height[i] = _image.length;\n                    this._width[i] = _image[0].length;\n                }\n                const buf8 = cmap.v_compute(img);\n                this._set_image_data_from_buffer(i, buf8);\n            }\n        }\n        _render(ctx, indices, { image_data, sx, sy, sw, sh }) {\n            const old_smoothing = ctx.getImageSmoothingEnabled();\n            ctx.setImageSmoothingEnabled(false);\n            ctx.globalAlpha = this.model.global_alpha;\n            for (const i of indices) {\n                if (image_data[i] == null)\n                    continue;\n                if (isNaN(sx[i] + sy[i] + sw[i] + sh[i]))\n                    continue;\n                const y_offset = sy[i];\n                ctx.translate(0, y_offset);\n                ctx.scale(1, -1);\n                ctx.translate(0, -y_offset);\n                ctx.drawImage(image_data[i], sx[i] | 0, sy[i] | 0, sw[i], sh[i]);\n                ctx.translate(0, y_offset);\n                ctx.scale(1, -1);\n                ctx.translate(0, -y_offset);\n            }\n            ctx.setImageSmoothingEnabled(old_smoothing);\n        }\n    }\n    exports.ImageView = ImageView;\n    ImageView.__name__ = \"ImageView\";\n    // NOTE: this needs to be redefined here, because palettes are located in bokeh-api.js bundle\n    const Greys9 = () => [\"#000000\", \"#252525\", \"#525252\", \"#737373\", \"#969696\", \"#bdbdbd\", \"#d9d9d9\", \"#f0f0f0\", \"#ffffff\"];\n    class Image extends image_base_1.ImageBase {\n        constructor(attrs) {\n            super(attrs);\n        }\n        static init_Image() {\n            this.prototype.default_view = ImageView;\n            this.define({\n                color_mapper: [p.Instance, () => new linear_color_mapper_1.LinearColorMapper({ palette: Greys9() })],\n            });\n        }\n    }\n    exports.Image = Image;\n    Image.__name__ = \"Image\";\n    Image.init_Image();\n}\n","/* models/glyphs/image_base.js */ function _(require, module, exports) {\n    const xy_glyph_1 = require(76) /* ./xy_glyph */;\n    const p = require(18) /* ../../core/properties */;\n    const hittest = require(81) /* ../../core/hittest */;\n    const spatial_1 = require(77) /* ../../core/util/spatial */;\n    class ImageBaseView extends xy_glyph_1.XYGlyphView {\n        _render(_ctx, _indices, _data) { }\n        _index_data() {\n            const points = [];\n            for (let i = 0, end = this._x.length; i < end; i++) {\n                const [l, r, t, b] = this._lrtb(i);\n                if (isNaN(l + r + t + b) || !isFinite(l + r + t + b)) {\n                    continue;\n                }\n                points.push({ x0: l, y0: b, x1: r, y1: t, i });\n            }\n            return new spatial_1.SpatialIndex(points);\n        }\n        _lrtb(i) {\n            const xr = this.renderer.xscale.source_range;\n            const x1 = this._x[i];\n            const x2 = xr.is_reversed ? x1 - this._dw[i] : x1 + this._dw[i];\n            const yr = this.renderer.yscale.source_range;\n            const y1 = this._y[i];\n            const y2 = yr.is_reversed ? y1 - this._dh[i] : y1 + this._dh[i];\n            const [l, r] = x1 < x2 ? [x1, x2] : [x2, x1];\n            const [b, t] = y1 < y2 ? [y1, y2] : [y2, y1];\n            return [l, r, t, b];\n        }\n        _set_width_heigh_data() {\n            if (this.image_data == null || this.image_data.length != this._image.length)\n                this.image_data = new Array(this._image.length);\n            if (this._width == null || this._width.length != this._image.length)\n                this._width = new Array(this._image.length);\n            if (this._height == null || this._height.length != this._image.length)\n                this._height = new Array(this._image.length);\n        }\n        _get_or_create_canvas(i) {\n            const _image_data = this.image_data[i];\n            if (_image_data != null && _image_data.width == this._width[i] &&\n                _image_data.height == this._height[i])\n                return _image_data;\n            else {\n                const canvas = document.createElement('canvas');\n                canvas.width = this._width[i];\n                canvas.height = this._height[i];\n                return canvas;\n            }\n        }\n        _set_image_data_from_buffer(i, buf8) {\n            const canvas = this._get_or_create_canvas(i);\n            const ctx = canvas.getContext('2d');\n            const image_data = ctx.getImageData(0, 0, this._width[i], this._height[i]);\n            image_data.data.set(buf8);\n            ctx.putImageData(image_data, 0, 0);\n            this.image_data[i] = canvas;\n        }\n        _map_data() {\n            switch (this.model.properties.dw.units) {\n                case \"data\": {\n                    this.sw = this.sdist(this.renderer.xscale, this._x, this._dw, 'edge', this.model.dilate);\n                    break;\n                }\n                case \"screen\": {\n                    this.sw = this._dw;\n                    break;\n                }\n            }\n            switch (this.model.properties.dh.units) {\n                case \"data\": {\n                    this.sh = this.sdist(this.renderer.yscale, this._y, this._dh, 'edge', this.model.dilate);\n                    break;\n                }\n                case \"screen\": {\n                    this.sh = this._dh;\n                    break;\n                }\n            }\n        }\n        _image_index(index, x, y) {\n            const [l, r, t, b] = this._lrtb(index);\n            const width = this._width[index];\n            const height = this._height[index];\n            const dx = (r - l) / width;\n            const dy = (t - b) / height;\n            let dim1 = Math.floor((x - l) / dx);\n            let dim2 = Math.floor((y - b) / dy);\n            if (this.renderer.xscale.source_range.is_reversed)\n                dim1 = width - dim1 - 1;\n            if (this.renderer.yscale.source_range.is_reversed)\n                dim2 = height - dim2 - 1;\n            return { index, dim1, dim2, flat_index: dim2 * width + dim1 };\n        }\n        _hit_point(geometry) {\n            const { sx, sy } = geometry;\n            const x = this.renderer.xscale.invert(sx);\n            const y = this.renderer.yscale.invert(sy);\n            const candidates = this.index.indices({ x0: x, x1: x, y0: y, y1: y });\n            const result = hittest.create_empty_hit_test_result();\n            result.image_indices = [];\n            for (const index of candidates) {\n                if ((sx != Infinity) && (sy != Infinity)) {\n                    result.image_indices.push(this._image_index(index, x, y));\n                }\n            }\n            return result;\n        }\n    }\n    exports.ImageBaseView = ImageBaseView;\n    ImageBaseView.__name__ = \"ImageBaseView\";\n    class ImageBase extends xy_glyph_1.XYGlyph {\n        constructor(attrs) {\n            super(attrs);\n        }\n        static init_ImageBase() {\n            this.prototype.default_view = ImageBaseView;\n            this.define({\n                image: [p.NumberSpec],\n                dw: [p.DistanceSpec],\n                dh: [p.DistanceSpec],\n                dilate: [p.Boolean, false],\n                global_alpha: [p.Number, 1.0],\n            });\n        }\n    }\n    exports.ImageBase = ImageBase;\n    ImageBase.__name__ = \"ImageBase\";\n    ImageBase.init_ImageBase();\n}\n","/* models/glyphs/image_rgba.js */ function _(require, module, exports) {\n    const image_base_1 = require(213) /* ./image_base */;\n    const array_1 = require(8) /* ../../core/util/array */;\n    class ImageRGBAView extends image_base_1.ImageBaseView {\n        initialize() {\n            super.initialize();\n            this.connect(this.model.properties.global_alpha.change, () => this.renderer.request_render());\n        }\n        _set_data(indices) {\n            this._set_width_heigh_data();\n            for (let i = 0, end = this._image.length; i < end; i++) {\n                if (indices != null && indices.indexOf(i) < 0)\n                    continue;\n                let buf;\n                if (this._image_shape != null && this._image_shape[i].length > 0) {\n                    buf = this._image[i].buffer;\n                    const shape = this._image_shape[i];\n                    this._height[i] = shape[0];\n                    this._width[i] = shape[1];\n                }\n                else {\n                    const _image = this._image[i];\n                    const flat = array_1.concat(_image);\n                    buf = new ArrayBuffer(flat.length * 4);\n                    const color = new Uint32Array(buf);\n                    for (let j = 0, endj = flat.length; j < endj; j++) {\n                        color[j] = flat[j];\n                    }\n                    this._height[i] = _image.length;\n                    this._width[i] = _image[0].length;\n                }\n                const buf8 = new Uint8Array(buf);\n                this._set_image_data_from_buffer(i, buf8);\n            }\n        }\n        _render(ctx, indices, { image_data, sx, sy, sw, sh }) {\n            const old_smoothing = ctx.getImageSmoothingEnabled();\n            ctx.setImageSmoothingEnabled(false);\n            ctx.globalAlpha = this.model.global_alpha;\n            for (const i of indices) {\n                if (isNaN(sx[i] + sy[i] + sw[i] + sh[i]))\n                    continue;\n                const y_offset = sy[i];\n                ctx.translate(0, y_offset);\n                ctx.scale(1, -1);\n                ctx.translate(0, -y_offset);\n                ctx.drawImage(image_data[i], sx[i] | 0, sy[i] | 0, sw[i], sh[i]);\n                ctx.translate(0, y_offset);\n                ctx.scale(1, -1);\n                ctx.translate(0, -y_offset);\n            }\n            ctx.setImageSmoothingEnabled(old_smoothing);\n        }\n    }\n    exports.ImageRGBAView = ImageRGBAView;\n    ImageRGBAView.__name__ = \"ImageRGBAView\";\n    class ImageRGBA extends image_base_1.ImageBase {\n        constructor(attrs) {\n            super(attrs);\n        }\n        static init_ImageRGBA() {\n            this.prototype.default_view = ImageRGBAView;\n        }\n    }\n    exports.ImageRGBA = ImageRGBA;\n    ImageRGBA.__name__ = \"ImageRGBA\";\n    ImageRGBA.init_ImageRGBA();\n}\n","/* models/glyphs/image_url.js */ function _(require, module, exports) {\n    const xy_glyph_1 = require(76) /* ./xy_glyph */;\n    const p = require(18) /* ../../core/properties */;\n    const arrayable_1 = require(11) /* ../../core/util/arrayable */;\n    const spatial_1 = require(77) /* ../../core/util/spatial */;\n    const image_1 = require(216) /* ../../core/util/image */;\n    class ImageURLView extends xy_glyph_1.XYGlyphView {\n        constructor() {\n            super(...arguments);\n            this._images_rendered = false;\n        }\n        initialize() {\n            super.initialize();\n            this.connect(this.model.properties.global_alpha.change, () => this.renderer.request_render());\n        }\n        _index_data() {\n            return new spatial_1.SpatialIndex([]);\n        }\n        _set_data() {\n            if (this.image == null || this.image.length != this._url.length)\n                this.image = arrayable_1.map(this._url, () => null);\n            const { retry_attempts, retry_timeout } = this.model;\n            for (let i = 0, end = this._url.length; i < end; i++) {\n                const url = this._url[i];\n                if (url == null || url == \"\")\n                    continue;\n                new image_1.ImageLoader(url, {\n                    loaded: (image) => {\n                        this.image[i] = image;\n                        this.renderer.request_render();\n                    },\n                    attempts: retry_attempts + 1,\n                    timeout: retry_timeout,\n                });\n            }\n            const w_data = this.model.properties.w.units == \"data\";\n            const h_data = this.model.properties.h.units == \"data\";\n            const n = this._x.length;\n            const xs = new Array(w_data ? 2 * n : n);\n            const ys = new Array(h_data ? 2 * n : n);\n            for (let i = 0; i < n; i++) {\n                xs[i] = this._x[i];\n                ys[i] = this._y[i];\n            }\n            // if the width/height are in screen units, don't try to include them in bounds\n            if (w_data) {\n                for (let i = 0; i < n; i++)\n                    xs[n + i] = this._x[i] + this._w[i];\n            }\n            if (h_data) {\n                for (let i = 0; i < n; i++)\n                    ys[n + i] = this._y[i] + this._h[i];\n            }\n            const x0 = arrayable_1.min(xs);\n            const x1 = arrayable_1.max(xs);\n            const y0 = arrayable_1.min(ys);\n            const y1 = arrayable_1.max(ys);\n            this._bounds_rect = { x0, x1, y0, y1 };\n        }\n        has_finished() {\n            return super.has_finished() && this._images_rendered == true;\n        }\n        _map_data() {\n            // Better to check this.model.w and this.model.h for null since the set_data\n            // machinery will have converted this._w and this._w to lists of null\n            const ws = this.model.w != null ? this._w : arrayable_1.map(this._x, () => NaN);\n            const hs = this.model.h != null ? this._h : arrayable_1.map(this._x, () => NaN);\n            switch (this.model.properties.w.units) {\n                case \"data\": {\n                    this.sw = this.sdist(this.renderer.xscale, this._x, ws, \"edge\", this.model.dilate);\n                    break;\n                }\n                case \"screen\": {\n                    this.sw = ws;\n                    break;\n                }\n            }\n            switch (this.model.properties.h.units) {\n                case \"data\": {\n                    this.sh = this.sdist(this.renderer.yscale, this._y, hs, \"edge\", this.model.dilate);\n                    break;\n                }\n                case \"screen\": {\n                    this.sh = hs;\n                    break;\n                }\n            }\n        }\n        _render(ctx, indices, { image, sx, sy, sw, sh, _angle }) {\n            // TODO (bev): take actual border width into account when clipping\n            const { frame } = this.renderer.plot_view;\n            ctx.rect(frame._left.value + 1, frame._top.value + 1, frame._width.value - 2, frame._height.value - 2);\n            ctx.clip();\n            let finished = true;\n            for (const i of indices) {\n                if (isNaN(sx[i] + sy[i] + _angle[i]))\n                    continue;\n                const img = image[i];\n                if (img == null) {\n                    finished = false;\n                    continue;\n                }\n                this._render_image(ctx, i, img, sx, sy, sw, sh, _angle);\n            }\n            if (finished && !this._images_rendered) {\n                this._images_rendered = true;\n                this.notify_finished();\n            }\n        }\n        _final_sx_sy(anchor, sx, sy, sw, sh) {\n            switch (anchor) {\n                case 'top_left': return [sx, sy];\n                case 'top_center': return [sx - (sw / 2), sy];\n                case 'top_right': return [sx - sw, sy];\n                case 'center_right': return [sx - sw, sy - (sh / 2)];\n                case 'bottom_right': return [sx - sw, sy - sh];\n                case 'bottom_center': return [sx - (sw / 2), sy - sh];\n                case 'bottom_left': return [sx, sy - sh];\n                case 'center_left': return [sx, sy - (sh / 2)];\n                case 'center': return [sx - (sw / 2), sy - (sh / 2)];\n            }\n        }\n        _render_image(ctx, i, image, sx, sy, sw, sh, angle) {\n            if (isNaN(sw[i]))\n                sw[i] = image.width;\n            if (isNaN(sh[i]))\n                sh[i] = image.height;\n            const { anchor } = this.model;\n            const [sxi, syi] = this._final_sx_sy(anchor, sx[i], sy[i], sw[i], sh[i]);\n            ctx.save();\n            ctx.globalAlpha = this.model.global_alpha;\n            if (angle[i]) {\n                ctx.translate(sxi, syi);\n                ctx.rotate(angle[i]);\n                ctx.drawImage(image, 0, 0, sw[i], sh[i]);\n                ctx.rotate(-angle[i]);\n                ctx.translate(-sxi, -syi);\n            }\n            else\n                ctx.drawImage(image, sxi, syi, sw[i], sh[i]);\n            ctx.restore();\n        }\n        bounds() {\n            return this._bounds_rect;\n        }\n    }\n    exports.ImageURLView = ImageURLView;\n    ImageURLView.__name__ = \"ImageURLView\";\n    class ImageURL extends xy_glyph_1.XYGlyph {\n        constructor(attrs) {\n            super(attrs);\n        }\n        static init_ImageURL() {\n            this.prototype.default_view = ImageURLView;\n            this.define({\n                url: [p.StringSpec],\n                anchor: [p.Anchor, 'top_left'],\n                global_alpha: [p.Number, 1.0],\n                angle: [p.AngleSpec, 0],\n                w: [p.DistanceSpec],\n                h: [p.DistanceSpec],\n                dilate: [p.Boolean, false],\n                retry_attempts: [p.Number, 0],\n                retry_timeout: [p.Number, 0],\n            });\n        }\n    }\n    exports.ImageURL = ImageURL;\n    ImageURL.__name__ = \"ImageURL\";\n    ImageURL.init_ImageURL();\n}\n","/* core/util/image.js */ function _(require, module, exports) {\n    const logging_1 = require(65) /* ../logging */;\n    class ImageLoader {\n        constructor(url, options = {}) {\n            this._image = new Image();\n            this._finished = false;\n            const { attempts = 1, timeout = 1 } = options;\n            this.promise = new Promise((resolve, _reject) => {\n                this._image.crossOrigin = \"anonymous\";\n                let retries = 0;\n                this._image.onerror = () => {\n                    if (++retries == attempts) {\n                        const message = `unable to load ${url} image after ${attempts} attempts`;\n                        logging_1.logger.warn(message);\n                        if (this._image.crossOrigin != null) {\n                            logging_1.logger.warn(`attempting to load ${url} without a cross origin policy`);\n                            this._image.crossOrigin = null;\n                            retries = 0;\n                        }\n                        else {\n                            if (options.failed != null)\n                                options.failed();\n                            // reject(new Error(message))\n                        }\n                    }\n                    setTimeout(() => this._image.src = url, timeout);\n                };\n                this._image.onload = () => {\n                    this._finished = true;\n                    if (options.loaded != null)\n                        options.loaded(this._image);\n                    resolve(this._image);\n                };\n                this._image.src = url;\n            });\n        }\n        get finished() {\n            return this._finished;\n        }\n        get image() {\n            return this._image;\n        }\n    }\n    exports.ImageLoader = ImageLoader;\n    ImageLoader.__name__ = \"ImageLoader\";\n}\n","/* models/glyphs/multi_line.js */ function _(require, module, exports) {\n    const spatial_1 = require(77) /* ../../core/util/spatial */;\n    const hittest = require(81) /* ../../core/hittest */;\n    const object_1 = require(22) /* ../../core/util/object */;\n    const array_1 = require(8) /* ../../core/util/array */;\n    const types_1 = require(7) /* ../../core/util/types */;\n    const glyph_1 = require(80) /* ./glyph */;\n    const utils_1 = require(84) /* ./utils */;\n    class MultiLineView extends glyph_1.GlyphView {\n        _index_data() {\n            const points = [];\n            for (let i = 0, end = this._xs.length; i < end; i++) {\n                if (this._xs[i] == null || this._xs[i].length === 0)\n                    continue;\n                const _xsi = this._xs[i];\n                const xs = [];\n                for (let j = 0, n = _xsi.length; j < n; j++) {\n                    const x = _xsi[j];\n                    if (!types_1.isStrictNaN(x))\n                        xs.push(x);\n                }\n                const _ysi = this._ys[i];\n                const ys = [];\n                for (let j = 0, n = _ysi.length; j < n; j++) {\n                    const y = _ysi[j];\n                    if (!types_1.isStrictNaN(y))\n                        ys.push(y);\n                }\n                const [x0, x1] = [array_1.min(xs), array_1.max(xs)];\n                const [y0, y1] = [array_1.min(ys), array_1.max(ys)];\n                points.push({ x0, y0, x1, y1, i });\n            }\n            return new spatial_1.SpatialIndex(points);\n        }\n        _render(ctx, indices, { sxs, sys }) {\n            for (const i of indices) {\n                const [sx, sy] = [sxs[i], sys[i]];\n                this.visuals.line.set_vectorize(ctx, i);\n                for (let j = 0, end = sx.length; j < end; j++) {\n                    if (j == 0) {\n                        ctx.beginPath();\n                        ctx.moveTo(sx[j], sy[j]);\n                        continue;\n                    }\n                    else if (isNaN(sx[j]) || isNaN(sy[j])) {\n                        ctx.stroke();\n                        ctx.beginPath();\n                        continue;\n                    }\n                    else\n                        ctx.lineTo(sx[j], sy[j]);\n                }\n                ctx.stroke();\n            }\n        }\n        _hit_point(geometry) {\n            const result = hittest.create_empty_hit_test_result();\n            const point = { x: geometry.sx, y: geometry.sy };\n            let shortest = 9999;\n            const hits = {};\n            for (let i = 0, end = this.sxs.length; i < end; i++) {\n                const threshold = Math.max(2, this.visuals.line.cache_select('line_width', i) / 2);\n                let points = null;\n                for (let j = 0, endj = this.sxs[i].length - 1; j < endj; j++) {\n                    const p0 = { x: this.sxs[i][j], y: this.sys[i][j] };\n                    const p1 = { x: this.sxs[i][j + 1], y: this.sys[i][j + 1] };\n                    const dist = hittest.dist_to_segment(point, p0, p1);\n                    if (dist < threshold && dist < shortest) {\n                        shortest = dist;\n                        points = [j];\n                    }\n                }\n                if (points)\n                    hits[i] = points;\n            }\n            result.indices = object_1.keys(hits).map((x) => parseInt(x, 10));\n            result.multiline_indices = hits;\n            return result;\n        }\n        _hit_span(geometry) {\n            const { sx, sy } = geometry;\n            const result = hittest.create_empty_hit_test_result();\n            let val;\n            let values;\n            if (geometry.direction === 'v') {\n                val = this.renderer.yscale.invert(sy);\n                values = this._ys;\n            }\n            else {\n                val = this.renderer.xscale.invert(sx);\n                values = this._xs;\n            }\n            const hits = {};\n            for (let i = 0, end = values.length; i < end; i++) {\n                const points = [];\n                for (let j = 0, endj = values[i].length - 1; j < endj; j++) {\n                    if (values[i][j] <= val && val <= values[i][j + 1])\n                        points.push(j);\n                }\n                if (points.length > 0)\n                    hits[i] = points;\n            }\n            result.indices = object_1.keys(hits).map((x) => parseInt(x, 10));\n            result.multiline_indices = hits;\n            return result;\n        }\n        get_interpolation_hit(i, point_i, geometry) {\n            const [x2, y2, x3, y3] = [this._xs[i][point_i], this._ys[i][point_i], this._xs[i][point_i + 1], this._ys[i][point_i + 1]];\n            return utils_1.line_interpolation(this.renderer, geometry, x2, y2, x3, y3);\n        }\n        draw_legend_for_index(ctx, bbox, index) {\n            utils_1.generic_line_legend(this.visuals, ctx, bbox, index);\n        }\n        scenterx() {\n            throw new Error(\"not implemented\");\n        }\n        scentery() {\n            throw new Error(\"not implemented\");\n        }\n    }\n    exports.MultiLineView = MultiLineView;\n    MultiLineView.__name__ = \"MultiLineView\";\n    class MultiLine extends glyph_1.Glyph {\n        constructor(attrs) {\n            super(attrs);\n        }\n        static init_MultiLine() {\n            this.prototype.default_view = MultiLineView;\n            this.coords([['xs', 'ys']]);\n            this.mixins(['line']);\n        }\n    }\n    exports.MultiLine = MultiLine;\n    MultiLine.__name__ = \"MultiLine\";\n    MultiLine.init_MultiLine();\n}\n","/* models/glyphs/multi_polygons.js */ function _(require, module, exports) {\n    const spatial_1 = require(77) /* ../../core/util/spatial */;\n    const glyph_1 = require(80) /* ./glyph */;\n    const utils_1 = require(84) /* ./utils */;\n    const array_1 = require(8) /* ../../core/util/array */;\n    const arrayable_1 = require(11) /* ../../core/util/arrayable */;\n    const hittest = require(81) /* ../../core/hittest */;\n    const types_1 = require(7) /* ../../core/util/types */;\n    class MultiPolygonsView extends glyph_1.GlyphView {\n        _index_data() {\n            const points = [];\n            for (let i = 0, end = this._xs.length; i < end; i++) {\n                for (let j = 0, endj = this._xs[i].length; j < endj; j++) {\n                    const xs = this._xs[i][j][0]; // do not use holes\n                    const ys = this._ys[i][j][0]; // do not use holes\n                    if (xs.length == 0)\n                        continue;\n                    points.push({ x0: array_1.min(xs), y0: array_1.min(ys), x1: array_1.max(xs), y1: array_1.max(ys), i });\n                }\n            }\n            this.hole_index = this._index_hole_data(); // should this be set here?\n            return new spatial_1.SpatialIndex(points);\n        }\n        _index_hole_data() {\n            // need advice on how to use this sure if this could be more useful\n            const points = [];\n            for (let i = 0, end = this._xs.length; i < end; i++) {\n                for (let j = 0, endj = this._xs[i].length; j < endj; j++) {\n                    if (this._xs[i][j].length > 1) {\n                        for (let k = 1, endk = this._xs[i][j].length; k < endk; k++) {\n                            const xs = this._xs[i][j][k]; // only use holes\n                            const ys = this._ys[i][j][k]; // only use holes\n                            if (xs.length == 0)\n                                continue;\n                            points.push({ x0: array_1.min(xs), y0: array_1.min(ys), x1: array_1.max(xs), y1: array_1.max(ys), i });\n                        }\n                    }\n                }\n            }\n            return new spatial_1.SpatialIndex(points);\n        }\n        _mask_data() {\n            const xr = this.renderer.plot_view.frame.x_ranges.default;\n            const [x0, x1] = [xr.min, xr.max];\n            const yr = this.renderer.plot_view.frame.y_ranges.default;\n            const [y0, y1] = [yr.min, yr.max];\n            const indices = this.index.indices({ x0, x1, y0, y1 });\n            // TODO this is probably needed in patches as well so that we don't draw glyphs multiple times\n            return indices.sort((a, b) => a - b).filter((value, index, array) => {\n                return (index === 0) || (value !== array[index - 1]);\n            });\n        }\n        _inner_loop(ctx, sx, sy) {\n            ctx.beginPath();\n            for (let j = 0, endj = sx.length; j < endj; j++) {\n                for (let k = 0, endk = sx[j].length; k < endk; k++) {\n                    const _sx = sx[j][k];\n                    const _sy = sy[j][k];\n                    for (let l = 0, endl = _sx.length; l < endl; l++) {\n                        if (l == 0) {\n                            ctx.moveTo(_sx[l], _sy[l]);\n                            continue;\n                        }\n                        else\n                            ctx.lineTo(_sx[l], _sy[l]);\n                    }\n                    ctx.closePath();\n                }\n            }\n        }\n        _render(ctx, indices, { sxs, sys }) {\n            if (this.visuals.fill.doit || this.visuals.line.doit) {\n                for (const i of indices) {\n                    const [sx, sy] = [sxs[i], sys[i]];\n                    if (this.visuals.fill.doit) {\n                        this.visuals.fill.set_vectorize(ctx, i);\n                        this._inner_loop(ctx, sx, sy);\n                        ctx.fill(\"evenodd\");\n                    }\n                    this.visuals.hatch.doit2(ctx, i, () => {\n                        this._inner_loop(ctx, sx, sy);\n                        ctx.fill(\"evenodd\");\n                    }, () => this.renderer.request_render());\n                    if (this.visuals.line.doit) {\n                        this.visuals.line.set_vectorize(ctx, i);\n                        this._inner_loop(ctx, sx, sy);\n                        ctx.stroke();\n                    }\n                }\n            }\n        }\n        _hit_point(geometry) {\n            const { sx, sy } = geometry;\n            const x = this.renderer.xscale.invert(sx);\n            const y = this.renderer.yscale.invert(sy);\n            const candidates = this.index.indices({ x0: x, y0: y, x1: x, y1: y });\n            const hole_candidates = this.hole_index.indices({ x0: x, y0: y, x1: x, y1: y });\n            const hits = [];\n            for (let i = 0, end = candidates.length; i < end; i++) {\n                const idx = candidates[i];\n                const sxs = this.sxs[idx];\n                const sys = this.sys[idx];\n                for (let j = 0, endj = sxs.length; j < endj; j++) {\n                    const nk = sxs[j].length;\n                    if (hittest.point_in_poly(sx, sy, sxs[j][0], sys[j][0])) {\n                        if (nk == 1) {\n                            hits.push(idx);\n                        }\n                        else if (hole_candidates.indexOf(idx) == -1) {\n                            hits.push(idx);\n                        }\n                        else if (nk > 1) {\n                            let in_a_hole = false;\n                            for (let k = 1; k < nk; k++) {\n                                const sxs_k = sxs[j][k];\n                                const sys_k = sys[j][k];\n                                if (hittest.point_in_poly(sx, sy, sxs_k, sys_k)) {\n                                    in_a_hole = true;\n                                    break;\n                                }\n                                else {\n                                    continue;\n                                }\n                            }\n                            if (!in_a_hole) {\n                                hits.push(idx);\n                            }\n                        }\n                    }\n                }\n            }\n            const result = hittest.create_empty_hit_test_result();\n            result.indices = hits;\n            return result;\n        }\n        _get_snap_coord(array) {\n            return arrayable_1.sum(array) / array.length;\n        }\n        scenterx(i, sx, sy) {\n            if (this.sxs[i].length == 1) {\n                // We don't have discontinuous objects so we're ok\n                return this._get_snap_coord(this.sxs[i][0][0]);\n            }\n            else {\n                // We have discontinuous objects, so we need to find which\n                // one we're in, we can use point_in_poly again\n                const sxs = this.sxs[i];\n                const sys = this.sys[i];\n                for (let j = 0, end = sxs.length; j < end; j++) {\n                    if (hittest.point_in_poly(sx, sy, sxs[j][0], sys[j][0]))\n                        return this._get_snap_coord(sxs[j][0]);\n                }\n            }\n            throw new Error(\"unreachable code\");\n        }\n        scentery(i, sx, sy) {\n            if (this.sys[i].length == 1) {\n                // We don't have discontinuous objects so we're ok\n                return this._get_snap_coord(this.sys[i][0][0]);\n            }\n            else {\n                // We have discontinuous objects, so we need to find which\n                // one we're in, we can use point_in_poly again\n                const sxs = this.sxs[i];\n                const sys = this.sys[i];\n                for (let j = 0, end = sxs.length; j < end; j++) {\n                    if (hittest.point_in_poly(sx, sy, sxs[j][0], sys[j][0]))\n                        return this._get_snap_coord(sys[j][0]);\n                }\n            }\n            throw new Error(\"unreachable code\");\n        }\n        map_data() {\n            const self = this;\n            for (let [xname, yname] of this.model._coords) {\n                const sxname = `s${xname}`;\n                const syname = `s${yname}`;\n                xname = `_${xname}`;\n                yname = `_${yname}`;\n                if (self[xname] != null && (types_1.isArray(self[xname][0]) || types_1.isTypedArray(self[xname][0]))) {\n                    const ni = self[xname].length;\n                    self[sxname] = new Array(ni);\n                    self[syname] = new Array(ni);\n                    for (let i = 0; i < ni; i++) {\n                        const nj = self[xname][i].length;\n                        self[sxname][i] = new Array(nj);\n                        self[syname][i] = new Array(nj);\n                        for (let j = 0; j < nj; j++) {\n                            const nk = self[xname][i][j].length;\n                            self[sxname][i][j] = new Array(nk);\n                            self[syname][i][j] = new Array(nk);\n                            for (let k = 0; k < nk; k++) {\n                                const [sx, sy] = this.map_to_screen(self[xname][i][j][k], self[yname][i][j][k]);\n                                self[sxname][i][j][k] = sx;\n                                self[syname][i][j][k] = sy;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        draw_legend_for_index(ctx, bbox, index) {\n            utils_1.generic_area_legend(this.visuals, ctx, bbox, index);\n        }\n    }\n    exports.MultiPolygonsView = MultiPolygonsView;\n    MultiPolygonsView.__name__ = \"MultiPolygonsView\";\n    class MultiPolygons extends glyph_1.Glyph {\n        constructor(attrs) {\n            super(attrs);\n        }\n        static init_MultiPolygons() {\n            this.prototype.default_view = MultiPolygonsView;\n            this.coords([['xs', 'ys']]);\n            this.mixins(['line', 'fill', 'hatch']);\n        }\n    }\n    exports.MultiPolygons = MultiPolygons;\n    MultiPolygons.__name__ = \"MultiPolygons\";\n    MultiPolygons.init_MultiPolygons();\n}\n","/* models/glyphs/oval.js */ function _(require, module, exports) {\n    const ellipse_oval_1 = require(208) /* ./ellipse_oval */;\n    class OvalView extends ellipse_oval_1.EllipseOvalView {\n        _map_data() {\n            let sw;\n            const n = this._x.length;\n            this.sw = new Float64Array(n);\n            if (this.model.properties.width.units == \"data\")\n                sw = this.sdist(this.renderer.xscale, this._x, this._width, 'center');\n            else\n                sw = this._width;\n            // oval drawn from bezier curves = ellipse with width reduced by 3/4\n            for (let i = 0; i < n; i++)\n                this.sw[i] = sw[i] * 0.75;\n            if (this.model.properties.height.units == \"data\")\n                this.sh = this.sdist(this.renderer.yscale, this._y, this._height, 'center');\n            else\n                this.sh = this._height;\n        }\n    }\n    exports.OvalView = OvalView;\n    OvalView.__name__ = \"OvalView\";\n    class Oval extends ellipse_oval_1.EllipseOval {\n        constructor(attrs) {\n            super(attrs);\n        }\n        static init_Oval() {\n            this.prototype.default_view = OvalView;\n        }\n    }\n    exports.Oval = Oval;\n    Oval.__name__ = \"Oval\";\n    Oval.init_Oval();\n}\n","/* models/glyphs/patches.js */ function _(require, module, exports) {\n    const spatial_1 = require(77) /* ../../core/util/spatial */;\n    const glyph_1 = require(80) /* ./glyph */;\n    const utils_1 = require(84) /* ./utils */;\n    const array_1 = require(8) /* ../../core/util/array */;\n    const arrayable_1 = require(11) /* ../../core/util/arrayable */;\n    const types_1 = require(7) /* ../../core/util/types */;\n    const hittest = require(81) /* ../../core/hittest */;\n    class PatchesView extends glyph_1.GlyphView {\n        _build_discontinuous_object(nanned_qs) {\n            // _s is this.xs, this.ys, this.sxs, this.sys\n            // an object of n 1-d arrays in either data or screen units\n            //\n            // Each 1-d array gets broken to an array of arrays split\n            // on any NaNs\n            //\n            // So:\n            // { 0: [x11, x12],\n            //   1: [x21, x22, x23],\n            //   2: [x31, NaN, x32]\n            // }\n            // becomes\n            // { 0: [[x11, x12]],\n            //   1: [[x21, x22, x23]],\n            //   2: [[x31],[x32]]\n            // }\n            const ds = [];\n            for (let i = 0, end = nanned_qs.length; i < end; i++) {\n                ds[i] = [];\n                let qs = array_1.copy(nanned_qs[i]);\n                while (qs.length > 0) {\n                    const nan_index = array_1.find_last_index(qs, (q) => types_1.isStrictNaN(q));\n                    let qs_part;\n                    if (nan_index >= 0)\n                        qs_part = qs.splice(nan_index);\n                    else {\n                        qs_part = qs;\n                        qs = [];\n                    }\n                    const denanned = qs_part.filter((q) => !types_1.isStrictNaN(q));\n                    ds[i].push(denanned);\n                }\n            }\n            return ds;\n        }\n        _index_data() {\n            const xss = this._build_discontinuous_object(this._xs); // XXX\n            const yss = this._build_discontinuous_object(this._ys); // XXX\n            const points = [];\n            for (let i = 0, end = this._xs.length; i < end; i++) {\n                for (let j = 0, endj = xss[i].length; j < endj; j++) {\n                    const xs = xss[i][j];\n                    const ys = yss[i][j];\n                    if (xs.length == 0)\n                        continue;\n                    points.push({ x0: array_1.min(xs), y0: array_1.min(ys), x1: array_1.max(xs), y1: array_1.max(ys), i });\n                }\n            }\n            return new spatial_1.SpatialIndex(points);\n        }\n        _mask_data() {\n            const xr = this.renderer.plot_view.frame.x_ranges.default;\n            const [x0, x1] = [xr.min, xr.max];\n            const yr = this.renderer.plot_view.frame.y_ranges.default;\n            const [y0, y1] = [yr.min, yr.max];\n            const indices = this.index.indices({ x0, x1, y0, y1 });\n            // TODO (bev) this should be under test\n            return indices.sort((a, b) => a - b);\n        }\n        _inner_loop(ctx, sx, sy, func) {\n            for (let j = 0, end = sx.length; j < end; j++) {\n                if (j == 0) {\n                    ctx.beginPath();\n                    ctx.moveTo(sx[j], sy[j]);\n                    continue;\n                }\n                else if (isNaN(sx[j] + sy[j])) {\n                    ctx.closePath();\n                    func.apply(ctx);\n                    ctx.beginPath();\n                    continue;\n                }\n                else\n                    ctx.lineTo(sx[j], sy[j]);\n            }\n            ctx.closePath();\n            func.call(ctx);\n        }\n        _render(ctx, indices, { sxs, sys }) {\n            // this.sxss and this.syss are used by _hit_point and sxc, syc\n            // This is the earliest we can build them, and only build them once\n            this.sxss = this._build_discontinuous_object(sxs); // XXX\n            this.syss = this._build_discontinuous_object(sys); // XXX\n            for (const i of indices) {\n                const [sx, sy] = [sxs[i], sys[i]];\n                if (this.visuals.fill.doit) {\n                    this.visuals.fill.set_vectorize(ctx, i);\n                    this._inner_loop(ctx, sx, sy, ctx.fill);\n                }\n                this.visuals.hatch.doit2(ctx, i, () => this._inner_loop(ctx, sx, sy, ctx.fill), () => this.renderer.request_render());\n                if (this.visuals.line.doit) {\n                    this.visuals.line.set_vectorize(ctx, i);\n                    this._inner_loop(ctx, sx, sy, ctx.stroke);\n                }\n            }\n        }\n        _hit_point(geometry) {\n            const { sx, sy } = geometry;\n            const x = this.renderer.xscale.invert(sx);\n            const y = this.renderer.yscale.invert(sy);\n            const candidates = this.index.indices({ x0: x, y0: y, x1: x, y1: y });\n            const hits = [];\n            for (let i = 0, end = candidates.length; i < end; i++) {\n                const idx = candidates[i];\n                const sxs = this.sxss[idx];\n                const sys = this.syss[idx];\n                for (let j = 0, endj = sxs.length; j < endj; j++) {\n                    if (hittest.point_in_poly(sx, sy, sxs[j], sys[j])) {\n                        hits.push(idx);\n                    }\n                }\n            }\n            const result = hittest.create_empty_hit_test_result();\n            result.indices = hits;\n            return result;\n        }\n        _get_snap_coord(array) {\n            return arrayable_1.sum(array) / array.length;\n        }\n        scenterx(i, sx, sy) {\n            if (this.sxss[i].length == 1) {\n                // We don't have discontinuous objects so we're ok\n                return this._get_snap_coord(this.sxs[i]);\n            }\n            else {\n                // We have discontinuous objects, so we need to find which\n                // one we're in, we can use point_in_poly again\n                const sxs = this.sxss[i];\n                const sys = this.syss[i];\n                for (let j = 0, end = sxs.length; j < end; j++) {\n                    if (hittest.point_in_poly(sx, sy, sxs[j], sys[j]))\n                        return this._get_snap_coord(sxs[j]);\n                }\n            }\n            throw new Error(\"unreachable code\");\n        }\n        scentery(i, sx, sy) {\n            if (this.syss[i].length == 1) {\n                // We don't have discontinuous objects so we're ok\n                return this._get_snap_coord(this.sys[i]);\n            }\n            else {\n                // We have discontinuous objects, so we need to find which\n                // one we're in, we can use point_in_poly again\n                const sxs = this.sxss[i];\n                const sys = this.syss[i];\n                for (let j = 0, end = sxs.length; j < end; j++) {\n                    if (hittest.point_in_poly(sx, sy, sxs[j], sys[j]))\n                        return this._get_snap_coord(sys[j]);\n                }\n            }\n            throw new Error(\"unreachable code\");\n        }\n        draw_legend_for_index(ctx, bbox, index) {\n            utils_1.generic_area_legend(this.visuals, ctx, bbox, index);\n        }\n    }\n    exports.PatchesView = PatchesView;\n    PatchesView.__name__ = \"PatchesView\";\n    class Patches extends glyph_1.Glyph {\n        constructor(attrs) {\n            super(attrs);\n        }\n        static init_Patches() {\n            this.prototype.default_view = PatchesView;\n            this.coords([['xs', 'ys']]);\n            this.mixins(['line', 'fill', 'hatch']);\n        }\n    }\n    exports.Patches = Patches;\n    Patches.__name__ = \"Patches\";\n    Patches.init_Patches();\n}\n","/* models/glyphs/quad.js */ function _(require, module, exports) {\n    const box_1 = require(210) /* ./box */;\n    class QuadView extends box_1.BoxView {\n        scenterx(i) {\n            return (this.sleft[i] + this.sright[i]) / 2;\n        }\n        scentery(i) {\n            return (this.stop[i] + this.sbottom[i]) / 2;\n        }\n        _index_data() {\n            return this._index_box(this._right.length);\n        }\n        _lrtb(i) {\n            const l = this._left[i];\n            const r = this._right[i];\n            const t = this._top[i];\n            const b = this._bottom[i];\n            return [l, r, t, b];\n        }\n    }\n    exports.QuadView = QuadView;\n    QuadView.__name__ = \"QuadView\";\n    class Quad extends box_1.Box {\n        constructor(attrs) {\n            super(attrs);\n        }\n        static init_Quad() {\n            this.prototype.default_view = QuadView;\n            this.coords([['right', 'bottom'], ['left', 'top']]);\n        }\n    }\n    exports.Quad = Quad;\n    Quad.__name__ = \"Quad\";\n    Quad.init_Quad();\n}\n","/* models/glyphs/quadratic.js */ function _(require, module, exports) {\n    const spatial_1 = require(77) /* ../../core/util/spatial */;\n    const glyph_1 = require(80) /* ./glyph */;\n    const utils_1 = require(84) /* ./utils */;\n    // Formula from: http://pomax.nihongoresources.com/pages/bezier/\n    //\n    // if segment is quadratic bezier do:\n    //   for both directions do:\n    //     if control between start and end, compute linear bounding box\n    //     otherwise, compute\n    //       bound = u(1-t)^2 + 2v(1-t)t + wt^2\n    //         (with t = ((u-v) / (u-2v+w)), with {u = start, v = control, w = end})\n    //       if control precedes start, min = bound, otherwise max = bound\n    function _qbb(u, v, w) {\n        if (v == (u + w) / 2)\n            return [u, w];\n        else {\n            const t = (u - v) / ((u - (2 * v)) + w);\n            const bd = (u * Math.pow((1 - t), 2)) + (2 * v * (1 - t) * t) + (w * Math.pow(t, 2));\n            return [Math.min(u, w, bd), Math.max(u, w, bd)];\n        }\n    }\n    class QuadraticView extends glyph_1.GlyphView {\n        _index_data() {\n            const points = [];\n            for (let i = 0, end = this._x0.length; i < end; i++) {\n                if (isNaN(this._x0[i] + this._x1[i] + this._y0[i] + this._y1[i] + this._cx[i] + this._cy[i]))\n                    continue;\n                const [x0, x1] = _qbb(this._x0[i], this._cx[i], this._x1[i]);\n                const [y0, y1] = _qbb(this._y0[i], this._cy[i], this._y1[i]);\n                points.push({ x0, y0, x1, y1, i });\n            }\n            return new spatial_1.SpatialIndex(points);\n        }\n        _render(ctx, indices, { sx0, sy0, sx1, sy1, scx, scy }) {\n            if (this.visuals.line.doit) {\n                for (const i of indices) {\n                    if (isNaN(sx0[i] + sy0[i] + sx1[i] + sy1[i] + scx[i] + scy[i]))\n                        continue;\n                    ctx.beginPath();\n                    ctx.moveTo(sx0[i], sy0[i]);\n                    ctx.quadraticCurveTo(scx[i], scy[i], sx1[i], sy1[i]);\n                    this.visuals.line.set_vectorize(ctx, i);\n                    ctx.stroke();\n                }\n            }\n        }\n        draw_legend_for_index(ctx, bbox, index) {\n            utils_1.generic_line_legend(this.visuals, ctx, bbox, index);\n        }\n        scenterx() {\n            throw new Error(\"not implemented\");\n        }\n        scentery() {\n            throw new Error(\"not implemented\");\n        }\n    }\n    exports.QuadraticView = QuadraticView;\n    QuadraticView.__name__ = \"QuadraticView\";\n    class Quadratic extends glyph_1.Glyph {\n        constructor(attrs) {\n            super(attrs);\n        }\n        static init_Quadratic() {\n            this.prototype.default_view = QuadraticView;\n            this.coords([['x0', 'y0'], ['x1', 'y1'], ['cx', 'cy']]);\n            this.mixins(['line']);\n        }\n    }\n    exports.Quadratic = Quadratic;\n    Quadratic.__name__ = \"Quadratic\";\n    Quadratic.init_Quadratic();\n}\n","/* models/glyphs/ray.js */ function _(require, module, exports) {\n    const xy_glyph_1 = require(76) /* ./xy_glyph */;\n    const utils_1 = require(84) /* ./utils */;\n    const p = require(18) /* ../../core/properties */;\n    class RayView extends xy_glyph_1.XYGlyphView {\n        _map_data() {\n            if (this.model.properties.length.units == \"data\")\n                this.slength = this.sdist(this.renderer.xscale, this._x, this._length);\n            else\n                this.slength = this._length;\n        }\n        _render(ctx, indices, { sx, sy, slength, _angle }) {\n            if (this.visuals.line.doit) {\n                const width = this.renderer.plot_view.frame._width.value;\n                const height = this.renderer.plot_view.frame._height.value;\n                const inf_len = 2 * (width + height);\n                for (let i = 0, end = slength.length; i < end; i++) {\n                    if (slength[i] == 0)\n                        slength[i] = inf_len;\n                }\n                for (const i of indices) {\n                    if (isNaN(sx[i] + sy[i] + _angle[i] + slength[i]))\n                        continue;\n                    ctx.translate(sx[i], sy[i]);\n                    ctx.rotate(_angle[i]);\n                    ctx.beginPath();\n                    ctx.moveTo(0, 0);\n                    ctx.lineTo(slength[i], 0);\n                    this.visuals.line.set_vectorize(ctx, i);\n                    ctx.stroke();\n                    ctx.rotate(-_angle[i]);\n                    ctx.translate(-sx[i], -sy[i]);\n                }\n            }\n        }\n        draw_legend_for_index(ctx, bbox, index) {\n            utils_1.generic_line_legend(this.visuals, ctx, bbox, index);\n        }\n    }\n    exports.RayView = RayView;\n    RayView.__name__ = \"RayView\";\n    class Ray extends xy_glyph_1.XYGlyph {\n        constructor(attrs) {\n            super(attrs);\n        }\n        static init_Ray() {\n            this.prototype.default_view = RayView;\n            this.mixins(['line']);\n            this.define({\n                length: [p.DistanceSpec],\n                angle: [p.AngleSpec],\n            });\n        }\n    }\n    exports.Ray = Ray;\n    Ray.__name__ = \"Ray\";\n    Ray.init_Ray();\n}\n","/* models/glyphs/rect.js */ function _(require, module, exports) {\n    const center_rotatable_1 = require(206) /* ./center_rotatable */;\n    const utils_1 = require(84) /* ./utils */;\n    const hittest = require(81) /* ../../core/hittest */;\n    const p = require(18) /* ../../core/properties */;\n    const arrayable_1 = require(11) /* ../../core/util/arrayable */;\n    class RectView extends center_rotatable_1.CenterRotatableView {\n        _set_data() {\n            this.max_w2 = 0;\n            if (this.model.properties.width.units == \"data\")\n                this.max_w2 = this.max_width / 2;\n            this.max_h2 = 0;\n            if (this.model.properties.height.units == \"data\")\n                this.max_h2 = this.max_height / 2;\n        }\n        _map_data() {\n            if (this.model.properties.width.units == \"data\")\n                [this.sw, this.sx0] = this._map_dist_corner_for_data_side_length(this._x, this._width, this.renderer.xscale);\n            else {\n                this.sw = this._width;\n                const n = this.sx.length;\n                this.sx0 = new Float64Array(n);\n                for (let i = 0; i < n; i++)\n                    this.sx0[i] = this.sx[i] - this.sw[i] / 2;\n            }\n            if (this.model.properties.height.units == \"data\")\n                [this.sh, this.sy1] = this._map_dist_corner_for_data_side_length(this._y, this._height, this.renderer.yscale);\n            else {\n                this.sh = this._height;\n                const n = this.sy.length;\n                this.sy1 = new Float64Array(n);\n                for (let i = 0; i < n; i++)\n                    this.sy1[i] = this.sy[i] - this.sh[i] / 2;\n            }\n            const n = this.sw.length;\n            this.ssemi_diag = new Float64Array(n);\n            for (let i = 0; i < n; i++)\n                this.ssemi_diag[i] = Math.sqrt((this.sw[i] / 2 * this.sw[i]) / 2 + (this.sh[i] / 2 * this.sh[i]) / 2);\n        }\n        _render(ctx, indices, { sx, sy, sx0, sy1, sw, sh, _angle }) {\n            if (this.visuals.fill.doit) {\n                for (const i of indices) {\n                    if (isNaN(sx[i] + sy[i] + sx0[i] + sy1[i] + sw[i] + sh[i] + _angle[i]))\n                        continue;\n                    //no need to test the return value, we call fillRect for every glyph anyway\n                    this.visuals.fill.set_vectorize(ctx, i);\n                    if (_angle[i]) {\n                        ctx.translate(sx[i], sy[i]);\n                        ctx.rotate(_angle[i]);\n                        ctx.fillRect(-sw[i] / 2, -sh[i] / 2, sw[i], sh[i]);\n                        ctx.rotate(-_angle[i]);\n                        ctx.translate(-sx[i], -sy[i]);\n                    }\n                    else\n                        ctx.fillRect(sx0[i], sy1[i], sw[i], sh[i]);\n                }\n            }\n            if (this.visuals.line.doit) {\n                ctx.beginPath();\n                for (const i of indices) {\n                    if (isNaN(sx[i] + sy[i] + sx0[i] + sy1[i] + sw[i] + sh[i] + _angle[i]))\n                        continue;\n                    // fillRect does not fill zero-height or -width rects, but rect(...)\n                    // does seem to stroke them (1px wide or tall). Explicitly ignore rects\n                    // with zero width or height to be consistent\n                    if (sw[i] == 0 || sh[i] == 0)\n                        continue;\n                    if (_angle[i]) {\n                        ctx.translate(sx[i], sy[i]);\n                        ctx.rotate(_angle[i]);\n                        ctx.rect(-sw[i] / 2, -sh[i] / 2, sw[i], sh[i]);\n                        ctx.rotate(-_angle[i]);\n                        ctx.translate(-sx[i], -sy[i]);\n                    }\n                    else\n                        ctx.rect(sx0[i], sy1[i], sw[i], sh[i]);\n                    this.visuals.line.set_vectorize(ctx, i);\n                    ctx.stroke();\n                    ctx.beginPath();\n                }\n                ctx.stroke();\n            }\n        }\n        _hit_rect(geometry) {\n            return this._hit_rect_against_index(geometry);\n        }\n        _hit_point(geometry) {\n            let { sx, sy } = geometry;\n            const x = this.renderer.xscale.invert(sx);\n            const y = this.renderer.yscale.invert(sy);\n            const scenter_x = [];\n            for (let i = 0, end = this.sx0.length; i < end; i++) {\n                scenter_x.push(this.sx0[i] + this.sw[i] / 2);\n            }\n            const scenter_y = [];\n            for (let i = 0, end = this.sy1.length; i < end; i++) {\n                scenter_y.push(this.sy1[i] + this.sh[i] / 2);\n            }\n            const max_x2_ddist = arrayable_1.max(this._ddist(0, scenter_x, this.ssemi_diag));\n            const max_y2_ddist = arrayable_1.max(this._ddist(1, scenter_y, this.ssemi_diag));\n            const x0 = x - max_x2_ddist;\n            const x1 = x + max_x2_ddist;\n            const y0 = y - max_y2_ddist;\n            const y1 = y + max_y2_ddist;\n            const hits = [];\n            for (const i of this.index.indices({ x0, x1, y0, y1 })) {\n                let height_in, width_in;\n                if (this._angle[i]) {\n                    const s = Math.sin(-this._angle[i]);\n                    const c = Math.cos(-this._angle[i]);\n                    const px = c * (sx - this.sx[i]) - s * (sy - this.sy[i]) + this.sx[i];\n                    const py = s * (sx - this.sx[i]) + c * (sy - this.sy[i]) + this.sy[i];\n                    sx = px;\n                    sy = py;\n                    width_in = Math.abs(this.sx[i] - sx) <= this.sw[i] / 2;\n                    height_in = Math.abs(this.sy[i] - sy) <= this.sh[i] / 2;\n                }\n                else {\n                    width_in = (sx - this.sx0[i] <= this.sw[i]) && (sx - this.sx0[i] >= 0);\n                    height_in = (sy - this.sy1[i] <= this.sh[i]) && (sy - this.sy1[i] >= 0);\n                }\n                if (height_in && width_in)\n                    hits.push(i);\n            }\n            const result = hittest.create_empty_hit_test_result();\n            result.indices = hits;\n            return result;\n        }\n        _map_dist_corner_for_data_side_length(coord, side_length, scale) {\n            const n = coord.length;\n            const pt0 = new Float64Array(n);\n            const pt1 = new Float64Array(n);\n            for (let i = 0; i < n; i++) {\n                pt0[i] = Number(coord[i]) - side_length[i] / 2;\n                pt1[i] = Number(coord[i]) + side_length[i] / 2;\n            }\n            const spt0 = scale.v_compute(pt0);\n            const spt1 = scale.v_compute(pt1);\n            const sside_length = this.sdist(scale, pt0, side_length, 'edge', this.model.dilate);\n            let spt_corner = spt0;\n            for (let i = 0, end = spt0.length; i < end; i++) {\n                if (spt0[i] != spt1[i]) {\n                    spt_corner = spt0[i] < spt1[i] ? spt0 : spt1;\n                    break;\n                }\n            }\n            return [sside_length, spt_corner];\n        }\n        _ddist(dim, spts, spans) {\n            const scale = dim == 0 ? this.renderer.xscale : this.renderer.yscale;\n            const spt0 = spts;\n            const m = spt0.length;\n            const spt1 = new Float64Array(m);\n            for (let i = 0; i < m; i++)\n                spt1[i] = spt0[i] + spans[i];\n            const pt0 = scale.v_invert(spt0);\n            const pt1 = scale.v_invert(spt1);\n            const n = pt0.length;\n            const ddist = new Float64Array(n);\n            for (let i = 0; i < n; i++)\n                ddist[i] = Math.abs(pt1[i] - pt0[i]);\n            return ddist;\n        }\n        draw_legend_for_index(ctx, bbox, index) {\n            utils_1.generic_area_legend(this.visuals, ctx, bbox, index);\n        }\n        _bounds({ x0, x1, y0, y1 }) {\n            return {\n                x0: x0 - this.max_w2,\n                x1: x1 + this.max_w2,\n                y0: y0 - this.max_h2,\n                y1: y1 + this.max_h2,\n            };\n        }\n    }\n    exports.RectView = RectView;\n    RectView.__name__ = \"RectView\";\n    class Rect extends center_rotatable_1.CenterRotatable {\n        constructor(attrs) {\n            super(attrs);\n        }\n        static init_Rect() {\n            this.prototype.default_view = RectView;\n            this.define({\n                dilate: [p.Boolean, false],\n            });\n        }\n    }\n    exports.Rect = Rect;\n    Rect.__name__ = \"Rect\";\n    Rect.init_Rect();\n}\n","/* models/glyphs/segment.js */ function _(require, module, exports) {\n    const hittest = require(81) /* ../../core/hittest */;\n    const spatial_1 = require(77) /* ../../core/util/spatial */;\n    const glyph_1 = require(80) /* ./glyph */;\n    const utils_1 = require(84) /* ./utils */;\n    class SegmentView extends glyph_1.GlyphView {\n        _index_data() {\n            const points = [];\n            for (let i = 0, end = this._x0.length; i < end; i++) {\n                const x0 = this._x0[i];\n                const x1 = this._x1[i];\n                const y0 = this._y0[i];\n                const y1 = this._y1[i];\n                if (!isNaN(x0 + x1 + y0 + y1)) {\n                    points.push({\n                        x0: Math.min(x0, x1),\n                        y0: Math.min(y0, y1),\n                        x1: Math.max(x0, x1),\n                        y1: Math.max(y0, y1),\n                        i,\n                    });\n                }\n            }\n            return new spatial_1.SpatialIndex(points);\n        }\n        _render(ctx, indices, { sx0, sy0, sx1, sy1 }) {\n            if (this.visuals.line.doit) {\n                for (const i of indices) {\n                    if (isNaN(sx0[i] + sy0[i] + sx1[i] + sy1[i]))\n                        continue;\n                    ctx.beginPath();\n                    ctx.moveTo(sx0[i], sy0[i]);\n                    ctx.lineTo(sx1[i], sy1[i]);\n                    this.visuals.line.set_vectorize(ctx, i);\n                    ctx.stroke();\n                }\n            }\n        }\n        _hit_point(geometry) {\n            const { sx, sy } = geometry;\n            const point = { x: sx, y: sy };\n            const hits = [];\n            const lw_voffset = 2; // FIXME: Use maximum of segments line_width/2 instead of magic constant 2\n            const [x0, x1] = this.renderer.xscale.r_invert(sx - lw_voffset, sx + lw_voffset);\n            const [y0, y1] = this.renderer.yscale.r_invert(sy - lw_voffset, sy + lw_voffset);\n            const candidates = this.index.indices({ x0, y0, x1, y1 });\n            for (const i of candidates) {\n                const threshold2 = Math.pow(Math.max(2, this.visuals.line.cache_select('line_width', i) / 2), 2);\n                const p0 = { x: this.sx0[i], y: this.sy0[i] };\n                const p1 = { x: this.sx1[i], y: this.sy1[i] };\n                const dist2 = hittest.dist_to_segment_squared(point, p0, p1);\n                if (dist2 < threshold2)\n                    hits.push(i);\n            }\n            const result = hittest.create_empty_hit_test_result();\n            result.indices = hits;\n            return result;\n        }\n        _hit_span(geometry) {\n            const [hr, vr] = this.renderer.plot_view.frame.bbox.ranges;\n            const { sx, sy } = geometry;\n            let v0;\n            let v1;\n            let val;\n            if (geometry.direction == 'v') {\n                val = this.renderer.yscale.invert(sy);\n                [v0, v1] = [this._y0, this._y1];\n            }\n            else {\n                val = this.renderer.xscale.invert(sx);\n                [v0, v1] = [this._x0, this._x1];\n            }\n            const hits = [];\n            const [x0, x1] = this.renderer.xscale.r_invert(hr.start, hr.end);\n            const [y0, y1] = this.renderer.yscale.r_invert(vr.start, vr.end);\n            const candidates = this.index.indices({ x0, y0, x1, y1 });\n            for (const i of candidates) {\n                if ((v0[i] <= val && val <= v1[i]) || (v1[i] <= val && val <= v0[i]))\n                    hits.push(i);\n            }\n            const result = hittest.create_empty_hit_test_result();\n            result.indices = hits;\n            return result;\n        }\n        scenterx(i) {\n            return (this.sx0[i] + this.sx1[i]) / 2;\n        }\n        scentery(i) {\n            return (this.sy0[i] + this.sy1[i]) / 2;\n        }\n        draw_legend_for_index(ctx, bbox, index) {\n            utils_1.generic_line_legend(this.visuals, ctx, bbox, index);\n        }\n    }\n    exports.SegmentView = SegmentView;\n    SegmentView.__name__ = \"SegmentView\";\n    class Segment extends glyph_1.Glyph {\n        constructor(attrs) {\n            super(attrs);\n        }\n        static init_Segment() {\n            this.prototype.default_view = SegmentView;\n            this.coords([['x0', 'y0'], ['x1', 'y1']]);\n            this.mixins(['line']);\n        }\n    }\n    exports.Segment = Segment;\n    Segment.__name__ = \"Segment\";\n    Segment.init_Segment();\n}\n","/* models/glyphs/step.js */ function _(require, module, exports) {\n    const xy_glyph_1 = require(76) /* ./xy_glyph */;\n    const utils_1 = require(84) /* ./utils */;\n    const p = require(18) /* ../../core/properties */;\n    class StepView extends xy_glyph_1.XYGlyphView {\n        _render(ctx, indices, { sx, sy }) {\n            let drawing = false;\n            let last_index = null;\n            this.visuals.line.set_value(ctx);\n            const L = indices.length;\n            if (L < 2)\n                return;\n            ctx.beginPath();\n            ctx.moveTo(sx[0], sy[0]);\n            for (const i of indices) {\n                let x1, x2;\n                let y1, y2;\n                switch (this.model.mode) {\n                    case \"before\": {\n                        [x1, y1] = [sx[i - 1], sy[i]];\n                        [x2, y2] = [sx[i], sy[i]];\n                        break;\n                    }\n                    case \"after\": {\n                        [x1, y1] = [sx[i], sy[i - 1]];\n                        [x2, y2] = [sx[i], sy[i]];\n                        break;\n                    }\n                    case \"center\": {\n                        const xm = (sx[i - 1] + sx[i]) / 2;\n                        [x1, y1] = [xm, sy[i - 1]];\n                        [x2, y2] = [xm, sy[i]];\n                        break;\n                    }\n                    default:\n                        throw new Error(\"unexpected\");\n                }\n                if (drawing) {\n                    if (!isFinite(sx[i] + sy[i])) {\n                        ctx.stroke();\n                        ctx.beginPath();\n                        drawing = false;\n                        last_index = i;\n                        continue;\n                    }\n                    if (last_index != null && i - last_index > 1) {\n                        ctx.stroke();\n                        drawing = false;\n                    }\n                }\n                if (drawing) {\n                    ctx.lineTo(x1, y1);\n                    ctx.lineTo(x2, y2);\n                }\n                else {\n                    ctx.beginPath();\n                    ctx.moveTo(sx[i], sy[i]);\n                    drawing = true;\n                }\n                last_index = i;\n            }\n            ctx.lineTo(sx[L - 1], sy[L - 1]);\n            ctx.stroke();\n        }\n        draw_legend_for_index(ctx, bbox, index) {\n            utils_1.generic_line_legend(this.visuals, ctx, bbox, index);\n        }\n    }\n    exports.StepView = StepView;\n    StepView.__name__ = \"StepView\";\n    class Step extends xy_glyph_1.XYGlyph {\n        constructor(attrs) {\n            super(attrs);\n        }\n        static init_Step() {\n            this.prototype.default_view = StepView;\n            this.mixins(['line']);\n            this.define({\n                mode: [p.StepMode, \"before\"],\n            });\n        }\n    }\n    exports.Step = Step;\n    Step.__name__ = \"Step\";\n    Step.init_Step();\n}\n","/* models/glyphs/text.js */ function _(require, module, exports) {\n    const xy_glyph_1 = require(76) /* ./xy_glyph */;\n    const hittest = require(81) /* ../../core/hittest */;\n    const p = require(18) /* ../../core/properties */;\n    const text_1 = require(124) /* ../../core/util/text */;\n    class TextView extends xy_glyph_1.XYGlyphView {\n        _rotate_point(x, y, xoff, yoff, angle) {\n            const sxr = (x - xoff) * Math.cos(angle) - (y - yoff) * Math.sin(angle) + xoff;\n            const syr = (x - xoff) * Math.sin(angle) + (y - yoff) * Math.cos(angle) + yoff;\n            return [sxr, syr];\n        }\n        _text_bounds(x0, y0, width, height) {\n            const xvals = [x0, x0 + width, x0 + width, x0, x0];\n            const yvals = [y0, y0, y0 - height, y0 - height, y0];\n            return [xvals, yvals];\n        }\n        _render(ctx, indices, { sx, sy, _x_offset, _y_offset, _angle, _text }) {\n            this._sys = [];\n            this._sxs = [];\n            for (const i of indices) {\n                if (isNaN(sx[i] + sy[i] + _x_offset[i] + _y_offset[i] + _angle[i]) || _text[i] == null)\n                    continue;\n                this._sxs[i] = [];\n                this._sys[i] = [];\n                if (this.visuals.text.doit) {\n                    const text = `${_text[i]}`;\n                    ctx.save();\n                    ctx.translate(sx[i] + _x_offset[i], sy[i] + _y_offset[i]);\n                    ctx.rotate(_angle[i]);\n                    this.visuals.text.set_vectorize(ctx, i);\n                    const font = this.visuals.text.cache_select(\"font\", i);\n                    const { height } = text_1.measure_font(font);\n                    const line_height = this.visuals.text.text_line_height.value() * height;\n                    if (text.indexOf(\"\\n\") == -1) {\n                        ctx.fillText(text, 0, 0);\n                        const x0 = sx[i] + _x_offset[i];\n                        const y0 = sy[i] + _y_offset[i];\n                        const width = ctx.measureText(text).width;\n                        const [xvalues, yvalues] = this._text_bounds(x0, y0, width, line_height);\n                        this._sxs[i].push(xvalues);\n                        this._sys[i].push(yvalues);\n                    }\n                    else {\n                        const lines = text.split(\"\\n\");\n                        const block_height = line_height * lines.length;\n                        const baseline = this.visuals.text.cache_select(\"text_baseline\", i);\n                        let y;\n                        switch (baseline) {\n                            case \"top\": {\n                                y = 0;\n                                break;\n                            }\n                            case \"middle\": {\n                                y = (-block_height / 2) + (line_height / 2);\n                                break;\n                            }\n                            case \"bottom\": {\n                                y = -block_height + line_height;\n                                break;\n                            }\n                            default: {\n                                y = 0;\n                                console.warn(`'${baseline}' baseline not supported with multi line text`);\n                            }\n                        }\n                        for (const line of lines) {\n                            ctx.fillText(line, 0, y);\n                            const x0 = sx[i] + _x_offset[i];\n                            const y0 = y + sy[i] + _y_offset[i];\n                            const width = ctx.measureText(line).width;\n                            const [xvalues, yvalues] = this._text_bounds(x0, y0, width, line_height);\n                            this._sxs[i].push(xvalues);\n                            this._sys[i].push(yvalues);\n                            y += line_height;\n                        }\n                    }\n                    ctx.restore();\n                }\n            }\n        }\n        _hit_point(geometry) {\n            const { sx, sy } = geometry;\n            const hits = [];\n            for (let i = 0; i < this._sxs.length; i++) {\n                const sxs = this._sxs[i];\n                const sys = this._sys[i];\n                const n = sxs.length;\n                for (let j = 0, endj = n; j < endj; j++) {\n                    const [sxr, syr] = this._rotate_point(sx, sy, sxs[n - 1][0], sys[n - 1][0], -this._angle[i]);\n                    if (hittest.point_in_poly(sxr, syr, sxs[j], sys[j])) {\n                        hits.push(i);\n                    }\n                }\n            }\n            const result = hittest.create_empty_hit_test_result();\n            result.indices = hits;\n            return result;\n        }\n        _scenterxy(i) {\n            const sx0 = this._sxs[i][0][0];\n            const sy0 = this._sys[i][0][0];\n            const sxc = (this._sxs[i][0][2] + sx0) / 2;\n            const syc = (this._sys[i][0][2] + sy0) / 2;\n            const [sxcr, sycr] = this._rotate_point(sxc, syc, sx0, sy0, this._angle[i]);\n            return { x: sxcr, y: sycr };\n        }\n        scenterx(i) {\n            return this._scenterxy(i).x;\n        }\n        scentery(i) {\n            return this._scenterxy(i).y;\n        }\n    }\n    exports.TextView = TextView;\n    TextView.__name__ = \"TextView\";\n    class Text extends xy_glyph_1.XYGlyph {\n        constructor(attrs) {\n            super(attrs);\n        }\n        static init_Text() {\n            this.prototype.default_view = TextView;\n            this.mixins(['text']);\n            this.define({\n                text: [p.NullStringSpec, { field: \"text\" }],\n                angle: [p.AngleSpec, 0],\n                x_offset: [p.NumberSpec, 0],\n                y_offset: [p.NumberSpec, 0],\n            });\n        }\n    }\n    exports.Text = Text;\n    Text.__name__ = \"Text\";\n    Text.init_Text();\n}\n","/* models/glyphs/vbar.js */ function _(require, module, exports) {\n    const box_1 = require(210) /* ./box */;\n    const p = require(18) /* ../../core/properties */;\n    class VBarView extends box_1.BoxView {\n        scenterx(i) {\n            return this.sx[i];\n        }\n        scentery(i) {\n            return (this.stop[i] + this.sbottom[i]) / 2;\n        }\n        _index_data() {\n            return this._index_box(this._x.length);\n        }\n        _lrtb(i) {\n            const l = this._x[i] - (this._width[i] / 2);\n            const r = this._x[i] + (this._width[i] / 2);\n            const t = Math.max(this._top[i], this._bottom[i]);\n            const b = Math.min(this._top[i], this._bottom[i]);\n            return [l, r, t, b];\n        }\n        _map_data() {\n            this.sx = this.renderer.xscale.v_compute(this._x);\n            this.sw = this.sdist(this.renderer.xscale, this._x, this._width, \"center\");\n            this.stop = this.renderer.yscale.v_compute(this._top);\n            this.sbottom = this.renderer.yscale.v_compute(this._bottom);\n            const n = this.sx.length;\n            this.sleft = new Float64Array(n);\n            this.sright = new Float64Array(n);\n            for (let i = 0; i < n; i++) {\n                this.sleft[i] = this.sx[i] - this.sw[i] / 2;\n                this.sright[i] = this.sx[i] + this.sw[i] / 2;\n            }\n            this._clamp_viewport();\n        }\n    }\n    exports.VBarView = VBarView;\n    VBarView.__name__ = \"VBarView\";\n    class VBar extends box_1.Box {\n        constructor(attrs) {\n            super(attrs);\n        }\n        static init_VBar() {\n            this.prototype.default_view = VBarView;\n            this.coords([['x', 'bottom']]);\n            this.define({\n                width: [p.NumberSpec],\n                top: [p.CoordinateSpec],\n            });\n            this.override({\n                bottom: 0,\n            });\n        }\n    }\n    exports.VBar = VBar;\n    VBar.__name__ = \"VBar\";\n    VBar.init_VBar();\n}\n","/* models/glyphs/wedge.js */ function _(require, module, exports) {\n    const xy_glyph_1 = require(76) /* ./xy_glyph */;\n    const utils_1 = require(84) /* ./utils */;\n    const hittest = require(81) /* ../../core/hittest */;\n    const p = require(18) /* ../../core/properties */;\n    const math_1 = require(9) /* ../../core/util/math */;\n    class WedgeView extends xy_glyph_1.XYGlyphView {\n        _map_data() {\n            if (this.model.properties.radius.units == \"data\")\n                this.sradius = this.sdist(this.renderer.xscale, this._x, this._radius);\n            else\n                this.sradius = this._radius;\n        }\n        _render(ctx, indices, { sx, sy, sradius, _start_angle, _end_angle }) {\n            const direction = this.model.properties.direction.value();\n            for (const i of indices) {\n                if (isNaN(sx[i] + sy[i] + sradius[i] + _start_angle[i] + _end_angle[i]))\n                    continue;\n                ctx.beginPath();\n                ctx.arc(sx[i], sy[i], sradius[i], _start_angle[i], _end_angle[i], direction);\n                ctx.lineTo(sx[i], sy[i]);\n                ctx.closePath();\n                if (this.visuals.fill.doit) {\n                    this.visuals.fill.set_vectorize(ctx, i);\n                    ctx.fill();\n                }\n                if (this.visuals.line.doit) {\n                    this.visuals.line.set_vectorize(ctx, i);\n                    ctx.stroke();\n                }\n            }\n        }\n        _hit_point(geometry) {\n            let dist, sx0, sx1, sy0, sy1, x0, x1, y0, y1;\n            const { sx, sy } = geometry;\n            const x = this.renderer.xscale.invert(sx);\n            const y = this.renderer.yscale.invert(sy);\n            // check diameter first\n            const max_diameter = 2 * this.max_radius;\n            if (this.model.properties.radius.units === \"data\") {\n                x0 = x - max_diameter;\n                x1 = x + max_diameter;\n                y0 = y - max_diameter;\n                y1 = y + max_diameter;\n            }\n            else {\n                sx0 = sx - max_diameter;\n                sx1 = sx + max_diameter;\n                [x0, x1] = this.renderer.xscale.r_invert(sx0, sx1);\n                sy0 = sy - max_diameter;\n                sy1 = sy + max_diameter;\n                [y0, y1] = this.renderer.yscale.r_invert(sy0, sy1);\n            }\n            const candidates = [];\n            for (const i of this.index.indices({ x0, x1, y0, y1 })) {\n                const r2 = Math.pow(this.sradius[i], 2);\n                [sx0, sx1] = this.renderer.xscale.r_compute(x, this._x[i]);\n                [sy0, sy1] = this.renderer.yscale.r_compute(y, this._y[i]);\n                dist = Math.pow(sx0 - sx1, 2) + Math.pow(sy0 - sy1, 2);\n                if (dist <= r2) {\n                    candidates.push([i, dist]);\n                }\n            }\n            const direction = this.model.properties.direction.value();\n            const hits = [];\n            for (const [i, dist] of candidates) {\n                // NOTE: minus the angle because JS uses non-mathy convention for angles\n                const angle = Math.atan2(sy - this.sy[i], sx - this.sx[i]);\n                if (math_1.angle_between(-angle, -this._start_angle[i], -this._end_angle[i], direction)) {\n                    hits.push([i, dist]);\n                }\n            }\n            return hittest.create_hit_test_result_from_hits(hits);\n        }\n        draw_legend_for_index(ctx, bbox, index) {\n            utils_1.generic_area_legend(this.visuals, ctx, bbox, index);\n        }\n        _scenterxy(i) {\n            const r = this.sradius[i] / 2;\n            const a = (this._start_angle[i] + this._end_angle[i]) / 2;\n            return { x: this.sx[i] + (r * Math.cos(a)), y: this.sy[i] + (r * Math.sin(a)) };\n        }\n        scenterx(i) {\n            return this._scenterxy(i).x;\n        }\n        scentery(i) {\n            return this._scenterxy(i).y;\n        }\n    }\n    exports.WedgeView = WedgeView;\n    WedgeView.__name__ = \"WedgeView\";\n    class Wedge extends xy_glyph_1.XYGlyph {\n        constructor(attrs) {\n            super(attrs);\n        }\n        static init_Wedge() {\n            this.prototype.default_view = WedgeView;\n            this.mixins(['line', 'fill']);\n            this.define({\n                direction: [p.Direction, 'anticlock'],\n                radius: [p.DistanceSpec],\n                start_angle: [p.AngleSpec],\n                end_angle: [p.AngleSpec],\n            });\n        }\n    }\n    exports.Wedge = Wedge;\n    Wedge.__name__ = \"Wedge\";\n    Wedge.init_Wedge();\n}\n","/* models/graphs/index.js */ function _(require, module, exports) {\n    function __export(m) {\n        for (var p in m)\n            if (!exports.hasOwnProperty(p))\n                exports[p] = m[p];\n    }\n    __export(require(91) /* ./graph_hit_test_policy */);\n    __export(require(231) /* ./layout_provider */);\n    __export(require(232) /* ./static_layout_provider */);\n}\n","/* models/graphs/layout_provider.js */ function _(require, module, exports) {\n    const model_1 = require(64) /* ../../model */;\n    class LayoutProvider extends model_1.Model {\n        constructor(attrs) {\n            super(attrs);\n        }\n    }\n    exports.LayoutProvider = LayoutProvider;\n    LayoutProvider.__name__ = \"LayoutProvider\";\n}\n","/* models/graphs/static_layout_provider.js */ function _(require, module, exports) {\n    const layout_provider_1 = require(231) /* ./layout_provider */;\n    const p = require(18) /* ../../core/properties */;\n    class StaticLayoutProvider extends layout_provider_1.LayoutProvider {\n        constructor(attrs) {\n            super(attrs);\n        }\n        static init_StaticLayoutProvider() {\n            this.define({\n                graph_layout: [p.Any, {}],\n            });\n        }\n        get_node_coordinates(node_source) {\n            const xs = [];\n            const ys = [];\n            const index = node_source.data.index;\n            for (let i = 0, end = index.length; i < end; i++) {\n                const point = this.graph_layout[index[i]];\n                const [x, y] = point != null ? point : [NaN, NaN];\n                xs.push(x);\n                ys.push(y);\n            }\n            return [xs, ys];\n        }\n        get_edge_coordinates(edge_source) {\n            const xs = [];\n            const ys = [];\n            const starts = edge_source.data.start;\n            const ends = edge_source.data.end;\n            const has_paths = (edge_source.data.xs != null) && (edge_source.data.ys != null);\n            for (let i = 0, endi = starts.length; i < endi; i++) {\n                const in_layout = (this.graph_layout[starts[i]] != null) && (this.graph_layout[ends[i]] != null);\n                if (has_paths && in_layout) {\n                    xs.push(edge_source.data.xs[i]);\n                    ys.push(edge_source.data.ys[i]);\n                }\n                else {\n                    let end, start;\n                    if (in_layout)\n                        [start, end] = [this.graph_layout[starts[i]], this.graph_layout[ends[i]]];\n                    else\n                        [start, end] = [[NaN, NaN], [NaN, NaN]];\n                    xs.push([start[0], end[0]]);\n                    ys.push([start[1], end[1]]);\n                }\n            }\n            return [xs, ys];\n        }\n    }\n    exports.StaticLayoutProvider = StaticLayoutProvider;\n    StaticLayoutProvider.__name__ = \"StaticLayoutProvider\";\n    StaticLayoutProvider.init_StaticLayoutProvider();\n}\n","/* models/grids/index.js */ function _(require, module, exports) {\n    var grid_1 = require(234) /* ./grid */;\n    exports.Grid = grid_1.Grid;\n}\n","/* models/grids/grid.js */ function _(require, module, exports) {\n    const guide_renderer_1 = require(142) /* ../renderers/guide_renderer */;\n    const p = require(18) /* ../../core/properties */;\n    const types_1 = require(7) /* ../../core/util/types */;\n    class GridView extends guide_renderer_1.GuideRendererView {\n        get _x_range_name() {\n            return this.model.x_range_name;\n        }\n        get _y_range_name() {\n            return this.model.y_range_name;\n        }\n        render() {\n            if (!this.model.visible)\n                return;\n            const ctx = this.plot_view.canvas_view.ctx;\n            ctx.save();\n            this._draw_regions(ctx);\n            this._draw_minor_grids(ctx);\n            this._draw_grids(ctx);\n            ctx.restore();\n        }\n        connect_signals() {\n            super.connect_signals();\n            this.connect(this.model.change, () => this.request_render());\n        }\n        _draw_regions(ctx) {\n            if (!this.visuals.band_fill.doit && !this.visuals.band_hatch.doit)\n                return;\n            this.visuals.band_fill.set_value(ctx);\n            const [xs, ys] = this.grid_coords('major', false);\n            for (let i = 0; i < xs.length - 1; i++) {\n                if (i % 2 != 1)\n                    continue;\n                const [sx0, sy0] = this.plot_view.map_to_screen(xs[i], ys[i], this._x_range_name, this._y_range_name);\n                const [sx1, sy1] = this.plot_view.map_to_screen(xs[i + 1], ys[i + 1], this._x_range_name, this._y_range_name);\n                if (this.visuals.band_fill.doit)\n                    ctx.fillRect(sx0[0], sy0[0], sx1[1] - sx0[0], sy1[1] - sy0[0]);\n                this.visuals.band_hatch.doit2(ctx, i, () => {\n                    ctx.fillRect(sx0[0], sy0[0], sx1[1] - sx0[0], sy1[1] - sy0[0]);\n                }, () => this.request_render());\n            }\n        }\n        _draw_grids(ctx) {\n            if (!this.visuals.grid_line.doit)\n                return;\n            const [xs, ys] = this.grid_coords('major');\n            this._draw_grid_helper(ctx, this.visuals.grid_line, xs, ys);\n        }\n        _draw_minor_grids(ctx) {\n            if (!this.visuals.minor_grid_line.doit)\n                return;\n            const [xs, ys] = this.grid_coords('minor');\n            this._draw_grid_helper(ctx, this.visuals.minor_grid_line, xs, ys);\n        }\n        _draw_grid_helper(ctx, visuals, xs, ys) {\n            visuals.set_value(ctx);\n            for (let i = 0; i < xs.length; i++) {\n                const [sx, sy] = this.plot_view.map_to_screen(xs[i], ys[i], this._x_range_name, this._y_range_name);\n                ctx.beginPath();\n                ctx.moveTo(Math.round(sx[0]), Math.round(sy[0]));\n                for (let i = 1; i < sx.length; i++)\n                    ctx.lineTo(Math.round(sx[i]), Math.round(sy[i]));\n                ctx.stroke();\n            }\n        }\n        // {{{ TODO: state\n        ranges() {\n            const i = this.model.dimension;\n            const j = (i + 1) % 2;\n            const frame = this.plot_view.frame;\n            const ranges = [\n                frame.x_ranges[this.model.x_range_name],\n                frame.y_ranges[this.model.y_range_name],\n            ];\n            return [ranges[i], ranges[j]];\n        }\n        computed_bounds() {\n            const [range] = this.ranges();\n            const user_bounds = this.model.bounds;\n            const range_bounds = [range.min, range.max];\n            let start;\n            let end;\n            if (types_1.isArray(user_bounds)) {\n                start = Math.min(user_bounds[0], user_bounds[1]);\n                end = Math.max(user_bounds[0], user_bounds[1]);\n                if (start < range_bounds[0])\n                    start = range_bounds[0];\n                // XXX:\n                //else if (start > range_bounds[1])\n                //  start = null\n                if (end > range_bounds[1])\n                    end = range_bounds[1];\n                // XXX:\n                //else if (end < range_bounds[0])\n                //  end = null\n            }\n            else {\n                [start, end] = range_bounds;\n                for (const axis_view of this.plot_view.axis_views) {\n                    if (axis_view.dimension == this.model.dimension\n                        && axis_view.model.x_range_name == this.model.x_range_name\n                        && axis_view.model.y_range_name == this.model.y_range_name) {\n                        [start, end] = axis_view.computed_bounds;\n                    }\n                }\n            }\n            return [start, end];\n        }\n        grid_coords(location, exclude_ends = true) {\n            const i = this.model.dimension;\n            const j = (i + 1) % 2;\n            const [range, cross_range] = this.ranges();\n            let [start, end] = this.computed_bounds();\n            [start, end] = [Math.min(start, end), Math.max(start, end)];\n            // TODO: (bev) using cross_range.min for cross_loc is a bit of a cheat. Since we\n            // currently only support \"straight line\" grids, this should be OK for now. If\n            // we ever want to support \"curved\" grids, e.g. for some projections, we may\n            // have to communicate more than just a single cross location.\n            const ticks = this.model.ticker.get_ticks(start, end, range, cross_range.min, {})[location];\n            const min = range.min;\n            const max = range.max;\n            const cmin = cross_range.min;\n            const cmax = cross_range.max;\n            const coords = [[], []];\n            if (!exclude_ends) {\n                if (ticks[0] != min)\n                    ticks.splice(0, 0, min);\n                if (ticks[ticks.length - 1] != max)\n                    ticks.push(max);\n            }\n            for (let ii = 0; ii < ticks.length; ii++) {\n                if ((ticks[ii] == min || ticks[ii] == max) && exclude_ends)\n                    continue;\n                const dim_i = [];\n                const dim_j = [];\n                const N = 2;\n                for (let n = 0; n < N; n++) {\n                    const loc = cmin + (cmax - cmin) / (N - 1) * n;\n                    dim_i.push(ticks[ii]);\n                    dim_j.push(loc);\n                }\n                coords[i].push(dim_i);\n                coords[j].push(dim_j);\n            }\n            return coords;\n        }\n    }\n    exports.GridView = GridView;\n    GridView.__name__ = \"GridView\";\n    class Grid extends guide_renderer_1.GuideRenderer {\n        constructor(attrs) {\n            super(attrs);\n        }\n        static init_Grid() {\n            this.prototype.default_view = GridView;\n            this.mixins(['line:grid_', 'line:minor_grid_', 'fill:band_', 'hatch:band_']);\n            this.define({\n                bounds: [p.Any, 'auto'],\n                dimension: [p.Any, 0],\n                ticker: [p.Instance],\n                x_range_name: [p.String, 'default'],\n                y_range_name: [p.String, 'default'],\n            });\n            this.override({\n                level: \"underlay\",\n                band_fill_color: null,\n                band_fill_alpha: 0,\n                grid_line_color: '#e5e5e5',\n                minor_grid_line_color: null,\n            });\n        }\n    }\n    exports.Grid = Grid;\n    Grid.__name__ = \"Grid\";\n    Grid.init_Grid();\n}\n","/* models/layouts/index.js */ function _(require, module, exports) {\n    var box_1 = require(236) /* ./box */;\n    exports.Box = box_1.Box;\n    var column_1 = require(238) /* ./column */;\n    exports.Column = column_1.Column;\n    var grid_box_1 = require(239) /* ./grid_box */;\n    exports.GridBox = grid_box_1.GridBox;\n    var html_box_1 = require(240) /* ./html_box */;\n    exports.HTMLBox = html_box_1.HTMLBox;\n    var layout_dom_1 = require(237) /* ./layout_dom */;\n    exports.LayoutDOM = layout_dom_1.LayoutDOM;\n    var row_1 = require(241) /* ./row */;\n    exports.Row = row_1.Row;\n    var spacer_1 = require(242) /* ./spacer */;\n    exports.Spacer = spacer_1.Spacer;\n    var tabs_1 = require(243) /* ./tabs */;\n    exports.Panel = tabs_1.Panel;\n    exports.Tabs = tabs_1.Tabs;\n    var widget_box_1 = require(247) /* ./widget_box */;\n    exports.WidgetBox = widget_box_1.WidgetBox;\n}\n","/* models/layouts/box.js */ function _(require, module, exports) {\n    const layout_dom_1 = require(237) /* ./layout_dom */;\n    const p = require(18) /* ../../core/properties */;\n    class BoxView extends layout_dom_1.LayoutDOMView {\n        connect_signals() {\n            super.connect_signals();\n            this.connect(this.model.properties.children.change, () => this.rebuild());\n        }\n        get child_models() {\n            return this.model.children;\n        }\n    }\n    exports.BoxView = BoxView;\n    BoxView.__name__ = \"BoxView\";\n    class Box extends layout_dom_1.LayoutDOM {\n        constructor(attrs) {\n            super(attrs);\n        }\n        static init_Box() {\n            this.define({\n                children: [p.Array, []],\n                spacing: [p.Number, 0],\n            });\n        }\n    }\n    exports.Box = Box;\n    Box.__name__ = \"Box\";\n    Box.init_Box();\n}\n","/* models/layouts/layout_dom.js */ function _(require, module, exports) {\n    const model_1 = require(64) /* ../../model */;\n    const dom_1 = require(61) /* ../../core/dom */;\n    const logging_1 = require(65) /* ../../core/logging */;\n    const types_1 = require(7) /* ../../core/util/types */;\n    const p = require(18) /* ../../core/properties */;\n    const build_views_1 = require(92) /* ../../core/build_views */;\n    const dom_view_1 = require(59) /* ../../core/dom_view */;\n    const root_1 = require(62) /* ../../styles/root */;\n    class LayoutDOMView extends dom_view_1.DOMView {\n        constructor() {\n            super(...arguments);\n            this._idle_notified = false;\n            this._offset_parent = null;\n            this._viewport = {};\n        }\n        initialize() {\n            super.initialize();\n            this.el.style.position = this.is_root ? \"relative\" : \"absolute\";\n            this._child_views = {};\n            this.build_child_views();\n        }\n        remove() {\n            for (const child_view of this.child_views)\n                child_view.remove();\n            this._child_views = {};\n            super.remove();\n        }\n        connect_signals() {\n            super.connect_signals();\n            if (this.is_root) {\n                this._on_resize = () => this.resize_layout();\n                window.addEventListener(\"resize\", this._on_resize);\n                this._parent_observer = setInterval(() => {\n                    const offset_parent = this.el.offsetParent;\n                    if (this._offset_parent != offset_parent) {\n                        this._offset_parent = offset_parent;\n                        if (offset_parent != null) {\n                            this.compute_viewport();\n                            this.invalidate_layout();\n                        }\n                    }\n                }, 250);\n            }\n            const p = this.model.properties;\n            this.on_change([\n                p.width, p.height,\n                p.min_width, p.min_height,\n                p.max_width, p.max_height,\n                p.margin,\n                p.width_policy, p.height_policy, p.sizing_mode,\n                p.aspect_ratio,\n                p.visible,\n            ], () => this.invalidate_layout());\n            this.on_change([\n                p.background,\n                p.css_classes,\n            ], () => this.invalidate_render());\n        }\n        disconnect_signals() {\n            if (this._parent_observer != null)\n                clearTimeout(this._parent_observer);\n            if (this._on_resize != null)\n                window.removeEventListener(\"resize\", this._on_resize);\n            super.disconnect_signals();\n        }\n        css_classes() {\n            return super.css_classes().concat(this.model.css_classes);\n        }\n        get child_views() {\n            return this.child_models.map((child) => this._child_views[child.id]);\n        }\n        build_child_views() {\n            build_views_1.build_views(this._child_views, this.child_models, { parent: this });\n        }\n        render() {\n            super.render();\n            dom_1.empty(this.el); // XXX: this should be in super\n            const { background } = this.model;\n            this.el.style.backgroundColor = background != null ? background : \"\";\n            dom_1.classes(this.el).clear().add(...this.css_classes());\n            for (const child_view of this.child_views) {\n                this.el.appendChild(child_view.el);\n                child_view.render();\n            }\n        }\n        update_layout() {\n            for (const child_view of this.child_views)\n                child_view.update_layout();\n            this._update_layout();\n        }\n        update_position() {\n            this.el.style.display = this.model.visible ? \"block\" : \"none\";\n            const margin = this.is_root ? this.layout.sizing.margin : undefined;\n            dom_1.position(this.el, this.layout.bbox, margin);\n            for (const child_view of this.child_views)\n                child_view.update_position();\n        }\n        after_layout() {\n            for (const child_view of this.child_views)\n                child_view.after_layout();\n            this._has_finished = true;\n        }\n        compute_viewport() {\n            this._viewport = this._viewport_size();\n        }\n        renderTo(element) {\n            element.appendChild(this.el);\n            this._offset_parent = this.el.offsetParent;\n            this.compute_viewport();\n            this.build();\n        }\n        build() {\n            this.assert_root();\n            this.render();\n            this.update_layout();\n            this.compute_layout();\n            return this;\n        }\n        rebuild() {\n            this.build_child_views();\n            this.invalidate_render();\n        }\n        compute_layout() {\n            const start = Date.now();\n            this.layout.compute(this._viewport);\n            this.update_position();\n            this.after_layout();\n            logging_1.logger.debug(`layout computed in ${Date.now() - start} ms`);\n            this.notify_finished();\n        }\n        resize_layout() {\n            this.root.compute_viewport();\n            this.root.compute_layout();\n        }\n        invalidate_layout() {\n            this.root.update_layout();\n            this.root.compute_layout();\n        }\n        invalidate_render() {\n            this.render();\n            this.invalidate_layout();\n        }\n        has_finished() {\n            if (!super.has_finished())\n                return false;\n            for (const child_view of this.child_views) {\n                if (!child_view.has_finished())\n                    return false;\n            }\n            return true;\n        }\n        notify_finished() {\n            if (!this.is_root)\n                this.root.notify_finished();\n            else {\n                if (!this._idle_notified && this.has_finished()) {\n                    if (this.model.document != null) {\n                        this._idle_notified = true;\n                        this.model.document.notify_idle(this.model);\n                    }\n                }\n            }\n        }\n        _width_policy() {\n            return this.model.width != null ? \"fixed\" : \"fit\";\n        }\n        _height_policy() {\n            return this.model.height != null ? \"fixed\" : \"fit\";\n        }\n        box_sizing() {\n            let { width_policy, height_policy, aspect_ratio } = this.model;\n            if (width_policy == \"auto\")\n                width_policy = this._width_policy();\n            if (height_policy == \"auto\")\n                height_policy = this._height_policy();\n            const { sizing_mode } = this.model;\n            if (sizing_mode != null) {\n                if (sizing_mode == \"fixed\")\n                    width_policy = height_policy = \"fixed\";\n                else if (sizing_mode == \"stretch_both\")\n                    width_policy = height_policy = \"max\";\n                else if (sizing_mode == \"stretch_width\")\n                    width_policy = \"max\";\n                else if (sizing_mode == \"stretch_height\")\n                    height_policy = \"max\";\n                else {\n                    if (aspect_ratio == null)\n                        aspect_ratio = \"auto\";\n                    switch (sizing_mode) {\n                        case \"scale_width\":\n                            width_policy = \"max\";\n                            height_policy = \"min\";\n                            break;\n                        case \"scale_height\":\n                            width_policy = \"min\";\n                            height_policy = \"max\";\n                            break;\n                        case \"scale_both\":\n                            width_policy = \"max\";\n                            height_policy = \"max\";\n                            break;\n                        default:\n                            throw new Error(\"unreachable\");\n                    }\n                }\n            }\n            const sizing = { width_policy, height_policy };\n            const { min_width, min_height } = this.model;\n            if (min_width != null)\n                sizing.min_width = min_width;\n            if (min_height != null)\n                sizing.min_height = min_height;\n            const { width, height } = this.model;\n            if (width != null)\n                sizing.width = width;\n            if (height != null)\n                sizing.height = height;\n            const { max_width, max_height } = this.model;\n            if (max_width != null)\n                sizing.max_width = max_width;\n            if (max_height != null)\n                sizing.max_height = max_height;\n            if (aspect_ratio == \"auto\" && width != null && height != null)\n                sizing.aspect = width / height;\n            else if (types_1.isNumber(aspect_ratio))\n                sizing.aspect = aspect_ratio;\n            const { margin } = this.model;\n            if (margin != null) {\n                if (types_1.isNumber(margin))\n                    sizing.margin = { top: margin, right: margin, bottom: margin, left: margin };\n                else if (margin.length == 2) {\n                    const [vertical, horizontal] = margin;\n                    sizing.margin = { top: vertical, right: horizontal, bottom: vertical, left: horizontal };\n                }\n                else {\n                    const [top, right, bottom, left] = margin;\n                    sizing.margin = { top, right, bottom, left };\n                }\n            }\n            sizing.visible = this.model.visible;\n            const { align } = this.model;\n            if (types_1.isArray(align))\n                [sizing.halign, sizing.valign] = align;\n            else\n                sizing.halign = sizing.valign = align;\n            return sizing;\n        }\n        _viewport_size() {\n            return dom_1.undisplayed(this.el, () => {\n                let measuring = this.el;\n                while (measuring = measuring.parentElement) {\n                    // .bk-root element doesn't bring any value\n                    if (measuring.classList.contains(root_1.bk_root))\n                        continue;\n                    // we reached <body> element, so use viewport size\n                    if (measuring == document.body) {\n                        const { margin: { left, right, top, bottom } } = dom_1.extents(document.body);\n                        const width = Math.ceil(document.documentElement.clientWidth - left - right);\n                        const height = Math.ceil(document.documentElement.clientHeight - top - bottom);\n                        return { width, height };\n                    }\n                    // stop on first element with sensible dimensions\n                    const { padding: { left, right, top, bottom } } = dom_1.extents(measuring);\n                    const { width, height } = measuring.getBoundingClientRect();\n                    const inner_width = Math.ceil(width - left - right);\n                    const inner_height = Math.ceil(height - top - bottom);\n                    if (inner_width > 0 || inner_height > 0)\n                        return {\n                            width: inner_width > 0 ? inner_width : undefined,\n                            height: inner_height > 0 ? inner_height : undefined,\n                        };\n                }\n                // this element is detached from DOM\n                return {};\n            });\n        }\n        serializable_state() {\n            return Object.assign(Object.assign({}, super.serializable_state()), { bbox: this.layout.bbox.box, children: this.child_views.map((child) => child.serializable_state()) });\n        }\n    }\n    exports.LayoutDOMView = LayoutDOMView;\n    LayoutDOMView.__name__ = \"LayoutDOMView\";\n    class LayoutDOM extends model_1.Model {\n        constructor(attrs) {\n            super(attrs);\n        }\n        static init_LayoutDOM() {\n            this.define({\n                width: [p.Number, null],\n                height: [p.Number, null],\n                min_width: [p.Number, null],\n                min_height: [p.Number, null],\n                max_width: [p.Number, null],\n                max_height: [p.Number, null],\n                margin: [p.Any, [0, 0, 0, 0]],\n                width_policy: [p.Any, \"auto\"],\n                height_policy: [p.Any, \"auto\"],\n                aspect_ratio: [p.Any, null],\n                sizing_mode: [p.SizingMode, null],\n                visible: [p.Boolean, true],\n                disabled: [p.Boolean, false],\n                align: [p.Any, \"start\"],\n                background: [p.Color, null],\n                css_classes: [p.Array, []],\n            });\n        }\n    }\n    exports.LayoutDOM = LayoutDOM;\n    LayoutDOM.__name__ = \"LayoutDOM\";\n    LayoutDOM.init_LayoutDOM();\n}\n","/* models/layouts/column.js */ function _(require, module, exports) {\n    const box_1 = require(236) /* ./box */;\n    const grid_1 = require(184) /* ../../core/layout/grid */;\n    const p = require(18) /* ../../core/properties */;\n    class ColumnView extends box_1.BoxView {\n        _update_layout() {\n            const items = this.child_views.map((child) => child.layout);\n            this.layout = new grid_1.Column(items);\n            this.layout.rows = this.model.rows;\n            this.layout.spacing = [this.model.spacing, 0];\n            this.layout.set_sizing(this.box_sizing());\n        }\n    }\n    exports.ColumnView = ColumnView;\n    ColumnView.__name__ = \"ColumnView\";\n    class Column extends box_1.Box {\n        constructor(attrs) {\n            super(attrs);\n        }\n        static init_Column() {\n            this.prototype.default_view = ColumnView;\n            this.define({\n                rows: [p.Any, \"auto\"],\n            });\n        }\n    }\n    exports.Column = Column;\n    Column.__name__ = \"Column\";\n    Column.init_Column();\n}\n","/* models/layouts/grid_box.js */ function _(require, module, exports) {\n    const layout_dom_1 = require(237) /* ./layout_dom */;\n    const grid_1 = require(184) /* ../../core/layout/grid */;\n    const p = require(18) /* ../../core/properties */;\n    class GridBoxView extends layout_dom_1.LayoutDOMView {\n        connect_signals() {\n            super.connect_signals();\n            this.connect(this.model.properties.children.change, () => this.rebuild());\n        }\n        get child_models() {\n            return this.model.children.map(([child]) => child);\n        }\n        _update_layout() {\n            this.layout = new grid_1.Grid();\n            this.layout.rows = this.model.rows;\n            this.layout.cols = this.model.cols;\n            this.layout.spacing = this.model.spacing;\n            for (const [child, row, col, row_span, col_span] of this.model.children) {\n                const child_view = this._child_views[child.id];\n                this.layout.items.push({ layout: child_view.layout, row, col, row_span, col_span });\n            }\n            this.layout.set_sizing(this.box_sizing());\n        }\n    }\n    exports.GridBoxView = GridBoxView;\n    GridBoxView.__name__ = \"GridBoxView\";\n    class GridBox extends layout_dom_1.LayoutDOM {\n        constructor(attrs) {\n            super(attrs);\n        }\n        static init_GridBox() {\n            this.prototype.default_view = GridBoxView;\n            this.define({\n                children: [p.Array, []],\n                rows: [p.Any, \"auto\"],\n                cols: [p.Any, \"auto\"],\n                spacing: [p.Any, 0],\n            });\n        }\n    }\n    exports.GridBox = GridBox;\n    GridBox.__name__ = \"GridBox\";\n    GridBox.init_GridBox();\n}\n","/* models/layouts/html_box.js */ function _(require, module, exports) {\n    const layout_dom_1 = require(237) /* ../layouts/layout_dom */;\n    const layout_1 = require(180) /* ../../core/layout */;\n    class HTMLBoxView extends layout_dom_1.LayoutDOMView {\n        get child_models() {\n            return [];\n        }\n        _update_layout() {\n            this.layout = new layout_1.ContentBox(this.el);\n            this.layout.set_sizing(this.box_sizing());\n        }\n    }\n    exports.HTMLBoxView = HTMLBoxView;\n    HTMLBoxView.__name__ = \"HTMLBoxView\";\n    class HTMLBox extends layout_dom_1.LayoutDOM {\n        constructor(attrs) {\n            super(attrs);\n        }\n    }\n    exports.HTMLBox = HTMLBox;\n    HTMLBox.__name__ = \"HTMLBox\";\n}\n","/* models/layouts/row.js */ function _(require, module, exports) {\n    const box_1 = require(236) /* ./box */;\n    const grid_1 = require(184) /* ../../core/layout/grid */;\n    const p = require(18) /* ../../core/properties */;\n    class RowView extends box_1.BoxView {\n        _update_layout() {\n            const items = this.child_views.map((child) => child.layout);\n            this.layout = new grid_1.Row(items);\n            this.layout.cols = this.model.cols;\n            this.layout.spacing = [0, this.model.spacing];\n            this.layout.set_sizing(this.box_sizing());\n        }\n    }\n    exports.RowView = RowView;\n    RowView.__name__ = \"RowView\";\n    class Row extends box_1.Box {\n        constructor(attrs) {\n            super(attrs);\n        }\n        static init_Row() {\n            this.prototype.default_view = RowView;\n            this.define({\n                cols: [p.Any, \"auto\"],\n            });\n        }\n    }\n    exports.Row = Row;\n    Row.__name__ = \"Row\";\n    Row.init_Row();\n}\n","/* models/layouts/spacer.js */ function _(require, module, exports) {\n    const layout_dom_1 = require(237) /* ./layout_dom */;\n    const layout_1 = require(180) /* ../../core/layout */;\n    class SpacerView extends layout_dom_1.LayoutDOMView {\n        get child_models() {\n            return [];\n        }\n        _update_layout() {\n            this.layout = new layout_1.LayoutItem();\n            this.layout.set_sizing(this.box_sizing());\n        }\n    }\n    exports.SpacerView = SpacerView;\n    SpacerView.__name__ = \"SpacerView\";\n    class Spacer extends layout_dom_1.LayoutDOM {\n        constructor(attrs) {\n            super(attrs);\n        }\n        static init_Spacer() {\n            this.prototype.default_view = SpacerView;\n        }\n    }\n    exports.Spacer = Spacer;\n    Spacer.__name__ = \"Spacer\";\n    Spacer.init_Spacer();\n}\n","/* models/layouts/tabs.js */ function _(require, module, exports) {\n    const layout_1 = require(180) /* ../../core/layout */;\n    const dom_1 = require(61) /* ../../core/dom */;\n    const array_1 = require(8) /* ../../core/util/array */;\n    const p = require(18) /* ../../core/properties */;\n    const layout_dom_1 = require(237) /* ./layout_dom */;\n    const model_1 = require(64) /* ../../model */;\n    const mixins_1 = require(138) /* ../../styles/mixins */;\n    const tabs_1 = require(244) /* ../../styles/tabs */;\n    const buttons_1 = require(245) /* ../../styles/buttons */;\n    const menus_1 = require(246) /* ../../styles/menus */;\n    class TabsView extends layout_dom_1.LayoutDOMView {\n        connect_signals() {\n            super.connect_signals();\n            this.connect(this.model.properties.tabs.change, () => this.rebuild());\n            this.connect(this.model.properties.active.change, () => this.on_active_change());\n        }\n        get child_models() {\n            return this.model.tabs.map((tab) => tab.child);\n        }\n        _update_layout() {\n            const loc = this.model.tabs_location;\n            const vertical = loc == \"above\" || loc == \"below\";\n            // XXX: this is a hack, this should be handled by \"fit\" policy in grid layout\n            const { scroll_el, headers_el } = this;\n            this.header = new class extends layout_1.ContentBox {\n                _measure(viewport) {\n                    const min_headers = 3;\n                    const scroll = dom_1.size(scroll_el);\n                    const headers = dom_1.children(headers_el).slice(0, min_headers).map((el) => dom_1.size(el));\n                    const { width, height } = super._measure(viewport);\n                    if (vertical) {\n                        const min_width = scroll.width + array_1.sum(headers.map((size) => size.width));\n                        return { width: viewport.width != Infinity ? viewport.width : min_width, height };\n                    }\n                    else {\n                        const min_height = scroll.height + array_1.sum(headers.map((size) => size.height));\n                        return { width, height: viewport.height != Infinity ? viewport.height : min_height };\n                    }\n                }\n            }(this.header_el);\n            if (vertical)\n                this.header.set_sizing({ width_policy: \"fit\", height_policy: \"fixed\" });\n            else\n                this.header.set_sizing({ width_policy: \"fixed\", height_policy: \"fit\" });\n            let row = 1;\n            let col = 1;\n            switch (loc) {\n                case \"above\":\n                    row -= 1;\n                    break;\n                case \"below\":\n                    row += 1;\n                    break;\n                case \"left\":\n                    col -= 1;\n                    break;\n                case \"right\":\n                    col += 1;\n                    break;\n            }\n            const header = { layout: this.header, row, col };\n            const panels = this.child_views.map((child_view) => {\n                return { layout: child_view.layout, row: 1, col: 1 };\n            });\n            this.layout = new layout_1.Grid([header, ...panels]);\n            this.layout.set_sizing(this.box_sizing());\n        }\n        update_position() {\n            super.update_position();\n            this.header_el.style.position = \"absolute\"; // XXX: do it in position()\n            dom_1.position(this.header_el, this.header.bbox);\n            const loc = this.model.tabs_location;\n            const vertical = loc == \"above\" || loc == \"below\";\n            const scroll_el_size = dom_1.size(this.scroll_el);\n            const headers_el_size = dom_1.scroll_size(this.headers_el);\n            if (vertical) {\n                const { width } = this.header.bbox;\n                if (headers_el_size.width > width) {\n                    this.wrapper_el.style.maxWidth = `${width - scroll_el_size.width}px`;\n                    dom_1.display(this.scroll_el);\n                }\n                else {\n                    this.wrapper_el.style.maxWidth = \"\";\n                    dom_1.undisplay(this.scroll_el);\n                }\n            }\n            else {\n                const { height } = this.header.bbox;\n                if (headers_el_size.height > height) {\n                    this.wrapper_el.style.maxHeight = `${height - scroll_el_size.height}px`;\n                    dom_1.display(this.scroll_el);\n                }\n                else {\n                    this.wrapper_el.style.maxHeight = \"\";\n                    dom_1.undisplay(this.scroll_el);\n                }\n            }\n            const { child_views } = this;\n            for (const child_view of child_views)\n                dom_1.hide(child_view.el);\n            const tab = child_views[this.model.active];\n            if (tab != null)\n                dom_1.show(tab.el);\n        }\n        render() {\n            super.render();\n            const { active } = this.model;\n            const loc = this.model.tabs_location;\n            const vertical = loc == \"above\" || loc == \"below\";\n            const headers = this.model.tabs.map((tab, i) => {\n                const el = dom_1.div({ class: [tabs_1.bk_tab, i == active ? mixins_1.bk_active : null] }, tab.title);\n                el.addEventListener(\"click\", (event) => {\n                    if (event.target == event.currentTarget)\n                        this.change_active(i);\n                });\n                if (tab.closable) {\n                    const close_el = dom_1.div({ class: tabs_1.bk_close });\n                    close_el.addEventListener(\"click\", (event) => {\n                        if (event.target == event.currentTarget) {\n                            this.model.tabs = array_1.remove_at(this.model.tabs, i);\n                            const ntabs = this.model.tabs.length;\n                            if (this.model.active > ntabs - 1)\n                                this.model.active = ntabs - 1;\n                        }\n                    });\n                    el.appendChild(close_el);\n                }\n                return el;\n            });\n            this.headers_el = dom_1.div({ class: [tabs_1.bk_headers] }, headers);\n            this.wrapper_el = dom_1.div({ class: tabs_1.bk_headers_wrapper }, this.headers_el);\n            const left_el = dom_1.div({ class: [buttons_1.bk_btn, buttons_1.bk_btn_default], disabled: \"\" }, dom_1.div({ class: [menus_1.bk_caret, mixins_1.bk_left] }));\n            const right_el = dom_1.div({ class: [buttons_1.bk_btn, buttons_1.bk_btn_default] }, dom_1.div({ class: [menus_1.bk_caret, mixins_1.bk_right] }));\n            let scroll_index = 0;\n            const do_scroll = (dir) => {\n                return () => {\n                    const ntabs = this.model.tabs.length;\n                    if (dir == \"left\")\n                        scroll_index = Math.max(scroll_index - 1, 0);\n                    else\n                        scroll_index = Math.min(scroll_index + 1, ntabs - 1);\n                    if (scroll_index == 0)\n                        left_el.setAttribute(\"disabled\", \"\");\n                    else\n                        left_el.removeAttribute(\"disabled\");\n                    if (scroll_index == ntabs - 1)\n                        right_el.setAttribute(\"disabled\", \"\");\n                    else\n                        right_el.removeAttribute(\"disabled\");\n                    const sizes = dom_1.children(this.headers_el)\n                        .slice(0, scroll_index)\n                        .map((el) => el.getBoundingClientRect());\n                    if (vertical) {\n                        const left = -array_1.sum(sizes.map((size) => size.width));\n                        this.headers_el.style.left = `${left}px`;\n                    }\n                    else {\n                        const top = -array_1.sum(sizes.map((size) => size.height));\n                        this.headers_el.style.top = `${top}px`;\n                    }\n                };\n            };\n            left_el.addEventListener(\"click\", do_scroll(\"left\"));\n            right_el.addEventListener(\"click\", do_scroll(\"right\"));\n            this.scroll_el = dom_1.div({ class: buttons_1.bk_btn_group }, left_el, right_el);\n            this.header_el = dom_1.div({ class: [tabs_1.bk_tabs_header, mixins_1.bk_side(loc)] }, this.scroll_el, this.wrapper_el);\n            this.el.appendChild(this.header_el);\n        }\n        change_active(i) {\n            if (i != this.model.active) {\n                this.model.active = i;\n                if (this.model.callback != null)\n                    this.model.callback.execute(this.model);\n            }\n        }\n        on_active_change() {\n            const i = this.model.active;\n            const headers = dom_1.children(this.headers_el);\n            for (const el of headers)\n                el.classList.remove(mixins_1.bk_active);\n            headers[i].classList.add(mixins_1.bk_active);\n            const { child_views } = this;\n            for (const child_view of child_views)\n                dom_1.hide(child_view.el);\n            dom_1.show(child_views[i].el);\n        }\n    }\n    exports.TabsView = TabsView;\n    TabsView.__name__ = \"TabsView\";\n    class Tabs extends layout_dom_1.LayoutDOM {\n        constructor(attrs) {\n            super(attrs);\n        }\n        static init_Tabs() {\n            this.prototype.default_view = TabsView;\n            this.define({\n                tabs: [p.Array, []],\n                tabs_location: [p.Location, \"above\"],\n                active: [p.Number, 0],\n                callback: [p.Any],\n            });\n        }\n    }\n    exports.Tabs = Tabs;\n    Tabs.__name__ = \"Tabs\";\n    Tabs.init_Tabs();\n    class Panel extends model_1.Model {\n        constructor(attrs) {\n            super(attrs);\n        }\n        static init_Panel() {\n            this.define({\n                title: [p.String, \"\"],\n                child: [p.Instance],\n                closable: [p.Boolean, false],\n            });\n        }\n    }\n    exports.Panel = Panel;\n    Panel.__name__ = \"Panel\";\n    Panel.init_Panel();\n}\n","/* styles/tabs.js */ function _(require, module, exports) {\n    require(62) /* ./root */;\n    const _a = require(61) /* ../core/dom */;\n    _a.styles.append(\".bk-root .bk-tabs-header {\\n  display: flex;\\n  display: -webkit-flex;\\n  flex-wrap: nowrap;\\n  -webkit-flex-wrap: nowrap;\\n  align-items: center;\\n  -webkit-align-items: center;\\n  overflow: hidden;\\n  user-select: none;\\n  -ms-user-select: none;\\n  -moz-user-select: none;\\n  -webkit-user-select: none;\\n}\\n.bk-root .bk-tabs-header .bk-btn-group {\\n  height: auto;\\n  margin-right: 5px;\\n}\\n.bk-root .bk-tabs-header .bk-btn-group > .bk-btn {\\n  flex-grow: 0;\\n  -webkit-flex-grow: 0;\\n  height: auto;\\n  padding: 4px 4px;\\n}\\n.bk-root .bk-tabs-header .bk-headers-wrapper {\\n  flex-grow: 1;\\n  -webkit-flex-grow: 1;\\n  overflow: hidden;\\n  color: #666666;\\n}\\n.bk-root .bk-tabs-header.bk-above .bk-headers-wrapper {\\n  border-bottom: 1px solid #e6e6e6;\\n}\\n.bk-root .bk-tabs-header.bk-right .bk-headers-wrapper {\\n  border-left: 1px solid #e6e6e6;\\n}\\n.bk-root .bk-tabs-header.bk-below .bk-headers-wrapper {\\n  border-top: 1px solid #e6e6e6;\\n}\\n.bk-root .bk-tabs-header.bk-left .bk-headers-wrapper {\\n  border-right: 1px solid #e6e6e6;\\n}\\n.bk-root .bk-tabs-header.bk-above,\\n.bk-root .bk-tabs-header.bk-below {\\n  flex-direction: row;\\n  -webkit-flex-direction: row;\\n}\\n.bk-root .bk-tabs-header.bk-above .bk-headers,\\n.bk-root .bk-tabs-header.bk-below .bk-headers {\\n  flex-direction: row;\\n  -webkit-flex-direction: row;\\n}\\n.bk-root .bk-tabs-header.bk-left,\\n.bk-root .bk-tabs-header.bk-right {\\n  flex-direction: column;\\n  -webkit-flex-direction: column;\\n}\\n.bk-root .bk-tabs-header.bk-left .bk-headers,\\n.bk-root .bk-tabs-header.bk-right .bk-headers {\\n  flex-direction: column;\\n  -webkit-flex-direction: column;\\n}\\n.bk-root .bk-tabs-header .bk-headers {\\n  position: relative;\\n  display: flex;\\n  display: -webkit-flex;\\n  flex-wrap: nowrap;\\n  -webkit-flex-wrap: nowrap;\\n  align-items: center;\\n  -webkit-align-items: center;\\n}\\n.bk-root .bk-tabs-header .bk-tab {\\n  padding: 4px 8px;\\n  border: solid transparent;\\n  white-space: nowrap;\\n  cursor: pointer;\\n}\\n.bk-root .bk-tabs-header .bk-tab:hover {\\n  background-color: #f2f2f2;\\n}\\n.bk-root .bk-tabs-header .bk-tab.bk-active {\\n  color: #4d4d4d;\\n  background-color: white;\\n  border-color: #e6e6e6;\\n}\\n.bk-root .bk-tabs-header .bk-tab .bk-close {\\n  margin-left: 10px;\\n}\\n.bk-root .bk-tabs-header.bk-above .bk-tab {\\n  border-width: 3px 1px 0px 1px;\\n  border-radius: 4px 4px 0 0;\\n}\\n.bk-root .bk-tabs-header.bk-right .bk-tab {\\n  border-width: 1px 3px 1px 0px;\\n  border-radius: 0 4px 4px 0;\\n}\\n.bk-root .bk-tabs-header.bk-below .bk-tab {\\n  border-width: 0px 1px 3px 1px;\\n  border-radius: 0 0 4px 4px;\\n}\\n.bk-root .bk-tabs-header.bk-left .bk-tab {\\n  border-width: 1px 0px 1px 3px;\\n  border-radius: 4px 0 0 4px;\\n}\\n.bk-root .bk-close {\\n  display: inline-block;\\n  width: 10px;\\n  height: 10px;\\n  vertical-align: middle;\\n  background-image: url('data:image/svg+xml;utf8,\\\\\\n      <svg viewPort=\\\"0 0 10 10\\\" version=\\\"1.1\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\">\\\\\\n        <line x1=\\\"1\\\" y1=\\\"9\\\" x2=\\\"9\\\" y2=\\\"1\\\" stroke=\\\"gray\\\" stroke-width=\\\"2\\\"/>\\\\\\n        <line x1=\\\"1\\\" y1=\\\"1\\\" x2=\\\"9\\\" y2=\\\"9\\\" stroke=\\\"gray\\\" stroke-width=\\\"2\\\"/>\\\\\\n      </svg>');\\n}\\n.bk-root .bk-close:hover {\\n  background-image: url('data:image/svg+xml;utf8,\\\\\\n      <svg viewPort=\\\"0 0 10 10\\\" version=\\\"1.1\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\">\\\\\\n        <line x1=\\\"1\\\" y1=\\\"9\\\" x2=\\\"9\\\" y2=\\\"1\\\" stroke=\\\"red\\\" stroke-width=\\\"2\\\"/>\\\\\\n        <line x1=\\\"1\\\" y1=\\\"1\\\" x2=\\\"9\\\" y2=\\\"9\\\" stroke=\\\"red\\\" stroke-width=\\\"2\\\"/>\\\\\\n      </svg>');\\n}\\n\");\n    exports.bk_tabs_header = \"bk-tabs-header\";\n    exports.bk_headers_wrapper = \"bk-headers-wrapper\";\n    exports.bk_headers = \"bk-headers\";\n    exports.bk_tab = \"bk-tab\";\n    exports.bk_close = \"bk-close\";\n}\n","/* styles/buttons.js */ function _(require, module, exports) {\n    require(62) /* ./root */;\n    const _a = require(61) /* ../core/dom */;\n    _a.styles.append(\".bk-root .bk-btn {\\n  height: 100%;\\n  display: inline-block;\\n  text-align: center;\\n  vertical-align: middle;\\n  white-space: nowrap;\\n  cursor: pointer;\\n  padding: 6px 12px;\\n  font-size: 12px;\\n  border: 1px solid transparent;\\n  border-radius: 4px;\\n  outline: 0;\\n  user-select: none;\\n  -ms-user-select: none;\\n  -moz-user-select: none;\\n  -webkit-user-select: none;\\n}\\n.bk-root .bk-btn:hover,\\n.bk-root .bk-btn:focus {\\n  text-decoration: none;\\n}\\n.bk-root .bk-btn:active,\\n.bk-root .bk-btn.bk-active {\\n  background-image: none;\\n  box-shadow: inset 0 3px 5px rgba(0, 0, 0, 0.125);\\n}\\n.bk-root .bk-btn[disabled] {\\n  cursor: not-allowed;\\n  pointer-events: none;\\n  opacity: 0.65;\\n  box-shadow: none;\\n}\\n.bk-root .bk-btn-default {\\n  color: #333;\\n  background-color: #fff;\\n  border-color: #ccc;\\n}\\n.bk-root .bk-btn-default:hover {\\n  background-color: #f5f5f5;\\n  border-color: #b8b8b8;\\n}\\n.bk-root .bk-btn-default.bk-active {\\n  background-color: #ebebeb;\\n  border-color: #adadad;\\n}\\n.bk-root .bk-btn-default[disabled],\\n.bk-root .bk-btn-default[disabled]:hover,\\n.bk-root .bk-btn-default[disabled]:focus,\\n.bk-root .bk-btn-default[disabled]:active,\\n.bk-root .bk-btn-default[disabled].bk-active {\\n  background-color: #e6e6e6;\\n  border-color: #ccc;\\n}\\n.bk-root .bk-btn-primary {\\n  color: #fff;\\n  background-color: #428bca;\\n  border-color: #357ebd;\\n}\\n.bk-root .bk-btn-primary:hover {\\n  background-color: #3681c1;\\n  border-color: #2c699e;\\n}\\n.bk-root .bk-btn-primary.bk-active {\\n  background-color: #3276b1;\\n  border-color: #285e8e;\\n}\\n.bk-root .bk-btn-primary[disabled],\\n.bk-root .bk-btn-primary[disabled]:hover,\\n.bk-root .bk-btn-primary[disabled]:focus,\\n.bk-root .bk-btn-primary[disabled]:active,\\n.bk-root .bk-btn-primary[disabled].bk-active {\\n  background-color: #506f89;\\n  border-color: #357ebd;\\n}\\n.bk-root .bk-btn-success {\\n  color: #fff;\\n  background-color: #5cb85c;\\n  border-color: #4cae4c;\\n}\\n.bk-root .bk-btn-success:hover {\\n  background-color: #4eb24e;\\n  border-color: #409240;\\n}\\n.bk-root .bk-btn-success.bk-active {\\n  background-color: #47a447;\\n  border-color: #398439;\\n}\\n.bk-root .bk-btn-success[disabled],\\n.bk-root .bk-btn-success[disabled]:hover,\\n.bk-root .bk-btn-success[disabled]:focus,\\n.bk-root .bk-btn-success[disabled]:active,\\n.bk-root .bk-btn-success[disabled].bk-active {\\n  background-color: #667b66;\\n  border-color: #4cae4c;\\n}\\n.bk-root .bk-btn-warning {\\n  color: #fff;\\n  background-color: #f0ad4e;\\n  border-color: #eea236;\\n}\\n.bk-root .bk-btn-warning:hover {\\n  background-color: #eea43b;\\n  border-color: #e89014;\\n}\\n.bk-root .bk-btn-warning.bk-active {\\n  background-color: #ed9c28;\\n  border-color: #d58512;\\n}\\n.bk-root .bk-btn-warning[disabled],\\n.bk-root .bk-btn-warning[disabled]:hover,\\n.bk-root .bk-btn-warning[disabled]:focus,\\n.bk-root .bk-btn-warning[disabled]:active,\\n.bk-root .bk-btn-warning[disabled].bk-active {\\n  background-color: #c89143;\\n  border-color: #eea236;\\n}\\n.bk-root .bk-btn-danger {\\n  color: #fff;\\n  background-color: #d9534f;\\n  border-color: #d43f3a;\\n}\\n.bk-root .bk-btn-danger:hover {\\n  background-color: #d5433e;\\n  border-color: #bd2d29;\\n}\\n.bk-root .bk-btn-danger.bk-active {\\n  background-color: #d2322d;\\n  border-color: #ac2925;\\n}\\n.bk-root .bk-btn-danger[disabled],\\n.bk-root .bk-btn-danger[disabled]:hover,\\n.bk-root .bk-btn-danger[disabled]:focus,\\n.bk-root .bk-btn-danger[disabled]:active,\\n.bk-root .bk-btn-danger[disabled].bk-active {\\n  background-color: #a55350;\\n  border-color: #d43f3a;\\n}\\n.bk-root .bk-btn-group {\\n  height: 100%;\\n  display: flex;\\n  display: -webkit-flex;\\n  flex-wrap: nowrap;\\n  -webkit-flex-wrap: nowrap;\\n  align-items: center;\\n  -webkit-align-items: center;\\n  flex-direction: row;\\n  -webkit-flex-direction: row;\\n}\\n.bk-root .bk-btn-group > .bk-btn {\\n  flex-grow: 1;\\n  -webkit-flex-grow: 1;\\n}\\n.bk-root .bk-btn-group > .bk-btn + .bk-btn {\\n  margin-left: -1px;\\n}\\n.bk-root .bk-btn-group > .bk-btn:first-child:not(:last-child) {\\n  border-bottom-right-radius: 0;\\n  border-top-right-radius: 0;\\n}\\n.bk-root .bk-btn-group > .bk-btn:not(:first-child):last-child {\\n  border-bottom-left-radius: 0;\\n  border-top-left-radius: 0;\\n}\\n.bk-root .bk-btn-group > .bk-btn:not(:first-child):not(:last-child) {\\n  border-radius: 0;\\n}\\n.bk-root .bk-btn-group .bk-dropdown-toggle {\\n  flex: 0 0 0;\\n  -webkit-flex: 0 0 0;\\n  padding: 6px 6px;\\n}\\n\");\n    exports.bk_btn = \"bk-btn\";\n    exports.bk_btn_group = \"bk-btn-group\";\n    exports.bk_btn_default = \"bk-btn-default\";\n    exports.bk_btn_primary = \"bk-btn-primary\";\n    exports.bk_btn_success = \"bk-btn-success\";\n    exports.bk_btn_warning = \"bk-btn-warning\";\n    exports.bk_btn_danger = \"bk-btn-danger\";\n    function bk_btn_type(button_type) {\n        switch (button_type) {\n            case \"default\": return exports.bk_btn_default;\n            case \"primary\": return exports.bk_btn_primary;\n            case \"success\": return exports.bk_btn_success;\n            case \"warning\": return exports.bk_btn_warning;\n            case \"danger\": return exports.bk_btn_danger;\n        }\n    }\n    exports.bk_btn_type = bk_btn_type;\n    exports.bk_dropdown_toggle = \"bk-dropdown-toggle\";\n}\n","/* styles/menus.js */ function _(require, module, exports) {\n    require(62) /* ./root */;\n    const _a = require(61) /* ../core/dom */;\n    _a.styles.append(\".bk-root .bk-menu {\\n  position: absolute;\\n  left: 0;\\n  width: 100%;\\n  z-index: 100;\\n  cursor: pointer;\\n  font-size: 12px;\\n  background-color: #fff;\\n  border: 1px solid #ccc;\\n  border-radius: 4px;\\n  box-shadow: 0 6px 12px rgba(0, 0, 0, 0.175);\\n}\\n.bk-root .bk-menu.bk-above {\\n  bottom: 100%;\\n}\\n.bk-root .bk-menu.bk-below {\\n  top: 100%;\\n}\\n.bk-root .bk-menu > .bk-divider {\\n  height: 1px;\\n  margin: 7.5px 0;\\n  overflow: hidden;\\n  background-color: #e5e5e5;\\n}\\n.bk-root .bk-menu > :not(.bk-divider) {\\n  padding: 6px 12px;\\n}\\n.bk-root .bk-menu > :not(.bk-divider):hover,\\n.bk-root .bk-menu > :not(.bk-divider).bk-active {\\n  background-color: #e6e6e6;\\n}\\n.bk-root .bk-caret {\\n  display: inline-block;\\n  vertical-align: middle;\\n  width: 0;\\n  height: 0;\\n  margin: 0 5px;\\n}\\n.bk-root .bk-caret.bk-down {\\n  border-top: 4px solid;\\n}\\n.bk-root .bk-caret.bk-up {\\n  border-bottom: 4px solid;\\n}\\n.bk-root .bk-caret.bk-down,\\n.bk-root .bk-caret.bk-up {\\n  border-right: 4px solid transparent;\\n  border-left: 4px solid transparent;\\n}\\n.bk-root .bk-caret.bk-left {\\n  border-right: 4px solid;\\n}\\n.bk-root .bk-caret.bk-right {\\n  border-left: 4px solid;\\n}\\n.bk-root .bk-caret.bk-left,\\n.bk-root .bk-caret.bk-right {\\n  border-top: 4px solid transparent;\\n  border-bottom: 4px solid transparent;\\n}\\n\");\n    exports.bk_menu = \"bk-menu\";\n    exports.bk_caret = \"bk-caret\";\n    exports.bk_divider = \"bk-divider\";\n}\n","/* models/layouts/widget_box.js */ function _(require, module, exports) {\n    const column_1 = require(238) /* ./column */;\n    class WidgetBoxView extends column_1.ColumnView {\n    }\n    exports.WidgetBoxView = WidgetBoxView;\n    WidgetBoxView.__name__ = \"WidgetBoxView\";\n    class WidgetBox extends column_1.Column {\n        constructor(attrs) {\n            super(attrs);\n        }\n        static init_WidgetBox() {\n            this.prototype.default_view = WidgetBoxView;\n        }\n    }\n    exports.WidgetBox = WidgetBox;\n    WidgetBox.__name__ = \"WidgetBox\";\n    WidgetBox.init_WidgetBox();\n}\n","/* models/mappers/index.js */ function _(require, module, exports) {\n    var categorical_color_mapper_1 = require(249) /* ./categorical_color_mapper */;\n    exports.CategoricalColorMapper = categorical_color_mapper_1.CategoricalColorMapper;\n    var categorical_marker_mapper_1 = require(251) /* ./categorical_marker_mapper */;\n    exports.CategoricalMarkerMapper = categorical_marker_mapper_1.CategoricalMarkerMapper;\n    var categorical_pattern_mapper_1 = require(252) /* ./categorical_pattern_mapper */;\n    exports.CategoricalPatternMapper = categorical_pattern_mapper_1.CategoricalPatternMapper;\n    var continuous_color_mapper_1 = require(109) /* ./continuous_color_mapper */;\n    exports.ContinuousColorMapper = continuous_color_mapper_1.ContinuousColorMapper;\n    var color_mapper_1 = require(110) /* ./color_mapper */;\n    exports.ColorMapper = color_mapper_1.ColorMapper;\n    var linear_color_mapper_1 = require(108) /* ./linear_color_mapper */;\n    exports.LinearColorMapper = linear_color_mapper_1.LinearColorMapper;\n    var log_color_mapper_1 = require(253) /* ./log_color_mapper */;\n    exports.LogColorMapper = log_color_mapper_1.LogColorMapper;\n}\n","/* models/mappers/categorical_color_mapper.js */ function _(require, module, exports) {\n    const categorical_mapper_1 = require(250) /* ./categorical_mapper */;\n    const color_mapper_1 = require(110) /* ./color_mapper */;\n    const p = require(18) /* ../../core/properties */;\n    class CategoricalColorMapper extends color_mapper_1.ColorMapper {\n        constructor(attrs) {\n            super(attrs);\n        }\n        static init_CategoricalColorMapper() {\n            this.define({\n                factors: [p.Array],\n                start: [p.Number, 0],\n                end: [p.Number],\n            });\n        }\n        _v_compute(data, values, palette, { nan_color }) {\n            categorical_mapper_1.cat_v_compute(data, this.factors, palette, values, this.start, this.end, nan_color);\n        }\n    }\n    exports.CategoricalColorMapper = CategoricalColorMapper;\n    CategoricalColorMapper.__name__ = \"CategoricalColorMapper\";\n    CategoricalColorMapper.init_CategoricalColorMapper();\n}\n","/* models/mappers/categorical_mapper.js */ function _(require, module, exports) {\n    const arrayable_1 = require(11) /* ../../core/util/arrayable */;\n    const types_1 = require(7) /* ../../core/util/types */;\n    function _cat_equals(a, b) {\n        if (a.length != b.length)\n            return false;\n        for (let i = 0, end = a.length; i < end; i++) {\n            if (a[i] !== b[i])\n                return false;\n        }\n        return true;\n    }\n    exports._cat_equals = _cat_equals;\n    function cat_v_compute(data, factors, targets, values, start, end, extra_value) {\n        for (let i = 0, N = data.length; i < N; i++) {\n            let d = data[i];\n            let key;\n            if (types_1.isString(d))\n                key = arrayable_1.index_of(factors, d);\n            else {\n                if (start != null) {\n                    if (end != null)\n                        d = d.slice(start, end);\n                    else\n                        d = d.slice(start);\n                }\n                else if (end != null)\n                    d = d.slice(0, end);\n                if (d.length == 1)\n                    key = arrayable_1.index_of(factors, d[0]);\n                else\n                    key = arrayable_1.find_index(factors, (x) => _cat_equals(x, d));\n            }\n            let value;\n            if (key < 0 || key >= targets.length)\n                value = extra_value;\n            else\n                value = targets[key];\n            values[i] = value;\n        }\n    }\n    exports.cat_v_compute = cat_v_compute;\n}\n","/* models/mappers/categorical_marker_mapper.js */ function _(require, module, exports) {\n    const categorical_mapper_1 = require(250) /* ./categorical_mapper */;\n    const mapper_1 = require(111) /* ./mapper */;\n    const p = require(18) /* ../../core/properties */;\n    class CategoricalMarkerMapper extends mapper_1.Mapper {\n        constructor(attrs) {\n            super(attrs);\n        }\n        static init_CategoricalMarkerMapper() {\n            this.define({\n                factors: [p.Array],\n                markers: [p.Array],\n                start: [p.Number, 0],\n                end: [p.Number],\n                default_value: [p.MarkerType, \"circle\"],\n            });\n        }\n        v_compute(xs) {\n            const values = new Array(xs.length);\n            categorical_mapper_1.cat_v_compute(xs, this.factors, this.markers, values, this.start, this.end, this.default_value);\n            return values;\n        }\n    }\n    exports.CategoricalMarkerMapper = CategoricalMarkerMapper;\n    CategoricalMarkerMapper.__name__ = \"CategoricalMarkerMapper\";\n    CategoricalMarkerMapper.init_CategoricalMarkerMapper();\n}\n","/* models/mappers/categorical_pattern_mapper.js */ function _(require, module, exports) {\n    const categorical_mapper_1 = require(250) /* ./categorical_mapper */;\n    const mapper_1 = require(111) /* ./mapper */;\n    const p = require(18) /* ../../core/properties */;\n    class CategoricalPatternMapper extends mapper_1.Mapper {\n        constructor(attrs) {\n            super(attrs);\n        }\n        static init_CategoricalPatternMapper() {\n            this.define({\n                factors: [p.Array],\n                patterns: [p.Array],\n                start: [p.Number, 0],\n                end: [p.Number],\n                default_value: [p.HatchPatternType, \" \"],\n            });\n        }\n        v_compute(xs) {\n            const values = new Array(xs.length);\n            categorical_mapper_1.cat_v_compute(xs, this.factors, this.patterns, values, this.start, this.end, this.default_value);\n            return values;\n        }\n    }\n    exports.CategoricalPatternMapper = CategoricalPatternMapper;\n    CategoricalPatternMapper.__name__ = \"CategoricalPatternMapper\";\n    CategoricalPatternMapper.init_CategoricalPatternMapper();\n}\n","/* models/mappers/log_color_mapper.js */ function _(require, module, exports) {\n    const continuous_color_mapper_1 = require(109) /* ./continuous_color_mapper */;\n    const arrayable_1 = require(11) /* ../../core/util/arrayable */;\n    // Math.log1p() is not supported by any version of IE, so let's use a polyfill based on\n    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/log1p.\n    const log1p = Math.log1p != null ? Math.log1p : (x) => Math.log(1 + x);\n    class LogColorMapper extends continuous_color_mapper_1.ContinuousColorMapper {\n        constructor(attrs) {\n            super(attrs);\n        }\n        _v_compute(data, values, palette, colors) {\n            const { nan_color, low_color, high_color } = colors;\n            const n = palette.length;\n            const low = this.low != null ? this.low : arrayable_1.min(data);\n            const high = this.high != null ? this.high : arrayable_1.max(data);\n            const scale = n / (log1p(high) - log1p(low)); // subtract the low offset\n            const max_key = palette.length - 1;\n            for (let i = 0, end = data.length; i < end; i++) {\n                const d = data[i];\n                // Check NaN\n                if (isNaN(d)) {\n                    values[i] = nan_color;\n                    continue;\n                }\n                if (d > high) {\n                    values[i] = high_color != null ? high_color : palette[max_key];\n                    continue;\n                }\n                // This handles the edge case where d == high, since the code below maps\n                // values exactly equal to high to palette.length, which is greater than\n                // max_key\n                if (d == high) {\n                    values[i] = palette[max_key];\n                    continue;\n                }\n                if (d < low) {\n                    values[i] = low_color != null ? low_color : palette[0];\n                    continue;\n                }\n                // Get the key\n                const log = log1p(d) - log1p(low); // subtract the low offset\n                let key = Math.floor(log * scale);\n                // Deal with upper bound\n                if (key > max_key)\n                    key = max_key;\n                values[i] = palette[key];\n            }\n        }\n    }\n    exports.LogColorMapper = LogColorMapper;\n    LogColorMapper.__name__ = \"LogColorMapper\";\n}\n","/* models/markers/index.js */ function _(require, module, exports) {\n    function __export(m) {\n        for (var p in m)\n            if (!exports.hasOwnProperty(p))\n                exports[p] = m[p];\n    }\n    __export(require(255) /* ./defs */);\n    var marker_1 = require(256) /* ./marker */;\n    exports.Marker = marker_1.Marker;\n    var scatter_1 = require(257) /* ./scatter */;\n    exports.Scatter = scatter_1.Scatter;\n}\n","/* models/markers/defs.js */ function _(require, module, exports) {\n    const marker_1 = require(256) /* ./marker */;\n    const SQ3 = Math.sqrt(3);\n    function _one_line(ctx, r) {\n        ctx.moveTo(-r, 0);\n        ctx.lineTo(r, 0);\n    }\n    function _one_x(ctx, r) {\n        ctx.moveTo(-r, r);\n        ctx.lineTo(r, -r);\n        ctx.moveTo(-r, -r);\n        ctx.lineTo(r, r);\n    }\n    function _one_cross(ctx, r) {\n        ctx.moveTo(0, r);\n        ctx.lineTo(0, -r);\n        ctx.moveTo(-r, 0);\n        ctx.lineTo(r, 0);\n    }\n    function _one_diamond(ctx, r) {\n        ctx.moveTo(0, r);\n        ctx.lineTo(r / 1.5, 0);\n        ctx.lineTo(0, -r);\n        ctx.lineTo(-r / 1.5, 0);\n        ctx.closePath();\n    }\n    function _one_hex(ctx, r) {\n        const r2 = r / 2;\n        const h = SQ3 * r2;\n        ctx.moveTo(r, 0);\n        ctx.lineTo(r2, -h);\n        ctx.lineTo(-r2, -h);\n        ctx.lineTo(-r, 0);\n        ctx.lineTo(-r2, h);\n        ctx.lineTo(r2, h);\n        ctx.closePath();\n    }\n    function _one_tri(ctx, r) {\n        const h = r * SQ3;\n        const a = h / 3;\n        ctx.moveTo(-r, a);\n        ctx.lineTo(r, a);\n        ctx.lineTo(0, a - h);\n        ctx.closePath();\n    }\n    function asterisk(ctx, i, r, line, _fill) {\n        const r2 = r * 0.65;\n        _one_cross(ctx, r);\n        _one_x(ctx, r2);\n        if (line.doit) {\n            line.set_vectorize(ctx, i);\n            ctx.stroke();\n        }\n    }\n    function circle(ctx, i, r, line, fill) {\n        ctx.arc(0, 0, r, 0, 2 * Math.PI, false);\n        if (fill.doit) {\n            fill.set_vectorize(ctx, i);\n            ctx.fill();\n        }\n        if (line.doit) {\n            line.set_vectorize(ctx, i);\n            ctx.stroke();\n        }\n    }\n    function circle_cross(ctx, i, r, line, fill) {\n        ctx.arc(0, 0, r, 0, 2 * Math.PI, false);\n        if (fill.doit) {\n            fill.set_vectorize(ctx, i);\n            ctx.fill();\n        }\n        if (line.doit) {\n            line.set_vectorize(ctx, i);\n            _one_cross(ctx, r);\n            ctx.stroke();\n        }\n    }\n    function circle_x(ctx, i, r, line, fill) {\n        ctx.arc(0, 0, r, 0, 2 * Math.PI, false);\n        if (fill.doit) {\n            fill.set_vectorize(ctx, i);\n            ctx.fill();\n        }\n        if (line.doit) {\n            line.set_vectorize(ctx, i);\n            _one_x(ctx, r);\n            ctx.stroke();\n        }\n    }\n    function cross(ctx, i, r, line, _fill) {\n        _one_cross(ctx, r);\n        if (line.doit) {\n            line.set_vectorize(ctx, i);\n            ctx.stroke();\n        }\n    }\n    function diamond(ctx, i, r, line, fill) {\n        _one_diamond(ctx, r);\n        if (fill.doit) {\n            fill.set_vectorize(ctx, i);\n            ctx.fill();\n        }\n        if (line.doit) {\n            line.set_vectorize(ctx, i);\n            ctx.stroke();\n        }\n    }\n    function diamond_cross(ctx, i, r, line, fill) {\n        _one_diamond(ctx, r);\n        if (fill.doit) {\n            fill.set_vectorize(ctx, i);\n            ctx.fill();\n        }\n        if (line.doit) {\n            line.set_vectorize(ctx, i);\n            _one_cross(ctx, r);\n            ctx.stroke();\n        }\n    }\n    function hex(ctx, i, r, line, fill) {\n        _one_hex(ctx, r);\n        if (fill.doit) {\n            fill.set_vectorize(ctx, i);\n            ctx.fill();\n        }\n        if (line.doit) {\n            line.set_vectorize(ctx, i);\n            ctx.stroke();\n        }\n    }\n    function inverted_triangle(ctx, i, r, line, fill) {\n        ctx.rotate(Math.PI);\n        _one_tri(ctx, r);\n        ctx.rotate(-Math.PI);\n        if (fill.doit) {\n            fill.set_vectorize(ctx, i);\n            ctx.fill();\n        }\n        if (line.doit) {\n            line.set_vectorize(ctx, i);\n            ctx.stroke();\n        }\n    }\n    function square(ctx, i, r, line, fill) {\n        const size = 2 * r;\n        ctx.rect(-r, -r, size, size);\n        if (fill.doit) {\n            fill.set_vectorize(ctx, i);\n            ctx.fill();\n        }\n        if (line.doit) {\n            line.set_vectorize(ctx, i);\n            ctx.stroke();\n        }\n    }\n    function square_cross(ctx, i, r, line, fill) {\n        const size = 2 * r;\n        ctx.rect(-r, -r, size, size);\n        if (fill.doit) {\n            fill.set_vectorize(ctx, i);\n            ctx.fill();\n        }\n        if (line.doit) {\n            line.set_vectorize(ctx, i);\n            _one_cross(ctx, r);\n            ctx.stroke();\n        }\n    }\n    function square_x(ctx, i, r, line, fill) {\n        const size = 2 * r;\n        ctx.rect(-r, -r, size, size);\n        if (fill.doit) {\n            fill.set_vectorize(ctx, i);\n            ctx.fill();\n        }\n        if (line.doit) {\n            line.set_vectorize(ctx, i);\n            _one_x(ctx, r);\n            ctx.stroke();\n        }\n    }\n    function triangle(ctx, i, r, line, fill) {\n        _one_tri(ctx, r);\n        if (fill.doit) {\n            fill.set_vectorize(ctx, i);\n            ctx.fill();\n        }\n        if (line.doit) {\n            line.set_vectorize(ctx, i);\n            ctx.stroke();\n        }\n    }\n    function dash(ctx, i, r, line, _fill) {\n        _one_line(ctx, r);\n        if (line.doit) {\n            line.set_vectorize(ctx, i);\n            ctx.stroke();\n        }\n    }\n    function x(ctx, i, r, line, _fill) {\n        _one_x(ctx, r);\n        if (line.doit) {\n            line.set_vectorize(ctx, i);\n            ctx.stroke();\n        }\n    }\n    function _mk_model(type, f) {\n        var _a;\n        const view = class extends marker_1.MarkerView {\n            static initClass() {\n                this.prototype._render_one = f;\n            }\n        };\n        view.initClass();\n        const model = (_a = class extends marker_1.Marker {\n            static initClass() {\n                this.prototype.default_view = view;\n            }\n        },\n            _a.__name__ = type,\n            _a);\n        model.initClass();\n        return model;\n    }\n    // markers are final, so no need to export views\n    exports.Asterisk = _mk_model('Asterisk', asterisk);\n    exports.CircleCross = _mk_model('CircleCross', circle_cross);\n    exports.CircleX = _mk_model('CircleX', circle_x);\n    exports.Cross = _mk_model('Cross', cross);\n    exports.Dash = _mk_model('Dash', dash);\n    exports.Diamond = _mk_model('Diamond', diamond);\n    exports.DiamondCross = _mk_model('DiamondCross', diamond_cross);\n    exports.Hex = _mk_model('Hex', hex);\n    exports.InvertedTriangle = _mk_model('InvertedTriangle', inverted_triangle);\n    exports.Square = _mk_model('Square', square);\n    exports.SquareCross = _mk_model('SquareCross', square_cross);\n    exports.SquareX = _mk_model('SquareX', square_x);\n    exports.Triangle = _mk_model('Triangle', triangle);\n    exports.X = _mk_model('X', x);\n    exports.marker_funcs = {\n        asterisk,\n        circle,\n        circle_cross,\n        circle_x,\n        cross,\n        diamond,\n        diamond_cross,\n        hex,\n        inverted_triangle,\n        square,\n        square_cross,\n        square_x,\n        triangle,\n        dash,\n        x,\n    };\n}\n","/* models/markers/marker.js */ function _(require, module, exports) {\n    const xy_glyph_1 = require(76) /* ../glyphs/xy_glyph */;\n    const hittest = require(81) /* ../../core/hittest */;\n    const p = require(18) /* ../../core/properties */;\n    const array_1 = require(8) /* ../../core/util/array */;\n    class MarkerView extends xy_glyph_1.XYGlyphView {\n        _render(ctx, indices, { sx, sy, _size, _angle }) {\n            for (const i of indices) {\n                if (isNaN(sx[i] + sy[i] + _size[i] + _angle[i]))\n                    continue;\n                const r = _size[i] / 2;\n                ctx.beginPath();\n                ctx.translate(sx[i], sy[i]);\n                if (_angle[i])\n                    ctx.rotate(_angle[i]);\n                this._render_one(ctx, i, r, this.visuals.line, this.visuals.fill);\n                if (_angle[i])\n                    ctx.rotate(-_angle[i]);\n                ctx.translate(-sx[i], -sy[i]);\n            }\n        }\n        _mask_data() {\n            // dilate the inner screen region by max_size and map back to data space for use in\n            // spatial query\n            const hr = this.renderer.plot_view.frame.bbox.h_range;\n            const sx0 = hr.start - this.max_size;\n            const sx1 = hr.end + this.max_size;\n            const [x0, x1] = this.renderer.xscale.r_invert(sx0, sx1);\n            const vr = this.renderer.plot_view.frame.bbox.v_range;\n            const sy0 = vr.start - this.max_size;\n            const sy1 = vr.end + this.max_size;\n            const [y0, y1] = this.renderer.yscale.r_invert(sy0, sy1);\n            return this.index.indices({ x0, x1, y0, y1 });\n        }\n        _hit_point(geometry) {\n            const { sx, sy } = geometry;\n            const sx0 = sx - this.max_size;\n            const sx1 = sx + this.max_size;\n            const [x0, x1] = this.renderer.xscale.r_invert(sx0, sx1);\n            const sy0 = sy - this.max_size;\n            const sy1 = sy + this.max_size;\n            const [y0, y1] = this.renderer.yscale.r_invert(sy0, sy1);\n            const candidates = this.index.indices({ x0, x1, y0, y1 });\n            const hits = [];\n            for (const i of candidates) {\n                const s2 = this._size[i] / 2;\n                const dist = Math.abs(this.sx[i] - sx) + Math.abs(this.sy[i] - sy);\n                if (Math.abs(this.sx[i] - sx) <= s2 && Math.abs(this.sy[i] - sy) <= s2) {\n                    hits.push([i, dist]);\n                }\n            }\n            return hittest.create_hit_test_result_from_hits(hits);\n        }\n        _hit_span(geometry) {\n            const { sx, sy } = geometry;\n            const bounds = this.bounds();\n            const ms = this.max_size / 2;\n            const result = hittest.create_empty_hit_test_result();\n            let x0, x1, y0, y1;\n            if (geometry.direction == 'h') {\n                y0 = bounds.y0;\n                y1 = bounds.y1;\n                const sx0 = sx - ms;\n                const sx1 = sx + ms;\n                [x0, x1] = this.renderer.xscale.r_invert(sx0, sx1);\n            }\n            else {\n                x0 = bounds.x0;\n                x1 = bounds.x1;\n                const sy0 = sy - ms;\n                const sy1 = sy + ms;\n                [y0, y1] = this.renderer.yscale.r_invert(sy0, sy1);\n            }\n            const hits = this.index.indices({ x0, x1, y0, y1 });\n            result.indices = hits;\n            return result;\n        }\n        _hit_rect(geometry) {\n            const { sx0, sx1, sy0, sy1 } = geometry;\n            const [x0, x1] = this.renderer.xscale.r_invert(sx0, sx1);\n            const [y0, y1] = this.renderer.yscale.r_invert(sy0, sy1);\n            const result = hittest.create_empty_hit_test_result();\n            result.indices = this.index.indices({ x0, x1, y0, y1 });\n            return result;\n        }\n        _hit_poly(geometry) {\n            const { sx, sy } = geometry;\n            // TODO (bev) use spatial index to pare candidate list\n            const candidates = array_1.range(0, this.sx.length);\n            const hits = [];\n            for (let i = 0, end = candidates.length; i < end; i++) {\n                const idx = candidates[i];\n                if (hittest.point_in_poly(this.sx[i], this.sy[i], sx, sy))\n                    hits.push(idx);\n            }\n            const result = hittest.create_empty_hit_test_result();\n            result.indices = hits;\n            return result;\n        }\n        draw_legend_for_index(ctx, { x0, x1, y0, y1 }, index) {\n            // using objects like this seems a little wonky, since the keys are coerced to\n            // stings, but it works\n            const len = index + 1;\n            const sx = new Array(len);\n            sx[index] = (x0 + x1) / 2;\n            const sy = new Array(len);\n            sy[index] = (y0 + y1) / 2;\n            const size = new Array(len);\n            size[index] = Math.min(Math.abs(x1 - x0), Math.abs(y1 - y0)) * 0.4;\n            const angle = new Array(len);\n            angle[index] = 0; // don't attempt to match glyph angle\n            this._render(ctx, [index], { sx, sy, _size: size, _angle: angle }); // XXX\n        }\n    }\n    exports.MarkerView = MarkerView;\n    MarkerView.__name__ = \"MarkerView\";\n    class Marker extends xy_glyph_1.XYGlyph {\n        constructor(attrs) {\n            super(attrs);\n        }\n        static init_Marker() {\n            this.mixins(['line', 'fill']);\n            this.define({\n                size: [p.DistanceSpec, { units: \"screen\", value: 4 }],\n                angle: [p.AngleSpec, 0],\n            });\n        }\n    }\n    exports.Marker = Marker;\n    Marker.__name__ = \"Marker\";\n    Marker.init_Marker();\n}\n","/* models/markers/scatter.js */ function _(require, module, exports) {\n    const marker_1 = require(256) /* ./marker */;\n    const defs_1 = require(255) /* ./defs */;\n    const p = require(18) /* ../../core/properties */;\n    class ScatterView extends marker_1.MarkerView {\n        _render(ctx, indices, { sx, sy, _size, _angle, _marker }) {\n            for (const i of indices) {\n                if (isNaN(sx[i] + sy[i] + _size[i] + _angle[i]) || _marker[i] == null)\n                    continue;\n                const r = _size[i] / 2;\n                ctx.beginPath();\n                ctx.translate(sx[i], sy[i]);\n                if (_angle[i])\n                    ctx.rotate(_angle[i]);\n                defs_1.marker_funcs[_marker[i]](ctx, i, r, this.visuals.line, this.visuals.fill);\n                if (_angle[i])\n                    ctx.rotate(-_angle[i]);\n                ctx.translate(-sx[i], -sy[i]);\n            }\n        }\n        draw_legend_for_index(ctx, { x0, x1, y0, y1 }, index) {\n            // using objects like this seems a little wonky, since the keys are coerced to\n            // stings, but it works\n            const len = index + 1;\n            const sx = new Array(len);\n            sx[index] = (x0 + x1) / 2;\n            const sy = new Array(len);\n            sy[index] = (y0 + y1) / 2;\n            const size = new Array(len);\n            size[index] = Math.min(Math.abs(x1 - x0), Math.abs(y1 - y0)) * 0.4;\n            const angle = new Array(len);\n            angle[index] = 0; // don't attempt to match glyph angle\n            const marker = new Array(len);\n            marker[index] = this._marker[index];\n            this._render(ctx, [index], { sx, sy, _size: size, _angle: angle, _marker: marker }); // XXX\n        }\n    }\n    exports.ScatterView = ScatterView;\n    ScatterView.__name__ = \"ScatterView\";\n    class Scatter extends marker_1.Marker {\n        constructor(attrs) {\n            super(attrs);\n        }\n        static init_Scatter() {\n            this.prototype.default_view = ScatterView;\n            this.define({\n                marker: [p.MarkerSpec, { value: \"circle\" }],\n            });\n        }\n    }\n    exports.Scatter = Scatter;\n    Scatter.__name__ = \"Scatter\";\n    Scatter.init_Scatter();\n}\n","/* models/plots/index.js */ function _(require, module, exports) {\n    var gmap_plot_1 = require(259) /* ./gmap_plot */;\n    exports.MapOptions = gmap_plot_1.MapOptions;\n    var gmap_plot_2 = require(259) /* ./gmap_plot */;\n    exports.GMapOptions = gmap_plot_2.GMapOptions;\n    var gmap_plot_3 = require(259) /* ./gmap_plot */;\n    exports.GMapPlot = gmap_plot_3.GMapPlot;\n    var plot_1 = require(260) /* ./plot */;\n    exports.Plot = plot_1.Plot;\n}\n","/* models/plots/gmap_plot.js */ function _(require, module, exports) {\n    const logging_1 = require(65) /* ../../core/logging */;\n    const plot_1 = require(260) /* ./plot */;\n    const p = require(18) /* ../../core/properties */;\n    const model_1 = require(64) /* ../../model */;\n    const range1d_1 = require(123) /* ../ranges/range1d */;\n    const gmap_plot_canvas_1 = require(280) /* ./gmap_plot_canvas */;\n    exports.GMapPlotView = gmap_plot_canvas_1.GMapPlotView;\n    class MapOptions extends model_1.Model {\n        constructor(attrs) {\n            super(attrs);\n        }\n        static init_MapOptions() {\n            this.define({\n                lat: [p.Number],\n                lng: [p.Number],\n                zoom: [p.Number, 12],\n            });\n        }\n    }\n    exports.MapOptions = MapOptions;\n    MapOptions.__name__ = \"MapOptions\";\n    MapOptions.init_MapOptions();\n    class GMapOptions extends MapOptions {\n        constructor(attrs) {\n            super(attrs);\n        }\n        static init_GMapOptions() {\n            this.define({\n                map_type: [p.String, \"roadmap\"],\n                scale_control: [p.Boolean, false],\n                styles: [p.String],\n                tilt: [p.Int, 45],\n            });\n        }\n    }\n    exports.GMapOptions = GMapOptions;\n    GMapOptions.__name__ = \"GMapOptions\";\n    GMapOptions.init_GMapOptions();\n    class GMapPlot extends plot_1.Plot {\n        constructor(attrs) {\n            super(attrs);\n        }\n        static init_GMapPlot() {\n            this.prototype.default_view = gmap_plot_canvas_1.GMapPlotView;\n            // This seems to be necessary so that everything can initialize.\n            // Feels very clumsy, but I'm not sure how the properties system wants\n            // to handle something like this situation.\n            this.define({\n                map_options: [p.Instance],\n                api_key: [p.String],\n            });\n            this.override({\n                x_range: () => new range1d_1.Range1d(),\n                y_range: () => new range1d_1.Range1d(),\n            });\n        }\n        initialize() {\n            super.initialize();\n            this.use_map = true;\n            if (!this.api_key)\n                logging_1.logger.error(\"api_key is required. See https://developers.google.com/maps/documentation/javascript/get-api-key for more information on how to obtain your own.\");\n        }\n    }\n    exports.GMapPlot = GMapPlot;\n    GMapPlot.__name__ = \"GMapPlot\";\n    GMapPlot.init_GMapPlot();\n}\n","/* models/plots/plot.js */ function _(require, module, exports) {\n    const p = require(18) /* ../../core/properties */;\n    const signaling_1 = require(13) /* ../../core/signaling */;\n    const array_1 = require(8) /* ../../core/util/array */;\n    const object_1 = require(22) /* ../../core/util/object */;\n    const types_1 = require(7) /* ../../core/util/types */;\n    const layout_dom_1 = require(237) /* ../layouts/layout_dom */;\n    const title_1 = require(134) /* ../annotations/title */;\n    const linear_scale_1 = require(113) /* ../scales/linear_scale */;\n    const toolbar_1 = require(261) /* ../tools/toolbar */;\n    const column_data_source_1 = require(68) /* ../sources/column_data_source */;\n    const glyph_renderer_1 = require(73) /* ../renderers/glyph_renderer */;\n    const data_range1d_1 = require(178) /* ../ranges/data_range1d */;\n    const plot_canvas_1 = require(273) /* ./plot_canvas */;\n    exports.PlotView = plot_canvas_1.PlotView;\n    class Plot extends layout_dom_1.LayoutDOM {\n        constructor(attrs) {\n            super(attrs);\n        }\n        static init_Plot() {\n            this.prototype.default_view = plot_canvas_1.PlotView;\n            this.mixins([\"line:outline_\", \"fill:background_\", \"fill:border_\"]);\n            this.define({\n                toolbar: [p.Instance, () => new toolbar_1.Toolbar()],\n                toolbar_location: [p.Location, 'right'],\n                toolbar_sticky: [p.Boolean, true],\n                plot_width: [p.Number, 600],\n                plot_height: [p.Number, 600],\n                frame_width: [p.Number, null],\n                frame_height: [p.Number, null],\n                title: [p.Any, () => new title_1.Title({ text: \"\" })],\n                title_location: [p.Location, 'above'],\n                above: [p.Array, []],\n                below: [p.Array, []],\n                left: [p.Array, []],\n                right: [p.Array, []],\n                center: [p.Array, []],\n                renderers: [p.Array, []],\n                x_range: [p.Instance, () => new data_range1d_1.DataRange1d()],\n                extra_x_ranges: [p.Any, {}],\n                y_range: [p.Instance, () => new data_range1d_1.DataRange1d()],\n                extra_y_ranges: [p.Any, {}],\n                x_scale: [p.Instance, () => new linear_scale_1.LinearScale()],\n                y_scale: [p.Instance, () => new linear_scale_1.LinearScale()],\n                lod_factor: [p.Number, 10],\n                lod_interval: [p.Number, 300],\n                lod_threshold: [p.Number, 2000],\n                lod_timeout: [p.Number, 500],\n                hidpi: [p.Boolean, true],\n                output_backend: [p.OutputBackend, \"canvas\"],\n                min_border: [p.Number, 5],\n                min_border_top: [p.Number, null],\n                min_border_left: [p.Number, null],\n                min_border_bottom: [p.Number, null],\n                min_border_right: [p.Number, null],\n                inner_width: [p.Number],\n                inner_height: [p.Number],\n                outer_width: [p.Number],\n                outer_height: [p.Number],\n                match_aspect: [p.Boolean, false],\n                aspect_scale: [p.Number, 1],\n                reset_policy: [p.ResetPolicy, \"standard\"],\n            });\n            this.override({\n                outline_line_color: \"#e5e5e5\",\n                border_fill_color: \"#ffffff\",\n                background_fill_color: \"#ffffff\",\n            });\n        }\n        get width() {\n            const width = this.getv(\"width\");\n            return width != null ? width : this.plot_width;\n        }\n        get height() {\n            const height = this.getv(\"height\");\n            return height != null ? height : this.plot_height;\n        }\n        _doc_attached() {\n            super._doc_attached();\n            this._tell_document_about_change('inner_height', null, this.inner_height, {});\n            this._tell_document_about_change('inner_width', null, this.inner_width, {});\n        }\n        initialize() {\n            super.initialize();\n            this.reset = new signaling_1.Signal0(this, \"reset\");\n            for (const xr of object_1.values(this.extra_x_ranges).concat(this.x_range)) {\n                let plots = xr.plots;\n                if (types_1.isArray(plots)) {\n                    plots = plots.concat(this);\n                    xr.setv({ plots }, { silent: true });\n                }\n            }\n            for (const yr of object_1.values(this.extra_y_ranges).concat(this.y_range)) {\n                let plots = yr.plots;\n                if (types_1.isArray(plots)) {\n                    plots = plots.concat(this);\n                    yr.setv({ plots }, { silent: true });\n                }\n            }\n        }\n        add_layout(renderer, side = \"center\") {\n            const side_renderers = this.getv(side);\n            side_renderers.push(renderer /* XXX */);\n        }\n        remove_layout(renderer) {\n            const del = (items) => {\n                array_1.remove_by(items, (item) => item == renderer);\n            };\n            del(this.left);\n            del(this.right);\n            del(this.above);\n            del(this.below);\n            del(this.center);\n        }\n        add_renderers(...renderers) {\n            this.renderers = this.renderers.concat(renderers);\n        }\n        add_glyph(glyph, source = new column_data_source_1.ColumnDataSource(), extra_attrs = {}) {\n            const attrs = Object.assign(Object.assign({}, extra_attrs), { data_source: source, glyph });\n            const renderer = new glyph_renderer_1.GlyphRenderer(attrs);\n            this.add_renderers(renderer);\n            return renderer;\n        }\n        add_tools(...tools) {\n            this.toolbar.tools = this.toolbar.tools.concat(tools);\n        }\n        get panels() {\n            return this.side_panels.concat(this.center);\n        }\n        get side_panels() {\n            const { above, below, left, right } = this;\n            return array_1.concat([above, below, left, right]);\n        }\n    }\n    exports.Plot = Plot;\n    Plot.__name__ = \"Plot\";\n    Plot.init_Plot();\n}\n","/* models/tools/toolbar.js */ function _(require, module, exports) {\n    const p = require(18) /* ../../core/properties */;\n    const types_1 = require(7) /* ../../core/util/types */;\n    const array_1 = require(8) /* ../../core/util/array */;\n    const inspect_tool_1 = require(262) /* ./inspectors/inspect_tool */;\n    const toolbar_base_1 = require(267) /* ./toolbar_base */;\n    const _get_active_attr = (et) => {\n        switch (et) {\n            case 'tap': return 'active_tap';\n            case 'pan': return 'active_drag';\n            case 'pinch':\n            case 'scroll': return 'active_scroll';\n            case 'multi': return 'active_multi';\n        }\n        return null;\n    };\n    const _supports_auto = (et) => {\n        return et == 'tap' || et == 'pan';\n    };\n    class Toolbar extends toolbar_base_1.ToolbarBase {\n        constructor(attrs) {\n            super(attrs);\n        }\n        static init_Toolbar() {\n            this.prototype.default_view = toolbar_base_1.ToolbarBaseView;\n            this.define({\n                active_drag: [p.Any, 'auto'],\n                active_inspect: [p.Any, 'auto'],\n                active_scroll: [p.Any, 'auto'],\n                active_tap: [p.Any, 'auto'],\n                active_multi: [p.Any, null],\n            });\n        }\n        connect_signals() {\n            super.connect_signals();\n            this.connect(this.properties.tools.change, () => this._init_tools());\n        }\n        _init_tools() {\n            super._init_tools();\n            if (this.active_inspect == 'auto') {\n                // do nothing as all tools are active be default\n            }\n            else if (this.active_inspect instanceof inspect_tool_1.InspectTool) {\n                let found = false;\n                for (const inspector of this.inspectors) {\n                    if (inspector != this.active_inspect)\n                        inspector.active = false;\n                    else\n                        found = true;\n                }\n                if (!found) {\n                    this.active_inspect = null;\n                }\n            }\n            else if (types_1.isArray(this.active_inspect)) {\n                const active_inspect = array_1.intersection(this.active_inspect, this.inspectors);\n                if (active_inspect.length != this.active_inspect.length) {\n                    this.active_inspect = active_inspect;\n                }\n                for (const inspector of this.inspectors) {\n                    if (!array_1.includes(this.active_inspect, inspector))\n                        inspector.active = false;\n                }\n            }\n            else if (this.active_inspect == null) {\n                for (const inspector of this.inspectors)\n                    inspector.active = false;\n            }\n            const _activate_gesture = (tool) => {\n                if (tool.active) {\n                    // tool was activated by a proxy, but we need to finish configuration manually\n                    this._active_change(tool);\n                }\n                else\n                    tool.active = true;\n            };\n            // Connecting signals has to be done before changing the active state of the tools.\n            for (const et in this.gestures) {\n                const gesture = this.gestures[et];\n                gesture.tools = array_1.sort_by(gesture.tools, (tool) => tool.default_order);\n                for (const tool of gesture.tools) {\n                    this.connect(tool.properties.active.change, this._active_change.bind(this, tool));\n                }\n            }\n            for (const et in this.gestures) {\n                const active_attr = _get_active_attr(et);\n                if (active_attr) {\n                    const active_tool = this[active_attr];\n                    if (active_tool == 'auto') {\n                        const gesture = this.gestures[et];\n                        if (gesture.tools.length != 0 && _supports_auto(et)) {\n                            _activate_gesture(gesture.tools[0]);\n                        }\n                    }\n                    else if (active_tool != null) {\n                        if (array_1.includes(this.tools, active_tool)) {\n                            _activate_gesture(active_tool);\n                        }\n                        else {\n                            this[active_attr] = null;\n                        }\n                    }\n                }\n            }\n        }\n    }\n    exports.Toolbar = Toolbar;\n    Toolbar.__name__ = \"Toolbar\";\n    Toolbar.init_Toolbar();\n}\n","/* models/tools/inspectors/inspect_tool.js */ function _(require, module, exports) {\n    const button_tool_1 = require(263) /* ../button_tool */;\n    const on_off_button_1 = require(266) /* ../on_off_button */;\n    const p = require(18) /* ../../../core/properties */;\n    class InspectToolView extends button_tool_1.ButtonToolView {\n    }\n    exports.InspectToolView = InspectToolView;\n    InspectToolView.__name__ = \"InspectToolView\";\n    class InspectTool extends button_tool_1.ButtonTool {\n        constructor(attrs) {\n            super(attrs);\n            this.event_type = \"move\";\n        }\n        static init_InspectTool() {\n            this.prototype.button_view = on_off_button_1.OnOffButtonView;\n            this.define({\n                toggleable: [p.Boolean, true],\n            });\n            this.override({\n                active: true,\n            });\n        }\n    }\n    exports.InspectTool = InspectTool;\n    InspectTool.__name__ = \"InspectTool\";\n    InspectTool.init_InspectTool();\n}\n","/* models/tools/button_tool.js */ function _(require, module, exports) {\n    const dom_view_1 = require(59) /* ../../core/dom_view */;\n    const tool_1 = require(264) /* ./tool */;\n    const dom_1 = require(61) /* ../../core/dom */;\n    const p = require(18) /* ../../core/properties */;\n    const string_1 = require(25) /* ../../core/util/string */;\n    const types_1 = require(7) /* ../../core/util/types */;\n    const toolbar_1 = require(265) /* ../../styles/toolbar */;\n    class ButtonToolButtonView extends dom_view_1.DOMView {\n        initialize() {\n            super.initialize();\n            this.connect(this.model.change, () => this.render());\n            this.el.addEventListener(\"click\", () => this._clicked());\n            this.render(); // XXX: this isn't governed by layout, for now\n        }\n        css_classes() {\n            return super.css_classes().concat(toolbar_1.bk_toolbar_button);\n        }\n        render() {\n            dom_1.empty(this.el);\n            const icon = this.model.computed_icon;\n            if (types_1.isString(icon)) {\n                if (string_1.startsWith(icon, \"data:image\"))\n                    this.el.style.backgroundImage = \"url('\" + icon + \"')\";\n                else\n                    this.el.classList.add(icon);\n            }\n            this.el.title = this.model.tooltip;\n        }\n    }\n    exports.ButtonToolButtonView = ButtonToolButtonView;\n    ButtonToolButtonView.__name__ = \"ButtonToolButtonView\";\n    class ButtonToolView extends tool_1.ToolView {\n    }\n    exports.ButtonToolView = ButtonToolView;\n    ButtonToolView.__name__ = \"ButtonToolView\";\n    class ButtonTool extends tool_1.Tool {\n        constructor(attrs) {\n            super(attrs);\n        }\n        static init_ButtonTool() {\n            this.internal({\n                disabled: [p.Boolean, false],\n            });\n        }\n        get tooltip() {\n            return this.tool_name;\n        }\n        get computed_icon() {\n            return this.icon;\n        }\n    }\n    exports.ButtonTool = ButtonTool;\n    ButtonTool.__name__ = \"ButtonTool\";\n    ButtonTool.init_ButtonTool();\n}\n","/* models/tools/tool.js */ function _(require, module, exports) {\n    const p = require(18) /* ../../core/properties */;\n    const view_1 = require(60) /* ../../core/view */;\n    const array_1 = require(8) /* ../../core/util/array */;\n    const model_1 = require(64) /* ../../model */;\n    class ToolView extends view_1.View {\n        get plot_view() {\n            return this.parent;\n        }\n        get plot_model() {\n            return this.parent.model;\n        }\n        connect_signals() {\n            super.connect_signals();\n            this.connect(this.model.properties.active.change, () => {\n                if (this.model.active)\n                    this.activate();\n                else\n                    this.deactivate();\n            });\n        }\n        // activate is triggered by toolbar ui actions\n        activate() { }\n        // deactivate is triggered by toolbar ui actions\n        deactivate() { }\n    }\n    exports.ToolView = ToolView;\n    ToolView.__name__ = \"ToolView\";\n    class Tool extends model_1.Model {\n        constructor(attrs) {\n            super(attrs);\n        }\n        static init_Tool() {\n            this.internal({\n                active: [p.Boolean, false],\n            });\n        }\n        get synthetic_renderers() {\n            return [];\n        }\n        // utility function to return a tool name, modified\n        // by the active dimensions. Used by tools that have dimensions\n        _get_dim_tooltip(name, dims) {\n            switch (dims) {\n                case \"width\": return `${name} (x-axis)`;\n                case \"height\": return `${name} (y-axis)`;\n                case \"both\": return name;\n            }\n        }\n        // utility function to get limits along both dimensions, given\n        // optional dimensional constraints\n        _get_dim_limits([sx0, sy0], [sx1, sy1], frame, dims) {\n            const hr = frame.bbox.h_range;\n            let sxlim;\n            if (dims == 'width' || dims == 'both') {\n                sxlim = [array_1.min([sx0, sx1]), array_1.max([sx0, sx1])];\n                sxlim = [array_1.max([sxlim[0], hr.start]), array_1.min([sxlim[1], hr.end])];\n            }\n            else\n                sxlim = [hr.start, hr.end];\n            const vr = frame.bbox.v_range;\n            let sylim;\n            if (dims == 'height' || dims == 'both') {\n                sylim = [array_1.min([sy0, sy1]), array_1.max([sy0, sy1])];\n                sylim = [array_1.max([sylim[0], vr.start]), array_1.min([sylim[1], vr.end])];\n            }\n            else\n                sylim = [vr.start, vr.end];\n            return [sxlim, sylim];\n        }\n    }\n    exports.Tool = Tool;\n    Tool.__name__ = \"Tool\";\n    Tool.init_Tool();\n}\n","/* styles/toolbar.js */ function _(require, module, exports) {\n    require(62) /* ./root */;\n    const _a = require(61) /* ../core/dom */;\n    _a.styles.append(\".bk-root .bk-toolbar-hidden {\\n  visibility: hidden;\\n  opacity: 0;\\n  transition: visibility 0.3s linear, opacity 0.3s linear;\\n}\\n.bk-root .bk-toolbar,\\n.bk-root .bk-button-bar {\\n  display: flex;\\n  display: -webkit-flex;\\n  flex-wrap: nowrap;\\n  -webkit-flex-wrap: nowrap;\\n  align-items: center;\\n  -webkit-align-items: center;\\n  user-select: none;\\n  -ms-user-select: none;\\n  -moz-user-select: none;\\n  -webkit-user-select: none;\\n}\\n.bk-root .bk-toolbar .bk-logo {\\n  flex-shrink: 0;\\n  -webkit-flex-shrink: 0;\\n}\\n.bk-root .bk-toolbar.bk-above,\\n.bk-root .bk-toolbar.bk-below {\\n  flex-direction: row;\\n  -webkit-flex-direction: row;\\n  justify-content: flex-end;\\n  -webkit-justify-content: flex-end;\\n}\\n.bk-root .bk-toolbar.bk-above .bk-button-bar,\\n.bk-root .bk-toolbar.bk-below .bk-button-bar {\\n  display: flex;\\n  display: -webkit-flex;\\n  flex-direction: row;\\n  -webkit-flex-direction: row;\\n}\\n.bk-root .bk-toolbar.bk-above .bk-logo,\\n.bk-root .bk-toolbar.bk-below .bk-logo {\\n  order: 1;\\n  -webkit-order: 1;\\n  margin-left: 5px;\\n  margin-right: 0px;\\n}\\n.bk-root .bk-toolbar.bk-left,\\n.bk-root .bk-toolbar.bk-right {\\n  flex-direction: column;\\n  -webkit-flex-direction: column;\\n  justify-content: flex-start;\\n  -webkit-justify-content: flex-start;\\n}\\n.bk-root .bk-toolbar.bk-left .bk-button-bar,\\n.bk-root .bk-toolbar.bk-right .bk-button-bar {\\n  display: flex;\\n  display: -webkit-flex;\\n  flex-direction: column;\\n  -webkit-flex-direction: column;\\n}\\n.bk-root .bk-toolbar.bk-left .bk-logo,\\n.bk-root .bk-toolbar.bk-right .bk-logo {\\n  order: 0;\\n  -webkit-order: 0;\\n  margin-bottom: 5px;\\n  margin-top: 0px;\\n}\\n.bk-root .bk-toolbar-button {\\n  width: 30px;\\n  height: 30px;\\n  background-size: 60%;\\n  background-color: transparent;\\n  background-repeat: no-repeat;\\n  background-position: center center;\\n}\\n.bk-root .bk-toolbar-button:hover {\\n  background-color: #f9f9f9;\\n}\\n.bk-root .bk-toolbar-button:focus {\\n  outline: none;\\n}\\n.bk-root .bk-toolbar-button::-moz-focus-inner {\\n  border: 0;\\n}\\n.bk-root .bk-toolbar.bk-above .bk-toolbar-button {\\n  border-bottom: 2px solid transparent;\\n}\\n.bk-root .bk-toolbar.bk-above .bk-toolbar-button.bk-active {\\n  border-bottom-color: #26aae1;\\n}\\n.bk-root .bk-toolbar.bk-below .bk-toolbar-button {\\n  border-top: 2px solid transparent;\\n}\\n.bk-root .bk-toolbar.bk-below .bk-toolbar-button.bk-active {\\n  border-top-color: #26aae1;\\n}\\n.bk-root .bk-toolbar.bk-right .bk-toolbar-button {\\n  border-left: 2px solid transparent;\\n}\\n.bk-root .bk-toolbar.bk-right .bk-toolbar-button.bk-active {\\n  border-left-color: #26aae1;\\n}\\n.bk-root .bk-toolbar.bk-left .bk-toolbar-button {\\n  border-right: 2px solid transparent;\\n}\\n.bk-root .bk-toolbar.bk-left .bk-toolbar-button.bk-active {\\n  border-right-color: #26aae1;\\n}\\n.bk-root .bk-button-bar + .bk-button-bar:before {\\n  content: \\\" \\\";\\n  display: inline-block;\\n  background-color: lightgray;\\n}\\n.bk-root .bk-toolbar.bk-above .bk-button-bar + .bk-button-bar:before,\\n.bk-root .bk-toolbar.bk-below .bk-button-bar + .bk-button-bar:before {\\n  height: 10px;\\n  width: 1px;\\n}\\n.bk-root .bk-toolbar.bk-left .bk-button-bar + .bk-button-bar:before,\\n.bk-root .bk-toolbar.bk-right .bk-button-bar + .bk-button-bar:before {\\n  height: 1px;\\n  width: 10px;\\n}\\n\");\n    exports.bk_toolbar = \"bk-toolbar\";\n    exports.bk_toolbar_hidden = \"bk-toolbar-hidden\";\n    exports.bk_toolbar_button = \"bk-toolbar-button\";\n    exports.bk_button_bar = \"bk-button-bar\";\n    exports.bk_toolbar_button_custom_action = \"bk-toolbar-button-custom-action\";\n}\n","/* models/tools/on_off_button.js */ function _(require, module, exports) {\n    const button_tool_1 = require(263) /* ./button_tool */;\n    const mixins_1 = require(138) /* ../../styles/mixins */;\n    class OnOffButtonView extends button_tool_1.ButtonToolButtonView {\n        render() {\n            super.render();\n            if (this.model.active)\n                this.el.classList.add(mixins_1.bk_active);\n            else\n                this.el.classList.remove(mixins_1.bk_active);\n        }\n        _clicked() {\n            const active = this.model.active;\n            this.model.active = !active;\n        }\n    }\n    exports.OnOffButtonView = OnOffButtonView;\n    OnOffButtonView.__name__ = \"OnOffButtonView\";\n}\n","/* models/tools/toolbar_base.js */ function _(require, module, exports) {\n    const logging_1 = require(65) /* ../../core/logging */;\n    const dom_1 = require(61) /* ../../core/dom */;\n    const build_views_1 = require(92) /* ../../core/build_views */;\n    const p = require(18) /* ../../core/properties */;\n    const dom_view_1 = require(59) /* ../../core/dom_view */;\n    const array_1 = require(8) /* ../../core/util/array */;\n    const data_structures_1 = require(14) /* ../../core/util/data_structures */;\n    const types_1 = require(7) /* ../../core/util/types */;\n    const model_1 = require(64) /* ../../model */;\n    const gesture_tool_1 = require(268) /* ./gestures/gesture_tool */;\n    const action_tool_1 = require(269) /* ./actions/action_tool */;\n    const help_tool_1 = require(270) /* ./actions/help_tool */;\n    const inspect_tool_1 = require(262) /* ./inspectors/inspect_tool */;\n    const toolbar_1 = require(265) /* ../../styles/toolbar */;\n    const logo_1 = require(272) /* ../../styles/logo */;\n    const mixins_1 = require(138) /* ../../styles/mixins */;\n    class ToolbarViewModel extends model_1.Model {\n        constructor(attrs) {\n            super(attrs);\n        }\n        static init_ToolbarViewModel() {\n            this.define({\n                _visible: [p.Any, null],\n                autohide: [p.Boolean, false],\n            });\n        }\n        get visible() {\n            return (!this.autohide) ? true : (this._visible == null) ? false : this._visible;\n        }\n    }\n    exports.ToolbarViewModel = ToolbarViewModel;\n    ToolbarViewModel.__name__ = \"ToolbarViewModel\";\n    ToolbarViewModel.init_ToolbarViewModel();\n    class ToolbarBaseView extends dom_view_1.DOMView {\n        initialize() {\n            super.initialize();\n            this._tool_button_views = {};\n            this._build_tool_button_views();\n            this._toolbar_view_model = new ToolbarViewModel({ autohide: this.model.autohide });\n        }\n        connect_signals() {\n            super.connect_signals();\n            this.connect(this.model.properties.tools.change, () => {\n                this._build_tool_button_views();\n                this.render();\n            });\n            this.connect(this.model.properties.autohide.change, () => {\n                this._toolbar_view_model.autohide = this.model.autohide;\n                this._on_visible_change();\n            });\n            this.connect(this._toolbar_view_model.properties._visible.change, () => this._on_visible_change());\n        }\n        remove() {\n            build_views_1.remove_views(this._tool_button_views);\n            super.remove();\n        }\n        _build_tool_button_views() {\n            const tools = (this.model._proxied_tools != null ? this.model._proxied_tools : this.model.tools); // XXX\n            build_views_1.build_views(this._tool_button_views, tools, { parent: this }, (tool) => tool.button_view);\n        }\n        set_visibility(visible) {\n            if (visible != this._toolbar_view_model._visible) {\n                this._toolbar_view_model._visible = visible;\n            }\n        }\n        _on_visible_change() {\n            const visible = this._toolbar_view_model.visible;\n            const hidden_class = toolbar_1.bk_toolbar_hidden;\n            if (this.el.classList.contains(hidden_class) && visible) {\n                this.el.classList.remove(hidden_class);\n            }\n            else if (!visible) {\n                this.el.classList.add(hidden_class);\n            }\n        }\n        render() {\n            dom_1.empty(this.el);\n            this.el.classList.add(toolbar_1.bk_toolbar);\n            this.el.classList.add(mixins_1.bk_side(this.model.toolbar_location));\n            this._toolbar_view_model.autohide = this.model.autohide;\n            this._on_visible_change();\n            if (this.model.logo != null) {\n                const gray = this.model.logo === \"grey\" ? logo_1.bk_grey : null;\n                const logo = dom_1.a({ href: \"https://bokeh.org/\", target: \"_blank\", class: [logo_1.bk_logo, logo_1.bk_logo_small, gray] });\n                this.el.appendChild(logo);\n            }\n            const bars = [];\n            const el = (tool) => {\n                return this._tool_button_views[tool.id].el;\n            };\n            const { gestures } = this.model;\n            for (const et in gestures) {\n                bars.push(gestures[et].tools.map(el));\n            }\n            bars.push(this.model.actions.map(el));\n            bars.push(this.model.inspectors.filter((tool) => tool.toggleable).map(el));\n            bars.push(this.model.help.map(el));\n            for (const bar of bars) {\n                if (bar.length !== 0) {\n                    const el = dom_1.div({ class: toolbar_1.bk_button_bar }, bar);\n                    this.el.appendChild(el);\n                }\n            }\n        }\n        update_layout() { }\n        update_position() { }\n        after_layout() {\n            this._has_finished = true;\n        }\n    }\n    exports.ToolbarBaseView = ToolbarBaseView;\n    ToolbarBaseView.__name__ = \"ToolbarBaseView\";\n    function createGestureMap() {\n        return {\n            pan: { tools: [], active: null },\n            scroll: { tools: [], active: null },\n            pinch: { tools: [], active: null },\n            tap: { tools: [], active: null },\n            doubletap: { tools: [], active: null },\n            press: { tools: [], active: null },\n            pressup: { tools: [], active: null },\n            rotate: { tools: [], active: null },\n            move: { tools: [], active: null },\n            multi: { tools: [], active: null },\n        };\n    }\n    class ToolbarBase extends model_1.Model {\n        constructor(attrs) {\n            super(attrs);\n        }\n        static init_ToolbarBase() {\n            this.prototype.default_view = ToolbarBaseView;\n            this.define({\n                tools: [p.Array, []],\n                logo: [p.Logo, 'normal'],\n                autohide: [p.Boolean, false],\n            });\n            this.internal({\n                gestures: [p.Any, createGestureMap],\n                actions: [p.Array, []],\n                inspectors: [p.Array, []],\n                help: [p.Array, []],\n                toolbar_location: [p.Location, 'right'],\n            });\n        }\n        initialize() {\n            super.initialize();\n            this._init_tools();\n        }\n        _init_tools() {\n            // The only purpose of this function is to avoid unnecessary property churning.\n            const tools_changed = function (old_tools, new_tools) {\n                if (old_tools.length != new_tools.length) {\n                    return true;\n                }\n                const new_ids = new data_structures_1.Set(new_tools.map(t => t.id));\n                return array_1.some(old_tools, t => !new_ids.has(t.id));\n            };\n            const new_inspectors = this.tools.filter(t => t instanceof inspect_tool_1.InspectTool);\n            if (tools_changed(this.inspectors, new_inspectors)) {\n                this.inspectors = new_inspectors;\n            }\n            const new_help = this.tools.filter(t => t instanceof help_tool_1.HelpTool);\n            if (tools_changed(this.help, new_help)) {\n                this.help = new_help;\n            }\n            const new_actions = this.tools.filter(t => t instanceof action_tool_1.ActionTool);\n            if (tools_changed(this.actions, new_actions)) {\n                this.actions = new_actions;\n            }\n            const check_event_type = (et, tool) => {\n                if (!(et in this.gestures)) {\n                    logging_1.logger.warn(`Toolbar: unknown event type '${et}' for tool: ${tool.type} (${tool.id})`);\n                }\n            };\n            const new_gestures = createGestureMap();\n            for (const tool of this.tools) {\n                if (tool instanceof gesture_tool_1.GestureTool && tool.event_type) {\n                    if (types_1.isString(tool.event_type)) {\n                        new_gestures[tool.event_type].tools.push(tool);\n                        check_event_type(tool.event_type, tool);\n                    }\n                    else {\n                        new_gestures.multi.tools.push(tool);\n                        for (const et of tool.event_type) {\n                            check_event_type(et, tool);\n                        }\n                    }\n                }\n            }\n            for (const et of Object.keys(new_gestures)) {\n                const gm = this.gestures[et];\n                if (tools_changed(gm.tools, new_gestures[et].tools)) {\n                    gm.tools = new_gestures[et].tools;\n                }\n                if (gm.active && array_1.every(gm.tools, t => t.id != gm.active.id)) {\n                    gm.active = null;\n                }\n            }\n        }\n        get horizontal() {\n            return this.toolbar_location === \"above\" || this.toolbar_location === \"below\";\n        }\n        get vertical() {\n            return this.toolbar_location === \"left\" || this.toolbar_location === \"right\";\n        }\n        _active_change(tool) {\n            const { event_type } = tool;\n            if (event_type == null)\n                return;\n            const event_types = types_1.isString(event_type) ? [event_type] : event_type;\n            for (const et of event_types) {\n                if (tool.active) {\n                    const currently_active_tool = this.gestures[et].active;\n                    if (currently_active_tool != null && tool != currently_active_tool) {\n                        logging_1.logger.debug(`Toolbar: deactivating tool: ${currently_active_tool.type} (${currently_active_tool.id}) for event type '${et}'`);\n                        currently_active_tool.active = false;\n                    }\n                    this.gestures[et].active = tool;\n                    logging_1.logger.debug(`Toolbar: activating tool: ${tool.type} (${tool.id}) for event type '${et}'`);\n                }\n                else\n                    this.gestures[et].active = null;\n            }\n        }\n    }\n    exports.ToolbarBase = ToolbarBase;\n    ToolbarBase.__name__ = \"ToolbarBase\";\n    ToolbarBase.init_ToolbarBase();\n}\n","/* models/tools/gestures/gesture_tool.js */ function _(require, module, exports) {\n    const button_tool_1 = require(263) /* ../button_tool */;\n    const on_off_button_1 = require(266) /* ../on_off_button */;\n    class GestureToolView extends button_tool_1.ButtonToolView {\n    }\n    exports.GestureToolView = GestureToolView;\n    GestureToolView.__name__ = \"GestureToolView\";\n    class GestureTool extends button_tool_1.ButtonTool {\n        constructor(attrs) {\n            super(attrs);\n            this.button_view = on_off_button_1.OnOffButtonView;\n        }\n    }\n    exports.GestureTool = GestureTool;\n    GestureTool.__name__ = \"GestureTool\";\n}\n","/* models/tools/actions/action_tool.js */ function _(require, module, exports) {\n    const button_tool_1 = require(263) /* ../button_tool */;\n    const signaling_1 = require(13) /* ../../../core/signaling */;\n    class ActionToolButtonView extends button_tool_1.ButtonToolButtonView {\n        _clicked() {\n            this.model.do.emit();\n        }\n    }\n    exports.ActionToolButtonView = ActionToolButtonView;\n    ActionToolButtonView.__name__ = \"ActionToolButtonView\";\n    class ActionToolView extends button_tool_1.ButtonToolView {\n        connect_signals() {\n            super.connect_signals();\n            this.connect(this.model.do, () => this.doit());\n        }\n    }\n    exports.ActionToolView = ActionToolView;\n    ActionToolView.__name__ = \"ActionToolView\";\n    class ActionTool extends button_tool_1.ButtonTool {\n        constructor(attrs) {\n            super(attrs);\n            this.button_view = ActionToolButtonView;\n            this.do = new signaling_1.Signal0(this, \"do\");\n        }\n    }\n    exports.ActionTool = ActionTool;\n    ActionTool.__name__ = \"ActionTool\";\n}\n","/* models/tools/actions/help_tool.js */ function _(require, module, exports) {\n    const action_tool_1 = require(269) /* ./action_tool */;\n    const p = require(18) /* ../../../core/properties */;\n    const icons_1 = require(271) /* ../../../styles/icons */;\n    class HelpToolView extends action_tool_1.ActionToolView {\n        doit() {\n            window.open(this.model.redirect);\n        }\n    }\n    exports.HelpToolView = HelpToolView;\n    HelpToolView.__name__ = \"HelpToolView\";\n    class HelpTool extends action_tool_1.ActionTool {\n        constructor(attrs) {\n            super(attrs);\n            this.tool_name = \"Help\";\n            this.icon = icons_1.bk_tool_icon_help;\n        }\n        static init_HelpTool() {\n            this.prototype.default_view = HelpToolView;\n            this.define({\n                help_tooltip: [p.String, 'Click the question mark to learn more about Bokeh plot tools.'],\n                redirect: [p.String, 'https://docs.bokeh.org/en/latest/docs/user_guide/tools.html'],\n            });\n        }\n        get tooltip() {\n            return this.help_tooltip;\n        }\n    }\n    exports.HelpTool = HelpTool;\n    HelpTool.__name__ = \"HelpTool\";\n    HelpTool.init_HelpTool();\n}\n","/* styles/icons.js */ function _(require, module, exports) {\n    require(62) /* ./root */;\n    const _a = require(61) /* ../core/dom */;\n    _a.styles.append(\".bk-root .bk-tool-icon-box-select {\\n  background-image: url(\\\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAB3RJTUUH4gEMEg0kduFrowAAAIdJREFUWMPtVtEKwCAI9KL//4e9DPZ3+wP3KgOjNZouFYI4C8q7s7DtB1lGIeMoRMRinCLXg/ML3EcFqpjjloOyZxRntxpwQ8HsgHYARKFAtSFrCg3TCdMFCE1BuuALEXJLjC4qENsFVXCESZw38/kWLOkC/K4PcOc/Hj03WkoDT3EaWW9egQul6CUbq90JTwAAAABJRU5ErkJggg==\\\");\\n}\\n.bk-root .bk-tool-icon-box-zoom {\\n  background-image: url(\\\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAB3RJTUUH4gEMEg82t254aQAAAkBJREFUWMPN11+E1FEUB/DPTFn2qaeIpcSwr5NlUyJiKWVXWUqvlUh/iE3RY9mUekkPPURtLKNRrFJEeuphGfUUaVliiX1aVjGs6aG7+XX9ZnZ+d2fTl2vmnHvPPfeee/79Sk+may2/UQq/q7Qu+bAJoxjHIKqB/wlfUMcMVqI9bLZ+DGIKwzlzQ2GcxCx2xwvKOUKlaHTiX8bHNspjDONHkOmJBW5jIof/FvPh/06MZOb6cRc7cGn1AKUE5cdzlM/gAr5F/O24H3xkFRfxAbVygvK+cIsspjGWo1zgjeFpxL+BvnLw7laBA4xjIFJwrgu52DoVjKdY4HBEX8dSF3JLYe1fe6UcYCii3xWQjdfuSTnAtoheKCC7GNED5Zx4L4qt61jbTLHA94geKSC7P7ZeShQ0Inoi1IJuEOeORooFXkV0FZNdZs5qvFfKAeqYy7nZ6yg//HG0MBfffh71lFrQDCW2EvEP4mt4okZUDftz9rmGZkotmMxJRtlisy+MTniAWrty3AlXw0hFM2TD89l+oNsoOJXjbIs4EpqNtTCLXbiZ0g+M4mFObj8U3vsNjoZCVcmk60ZwthpepLZkB/AsivWfOJZxtpUQHfWib7KWDwzjeegBZJSdKFiE2qJTFFTwElsi/unQ/awXrU4WGMD7nOJxBY/1EO2iYConq93CHT1GOwucjdqnRyFz+VcHmMNefMY9nNkA3SWUOoXhQviSWQ4huLIRFlirFixnQq/XaKXUgg2xQNGv4V7x/RcW+AXPB3h7H1PaiQAAAABJRU5ErkJggg==\\\");\\n}\\n.bk-root .bk-tool-icon-zoom-in {\\n  background-image: url(\\\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAB3RJTUUH4gEMEgsUBmL8iQAAA2JJREFUWMO9l12IlFUYx3//MzPrLpSjkm5oN4FFIWVEl66IQlFYwtLOzozsjHdGRSCRF0sfBEXRVV0FQuQiLm5CZNBFgRRaRLVFhbJ2EdiN5gbK7toObTPn6eYdPTvNzPvOBz5Xh/ec5/n/n89zXtEHmZqeSXSuXBz/3zfdKvBWJHQrwZuRcP0El+QkbQXeBX6WZEgm6TtJk5lM5o4Lc+cV6qpf4Ga20Tm338zeATItVK9Ker6yvPzp4NDQ3+XieGsCU9MzTYumGbhz7m4ze9/MHgvBgItACrgfGAj2jgAvAYs3wlEujjc13kii8YyZrXXOfWhmo9GnFUlvOOemarVapVqtkslksmb2KjARqL62ecuWN9NxbRInzrldAXhV0uFSIfdew7G/gNLU9MwS8CwSmE3Oz88fcXG5blfpqVRq0Ix8VIAAX0XgrVL7HDCHGcCaWrV60LUBN8Dae58aQIxEqcA592I9M610JL0cpG/U9TIHJNKY3RV5z0R+7Nd4HZ0P1g/2RMBuegLAsRMnb4vT8d5vqKfMzOgtAlADrkmqGywmiMBTwfr3dC9j1Xv/r6Tvg/5/5ejxE6cO7M9faVbQZrYNOFSPmqQvVo9FKexvi5uWX58943aM7DwAfBDY+FbSCxP5sdkGx55GeguzrUEXPaSo2pFkAbiSZQCAzZJOmdkjwd6SpB/M7KykQTPbA2wDhoIzRzcNDx9MJwGNIXdJ0mEzmwbujL7dbma7gd03A7lKfnTOvf74nl0r6bonTUbujRSUCrm2d4L3/kvn3JPe+8+BDW2i9o+kT7z3kxP5sYsA6W47oE64TsR7P9tQL4vA2mh9WdIscKxUyJ0M7aR7acOGzikD65EQLEjaa2ZXzMwDFeB6qZBbbLTRE4EGeSaozNOZgYFf8qP7lmIvs354n0qlHpB0T7B9Ogl4IgJJrmjv/SiQjbrkD+BMUkfSbYATPdckrTOzkciWAXOlQu5cYgLdPEIapud9wMOR9zVJH3ViKx333mtHMJvNuoWFhZ3A+ojMcja77njXBEKwJJfTcqUyCIQ34Mf7nnh0paMnXacFuGoC1mr3AtuDfLzd8Zuyl+rfuGn4HLAD+Az4qZQf+61TAj0Noj8vX6oC35SL43u7teG6rf5+iXppwW7/JUL5D03qaFRvvUe+AAAAAElFTkSuQmCC\\\");\\n}\\n.bk-root .bk-tool-icon-zoom-out {\\n  background-image: url(\\\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAB3RJTUUH4gEMEgsHgty9VwAAA0FJREFUWMO9l09oXFUUxn/fmXlpItppi22k7UJBRSlVkCytSAuKUloIdjKT0El3FXVXdVFKRVAQV7qQohsNwdA0UFvBhYtqUVyIVlRaogtFQVq7qSTVjA3z3nHzBq/jvPmTN/Ss7rv3nvN99/y794kByMzcfE/7picn/jenmwWeRUI3E7wdCRskuCSTdDfwBvCtJEdySV9KOhpF0e0/LF5SqKtBgbv7ZjObcvfXgShD9Zqk5+orKx8Oj4z8NT05kU1gZm6+bdK0Azezu9z9hLs/HoIBvwAF4H5gKFh7B3gBWFY3460kWve4+3oze9fdx9OpVUmvmNlMHMf1RqNBFEUldz8OHAxUX9q6bduryut+Sfvc/Wz62ZD0fK1afjND9y3gGSRwv1GMojstTxUUCoVhdyopEYDzKXjWwZ4FFnEHWBc3Goet00m7lZlZYQixKw0FZnakGZksHUnHgvCN5/KARBH37enpOVg58H13HV0Kxg/kIuD/ngSA2ZMLt3bTSZJkUzNk7k4+D0AM/CGpaXCyBw/sC8Y/qZd2GpZiuL9YLN4Sx/HpoP5/c/exQ1OVq+1yyt13SLoArEsJnMjlgfOffvK3u58Kprab2QezJxfG2iTzUzI70wRPG9jbmpmb95SNB9mpzp7/j2yVdNbdx4K565K+cvfPJQ27+x5gBzAS7Hlvy+jo4WIvoC3kWpcvS3rR3eeAO9K529x9N7C7zX6AC2b28hN7Hl1Vt44niVq13LUjmtlYkiQfA5s6eO+GpDNJkhw9NFX5ueNt2ARodyF1IHIN2JiOl4H16fiKpK+B2Vq1vBAqFAf4IJkGNiIhWJK0192vunsC1IE/a9XycquNXARa5OnApeeioaHvKuP7r3dTGsiLqFAo7JR0T7B8rhfwXARa2us4UEqr5Ffgs151i/08oTNKdIO770ptObBYq5Yv5ibQq/sl3Qc8lJ4+lnSqH1vFfp9koZRKJVtaWnqkWXqSVkqlDe+vmUDWpZMlK/X6MBDegKf3P/nYaj8ErN9fqZBYEsf3Ag8G8Xit33BaniTcvGX0IvAw8BHwTa1y4Md+CeRqRL9fudwAvpienNi7Vhu21uwflOT+L+i1X2TJP57iUvUFtHWsAAAAAElFTkSuQmCC\\\");\\n}\\n.bk-root .bk-tool-icon-help {\\n  background-image: url(\\\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAAXNSR0IArs4c6QAAAAlwSFlzAAALEwAACxMBAJqcGAAABltpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IlhNUCBDb3JlIDUuNC4wIj4KICAgPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4KICAgICAgPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIKICAgICAgICAgICAgeG1sbnM6dGlmZj0iaHR0cDovL25zLmFkb2JlLmNvbS90aWZmLzEuMC8iCiAgICAgICAgICAgIHhtbG5zOmV4aWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20vZXhpZi8xLjAvIgogICAgICAgICAgICB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIKICAgICAgICAgICAgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiCiAgICAgICAgICAgIHhtbG5zOmRjPSJodHRwOi8vcHVybC5vcmcvZGMvZWxlbWVudHMvMS4xLyIKICAgICAgICAgICAgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIj4KICAgICAgICAgPHRpZmY6UmVzb2x1dGlvblVuaXQ+MjwvdGlmZjpSZXNvbHV0aW9uVW5pdD4KICAgICAgICAgPHRpZmY6Q29tcHJlc3Npb24+NTwvdGlmZjpDb21wcmVzc2lvbj4KICAgICAgICAgPHRpZmY6WFJlc29sdXRpb24+NzI8L3RpZmY6WFJlc29sdXRpb24+CiAgICAgICAgIDx0aWZmOk9yaWVudGF0aW9uPjE8L3RpZmY6T3JpZW50YXRpb24+CiAgICAgICAgIDx0aWZmOllSZXNvbHV0aW9uPjcyPC90aWZmOllSZXNvbHV0aW9uPgogICAgICAgICA8ZXhpZjpQaXhlbFlEaW1lbnNpb24+MzI8L2V4aWY6UGl4ZWxZRGltZW5zaW9uPgogICAgICAgICA8ZXhpZjpQaXhlbFhEaW1lbnNpb24+MzI8L2V4aWY6UGl4ZWxYRGltZW5zaW9uPgogICAgICAgICA8ZXhpZjpDb2xvclNwYWNlPjE8L2V4aWY6Q29sb3JTcGFjZT4KICAgICAgICAgPHhtcE1NOkluc3RhbmNlSUQ+eG1wLmlpZDpBODVDNDBDMzIwQjMxMUU0ODREQUYzNzM5QTM2MjBCRTwveG1wTU06SW5zdGFuY2VJRD4KICAgICAgICAgPHhtcE1NOkRvY3VtZW50SUQ+eG1wLmRpZDpBODVDNDBDNDIwQjMxMUU0ODREQUYzNzM5QTM2MjBCRTwveG1wTU06RG9jdW1lbnRJRD4KICAgICAgICAgPHhtcE1NOkRlcml2ZWRGcm9tIHJkZjpwYXJzZVR5cGU9IlJlc291cmNlIj4KICAgICAgICAgICAgPHN0UmVmOmluc3RhbmNlSUQ+eG1wLmlpZDpBODVDNDBDMTIwQjMxMUU0ODREQUYzNzM5QTM2MjBCRTwvc3RSZWY6aW5zdGFuY2VJRD4KICAgICAgICAgICAgPHN0UmVmOmRvY3VtZW50SUQ+eG1wLmRpZDpBODVDNDBDMjIwQjMxMUU0ODREQUYzNzM5QTM2MjBCRTwvc3RSZWY6ZG9jdW1lbnRJRD4KICAgICAgICAgPC94bXBNTTpEZXJpdmVkRnJvbT4KICAgICAgICAgPGRjOnN1YmplY3Q+CiAgICAgICAgICAgIDxyZGY6U2VxLz4KICAgICAgICAgPC9kYzpzdWJqZWN0PgogICAgICAgICA8eG1wOk1vZGlmeURhdGU+MjAxNjoxMToyOCAxMToxMTo4MjwveG1wOk1vZGlmeURhdGU+CiAgICAgICAgIDx4bXA6Q3JlYXRvclRvb2w+UGl4ZWxtYXRvciAzLjY8L3htcDpDcmVhdG9yVG9vbD4KICAgICAgPC9yZGY6RGVzY3JpcHRpb24+CiAgIDwvcmRmOlJERj4KPC94OnhtcG1ldGE+Cphjt2AAAAT7SURBVFgJxRdbaFxFdGb2bhui227BWrsVKYgf2kJUbP9EUPuzEB803WTXJjH61Q/7Ya1+CMYKEVTsh4J/EpvY7BoabUiNiA8s1p+4KIhpoUUEselHqyS76TbZ3HuP58ydc3d2u4+IkQxczpz3mZkzZ86VYpXjvenpjZsLhUcliE4AuUuASAgptmt1EFdwPiclzIIUUwubNn17OJlcXo1p2UpodHRiux9xB1Eug1+slbzhFxGOKc851tu7/0oznYYBDA8Pt0U2tL8KQryIq2tvZqQhD0QJHRz3yqWhgYGBpXpydQMwqz6NCnurleCSADkJEfgKfOePqL80R/wV1ZaQyr1LenKfkPCkEPKeaj0xg7vxVL3duCmA0Vyuw/fl52hgBxsBED+h4Cv9z3R/zbRm8MTJTx7HQN7GQB6w5C4L4SX7M5lfLBpurjXMyvNIShiyi0l1pL8n9b7EDGPR8fHxzSsQ6XDB3618/xqo6Pk25V5MpVJllgHM1BO58RdQ612kOYZ+GXdij70TYQB05mpj+1kU5G2fB+l3PZtOf8NGx6ambnMXb3yAxg8wjSEG6OKKR9oicBQD+ZvpH2Wzj0lQpxCPG9qMv1x6hHNCsSAlHM7ZOa682vlI9tRDbvHGbD3nZAPpDoD/3JIrLpAs26UFkC3EMUA99hpfGtEBfJjNJnS2Gwnadnvl+Xw+iuc3DAJuNyIaSCHpilVldyDjjUxj3WDZIAhxhHHyRcdNuA7AAfUaXzVKODpzFiZ4/uLvh5G+m2no+C/pyIf7MqlEJB7bpqR6nXkEUfbeawuLaZsW2ISfNQ2vtaktQlGFQyIVGT0o2+2EC4iQNGwjBIN9qdQ5Qg4mk4X4rW3vCClLtowE2FOFUxKDfNmiZci3ovKKRFPh4FK9q4Zbdr+lKKJiA13TcHR2dmLBgdmQ0GAS2MZaEowY+XbAk09IvgtYZGp16SyvFhaHcIUh645t8T9DBCcnz5zZ4hZLu3DzK2QlL1QQa0Y+pHiJKPSuOGj3PmZTheM5w2TwqBxnvBZOTk7G5gvXJ5Aelms8wnJURL+olSWcfEhf6gDoUXPMq6ZlqbzWU2pE+3hi4s6F68tfIj9cBMlikr7Z0/P0b/X0yIcUXsDCF1WhtL4OROHaXk+xlkbV0Cu732Nmhc4peaWSg73pA8dq5RkvO37ldUTfXCKZv2q45MkhvG87WQEzpCCUSvV1d9GONBy3lMvgKSwrZig8gjAietWY0QriylO2jIo4yVbOSb7KB/qmI9BPKjHpSSXYauRyn92Nq9/Kcrj13x3s3v8D481glQ/0raiNYgX9njPSBOImbrHZePl+tfFmc9sH+Xaoh8NjOKSVdDMhjjYzQLy+dFceH5+IJQf9VYXX4tROg4ZFU8m31M3mfPEqUoJqCGJfvWpo2xnNfdrhC28n06SCeSzNZxlvBINGRXCtKS7EY1uV6V7HWAm38y1cXaXsMcOCvr9ySPj+af7A1U2HJXHzVNvUXVLIGyPf+jV0pf8GHoN+TLAyPkidTCi2RpPApmnR0Bd1zGRaB/B8Oj2HSw7LLbVR1MmskW8RdEWVXSJf3JbpAMgRtc4IZoxTh9qotQjCasm46M0YX9pV1VmbpvRH5OwwgdRtSg2vKaAz/1dNKVtb17Y8DCL4HVufHxMOYl1/zTgIgiYvBnFKfaNp3YjTdPz3n9Na8//X7/k/O1tdwopcZlcAAAAASUVORK5CYII=\\\");\\n}\\n.bk-root .bk-tool-icon-hover {\\n  background-image: url(\\\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAB3RJTUUH4gEMEg4oVHp0SwAAAQJJREFUWMPtlsENgzAMRb8RQ5VJItFDOgaZAMaAA0iZpN3KPZSoEEHSQBCViI/G8pfNt/KAFFcPshPdoAGgZkYVVYjQAFCyFLN8tlAbXRwAxp61nc9XCkGERpZCxRDvBl0zoxp7K98GAACxxH29srNNmPsK2l7zHoHHXZDr+/9vwDfB3kgeSB5IHkgeOH0DmesJjSXi6pUvkYt5u9teVy6aWREDM0D0BRvmGRV5N6DsQkMzI64FidtI5t3AOKWaFhuioY8dlYf9TO1PREUh/9HVeAqzIThHgWZ6MuNmC1jiL1mK4pAzlKUojEmNsxcmL0J60tazWjLZFpClPbd9BMJfL95145YajN5RHQAAAABJRU5ErkJggg==\\\");\\n}\\n.bk-root .bk-tool-icon-crosshair {\\n  background-image: url(\\\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAADEUlEQVRYR81XXVIaQRCeHqug8CXmBNETaE4gniDwIgpVspxAbxC9ATkBkCpQ8gKeQDiB5AQxNyAvUlrldr7eHxyGXZi1rMJ5opbp7m++7un+htSGF204vsoMoNXrlzSpfWa1oxQfhAegCZGaEtPorHo8znIoJwCt6+td8uk7ApUQCIHTF4BNAWzImq8ap6cP68CsBdDp9i9ZqXM7ML79g/EnCWD+jgMKENKqWT+tXK0CkQqgNRjs0OxpQIqKhoMxaG6/6JeRnK7T6yO2UvVqhYSlLX+ryORfgKn9ORDFIy7ky41yGcwsr0QAQfDH5zucOswx819fs4egI9OFCcD8DjBF7VNbEX0JzdWEt3NHSSASAcCxBDqMgt/623kvyTgNgNjJIfTjk4D4FqaJR1715MjmYAmA5Bx3AwUXQL+t105KaTlcBSC26XRvhjEIoLiq1yqXpr8FAGG16/ug4IT27fxBWu7EiQuAiImJpEMKE6nYM30uAIDDttSUOPfJP7JzbjPhAiBIh9QE67vIvoOi9WJfCwDavf40ulpjbCqmUf+W753ezURuh7Dg1SqflwAEHU6pgfyBq9Y4qx0LG++2fnZ/eUzcstmdM2AWH+jfc+liWdBJfSENf8Lifi3GVwC9mybOfi5dzatWVrbbLIHNva8p5h/16gkaFiLGGxbufkoE6XguwePiXLF3XmMfCUCUAqtKXU7sumd1CowOuJEi3Pg1FBpjitIGhyvVSfvmjci6ZR+rFQfDiPVE2jFYeICQ+PoewwjC5h7CZld6DBdyu6nDSKgzOyIMhmhK5TTqXYbRorZYM46TmpKAAOrGWwSJJekSB1yqJNOzp1Gs7YJ0EDeySDIMtJbQHh6Kf/uFfNFZkolJICRmz0P8DKWZuIG2g1hpok+Mk0Qphs0h9lzMtWRoNvYLuVImUWrmPJDlBKeRBDfATGOpHkhw670QSHWGLLckmF1PTsMlYqMJpyUbiO0weiMMceqLVTcotnMCYAYJJbcuQrVgZFP0NOOJYpr62pf3AmrHfWUG4O7abefGAfwH7EXSMJafOlYAAAAASUVORK5CYII=\\\");\\n}\\n.bk-root .bk-tool-icon-lasso-select {\\n  background-image: url(\\\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAB3RJTUUH4gEMEgwlGP1qdAAABMBJREFUWMO9V1uIVVUY/r61z57ZMx4DnbzgkbQXL5iCJphlWdpIGY4jpFBkEiU9ZNaDRRcITcIwMwgxoQtU2IMXdAZfMjFvpERXYiSbysyBEXFmyuHMnLP32uvrwT2xnY5nxvHQ93Jg7fWv71/r//7L4a59TRgqJk+Z6v3a+sv0OI5nk5wu6VaSVZImAThHsgjgrKTvM5nMUWvtmf5n8HodCIKgOgzDhc65pSTrJQWDsSNpJX1ljHnDOfdT37oZLLHv+8OMMasKhcIJ59xHAJYMlhwAJGUAzJfUTHLFuFzOG5QDU6dNMyQfs9Yedc5tBpAD4IYYNQGoBrDtQnt7/b0LFrJsCHzfn2itfQfAnZLiazytA3AaQAuAiwDaEgeNpGkkswAWSBqRONB38b88z5uTKePt6iiKXkk8jq+iJC5LOmiMaTLGHLPWhmWeHr7vV0dRtATAapAzIVmSo51zyzIlbm2stesFPA6pKk0r6Ryg93y/ek8YFvPOOTg3cDSiKCoC2OP7/rEoirYm4rUkF12lAWNM1lr7lqQn0+QA8gI2jBg5cj6Aj8OwmB+KAKIoukhyp6SRJAUgl0ndPLDWPi9pJQCbuviXvu+/GIZhW1dnJ24UJFuTjCCA2ADA8sYGWmsXS3qmL94kDYAtkh4Nw7ANlQJ5U6INT1KrAYC9zQdykl7nFSj5fXp5Y8NWVBhy7mUAjqShMYdMXV2dJ2klyRwAJ8lIeuGWCRMP7N7frEqSG2OmAFhKshNAp5wrmO7u7jEAngPQm1S2z2pqapr+OPt7XEly0oxwzq2RdFmSD2AMgKKJouhhAL4kA+Cs53l7e3t7uytJHgRBreTWkXwkKVJnJD0B4GAGwIJE9R6AFufc6UqSZ7PZbD6ff5dkA4CQZEHSqwAOISmXtwGIE+F1SeqqIP8d+Xz+C0mLJYWSAODteXffczjdDQNJ0BWMCoLg5gqIbRTJNwHsljQhUb0luWPM2LE7Thw/9m/5NCT/TByxAOYWi8X6/gdWV1dnfN8fNRBxJpMZTXKdc+6IpFVJWAEgkvSJpA0X2tvtVTaSjgOYBCAEEADYSHK87/sfhmEYA9gShuEDkgzJHyWtB/B1irQ2juP7ADxkrX0wOUOpzmdpzEY590HJ7Ni1r2kSyZOSiv2+hSRjSTXp/QAukzySNJOJkmalyNIl10hqMcasdc61XDNcQRD8BnITgNp+36r6kfcNFMMlLQGwTNLMEuQGQBfJl2bdPru+HDkAZAqFQux53jZHEsC6aw0eg2gylNRBcqcx5v04ji999+03AwsWAOI4Lsy9a94WkisAnE5a5WCJYwCfA1g7LJudI2lTHMeXBm1faiQzxkyRtF3S5CTupeAB+KG2tnZFT0/P30NO2VKLzrmfAbwGMipjG5Oc0dPTc0Md05SZ5U4Q2FxChErtEYD7jTGNQ3UgM8Asv90Yc9I5LSKRlXSI5CxJa0jWSALJjKRnAewfkniT+vwf7N7fXHK9rq7O7+jo+BTA/NRrdBpjnnLOnUrvXd7YMPQXSBunneno6IhIHgYwW1JtkgmBpBkATlVMAwOk3nFJ+VSoqgCMr6gIy2FcLtdKspAedyQN/98caDt/3kpyabUmf8WvG/8A1vODTBVE/0MAAAAASUVORK5CYII=\\\");\\n}\\n.bk-root .bk-tool-icon-pan {\\n  background-image: url(\\\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAB3RJTUUH4gEMEg4lKssI9gAAAOtJREFUWMPVll0KwyAMgNPgoc0JzDX2Mtgp3csKErSamGabIEUo/T6bHz0ezxdsjPJ5kvUDaROem7VJAp3gufkbtwtI+JYEOsHNEugIN0mgM1wtsVoF1MnyKtZHZBW4DVxoMh6jaAW0MTfnBAbALyUwCD6UwEB4VyJN4FXx4aqUAACgFLjzrsRP9AECAP4Cm88QtJeJrGivdeNdPpko+j1H7XzUB+6WYHmo4eDk4wj41XFMEfBZGXpK0F/eB+QhVcXslVo7i6eANjF5NYSojCN7wi05MJNgbfKiMaPZA75TBVKCrWWbnGrb3DPePZ9Bcbe/QecAAAAASUVORK5CYII=\\\");\\n}\\n.bk-root .bk-tool-icon-xpan {\\n  background-image: url(\\\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAB3RJTUUH4gEMEg4X4hxZdgAAAMpJREFUWMPtlsEKwjAMhr/pwOOedINJe/PobWXCfAIvgo/nA4heOiilZQqN2yE5lpD/I38SWt3uD9aMHSuHAiiAAmwaYCqoM/0KMABtQYDW11wEaHyiEei28bWb8LGOkk5C4iEEgE11YBQWDyHGuAMD0CeS30IQPfACbC3o+Vd2bOIOWMCtoO1mC+ap3CfmoCokFs/SZd6E0ILjnzrhvFbyEJ2FIZzXyB6iZ3AkjITn8WOdSbbAoaD4NSW+tIZdQYBOPyQKoAAKkIsPv0se4A/1UC0AAAAASUVORK5CYII=\\\");\\n}\\n.bk-root .bk-tool-icon-ypan {\\n  background-image: url(\\\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAB3RJTUUH4gEMEg4anK0lywAAAMVJREFUWMPtlzEKwzAMRX/S7rlpIMXeOnaLaME36FLo8XqCdNFghGljyc4kgQi2Q/SUj0F/eL7eMMTKz6j9wNlYPGRrFcSoLH4XxQPvdQeYuPOlcLbw2dRTgqvoXEaolWM0aP4LYm0NkHYWzyFSSwlmzjw2sR6OvAXNwgEcwAEcwAEcwAEcoGYk20SiMCHlmVoCzACoojEqjHBmCeJOCOo1lgPA7Q8E8TvdjMmHuzsV3NFD4w+1t+Ai/gTx3qHuOFqdMQB8ASMwJX0IEHOeAAAAAElFTkSuQmCC\\\");\\n}\\n.bk-root .bk-tool-icon-range {\\n  background-image: url(\\\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAAXNSR0IArs4c6QAAAAlwSFlzAAALEwAACxMBAJqcGAAABCJpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IlhNUCBDb3JlIDUuNC4wIj4KICAgPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4KICAgICAgPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIKICAgICAgICAgICAgeG1sbnM6dGlmZj0iaHR0cDovL25zLmFkb2JlLmNvbS90aWZmLzEuMC8iCiAgICAgICAgICAgIHhtbG5zOmV4aWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20vZXhpZi8xLjAvIgogICAgICAgICAgICB4bWxuczpkYz0iaHR0cDovL3B1cmwub3JnL2RjL2VsZW1lbnRzLzEuMS8iCiAgICAgICAgICAgIHhtbG5zOnhtcD0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wLyI+CiAgICAgICAgIDx0aWZmOlJlc29sdXRpb25Vbml0PjI8L3RpZmY6UmVzb2x1dGlvblVuaXQ+CiAgICAgICAgIDx0aWZmOkNvbXByZXNzaW9uPjU8L3RpZmY6Q29tcHJlc3Npb24+CiAgICAgICAgIDx0aWZmOlhSZXNvbHV0aW9uPjcyPC90aWZmOlhSZXNvbHV0aW9uPgogICAgICAgICA8dGlmZjpPcmllbnRhdGlvbj4xPC90aWZmOk9yaWVudGF0aW9uPgogICAgICAgICA8dGlmZjpZUmVzb2x1dGlvbj43MjwvdGlmZjpZUmVzb2x1dGlvbj4KICAgICAgICAgPGV4aWY6UGl4ZWxYRGltZW5zaW9uPjMyPC9leGlmOlBpeGVsWERpbWVuc2lvbj4KICAgICAgICAgPGV4aWY6Q29sb3JTcGFjZT4xPC9leGlmOkNvbG9yU3BhY2U+CiAgICAgICAgIDxleGlmOlBpeGVsWURpbWVuc2lvbj4zMjwvZXhpZjpQaXhlbFlEaW1lbnNpb24+CiAgICAgICAgIDxkYzpzdWJqZWN0PgogICAgICAgICAgICA8cmRmOkJhZy8+CiAgICAgICAgIDwvZGM6c3ViamVjdD4KICAgICAgICAgPHhtcDpNb2RpZnlEYXRlPjIwMTgtMDQtMjhUMTQ6MDQ6NDk8L3htcDpNb2RpZnlEYXRlPgogICAgICAgICA8eG1wOkNyZWF0b3JUb29sPlBpeGVsbWF0b3IgMy43PC94bXA6Q3JlYXRvclRvb2w+CiAgICAgIDwvcmRmOkRlc2NyaXB0aW9uPgogICA8L3JkZjpSREY+CjwveDp4bXBtZXRhPgrsrWBhAAAD60lEQVRYCcVWv2scRxSemZ097SHbSeWkcYwwclDhzr1Q5T6QE1LghP6BGNIYJGRWNlaZItiFK1mr+JAu4HQu0kjpU8sgF3ITAsaFg0hOvt2Zyfvmdsa7a610Unx44Zgf773vvfneezPHNzrbhn3CT3xC3wPXYOC8LDzqdi8YY/gwh4BeknS/2th6dr2kf94AOp3OFyWgMyziOPbMDxV9FTtJnl1ut795Xd0/YQ0/vtYQwMT1KXWCfr2IjOWwtNehwN4xL9ykTrm6Pzl58yLn3J+mKh9mXbT3uRjGEDph+O8/TjfP5dBp7Ha7AX7O3o5nZeD/0E/OGyXntDgzA0X6qmCnrVutVlrUWV9f/3xo+pwhGDhvEPHOjoxnZjJggXmMHzBQ7NGNp9vxk61fr0HR7e/u7pZzCGHlc7qwBYYTT7tJYSx1AQzppyFPft5apta9w7SKcn0b7P7+/jCsDQ5mbc0dCmIJGDN0ehdcjsmkm6A6KUeKFOTE11PLxrC7Ukqh3ylL2fT0NAP9q6ur6rRCJJYsbKB0JsbCKMuy+xREePDyxQPCz+Crlw062QcA5wBOOt1l6vIl2WiI9F1fN6Q+BBqit6hEC4Hk08GQJMn4myjSP7RavVxgdaVUh/3U6HCMsPr9pYnJKRziHtWQ+un58+hGs6nsjQSjpuTyKGN3CX+FBwHXSiEVgjP+O8X6N12kIePES+GzTKAkGbNp8yJsGUMVzz8jPKReiyAQRimy5/cjye5RpF8utFp/+nwmT7d/NMzcFkS7yjJNGDaPURQxIQThEQy0SyF4l5WJYYhBa816vZ6dU7A6CAhbZVow/pDe0O9hVOoCi13r4BgBAvJHqMSQL2vE/iH6IAXEwgrRVUmBoRRwnwJQT98xEeVeSUyB4dJ5nwJBKdCFFGRmUCcu7rwIYypCTblaChuNBhWODrman5ub+4v0rMNBt8z6Ezh7GksJQpCbm79cMQE7QBFm/X6f0rjWnv8WRYg/QdbUpwDAEBy8vPyA8rNGzg3a8MiElwiM7dAtRqNoNptjGPM1laVxP9umWEMGLOKhKUOJDtBwDmzsw9fC/CzHr9SGuCTi2LbbKvVtmqXpCjMihBFa79Wrt5fGx9PDzc3fmu32Lf8qFliwU9emKhBSp+kRKn/hu9k1COEDbFdt/BoKWOAkuEbdVYyoIXv8+I/QK9dMHEb1Knb7MHOv8LFFOsjzCVHWOD7Ltn+MXCRF4729vWMDK+p8rLkvwjLg4N4v741m5YuwCI9CvHp1Ha8gFdBoPnQAkGsYYGxxcfEI7QQlFCTGUXwjAz4tWF+EpymOWu7fglE7qsOvrYE6g4+9/x/vhRbMdLOCFgAAAABJRU5ErkJggg==\\\");\\n}\\n.bk-root .bk-tool-icon-polygon-select {\\n  background-image: url(\\\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAB3RJTUUH4gEMEjc1OfiVKAAAAe1JREFUWMPt1r9rU1EUB/DPK0XbqphFHETo4OCiFhwF0V1KHbRSROLqon+AUMVRRFBwEbRFMBiV+mMW/wIxi5OD1kERRVKRJHUwLvfBTZrU5OWBGXLgQu7Jfe98z/ec7z0vKa88b2q1BDtRHdAPBaylm1NzsxsOjPnPNt6WSWprbft+/c3I3zOAjhT1Y4+fvcjEQJIXnVECSa+AhqIHqlHH5lWCZoe+Gk4GRgDG86j9SAUdlDBSQaZhlOkuHyoVdJmsw98D1S5fM4NYM1LCpqM+Lwa240oLgmZzpVZvzKT75VLZcqksSZKWlQeAy/iORVwIvh31xvotvK7VG3Px4aWHj3Jl4C2uYSvq+Bn8v6LLbaVWb9zsBiKLCvbiNG7gLm7jAYqbPHMJMziZ9lsKoh8GtqCEVVzHftwJn+TFHp4/hg8BSCYVfMOZoPEv2NZGdy9WCGUr9toDR3E2/H4V6nwRe/BmgN65H1ZhvMuB3XiKIyFoGefwO6ysVkUlrNUNsyAK/jli533Q+Y8cJFvAeXyMS1CI/jiMr/gUtD2LQwMGr4R3p7bY3oQHQ5b38CT4D2AXXg6YcQXHpyYnlqKsi5iOAVSwL9zd7zJ09r+Cpwq72omFMazjT9Dnibym0dTkRDUKrrgwH7MwXVyYB38BstaGDfLUTsgAAAAASUVORK5CYII=\\\");\\n}\\n.bk-root .bk-tool-icon-redo {\\n  background-image: url(\\\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAB3RJTUUH4gEMEg4itK+dVQAAAaFJREFUWMPt1L1rFFEUBfDfJDaBBSslIFjbaSFp1FJQFMVCHkzhKIqdUYOCoBgErVz8rCwiTDMwBCIKipDWyip/gxAIWAmBgBC0eYFh2Gx2l9lFcA5M8e59782Zc84dWrT435Hs1siLchqn43MS0zgW22vYxjesYjVLw3YjBPKinMUTBOwf8J5fKLGYpWFjJAJ5Uc7gIW6jM6Kim3iNZ1katgYmEL/6I+YasvY7Lg6iRpIX5VF8wuEe/XV8wGf8jN6LWTiAc7iEQ7ucPZ+lYW0vAtfwvlbfwCKW9gpXDOv1mJvZHiSO91MiyYsyiQSuxtpXXM7SsDmM5nlRdrCMMz3sOJWl4Xevc/vwBzdwAl+yNNwZxfRI+GxelK9ikHcwh8d4NNR/YFRES1ZwoTYdR7I0rNf3TzVNIGbmSvR/Bx08mIgCFSVu4l2ltIWD9WxNGR+W8KOynqnZ0rwCeVG+wa0hjrxtWoF5dAfc28V8Mib/n+Nev5dnabg/zgw87aNEN/bHOwVRiRe4Wym9zNKwMKkpgIWKEt24njxiJlq0aPFv4i9ZWXMSPPhE/QAAAABJRU5ErkJggg==\\\");\\n}\\n.bk-root .bk-tool-icon-reset {\\n  background-image: url(\\\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAB3RJTUUH4gEMEg4gWqH8eQAABLdJREFUWMPtlktsVGUUx3/nfvfOlLQaY2IiRRMQIRpI0PjamJhoVASDvNpCpYw1vJQYSVwZwIVQF6wwRHmkAUof9ElrI6VqDAXcID4TF0IiYQMkSlTokNCZ+b7jove2t+NMH7rQBWd3v+989/zP+Z8X3Jb/WGQySvUNTQBJESkNguAVYIWqzhaRhwBU9WcR+QXoymazn6jqzUQiMQSQzWZRVdal1vwzAI2tHQBPOuc2AbWTdOyQ53n7nHNfRwee51GzqoIQMCLDpr3x/tLQ0oZzrk5Vj0/BOEBt+KYuOlBVGlrahr0Wob27t3gEjnZ2AyQzmUwHsDgP6J/AYRE553neDwDOuUdU9QngNeCumK4TkRMhZUORcYC1qysLA6iuSQHIwkWLD6lqapQsuSmwTVV3h99I7EcAR462A2xR2Ilq6ehTaejvO1774kuLNALR33eclsaGsQDe3fYegHl43vyNwEeqGl1963mm2jl7YZRTQ82qlWP4HM6ZToC5ztkW4LHQoALru7s6Di5dvlIj/e6ujrEAWoZDn8hmMjXATMACGaAVuBjXTVVXFc/AxhaA+4zvn1DV+eHxVWPMAmvtb5GeMWZyZVhI2rt7qVy2pOh9U1snwIPW2vMi4oWJuBPYHkVAVScPoKmtkzVVK6cEMsyJraHhiCqJqJUwj/JRz7TW1iSSyR2rVyylqa0Ta+24Ic8vXaAEmDFc/l5Z2A/80OibuVyuz/f9ElUdHCmvw82t5HK5h6y1PYhsz2YyGw43t2KtBZHIGwB6+j4rCkBVUdV7gXrggnPuu8h4eP+xMeZS2D0rJYZ6AdAMzAt1b4nI26p6IFZOY8pugijcKSIHVLUK0LyST4vnrVfnWr3mjmP4QTATaERkXkypRFX3isjmuHdRJEK6Ckqquopp06bdKCkp2Sgi7XnGLcg7gzeutwNIiPYc8HixqIrIOlU9ONVIhHPEd851icgSVXUiskVV94gIqoonIt0i8gfQCfwae38e6BWRXuBZz5jZ8VbaOE4EIqlZVUEQBLlkMplS1QER2RwkEnsSyaREDUzyeNsvIhvCMqkH1kdIJ2o+k8iJB1LVVRfjZ6nqqlEAIbdVQGto8Lrv+/dbawcjAL7vc+6bs+zetetfLSHxniIFGofGGsU2oC7eOCbDfZ7nQawBOSAX74SF9oEPImOq+r7nmVmxb5raukZa8UReGmNmhbMkAwwBH467EYVZe49z7kdgenj8k7V2oTHm8kgdWcvrNdVFjR8cHkYzjDH9wLjDaEwEzpwa4MypgWvAjtjxfGNMj4jMiT+M+kFsZI/Q6Pv+HGNMT8w4wI7TAyevxXVPD5z8+zD64tRXAMHVK1eaVLUyVvuDqroV2BOnJF4ZIedviUidqt4Re9s+vbx8zZXLl7PR2+nl5Tz/zNOFp2FzxzGAklw22wUsLLaSKXwf8vhosZUM6PeDYEUum70VHfpBwKsVyyfeikOP6oBNwN1TrLbfgX3A1kKLzKeff8nLLzw38T5wZDgxn1LnNk5lLRfP26/OnR2hwfNYW2Atn9RCsrf+EECyrKysDFimqhXhyjY3VLkAXBKRDqA7nU6nS0tLhyIj6XSaN9bVclv+l/IXAmkwvZc+jNUAAAAASUVORK5CYII=\\\");\\n}\\n.bk-root .bk-tool-icon-save {\\n  background-image: url(\\\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAB3RJTUUH4gEMEg4UexUIzAAAAIRJREFUWMNjXLhs5X+GAQRMDAMMWJDYjGhyf7CoIQf8x2H+f0KGM9M7BBio5FNcITo408CoA0YdQM1cwEhtB/ylgqMkCJmFLwrOQguj/xTg50hmkeyARAYGhlNUCIXjDAwM0eREwTUGBgbz0Ww46oBRB4w6YNQBow4YdcCIahP+H5EhAAAH2R8hH3Rg0QAAAABJRU5ErkJggg==\\\");\\n}\\n.bk-root .bk-tool-icon-tap-select {\\n  background-image: url(\\\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAA2hpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMC1jMDYxIDY0LjE0MDk0OSwgMjAxMC8xMi8wNy0xMDo1NzowMSAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VSZWYjIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDo3NzIwRUFGMDYyMjE2ODExOTdBNUNBNjVEQTY5OTRDRSIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDpCOTJBQzE0RDQ0RDUxMUU0QTE0ODk2NTE1M0M0MkZENCIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDpCOTJBQzE0QzQ0RDUxMUU0QTE0ODk2NTE1M0M0MkZENCIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgQ1M1LjEgTWFjaW50b3NoIj4gPHhtcE1NOkRlcml2ZWRGcm9tIHN0UmVmOmluc3RhbmNlSUQ9InhtcC5paWQ6OTQ0QzIwMUM1RjIxNjgxMUE3QkFFMzhGRjc2NTI3MjgiIHN0UmVmOmRvY3VtZW50SUQ9InhtcC5kaWQ6NzcyMEVBRjA2MjIxNjgxMTk3QTVDQTY1REE2OTk0Q0UiLz4gPC9yZGY6RGVzY3JpcHRpb24+IDwvcmRmOlJERj4gPC94OnhtcG1ldGE+IDw/eHBhY2tldCBlbmQ9InIiPz6eYZ88AAADLklEQVR42rSXf2TUYRzHv7tuGcfE6Vwb5zLSSjEj7Y9KWqfEmFZJP+yPMdKKmUrrn0iUfjhWlLFi6YfNrF+StBoTo39iYkTGco4xxxG59P7k/T2PT8/37nu3bx9ezvPj+zyf5/PreS78bGLS8SmrwE6yje3NHJsDBTALpknBz6JhH3NiYAB0gHqPOVv52wJ6QQ48BzdAttTioRJjdeA8mAHHS2xuk3p+M8M16ipVQE49Ds6CiFO9RLjGONf05QLx6wPQaBlbBlPgJVgkP0ETiIJ2sB/E1XfimjfgBOOlKDUqCGOcqBcQnw6BYW5YTo4wbvQhMmCfGRemC2rBiGXzWUb+kM/NRZ6CHWBM9ce5R61NgX6ayhSJ5EPlItlDRNkz4JbFHf06BkSzHjXxM+gDv1S/mPUo2AXWgt9UUHL/IVhS8yUV1/EbV3o4N+NaoE9Fu/i827K5pNYHnqAVJECShWmAaddpscYFFXwR7vnXBRGlnUN/L6kqKJlxnRUuDbaDBiL+vst5d4gpcpBrqk/2jIgCKVUolhntplzivHmwh4stGOPfwBWwl/2dpp8p7xjQZqFLiQJtauKkivYm+kzccpK57yXfOUe+P23JqAnVbhMFmlXntCWnxbT31am9ZJ4BJifsUmNTqt0cYhA5ypympPg7VkEKunPbVb8cIG+0kyHLJZNR7fUMooUKFHAPkfQo58VLK+RzwRDd4FdWG9mjpaAXzqkJa1R7kQttqEABWXMjOOxxVRfnhRm5URX1prk/0pQHwNcKlchZ+jdpC+hFdVqO0my9Hj5dkYgCn1Rfh/KdlNDHrJhPqlDih+IfBd6qwpOgEqYMsorJ2HtWxtagLJDn/W3KRfPOZhoeBJfZPgVeGKeKrkQBh5dLXl25Ny3pc4/1fkTdbvFqFQgbxWeYD0hXulhQ0pYiM1jG547fcbMQpVnHTZEn9W3ljsCzwHxCdVteNHIZvQa7/7cC7nV6zHIfyFP9EXjFa7YxKAVqPP4bxhhoLWW+z9JyCb6M/MREg59/RlmmXbmneIybB+YC/ay+yrffqEddDzwGvKxxDmzhc0tc80XVgblqFfgjwAAPubcGjAOl1wAAAABJRU5ErkJggg==\\\");\\n}\\n.bk-root .bk-tool-icon-undo {\\n  background-image: url(\\\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAB3RJTUUH4gEMEg4em8Dh0gAAAatJREFUWMPt1rFrFFEQBvDfGhACASshkL/ALpWVrSAKEQV5sIULWlgZNSgIFkGIVQ412gkBt1lYLERREFJqJRaW1oHAoZUQsDqwecWy7N3tbe6C4H2wxc682Zn3zTfvLXPM8b8j6RqYF+UCzsfnHBawGt3fMcAX7GEvS8NgKgXkRbmMxwg41TLsN0psZmnodyogL8pFPMIdLHUk7hA7eJKl4U/rAuKu3+HslFr/FZezNPSTFslX8QErDe4DvMVH/Iq9F7VwGpdwZUjsPtaSFjv/1vCBPjaxO0xcNbHejLpZrrlvJCMCT+JzA+2fcC1Lw+GE4l3CG1yIptfjCtiKoqtiJ0vD3aM0Py/K57iIMxgkQxat4EdN7e9xdRzlk+LEEPvDWvIDXJ928sYxjL36icWK+VaWhlezOIqbGFirJd/H7szugrwoX+D2BDEvszSsT5OBdfRaru/F9dPXQF6U27g/KnmWhgctxqyzBrZGMNGL/rHI0nDkKXiKexXTsywNGx0OnFbFNk3BRoWJXnw//j+ivCi32/S8CxPVNiWOAdUiJtXITIqYY45/Cn8B2D97FYW2H+IAAAAASUVORK5CYII=\\\");\\n}\\n.bk-root .bk-tool-icon-wheel-pan {\\n  background-image: url(\\\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAB3RJTUUH4gEMEgswOmEYWAAABddJREFUWMO9l09oXNcVxn/n3vc0fzRjj2RHyIZ6ERuy6CarxJtS0pQSCsXNpqGFWK5tTHAwyqIGN7VdEts1LV04BEoxdlJnUbfNogtDCYWQRZOSxtAUCoFiJY0pWJVUjeTKM9LMe+9+Xcyb8ZMychuofeHCffeee7/vnXvOuefYlV/+mv932//tb91z/Y2rvxmMHQ+4FcEfOIGN4A+UwDDwoQScc7vM7AIwB8yZ2QXn3K77Ab6OgJnVgeOSbkqaBiaACUnTkm4Cx3OZzwf+qzcRQup1zNZ9RwDe+0YI4YKZTUn6zCGSMLOfAF/03r+QZdnyfwO+ePEiI6N1nPMgMDMkETLRbd2mXG8gCbd9YiIKIUxLKoLfBN7I+80+CUlTIYTp7RMT0b3Af37p8kh5y9gZcy4Fzt+5szqSaxkzUR7dwtrKMmaGW242d0t6vrD/He/90865o865o977p4F3Ctp4frnZ3L0Z+OryUrVSrZ0z8ZxhHjhcq1XPrS43q/0flDlK9XpPA2ma7gMeyvfPx3H8TJZlH4YQWiGEVpZlH8Zx/Awwn8s8lKbpvmq1ahvB641SXNk6dhLskNA2MIBtwKHK1vGTW8bKMRbAMgyPqWeETxUM8VSSJAv52JmZA0iSZMHMThWwnipXKp8hsLLcSaIR92oU8xjSayCQXotiHotG3Ku3m+0EOQwPQCDggMf7BzQajSs5eAk4B5zLx4O1vD2eJMmAQKliscgASJMw21pansFs1swQ/DNLmUmTMNuXX+taXHTDaj5OW612R1JZ0nFJJ/J+XFJ5aWmpA6S5bHV8fHsPHFU6q3pJCjtFxtrKMuXRLUUXXxdrRLazFOtUolZlsGhmACsgnHPTwJnCnjP5HMBKLotzxsTE9rgDL0t6LoriKsDIaB31ZEK+JxQJRHFUBR2NqLw8OTkZR0OC0ntm9k1JWU7OA4vD/mZ+YfElsANmNEKi75vztzB5M8uAr+bx48me88g757PQ1U5zNg52YH7hX8l6f+4Fi3c3BqHNmkI4YQOV2MGCNu9qHPYCewfzbrC+XSGcWEcgTRKA3wFfyzdDz5d+D3x9CIcfA4eBbQS9LscskgfLnHNPAnslvS/pbZDHLLPADpx9N9fqpSIBH8cxWZY9m6bpb4Ev5fN/iKLo2TRNgdx/eo8Wk5O7Ts/N/SOSdMjHdj4kmgkIEJLJzPZKetvMTkIvFLsR25Ml2gfuF5M7vnA66sdooJYkCSGERe/9VAjhzRxoKk3Tvg3U8nulVqvx8cyNpER2umM+SdOkbc5B8JhpqBdIgTRR24h+lpKen731aRIN7thscH9Zlv0d2F8YD2TIX7F2uw3A7ZWV1a0TYz9ca8cJZHRbuRuaDfUCw9/qJHamPOKToAwHtHN6lMvlSkH2o7wDMDo6WuGuQbbn5+YAKNcb3J5fSvrhtTY+vsOPuD1IOyRhMOkj9kSx29HfXB5RUnS964NT2+3vbGbxG9auO2cDNuV6A8NTb5TitBuOpQkfYD2vwOxgmvBB2g3Hto5X42EJyVsFlztbKpXGNgqVSqUxSWcLU2+tdToa9hasLjfPYlwGa+bTi8Dl1dvNsyvNtQQL9MO2w+HM7BqwlAtPdrvdq9773WAVsIr3fne3270KTOYyS2Z2bbXdHhogKmPj7YWF+VOSXs/v/9KdO+0fVBrjbRkgB/KIDBnYu9f/7D+ZmfmRxPd6qwB8YmZXcq1MAQ/nJhTM+OnDe/a8+PGNG9lm19V/D1Qw7HXZlcRa69+U6w38l5/4ipxzf5X0CPBILjcGPJH34pVcc8692FxcXLlXRnTwwH7+9P4f8aWe3fY59LIqo1NMyQBCCHNmdgx4BegUWefjDvCKmR0LIcz9L8nokSNH+PRvH4HC3YQ098pSbevg24qlmZmNmtmjkg4D3+j/tZldkvQXSa3PW5ptlpL3ZaIN99OS9F7+IgKUgSyEkNyv2nHT7DZX0dr9rpjua2l2r4rogRAYVqZvnPsPqVnpEXjEaB4AAAAASUVORK5CYII=\\\");\\n}\\n.bk-root .bk-tool-icon-wheel-zoom {\\n  background-image: url(\\\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAB3RJTUUH4gEMEgskILvMJQAABTtJREFUWMPdl1+MXVUVxn/fPvf2zrSFmUKnoBCUdjRoVaIxEpO2JhilMYBCtBQS2hejpg1Uo2NUrIFAoyGmtiE+GHwQGtvQJhqDmKYRBv+URFsFDNCSptH60DJTO3dKnX/33rM/H7rvsDu9M20fDMaVnGTvtb69z7fWXmvtc/TEzqd4OyXwNsv/FwFJQVI/sA14SZKRLOlPkr5TrVYXHz70quYkEEK4TtI2YAgYkrQthHDdhV5uuw+43/ZrwCbgRttgY/tjtrc0m83X3/f+D6ydnJhYcB4BSZcBA7aP2d4ELAGW2N5k+xgwkDB0IH19CGGH7R8B1aQeAf4KvAw0ku4K2zu7uru3ApdPEyiKohd4TNKjtjt5h6RHgccSNrddbvuHtm9Jqoak7xVF8WFgdavV+pSk5cCObNmXgK++85prCj3z28HKqZMnH7D9YAY4BvwujT8BvCuL1INX9vVt+dfwcCvNb7f9q2RuSfrGvWu/sL2Nf3LX7pzvj4ENSGBPVarVd4fRkZFltjdmoMGiKO4IIWwIIWwoiuIOYDDzeOPoyMiyFLkum7WJCMDztrcrTTrIRuAQZ6NcK1utL4dWq/VZoC8BhqvV6l1lWb4YYxyLMY6VZflitVq9CxhOmL60hhCKeYiV7WMKIXw9jT1HpXw3c+bOAKzOjJubzebJrKQCQLPZPClpc7bP6rMYKtjXth2OMf7tIkr11Wz8oQDc1Fb09vY+kQw1YAuwJY2nbUluAnCWpKkaFl6IQIzxivaR2SYA89sJVK/Xp2x32R6w/a30DNjuqtfrU0ArYecDCEqgLqm94T0dEm9mBG7PxkdDlkBnkhebgIezNQ8nHcCZPL9ijE1Jf/bZZoPtzbavmqNZLbf9tSxq+yoduuJ+SZ+zXSZyBXCqU+d8fvC5yRUrV+0G2j3g2hDCLyXd/+Su3QdnvP/zCuH72LWsgf2k0oHlH2c2odlkxcpVEdgr6aDtjyb8x20/J+mA7T9I6rL9SWA5dne2/GdXLl58qNJh398An85yTMA+4DOz8Dgu6Zu2dwJXJ91ltm8Gbp7Fgb+EEB4aHhpq5CEtACqVyr3AC0AlPS8k3TSmQ2YPhhBuS/1/LpmS9JTtNTHGfwBU2uUALARotVqniqJYH2Pck85pfavVaufAwnQvnHc0McaDKVptebN94QAnJB0EdtjekydyZXqjs/0ZgLIs/w6sy8bnYGYJ63pgERKC05JutT1kOwITwL9tvzlzUQUYB+Zjs2DBgu6xsbGJZHstByZbezregcBXeCsEz1bnzXt5anLyzLq71zDLxTRdVgemdx0fv2e2w5thO5DbiqL4oKT3ZKpnpyYnz+SY2ZpTAPZmJfdIrVZbNBNUq9UW2X4kU+2dcf53Aj1pj2PA7y/6m1DS00A9za9uNBq7iqJYBuoGdRdFsazRaOzKSqye1rTbaa/tlbYrqXQP2X4FIA9/J1l39xrC0v7+w5IeB8XkwS1lWe6TGJAYKMty31tfO4qSHl/a3384I3CDpI+kzC4lnRfrue6GytEjR8oQwlY73gC0L4qlth/q0M1/LYWtR48cKQF6enrC6dOnVwGLEpnxnp7en4+O1i/tszzGOCTpPmB7ahb57QUwBWyXdF+McWg6MScmuoA8OX8xOlpvXGz422XYTsB/SnpA0h7bX5R0WzI9HUL4qe2XbI+dk3xl+V7gxoztD5jRI+YK/zkEEokx2/uB/RdzIfUtueqVN04cXwF8G3iHY3z9Urw/j8ClyhsnjrcS2Vv/J/8NLxT+/zqBTkcxU/cfEkyEAu3kmjAAAAAASUVORK5CYII=\\\");\\n}\\n.bk-root .bk-tool-icon-box-edit {\\n  background-image: url(\\\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAB3RJTUUH4gEMEg4QfHjM1QAAAGRJREFUWMNjXLhsJcNAAiaGAQYsDAwM/+lsJ+OgCwGsLqMB+D8o08CoA0YdMOqAUQewDFQdMBoFIyoN/B/U7YFRB7DQIc7xyo9GwbBMA4xDqhxgISH1klXbDYk0QOseEeOgDgEAIS0JQleje6IAAAAASUVORK5CYII=\\\");\\n}\\n.bk-root .bk-tool-icon-freehand-draw {\\n  background-image: url(\\\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAADTElEQVRYCeWWTWwMYRjH/88721X1lZJIGxJxcEE4OOiBgzjXWh8TJKR76kWacOBGxdEJIdk4VChZI/phidRBHMRRIr7DSUiaSCRFRM3u88gz+o7Z6bBTdjmYZPf9eJ55fv/5zzvvDPC/H9QsA66Olo9Ga+/MdR+Ljm2/KQIULsz9FqItGdOfJKLhApLgVkiSCGODjWit7QpKWy+TNrFeXvzKVUT8NiTVaIgDcbiCFJ7GiT8WkARXAdYBK0Lbhi/CenArRNskuM7/tgNp4ArQ42dwjf3WY5gWTqC7O/NbNn2Xkfw/YwdSw/We14HP2IEZwX+y9cZ9SH0LmgFP7UCz4KkENBNeV0Cz4b8U8DfgKiDxMWwUXETqLvJpCQpXZfawbzS7t9v5pL19cHBwfja7YA0y/lyCM0+E5hv5+piZXwKYcF23as+37bTXsQVqgkL0p/34fHR7DcBtbetFsBmGDwMOJCggYG55yw7dMlk6DuC1Bdu2RsCU9TYWQq2IoGbsreZ5NzvEqfSBsIsIy8OTbcdgiRHeh4o8AFAEwDakbY2AaCCpH7V9aGhoUUUy3UyVbkPYFuYLDlUZH8XBpwxkK0Dbgxg5HcVi0ent7a0RULMIozaHBSMfF9b2SzdutFcFB2FkwMIJOG6qfteXOa1nHZ48tyefuwyfT9s6wtzZ3t7eZse2DR2I228TtHXzuWCx9g8MtK5cuHCZTH4tiHEOa4xFngvTyS8f35d6enomiCi4/foEXBkZaQuukChL4FYA2Whd7YcC4gEdW3CpdL3LtGAVCVYJywEyTpAuJKeMOKXZs/Bw947C50KhUFOG4cwz35cjWNBlHGeD53n3xsfHP/T19U1qciggar8Fa4I3PHobIotBWBtc2hSiChyZxVzM53Pv7FVH6Tp3uVy+g0r1ImD2GjIrQGYIxjnfuXTZGICS5k/bBwJoubwEFX4TLah9EXomJGMA3za+f9913Yl4TnzsDQ+vE6YTZOjHh4ngibstt1pzQwd04F0bPStEBpXqRoBeQ/AKghfBnOEKgS+Q7z91Xfdz/HGKg8Ox7z8iYD9z6wqTkZFgnvhMGP9VZ2or1XVkPM9z0mytSfVsHa1RLBZbLoyNzUnK+ydz3wC6I9x+lwbngwAAAABJRU5ErkJggg==\\\");\\n}\\n.bk-root .bk-tool-icon-poly-draw {\\n  background-image: url(\\\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAB3RJTUUH4gEMEjglo9eZgwAAAc5JREFUWMPt1zFrU1EUB/DfS4OmVTGDIChCP4BgnQXRxVHqIJUupp9AB8VBQcRBQUXIB9DWQoMRiXZzcnQSA34A7aAuHSJKkgo2LvfBrU3aJnlYkBy4vHcP557zP/9z3r33JdXa647N0kHSZd5Nn0rSxc8G3cXp85sMcnZZ8vge3osZ+l3vB8CWFA0iL14t79h210swAjACMAIwAjACkB90D/8/GchI9ve4nPwTBh5E9ws7OepzGWb9EddSn51Op9ZstadSg4VK1UKlKkmSDSMLALewiuNh/hVJq71Wxttmqz0dG88vPc+MgWP4grvYG3SLOBrZFFFrttqPe4HIDxh4GSei+98iSlusuYopXEAjBtEPA3tQwUpwluAbDm4TPJUz+BTW9l2Ce6G7L0X/Bw8D3T/7SKKIDzHg7QCcxjvcQAEtXAnrrg/RP0/DKPbqgcN4iVOR7gcO4dcQgRuoh7HSqwlP4n20m63jJu5n8MkWMYfP3UowhzdR8FU8w9iQwevBdyq3/27CMRzAE5yLuvsRLg+ZcR1nJ8YL81HWJUzGAPaFZwe/Q5MdyYDyNHgjzO90YyGHtVDncuiJchaHw8R4oREFV5qdiVmYLM3OgD9k5209/atmIAAAAABJRU5ErkJggg==\\\");\\n}\\n.bk-root .bk-tool-icon-point-draw {\\n  background-image: url(\\\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAB3RJTUUH4gEMEiERGWPELgAAA4RJREFUWMO1lr1uG1cQhb9ztdRSP7AF1QxgwKlcuZSqRC9gWUUUINWqTh5AnaFOnVPEteQmRuhCURqWsSqqc9IolREXdEvQBElxtdw7KURSFEVKu4w8wAKLxdw9Z+bMnRmZGXfZ29//II8th4WwGVNyIoQLYB5vxA9Caq04iUd9A+7ZlsNC2I7TdSd2hZXMJKlnTqp9jtl/GBaqoyQ0noFKpUIzBicYYc+DEFpxkglc4oVJa5gvDn8v1xV2irG3FM4NSVwjUKlUaMcpJhCGmSEJQ6QGD8M5WnHCd8+f3QCXpPLx8WNwv0j6Bm9FMK7FJ3WBE+R/2t7c/GBmFvSBrzRTCsyTDjXrxUgEMtpxynJYmJoBJ4VAybwVARgvL7Oik0okCodnKpVKX7P0leiVMb0VvbJT+upznK4vh0GIeQwwQStJkHQD3MwsCALTJRG7Qrdrj5m/djgYaIa0hlkRdJk26XEgC9txurccBtVW3IudBImmZuACUP+ZlIDBt9FKcubYNTcAH/X0RYM1E7utJPlqe+uZzPxUcEkiSS4sTT95n15Mud0xWC0o2PAWOCdK3KYZlFxfM+tHOcnMzNr1es18ug+cgsVjP4yBU/Ppfrter1m/+l0+zYygML1xRVHU7TSb1cSzBzoBzszsH+AMdJJ49jrNZjWKou6wBnwOzcyndBpNbuueURR1Dw8Pq35p9cc5p/Dy9Dypt7jXrtdGwQECS9NPhr6Gq6txUzNigE6zydLK6lTw12/KT4FGFEUfJX2YJNONq5tVs4ODA7sD/DnwJ/BoADZuE3tHFs12dna6d4C/BI6AlbyzI8ii2TTw12/KK33gb2cdXsNZoAntbZC2SeO4c9592k/5eNQbiwvFd1kJuFGwLJr1wSPg/SwpvyFBHufOeXcFeAlE97U/uCxOY+P3b+Bn4B3Q+L8EdJfD4a+/AbC4UBzPxiPg3wlHZquB28Cn2IuR9x3gr3uV4DbwfvSDOvi4uFA8BDZmIRHkjHpS9Ht9iRqd8+5G3g05mAGcQbsdiX5QJ428G7Kygo8XYdb1/K4NWVmjzkNge2sz84bs+ELmpDDLtqWsNZBXgvmw8CTtpWVMT7x5YWBjLARnwZfKQNYN2U2LPvrh+5nBt7c2M2/It9bArCTKR8eZN+SJ13AScPnoODeRdqNenH+wul5w2gUr2WUjMFAt8bZ/0axX/wNnv4H8vTFb1QAAAABJRU5ErkJggg==\\\");\\n}\\n.bk-root .bk-tool-icon-poly-edit {\\n  background-image: url(\\\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAB3RJTUUH4gELFi46qJmxxAAABV9JREFUWMOdl19vFFUYxn9n9u9sCyylUIzWUoMQBAWCMdEEIt6xIRQSLIEKtvHe6AcA4yeQb7CAUNJy0daLeomJN8SEULAC2kBBapBKoLvbmdl/c14vdmY7u91tF95kknPOnHmf95znPc97Ro2OTeBbdjFDT3c32ZxVHUOE9kSMB0/m6ExuoJn1H+ur6Y+OTfD50SMN5168OgrAlyf7CfuD+z7+iDs3p8hkLUQ0iFQ/yFl5Nm/qonfHVva+s32Zw9GxCYILsZ08tpNfBhbs+1YN4OH9+7huGdECSBVfqUosbsllfmauBqiR+cCNwOr7AEo8pPHJnymXykhg5fUWjoQpl0vVvhZhbSzGoUOHqgBlt6B6uruj2Zy1E9jo0fhfeyL2x4Mnc8VErK0KUEOB64JSyptfG4RSytsJjUJVxw2lsFy3urL9nx1Qd25ObctkrVMi+jQivd7U2ZyV/3Hzpq7h3h1b/7p9Y0o8v8rwAbTWrGpSocN/FGDlbAI0Rl23PCBan0Ok158H9Ipwzi25A/Mzc9Gl/BYx/E4kYqC1NKRARNAaDCNUM27Z+Zr+ouXs0q4+LSLBHPYCFkTkC6uU39kwCdsS7WRKmaYUiAhdnZ3MPX2K4+QjQI+C94A93rMzm8ltMwyDeDzWjMZeEb2pYQDdW3vITU2jtUZ5QThOPgm8C7wP7J15OPsBsB3oWpGnVWisCeDS1VHj4vBI92+/3tgB7Ab2AruAXiDBK5oIOkhtkEYRNRuJhObrd8Dl9ewf4D5wG7hVLpen29vb5wzD+BrkbBMaL3d1dk5nsrnlFDTTFWAWmAZueWD3gCemGde2k2fw1Al1YXhEvjozoO49eczdqekrWmsc2zlrmvEKOGoW1GUjFLqSk2KpJrCLwyMCPAP+BO54QL8DM6YZX/ClsP9YnwKkXnIBP4jdIpJRpdJTCYdMwwi98KU0Hjc/dDILNyUcwTCWdOSMJ0TRmBktGRhLugu0xyLk7CIqVNm+0bGJptl1YXikD0grpY4Rjc4a8Fbgdab/6OGbAJeCUuyJnnHmZH9pbSyGuBXV8NUwlUpR1EWyixmSyTWEwqGlJ2Swbo2JXbAAfgDGgGQA9I1A9t1tlq0AxrXxn0ilUpw4fhQqYkH/sT41OTnJJwf2s6FjI5mshdYa7bqVR2uezr9MJmJt14FvGrh/O9D+e6UkM/xyCuCqEKCYnJyUTKFQrZDHjxzGshwWLQcRsOz8Hi85P23id0ug/XilAMLBmm4tPGdoaKjSH5+oAGrhwvBI9SjZTn4QSK9yenoD7dlrExPoJlXW8G8ytpNHxRKk02lGxsdRKFwXLNvx5yY94HQLGhGk4LFCYQSqaE0AwWM1eOoEbR0dKBSW7bC4mKuffxs4D/wCLKwQQPAUzIkslfp6cVomROWSolh0GjldAM4nzDi2k9/i5UAzC9aKfwNJ3zgJg9YEvN6+C7SHgKm69+sD7RfNnKTTaZRPQfAut4oFV//IS7gkcB34VlVo8kGzphlfB+DU+TfNGBpZtRastvrvARJmfMF28ge9sc2B9/PNnCilMIDwK6y8/ow/Ai4kvILTljAXvDvEvrqKSUs60KolzPjBxspavQD2tKqCAGF/Ba+xE/Wbilu54wZV8NEKF5fXzQHl/bh4hUsE0WAXSlDMYcQSrQXgCmsTseXHsJkNnjqBFGwKJaHsKlxtUHYVhbLCzr1kaOA4bcn1y1Swmb+iLpJKpVrfgdpfsiVVCYcgluwgnU7jEgJ4s5UkLFtWYyHyEg0/N1q1tmQH+YXnAMFr97Nmv3p+0QsHQRsF8qpBOE5+rb9Nkaj50tVQKjqh4OU3GNL/1/So3vuUgbAAAAAASUVORK5CYII=\\\");\\n}\\n\");\n    exports.bk_tool_icon_box_select = \"bk-tool-icon-box-select\";\n    exports.bk_tool_icon_box_zoom = \"bk-tool-icon-box-zoom\";\n    exports.bk_tool_icon_zoom_in = \"bk-tool-icon-zoom-in\";\n    exports.bk_tool_icon_zoom_out = \"bk-tool-icon-zoom-out\";\n    exports.bk_tool_icon_help = \"bk-tool-icon-help\";\n    exports.bk_tool_icon_hover = \"bk-tool-icon-hover\";\n    exports.bk_tool_icon_crosshair = \"bk-tool-icon-crosshair\";\n    exports.bk_tool_icon_lasso_select = \"bk-tool-icon-lasso-select\";\n    exports.bk_tool_icon_pan = \"bk-tool-icon-pan\";\n    exports.bk_tool_icon_xpan = \"bk-tool-icon-xpan\";\n    exports.bk_tool_icon_ypan = \"bk-tool-icon-ypan\";\n    exports.bk_tool_icon_range = \"bk-tool-icon-range\";\n    exports.bk_tool_icon_polygon_select = \"bk-tool-icon-polygon-select\";\n    exports.bk_tool_icon_redo = \"bk-tool-icon-redo\";\n    exports.bk_tool_icon_reset = \"bk-tool-icon-reset\";\n    exports.bk_tool_icon_save = \"bk-tool-icon-save\";\n    exports.bk_tool_icon_tap_select = \"bk-tool-icon-tap-select\";\n    exports.bk_tool_icon_undo = \"bk-tool-icon-undo\";\n    exports.bk_tool_icon_wheel_pan = \"bk-tool-icon-wheel-pan\";\n    exports.bk_tool_icon_wheel_zoom = \"bk-tool-icon-wheel-zoom\";\n    exports.bk_tool_icon_box_edit = \"bk-tool-icon-box-edit\";\n    exports.bk_tool_icon_freehand_draw = \"bk-tool-icon-freehand-draw\";\n    exports.bk_tool_icon_poly_draw = \"bk-tool-icon-poly-draw\";\n    exports.bk_tool_icon_point_draw = \"bk-tool-icon-point-draw\";\n    exports.bk_tool_icon_poly_edit = \"bk-tool-icon-poly-edit\";\n}\n","/* styles/logo.js */ function _(require, module, exports) {\n    require(62) /* ./root */;\n    const _a = require(61) /* ../core/dom */;\n    _a.styles.append(\".bk-root .bk-logo {\\n  margin: 5px;\\n  position: relative;\\n  display: block;\\n  background-repeat: no-repeat;\\n}\\n.bk-root .bk-logo.bk-grey {\\n  filter: url(\\\"data:image/svg+xml;utf8,<svg xmlns=\\\\'http://www.w3.org/2000/svg\\\\'><filter id=\\\\'grayscale\\\\'><feColorMatrix type=\\\\'matrix\\\\' values=\\\\'0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0 0 0 1 0\\\\'/></filter></svg>#grayscale\\\");\\n  /* Firefox 10+, Firefox on Android */\\n  filter: gray;\\n  /* IE6-9 */\\n  -webkit-filter: grayscale(100%);\\n  /* Chrome 19+, Safari 6+, Safari 6+ iOS */\\n}\\n.bk-root .bk-logo-small {\\n  width: 20px;\\n  height: 20px;\\n  background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAYAAACNiR0NAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAALEgAACxIB0t1+/AAAABx0RVh0U29mdHdhcmUAQWRvYmUgRmlyZXdvcmtzIENTNui8sowAAAOkSURBVDiNjZRtaJVlGMd/1/08zzln5zjP1LWcU9N0NkN8m2CYjpgQYQXqSs0I84OLIC0hkEKoPtiH3gmKoiJDU7QpLgoLjLIQCpEsNJ1vqUOdO7ppbuec5+V+rj4ctwzd8IIbbi6u+8f1539dt3A78eXC7QizUF7gyV1fD1Yqg4JWz84yffhm0qkFqBogB9rM8tZdtwVsPUhWhGcFJngGeWrPzHm5oaMmkfEg1usvLFyc8jLRqDOMru7AyC8saQr7GG7f5fvDeH7Ej8CM66nIF+8yngt6HWaKh7k49Soy9nXurCi1o3qUbS3zWfrYeQDTB/Qj6kX6Ybhw4B+bOYoLKCC9H3Nu/leUTZ1JdRWkkn2ldcCamzrcf47KKXdAJllSlxAOkRgyHsGC/zRday5Qld9DyoM4/q/rUoy/CXh3jzOu3bHUVZeU+DEn8FInkPBFlu3+nW3Nw0mk6vCDiWg8CeJaxEwuHS3+z5RgY+YBR6V1Z1nxSOfoaPa4LASWxxdNp+VWTk7+4vzaou8v8PN+xo+KY2xsw6une2frhw05CTYOmQvsEhjhWjn0bmXPjpE1+kplmmkP3suftwTubK9Vq22qKmrBhpY4jvd5afdRA3wGjFAgcnTK2s4hY0/GPNIb0nErGMCRxWOOX64Z8RAC4oCXdklmEvcL8o0BfkNK4lUg9HTl+oPlQxdNo3Mg4Nv175e/1LDGzZen30MEjRUtmXSfiTVu1kK8W4txyV6BMKlbgk3lMwYCiusNy9fVfvvwMxv8Ynl6vxoByANLTWplvuj/nF9m2+PDtt1eiHPBr1oIfhCChQMBw6Aw0UulqTKZdfVvfG7VcfIqLG9bcldL/+pdWTLxLUy8Qq38heUIjh4XlzZxzQm19lLFlr8vdQ97rjZVOLf8nclzckbcD4wxXMidpX30sFd37Fv/GtwwhzhxGVAprjbg0gCAEeIgwCZyTV2Z1REEW8O4py0wsjeloKoMr6iCY6dP92H6Vw/oTyICIthibxjm/DfN9lVz8IqtqKYLUXfoKVMVQVVJOElGjrnnUt9T9wbgp8AyYKaGlqingHZU/uG2NTZSVqwHQTWkx9hxjkpWDaCg6Ckj5qebgBVbT3V3NNXMSiWSDdGV3hrtzla7J+duwPOToIg42ChPQOQjspnSlp1V+Gjdged7+8UN5CRAV7a5EdFNwCjEaBR27b3W890TE7g24NAP/mMDXRWrGoFPQI9ls/MWO2dWFAar/xcOIImbbpA3zgAAAABJRU5ErkJggg==);\\n}\\n.bk-root .bk-logo-notebook {\\n  display: inline-block;\\n  vertical-align: middle;\\n  margin-right: 5px;\\n}\\n\");\n    exports.bk_logo = \"bk-logo\";\n    exports.bk_logo_notebook = \"bk-logo-notebook\";\n    exports.bk_logo_small = \"bk-logo-small\";\n    exports.bk_grey = \"bk-grey\";\n}\n","/* models/plots/plot_canvas.js */ function _(require, module, exports) {\n    var __rest = (this && this.__rest) || function (s, e) {\n        var t = {};\n        for (var p in s)\n            if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n                t[p] = s[p];\n        if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n                    t[p[i]] = s[p[i]];\n            }\n        return t;\n    };\n    const cartesian_frame_1 = require(176) /* ../canvas/cartesian_frame */;\n    const canvas_1 = require(172) /* ../canvas/canvas */;\n    const data_range1d_1 = require(178) /* ../ranges/data_range1d */;\n    const glyph_renderer_1 = require(73) /* ../renderers/glyph_renderer */;\n    const layout_dom_1 = require(237) /* ../layouts/layout_dom */;\n    const title_1 = require(134) /* ../annotations/title */;\n    const axis_1 = require(141) /* ../axes/axis */;\n    const toolbar_panel_1 = require(135) /* ../annotations/toolbar_panel */;\n    const bokeh_events_1 = require(274) /* ../../core/bokeh_events */;\n    const signaling_1 = require(13) /* ../../core/signaling */;\n    const build_views_1 = require(92) /* ../../core/build_views */;\n    const visuals_1 = require(63) /* ../../core/visuals */;\n    const logging_1 = require(65) /* ../../core/logging */;\n    const throttle_1 = require(275) /* ../../core/util/throttle */;\n    const types_1 = require(7) /* ../../core/util/types */;\n    const array_1 = require(8) /* ../../core/util/array */;\n    const object_1 = require(22) /* ../../core/util/object */;\n    const layout_1 = require(180) /* ../../core/layout */;\n    const alignments_1 = require(183) /* ../../core/layout/alignments */;\n    const side_panel_1 = require(276) /* ../../core/layout/side_panel */;\n    const grid_1 = require(184) /* ../../core/layout/grid */;\n    const bbox_1 = require(79) /* ../../core/util/bbox */;\n    let global_gl = null;\n    class PlotLayout extends layout_1.Layoutable {\n        constructor() {\n            super(...arguments);\n            this.min_border = { left: 0, top: 0, right: 0, bottom: 0 };\n        }\n        _measure(viewport) {\n            viewport = new layout_1.Sizeable(viewport).bounded_to(this.sizing.size);\n            const left_hint = this.left_panel.measure({ width: 0, height: viewport.height });\n            const left = Math.max(left_hint.width, this.min_border.left);\n            const right_hint = this.right_panel.measure({ width: 0, height: viewport.height });\n            const right = Math.max(right_hint.width, this.min_border.right);\n            const top_hint = this.top_panel.measure({ width: viewport.width, height: 0 });\n            const top = Math.max(top_hint.height, this.min_border.top);\n            const bottom_hint = this.bottom_panel.measure({ width: viewport.width, height: 0 });\n            const bottom = Math.max(bottom_hint.height, this.min_border.bottom);\n            const center_viewport = new layout_1.Sizeable(viewport).shrink_by({ left, right, top, bottom });\n            const center = this.center_panel.measure(center_viewport);\n            const width = left + center.width + right;\n            const height = top + center.height + bottom;\n            const align = (() => {\n                const { width_policy, height_policy } = this.center_panel.sizing;\n                return width_policy != \"fixed\" && height_policy != \"fixed\";\n            })();\n            return { width, height, inner: { left, right, top, bottom }, align };\n        }\n        _set_geometry(outer, inner) {\n            super._set_geometry(outer, inner);\n            this.center_panel.set_geometry(inner);\n            const left_hint = this.left_panel.measure({ width: 0, height: outer.height });\n            const right_hint = this.right_panel.measure({ width: 0, height: outer.height });\n            const top_hint = this.top_panel.measure({ width: outer.width, height: 0 });\n            const bottom_hint = this.bottom_panel.measure({ width: outer.width, height: 0 });\n            const { left, top, right, bottom } = inner;\n            this.top_panel.set_geometry(new bbox_1.BBox({ left, right, bottom: top, height: top_hint.height }));\n            this.bottom_panel.set_geometry(new bbox_1.BBox({ left, right, top: bottom, height: bottom_hint.height }));\n            this.left_panel.set_geometry(new bbox_1.BBox({ top, bottom, right: left, width: left_hint.width }));\n            this.right_panel.set_geometry(new bbox_1.BBox({ top, bottom, left: right, width: right_hint.width }));\n        }\n    }\n    exports.PlotLayout = PlotLayout;\n    PlotLayout.__name__ = \"PlotLayout\";\n    class PlotView extends layout_dom_1.LayoutDOMView {\n        constructor() {\n            super(...arguments);\n            this._outer_bbox = new bbox_1.BBox();\n            this._inner_bbox = new bbox_1.BBox();\n            this._needs_paint = true;\n            this._needs_layout = false;\n        }\n        get canvas_overlays() {\n            return this.canvas_view.overlays_el;\n        }\n        get canvas_events() {\n            return this.canvas_view.events_el;\n        }\n        get is_paused() {\n            return this._is_paused != null && this._is_paused !== 0;\n        }\n        get child_models() {\n            return [];\n        }\n        pause() {\n            if (this._is_paused == null)\n                this._is_paused = 1;\n            else\n                this._is_paused += 1;\n        }\n        unpause(no_render = false) {\n            if (this._is_paused == null)\n                throw new Error(\"wasn't paused\");\n            this._is_paused -= 1;\n            if (this._is_paused == 0 && !no_render)\n                this.request_paint();\n        }\n        // TODO: this needs to be removed\n        request_render() {\n            this.request_paint();\n        }\n        request_paint() {\n            if (!this.is_paused)\n                this.throttled_paint();\n        }\n        request_layout() {\n            this._needs_layout = true;\n            this.request_paint();\n        }\n        reset() {\n            if (this.model.reset_policy == \"standard\") {\n                this.clear_state();\n                this.reset_range();\n                this.reset_selection();\n            }\n            this.model.trigger_event(new bokeh_events_1.Reset());\n        }\n        remove() {\n            this.ui_event_bus.destroy();\n            build_views_1.remove_views(this.renderer_views);\n            build_views_1.remove_views(this.tool_views);\n            this.canvas_view.remove();\n            super.remove();\n        }\n        render() {\n            super.render();\n            this.el.appendChild(this.canvas_view.el);\n            this.canvas_view.render();\n        }\n        initialize() {\n            this.pause();\n            super.initialize();\n            this.force_paint = new signaling_1.Signal0(this, \"force_paint\");\n            this.state_changed = new signaling_1.Signal0(this, \"state_changed\");\n            this.lod_started = false;\n            this.visuals = new visuals_1.Visuals(this.model); // XXX\n            this._initial_state_info = {\n                selection: {},\n                dimensions: { width: 0, height: 0 },\n            };\n            this.visibility_callbacks = [];\n            this.state = { history: [], index: -1 };\n            this.canvas = new canvas_1.Canvas({\n                map: this.model.use_map || false,\n                use_hidpi: this.model.hidpi,\n                output_backend: this.model.output_backend,\n            });\n            this.frame = new cartesian_frame_1.CartesianFrame(this.model.x_scale, this.model.y_scale, this.model.x_range, this.model.y_range, this.model.extra_x_ranges, this.model.extra_y_ranges);\n            this.canvas_view = new this.canvas.default_view({ model: this.canvas, parent: this });\n            // If requested, try enabling webgl\n            if (this.model.output_backend == \"webgl\")\n                this.init_webgl();\n            this.throttled_paint = throttle_1.throttle((() => this.force_paint.emit()), 15); // TODO (bev) configurable\n            // XXX: lazy value import to avoid touching window\n            const { UIEvents } = require(277) /* ../../core/ui_events */;\n            this.ui_event_bus = new UIEvents(this, this.model.toolbar, this.canvas_view.events_el);\n            const { title_location, title } = this.model;\n            if (title_location != null && title != null) {\n                this._title = title instanceof title_1.Title ? title : new title_1.Title({ text: title });\n            }\n            const { toolbar_location, toolbar } = this.model;\n            if (toolbar_location != null && toolbar != null) {\n                this._toolbar = new toolbar_panel_1.ToolbarPanel({ toolbar });\n                toolbar.toolbar_location = toolbar_location;\n            }\n            this.renderer_views = {};\n            this.tool_views = {};\n            this.build_renderer_views();\n            this.build_tool_views();\n            this.update_dataranges();\n            this.unpause(true);\n            logging_1.logger.debug(\"PlotView initialized\");\n        }\n        _width_policy() {\n            return this.model.frame_width == null ? super._width_policy() : \"min\";\n        }\n        _height_policy() {\n            return this.model.frame_height == null ? super._height_policy() : \"min\";\n        }\n        _update_layout() {\n            this.layout = new PlotLayout();\n            this.layout.set_sizing(this.box_sizing());\n            const { frame_width, frame_height } = this.model;\n            this.layout.center_panel = this.frame;\n            this.layout.center_panel.set_sizing(Object.assign(Object.assign({}, (frame_width != null ? { width_policy: \"fixed\", width: frame_width } : { width_policy: \"fit\" })), (frame_height != null ? { height_policy: \"fixed\", height: frame_height } : { height_policy: \"fit\" })));\n            const above = array_1.copy(this.model.above);\n            const below = array_1.copy(this.model.below);\n            const left = array_1.copy(this.model.left);\n            const right = array_1.copy(this.model.right);\n            const get_side = (side) => {\n                switch (side) {\n                    case \"above\": return above;\n                    case \"below\": return below;\n                    case \"left\": return left;\n                    case \"right\": return right;\n                }\n            };\n            const { title_location, title } = this.model;\n            if (title_location != null && title != null) {\n                get_side(title_location).push(this._title);\n            }\n            const { toolbar_location, toolbar } = this.model;\n            if (toolbar_location != null && toolbar != null) {\n                const panels = get_side(toolbar_location);\n                let push_toolbar = true;\n                if (this.model.toolbar_sticky) {\n                    for (let i = 0; i < panels.length; i++) {\n                        const panel = panels[i];\n                        if (panel instanceof title_1.Title) {\n                            if (toolbar_location == \"above\" || toolbar_location == \"below\")\n                                panels[i] = [panel, this._toolbar];\n                            else\n                                panels[i] = [this._toolbar, panel];\n                            push_toolbar = false;\n                            break;\n                        }\n                    }\n                }\n                if (push_toolbar)\n                    panels.push(this._toolbar);\n            }\n            const set_layout = (side, model) => {\n                const view = this.renderer_views[model.id];\n                return view.layout = new side_panel_1.SidePanel(side, view);\n            };\n            const set_layouts = (side, panels) => {\n                const horizontal = side == \"above\" || side == \"below\";\n                const layouts = [];\n                for (const panel of panels) {\n                    if (types_1.isArray(panel)) {\n                        const items = panel.map((subpanel) => {\n                            const item = set_layout(side, subpanel);\n                            if (subpanel instanceof toolbar_panel_1.ToolbarPanel) {\n                                const dim = horizontal ? \"width_policy\" : \"height_policy\";\n                                item.set_sizing(Object.assign(Object.assign({}, item.sizing), { [dim]: \"min\" }));\n                            }\n                            return item;\n                        });\n                        let layout;\n                        if (horizontal) {\n                            layout = new grid_1.Row(items);\n                            layout.set_sizing({ width_policy: \"max\", height_policy: \"min\" });\n                        }\n                        else {\n                            layout = new grid_1.Column(items);\n                            layout.set_sizing({ width_policy: \"min\", height_policy: \"max\" });\n                        }\n                        layout.absolute = true;\n                        layouts.push(layout);\n                    }\n                    else\n                        layouts.push(set_layout(side, panel));\n                }\n                return layouts;\n            };\n            const min_border = this.model.min_border != null ? this.model.min_border : 0;\n            this.layout.min_border = {\n                left: this.model.min_border_left != null ? this.model.min_border_left : min_border,\n                top: this.model.min_border_top != null ? this.model.min_border_top : min_border,\n                right: this.model.min_border_right != null ? this.model.min_border_right : min_border,\n                bottom: this.model.min_border_bottom != null ? this.model.min_border_bottom : min_border,\n            };\n            const top_panel = new alignments_1.VStack();\n            const bottom_panel = new alignments_1.VStack();\n            const left_panel = new alignments_1.HStack();\n            const right_panel = new alignments_1.HStack();\n            top_panel.children = array_1.reversed(set_layouts(\"above\", above));\n            bottom_panel.children = set_layouts(\"below\", below);\n            left_panel.children = array_1.reversed(set_layouts(\"left\", left));\n            right_panel.children = set_layouts(\"right\", right);\n            top_panel.set_sizing({ width_policy: \"fit\", height_policy: \"min\" /*, min_height: this.layout.min_border.top*/ });\n            bottom_panel.set_sizing({ width_policy: \"fit\", height_policy: \"min\" /*, min_height: this.layout.min_width.bottom*/ });\n            left_panel.set_sizing({ width_policy: \"min\", height_policy: \"fit\" /*, min_width: this.layout.min_width.left*/ });\n            right_panel.set_sizing({ width_policy: \"min\", height_policy: \"fit\" /*, min_width: this.layout.min_width.right*/ });\n            this.layout.top_panel = top_panel;\n            this.layout.bottom_panel = bottom_panel;\n            this.layout.left_panel = left_panel;\n            this.layout.right_panel = right_panel;\n        }\n        get axis_views() {\n            const views = [];\n            for (const id in this.renderer_views) {\n                const child_view = this.renderer_views[id];\n                if (child_view instanceof axis_1.AxisView)\n                    views.push(child_view);\n            }\n            return views;\n        }\n        set_cursor(cursor = \"default\") {\n            this.canvas_view.el.style.cursor = cursor;\n        }\n        set_toolbar_visibility(visible) {\n            for (const callback of this.visibility_callbacks)\n                callback(visible);\n        }\n        init_webgl() {\n            // We use a global invisible canvas and gl context. By having a global context,\n            // we avoid the limitation of max 16 contexts that most browsers have.\n            if (global_gl == null) {\n                const canvas = document.createElement('canvas');\n                const ctx = canvas.getContext(\"webgl\", { premultipliedAlpha: true });\n                // If WebGL is available, we store a reference to the gl canvas on\n                // the ctx object, because that's what gets passed everywhere.\n                if (ctx != null)\n                    global_gl = { canvas, ctx };\n            }\n            if (global_gl != null)\n                this.gl = global_gl;\n            else\n                logging_1.logger.warn('WebGL is not supported, falling back to 2D canvas.');\n        }\n        prepare_webgl(ratio, frame_box) {\n            // Prepare WebGL for a drawing pass\n            if (this.gl != null) {\n                const canvas = this.canvas_view.get_canvas_element();\n                // Sync canvas size\n                this.gl.canvas.width = canvas.width;\n                this.gl.canvas.height = canvas.height;\n                const { ctx: gl } = this.gl;\n                // Clipping\n                gl.enable(gl.SCISSOR_TEST);\n                const [sx, sy, w, h] = frame_box;\n                const { xview, yview } = this.canvas_view.bbox;\n                const vx = xview.compute(sx);\n                const vy = yview.compute(sy + h);\n                gl.scissor(ratio * vx, ratio * vy, ratio * w, ratio * h); // lower left corner, width, height\n                // Setup blending\n                gl.enable(gl.BLEND);\n                gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE_MINUS_DST_ALPHA, gl.ONE); // premultipliedAlpha == true\n            }\n        }\n        clear_webgl() {\n            if (this.gl != null) {\n                // Prepare GL for drawing\n                const { ctx: gl } = this.gl;\n                gl.viewport(0, 0, this.gl.canvas.width, this.gl.canvas.height);\n                gl.clearColor(0, 0, 0, 0);\n                gl.clear(gl.COLOR_BUFFER_BIT || gl.DEPTH_BUFFER_BIT);\n            }\n        }\n        blit_webgl() {\n            // This should be called when the ctx has no state except the HIDPI transform\n            const { ctx } = this.canvas_view;\n            if (this.gl != null) {\n                // Blit gl canvas into the 2D canvas. To do 1-on-1 blitting, we need\n                // to remove the hidpi transform, then blit, then restore.\n                // ctx.globalCompositeOperation = \"source-over\"  -> OK; is the default\n                logging_1.logger.debug('drawing with WebGL');\n                ctx.restore();\n                ctx.drawImage(this.gl.canvas, 0, 0);\n                // Set back hidpi transform\n                ctx.save();\n                const ratio = this.canvas.pixel_ratio;\n                ctx.scale(ratio, ratio);\n                ctx.translate(0.5, 0.5);\n            }\n        }\n        update_dataranges() {\n            // Update any DataRange1ds here\n            const bounds = {};\n            const log_bounds = {};\n            let calculate_log_bounds = false;\n            for (const r of object_1.values(this.frame.x_ranges).concat(object_1.values(this.frame.y_ranges))) {\n                if (r instanceof data_range1d_1.DataRange1d) {\n                    if (r.scale_hint == \"log\")\n                        calculate_log_bounds = true;\n                }\n            }\n            for (const id in this.renderer_views) {\n                const view = this.renderer_views[id];\n                if (view instanceof glyph_renderer_1.GlyphRendererView) {\n                    const bds = view.glyph.bounds();\n                    if (bds != null)\n                        bounds[id] = bds;\n                    if (calculate_log_bounds) {\n                        const log_bds = view.glyph.log_bounds();\n                        if (log_bds != null)\n                            log_bounds[id] = log_bds;\n                    }\n                }\n            }\n            let follow_enabled = false;\n            let has_bounds = false;\n            const { width, height } = this.frame.bbox;\n            let r;\n            if (this.model.match_aspect !== false && width != 0 && height != 0)\n                r = (1 / this.model.aspect_scale) * (width / height);\n            for (const xr of object_1.values(this.frame.x_ranges)) {\n                if (xr instanceof data_range1d_1.DataRange1d) {\n                    const bounds_to_use = xr.scale_hint == \"log\" ? log_bounds : bounds;\n                    xr.update(bounds_to_use, 0, this.model.id, r);\n                    if (xr.follow) {\n                        follow_enabled = true;\n                    }\n                }\n                if (xr.bounds != null)\n                    has_bounds = true;\n            }\n            for (const yr of object_1.values(this.frame.y_ranges)) {\n                if (yr instanceof data_range1d_1.DataRange1d) {\n                    const bounds_to_use = yr.scale_hint == \"log\" ? log_bounds : bounds;\n                    yr.update(bounds_to_use, 1, this.model.id, r);\n                    if (yr.follow) {\n                        follow_enabled = true;\n                    }\n                }\n                if (yr.bounds != null)\n                    has_bounds = true;\n            }\n            if (follow_enabled && has_bounds) {\n                logging_1.logger.warn('Follow enabled so bounds are unset.');\n                for (const xr of object_1.values(this.frame.x_ranges)) {\n                    xr.bounds = null;\n                }\n                for (const yr of object_1.values(this.frame.y_ranges)) {\n                    yr.bounds = null;\n                }\n            }\n            this.range_update_timestamp = Date.now();\n        }\n        map_to_screen(x, y, x_name = \"default\", y_name = \"default\") {\n            return this.frame.map_to_screen(x, y, x_name, y_name);\n        }\n        push_state(type, new_info) {\n            const { history, index } = this.state;\n            const prev_info = history[index] != null ? history[index].info : {};\n            const info = Object.assign(Object.assign(Object.assign({}, this._initial_state_info), prev_info), new_info);\n            this.state.history = this.state.history.slice(0, this.state.index + 1);\n            this.state.history.push({ type, info });\n            this.state.index = this.state.history.length - 1;\n            this.state_changed.emit();\n        }\n        clear_state() {\n            this.state = { history: [], index: -1 };\n            this.state_changed.emit();\n        }\n        can_undo() {\n            return this.state.index >= 0;\n        }\n        can_redo() {\n            return this.state.index < this.state.history.length - 1;\n        }\n        undo() {\n            if (this.can_undo()) {\n                this.state.index -= 1;\n                this._do_state_change(this.state.index);\n                this.state_changed.emit();\n            }\n        }\n        redo() {\n            if (this.can_redo()) {\n                this.state.index += 1;\n                this._do_state_change(this.state.index);\n                this.state_changed.emit();\n            }\n        }\n        _do_state_change(index) {\n            const info = this.state.history[index] != null ? this.state.history[index].info : this._initial_state_info;\n            if (info.range != null)\n                this.update_range(info.range);\n            if (info.selection != null)\n                this.update_selection(info.selection);\n        }\n        get_selection() {\n            const selection = {};\n            for (const renderer of this.model.renderers) {\n                if (renderer instanceof glyph_renderer_1.GlyphRenderer) {\n                    const { selected } = renderer.data_source;\n                    selection[renderer.id] = selected;\n                }\n            }\n            return selection;\n        }\n        update_selection(selection) {\n            for (const renderer of this.model.renderers) {\n                if (!(renderer instanceof glyph_renderer_1.GlyphRenderer))\n                    continue;\n                const ds = renderer.data_source;\n                if (selection != null) {\n                    if (selection[renderer.id] != null)\n                        ds.selected.update(selection[renderer.id], true, false);\n                }\n                else\n                    ds.selection_manager.clear();\n            }\n        }\n        reset_selection() {\n            this.update_selection(null);\n        }\n        _update_ranges_together(range_info_iter) {\n            // Get weight needed to scale the diff of the range to honor interval limits\n            let weight = 1.0;\n            for (const [rng, range_info] of range_info_iter) {\n                weight = Math.min(weight, this._get_weight_to_constrain_interval(rng, range_info));\n            }\n            // Apply shared weight to all ranges\n            if (weight < 1) {\n                for (const [rng, range_info] of range_info_iter) {\n                    range_info.start = weight * range_info.start + (1 - weight) * rng.start;\n                    range_info.end = weight * range_info.end + (1 - weight) * rng.end;\n                }\n            }\n        }\n        _update_ranges_individually(range_info_iter, is_panning, is_scrolling, maintain_focus) {\n            let hit_bound = false;\n            for (const [rng, range_info] of range_info_iter) {\n                // Limit range interval first. Note that for scroll events,\n                // the interval has already been limited for all ranges simultaneously\n                if (!is_scrolling) {\n                    const weight = this._get_weight_to_constrain_interval(rng, range_info);\n                    if (weight < 1) {\n                        range_info.start = weight * range_info.start + (1 - weight) * rng.start;\n                        range_info.end = weight * range_info.end + (1 - weight) * rng.end;\n                    }\n                }\n                // Prevent range from going outside limits\n                // Also ensure that range keeps the same delta when panning/scrolling\n                if (rng.bounds != null && rng.bounds != \"auto\") { // check `auto` for type-checking purpose\n                    const [min, max] = rng.bounds;\n                    const new_interval = Math.abs(range_info.end - range_info.start);\n                    if (rng.is_reversed) {\n                        if (min != null) {\n                            if (min >= range_info.end) {\n                                hit_bound = true;\n                                range_info.end = min;\n                                if (is_panning || is_scrolling) {\n                                    range_info.start = min + new_interval;\n                                }\n                            }\n                        }\n                        if (max != null) {\n                            if (max <= range_info.start) {\n                                hit_bound = true;\n                                range_info.start = max;\n                                if (is_panning || is_scrolling) {\n                                    range_info.end = max - new_interval;\n                                }\n                            }\n                        }\n                    }\n                    else {\n                        if (min != null) {\n                            if (min >= range_info.start) {\n                                hit_bound = true;\n                                range_info.start = min;\n                                if (is_panning || is_scrolling) {\n                                    range_info.end = min + new_interval;\n                                }\n                            }\n                        }\n                        if (max != null) {\n                            if (max <= range_info.end) {\n                                hit_bound = true;\n                                range_info.end = max;\n                                if (is_panning || is_scrolling) {\n                                    range_info.start = max - new_interval;\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n            // Cancel the event when hitting a bound while scrolling. This ensures that\n            // the scroll-zoom tool maintains its focus position. Setting `maintain_focus`\n            // to false results in a more \"gliding\" behavior, allowing one to\n            // zoom out more smoothly, at the cost of losing the focus position.\n            if (is_scrolling && hit_bound && maintain_focus)\n                return;\n            for (const [rng, range_info] of range_info_iter) {\n                rng.have_updated_interactively = true;\n                if (rng.start != range_info.start || rng.end != range_info.end)\n                    rng.setv(range_info);\n            }\n        }\n        _get_weight_to_constrain_interval(rng, range_info) {\n            // Get the weight by which a range-update can be applied\n            // to still honor the interval limits (including the implicit\n            // max interval imposed by the bounds)\n            const { min_interval } = rng;\n            let { max_interval } = rng;\n            // Express bounds as a max_interval. By doing this, the application of\n            // bounds and interval limits can be applied independent from each-other.\n            if (rng.bounds != null && rng.bounds != \"auto\") { // check `auto` for type-checking purpose\n                const [min, max] = rng.bounds;\n                if (min != null && max != null) {\n                    const max_interval2 = Math.abs(max - min);\n                    max_interval = max_interval != null ? Math.min(max_interval, max_interval2) : max_interval2;\n                }\n            }\n            let weight = 1.0;\n            if (min_interval != null || max_interval != null) {\n                const old_interval = Math.abs(rng.end - rng.start);\n                const new_interval = Math.abs(range_info.end - range_info.start);\n                if (min_interval > 0 && new_interval < min_interval) {\n                    weight = (old_interval - min_interval) / (old_interval - new_interval);\n                }\n                if (max_interval > 0 && new_interval > max_interval) {\n                    weight = (max_interval - old_interval) / (new_interval - old_interval);\n                }\n                weight = Math.max(0.0, Math.min(1.0, weight));\n            }\n            return weight;\n        }\n        update_range(range_info, is_panning = false, is_scrolling = false, maintain_focus = true) {\n            this.pause();\n            const { x_ranges, y_ranges } = this.frame;\n            if (range_info == null) {\n                for (const name in x_ranges) {\n                    const rng = x_ranges[name];\n                    rng.reset();\n                }\n                for (const name in y_ranges) {\n                    const rng = y_ranges[name];\n                    rng.reset();\n                }\n                this.update_dataranges();\n            }\n            else {\n                const range_info_iter = [];\n                for (const name in x_ranges) {\n                    const rng = x_ranges[name];\n                    range_info_iter.push([rng, range_info.xrs[name]]);\n                }\n                for (const name in y_ranges) {\n                    const rng = y_ranges[name];\n                    range_info_iter.push([rng, range_info.yrs[name]]);\n                }\n                if (is_scrolling) {\n                    this._update_ranges_together(range_info_iter); // apply interval bounds while keeping aspect\n                }\n                this._update_ranges_individually(range_info_iter, is_panning, is_scrolling, maintain_focus);\n            }\n            this.unpause();\n        }\n        reset_range() {\n            this.update_range(null);\n        }\n        _invalidate_layout() {\n            const needs_layout = () => {\n                for (const panel of this.model.side_panels) {\n                    const view = this.renderer_views[panel.id];\n                    if (view.layout.has_size_changed())\n                        return true;\n                }\n                return false;\n            };\n            if (needs_layout())\n                this.root.compute_layout();\n        }\n        build_renderer_views() {\n            this.computed_renderers = [];\n            this.computed_renderers.push(...this.model.above);\n            this.computed_renderers.push(...this.model.below);\n            this.computed_renderers.push(...this.model.left);\n            this.computed_renderers.push(...this.model.right);\n            this.computed_renderers.push(...this.model.center);\n            this.computed_renderers.push(...this.model.renderers);\n            if (this._title != null)\n                this.computed_renderers.push(this._title);\n            if (this._toolbar != null)\n                this.computed_renderers.push(this._toolbar);\n            for (const tool of this.model.toolbar.tools) {\n                if (tool.overlay != null)\n                    this.computed_renderers.push(tool.overlay);\n                this.computed_renderers.push(...tool.synthetic_renderers);\n            }\n            build_views_1.build_views(this.renderer_views, this.computed_renderers, { parent: this });\n        }\n        get_renderer_views() {\n            return this.computed_renderers.map((r) => this.renderer_views[r.id]);\n        }\n        build_tool_views() {\n            const tool_models = this.model.toolbar.tools;\n            const new_tool_views = build_views_1.build_views(this.tool_views, tool_models, { parent: this });\n            new_tool_views.map((tool_view) => this.ui_event_bus.register_tool(tool_view));\n        }\n        connect_signals() {\n            super.connect_signals();\n            this.connect(this.force_paint, () => this.repaint());\n            const { x_ranges, y_ranges } = this.frame;\n            for (const name in x_ranges) {\n                const rng = x_ranges[name];\n                this.connect(rng.change, () => { this._needs_layout = true; this.request_paint(); });\n            }\n            for (const name in y_ranges) {\n                const rng = y_ranges[name];\n                this.connect(rng.change, () => { this._needs_layout = true; this.request_paint(); });\n            }\n            this.connect(this.model.properties.renderers.change, () => this.build_renderer_views());\n            this.connect(this.model.toolbar.properties.tools.change, () => { this.build_renderer_views(); this.build_tool_views(); });\n            this.connect(this.model.change, () => this.request_paint());\n            this.connect(this.model.reset, () => this.reset());\n        }\n        set_initial_range() {\n            // check for good values for ranges before setting initial range\n            let good_vals = true;\n            const { x_ranges, y_ranges } = this.frame;\n            const xrs = {};\n            const yrs = {};\n            for (const name in x_ranges) {\n                const { start, end } = x_ranges[name];\n                if (start == null || end == null || types_1.isStrictNaN(start + end)) {\n                    good_vals = false;\n                    break;\n                }\n                xrs[name] = { start, end };\n            }\n            if (good_vals) {\n                for (const name in y_ranges) {\n                    const { start, end } = y_ranges[name];\n                    if (start == null || end == null || types_1.isStrictNaN(start + end)) {\n                        good_vals = false;\n                        break;\n                    }\n                    yrs[name] = { start, end };\n                }\n            }\n            if (good_vals) {\n                this._initial_state_info.range = { xrs, yrs };\n                logging_1.logger.debug(\"initial ranges set\");\n            }\n            else\n                logging_1.logger.warn('could not set initial ranges');\n        }\n        has_finished() {\n            if (!super.has_finished())\n                return false;\n            for (const id in this.renderer_views) {\n                const view = this.renderer_views[id];\n                if (!view.has_finished())\n                    return false;\n            }\n            return true;\n        }\n        after_layout() {\n            super.after_layout();\n            this._needs_layout = false;\n            this.model.setv({\n                inner_width: Math.round(this.frame._width.value),\n                inner_height: Math.round(this.frame._height.value),\n                outer_width: Math.round(this.layout._width.value),\n                outer_height: Math.round(this.layout._height.value),\n            }, { no_change: true });\n            if (this.model.match_aspect !== false) {\n                this.pause();\n                this.update_dataranges();\n                this.unpause(true);\n            }\n            if (!this._outer_bbox.equals(this.layout.bbox)) {\n                const { width, height } = this.layout.bbox;\n                this.canvas_view.prepare_canvas(width, height);\n                this._outer_bbox = this.layout.bbox;\n                this._needs_paint = true;\n            }\n            if (!this._inner_bbox.equals(this.frame.inner_bbox)) {\n                this._inner_bbox = this.layout.inner_bbox;\n                this._needs_paint = true;\n            }\n            if (this._needs_paint) {\n                // XXX: can't be this.request_paint(), because it would trigger back-and-forth\n                // layout recomputing feedback loop between plots. Plots are also much more\n                // responsive this way, especially in interactive mode.\n                this._needs_paint = false;\n                this.paint();\n            }\n        }\n        repaint() {\n            if (this._needs_layout)\n                this._invalidate_layout();\n            this.paint();\n        }\n        paint() {\n            if (this.is_paused)\n                return;\n            logging_1.logger.trace(`PlotView.paint() for ${this.model.id}`);\n            const { document } = this.model;\n            if (document != null) {\n                const interactive_duration = document.interactive_duration();\n                if (interactive_duration >= 0 && interactive_duration < this.model.lod_interval) {\n                    setTimeout(() => {\n                        if (document.interactive_duration() > this.model.lod_timeout) {\n                            document.interactive_stop(this.model);\n                        }\n                        this.request_paint();\n                    }, this.model.lod_timeout);\n                }\n                else\n                    document.interactive_stop(this.model);\n            }\n            for (const id in this.renderer_views) {\n                const v = this.renderer_views[id];\n                if (this.range_update_timestamp == null ||\n                    (v instanceof glyph_renderer_1.GlyphRendererView && v.set_data_timestamp > this.range_update_timestamp)) {\n                    this.update_dataranges();\n                    break;\n                }\n            }\n            const { ctx } = this.canvas_view;\n            const ratio = this.canvas.pixel_ratio;\n            // Set hidpi-transform\n            ctx.save(); // Save default state, do *after* getting ratio, cause setting canvas.width resets transforms\n            ctx.scale(ratio, ratio);\n            ctx.translate(0.5, 0.5);\n            const frame_box = [\n                this.frame._left.value,\n                this.frame._top.value,\n                this.frame._width.value,\n                this.frame._height.value,\n            ];\n            this._map_hook(ctx, frame_box);\n            this._paint_empty(ctx, frame_box);\n            this.prepare_webgl(ratio, frame_box);\n            this.clear_webgl();\n            if (this.visuals.outline_line.doit) {\n                ctx.save();\n                this.visuals.outline_line.set_value(ctx);\n                let [x0, y0, w, h] = frame_box;\n                // XXX: shrink outline region by 1px to make right and bottom lines visible\n                // if they are on the edge of the canvas.\n                if (x0 + w == this.layout._width.value) {\n                    w -= 1;\n                }\n                if (y0 + h == this.layout._height.value) {\n                    h -= 1;\n                }\n                ctx.strokeRect(x0, y0, w, h);\n                ctx.restore();\n            }\n            this._paint_levels(ctx, ['image', 'underlay', 'glyph'], frame_box, true);\n            this._paint_levels(ctx, ['annotation'], frame_box, false);\n            this._paint_levels(ctx, ['overlay'], frame_box, false);\n            if (this._initial_state_info.range == null)\n                this.set_initial_range();\n            ctx.restore(); // Restore to default state\n        }\n        _paint_levels(ctx, levels, clip_region, global_clip) {\n            for (const level of levels) {\n                for (const renderer of this.computed_renderers) {\n                    if (renderer.level != level)\n                        continue;\n                    const renderer_view = this.renderer_views[renderer.id];\n                    ctx.save();\n                    if (global_clip || renderer_view.needs_clip) {\n                        ctx.beginPath();\n                        ctx.rect(...clip_region);\n                        ctx.clip();\n                    }\n                    renderer_view.render();\n                    ctx.restore();\n                    if (renderer_view.has_webgl) {\n                        this.blit_webgl();\n                        this.clear_webgl();\n                    }\n                }\n            }\n        }\n        _map_hook(_ctx, _frame_box) { }\n        _paint_empty(ctx, frame_box) {\n            const [cx, cy, cw, ch] = [0, 0, this.layout._width.value, this.layout._height.value];\n            const [fx, fy, fw, fh] = frame_box;\n            ctx.clearRect(cx, cy, cw, ch);\n            if (this.visuals.border_fill.doit) {\n                this.visuals.border_fill.set_value(ctx);\n                ctx.fillRect(cx, cy, cw, ch);\n                ctx.clearRect(fx, fy, fw, fh);\n            }\n            if (this.visuals.background_fill.doit) {\n                this.visuals.background_fill.set_value(ctx);\n                ctx.fillRect(fx, fy, fw, fh);\n            }\n        }\n        save(name) {\n            switch (this.model.output_backend) {\n                case \"canvas\":\n                case \"webgl\": {\n                    const canvas = this.canvas_view.get_canvas_element();\n                    if (canvas.msToBlob != null) {\n                        const blob = canvas.msToBlob();\n                        window.navigator.msSaveBlob(blob, name);\n                    }\n                    else {\n                        const link = document.createElement('a');\n                        link.href = canvas.toDataURL('image/png');\n                        link.download = name + \".png\";\n                        link.target = \"_blank\";\n                        link.dispatchEvent(new MouseEvent('click'));\n                    }\n                    break;\n                }\n                case \"svg\": {\n                    const ctx = this.canvas_view._ctx;\n                    const svg = ctx.getSerializedSvg(true);\n                    const svgblob = new Blob([svg], { type: 'text/plain' });\n                    const downloadLink = document.createElement(\"a\");\n                    downloadLink.download = name + \".svg\";\n                    downloadLink.innerHTML = \"Download svg\";\n                    downloadLink.href = window.URL.createObjectURL(svgblob);\n                    downloadLink.onclick = (event) => document.body.removeChild(event.target);\n                    downloadLink.style.display = \"none\";\n                    document.body.appendChild(downloadLink);\n                    downloadLink.click();\n                    break;\n                }\n            }\n        }\n        serializable_state() {\n            const _a = super.serializable_state(), { children } = _a, state = __rest(_a, [\"children\"]);\n            const renderers = this.get_renderer_views()\n                .map((view) => view.serializable_state())\n                .filter((item) => \"bbox\" in item);\n            return Object.assign(Object.assign({}, state), { children: [...children, ...renderers] }); // XXX\n        }\n    }\n    exports.PlotView = PlotView;\n    PlotView.__name__ = \"PlotView\";\n}\n","/* core/bokeh_events.js */ function _(require, module, exports) {\n    var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n        if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\")\n            r = Reflect.decorate(decorators, target, key, desc);\n        else\n            for (var i = decorators.length - 1; i >= 0; i--)\n                if (d = decorators[i])\n                    r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n        return c > 3 && r && Object.defineProperty(target, key, r), r;\n    };\n    function event(event_name) {\n        return function (cls) {\n            cls.prototype.event_name = event_name;\n        };\n    }\n    class BokehEvent {\n        to_json() {\n            const { event_name } = this;\n            return { event_name, event_values: this._to_json() };\n        }\n        _to_json() {\n            const { origin } = this;\n            return { model_id: origin != null ? origin.id : null };\n        }\n    }\n    exports.BokehEvent = BokehEvent;\n    BokehEvent.__name__ = \"BokehEvent\";\n    let ButtonClick = class ButtonClick extends BokehEvent {\n    };\n    ButtonClick.__name__ = \"ButtonClick\";\n    ButtonClick = __decorate([\n        event(\"button_click\")\n    ], ButtonClick);\n    exports.ButtonClick = ButtonClick;\n    let MenuItemClick = class MenuItemClick extends BokehEvent {\n        constructor(item) {\n            super();\n            this.item = item;\n        }\n        _to_json() {\n            const { item } = this;\n            return Object.assign(Object.assign({}, super._to_json()), { item });\n        }\n    };\n    MenuItemClick.__name__ = \"MenuItemClick\";\n    MenuItemClick = __decorate([\n        event(\"menu_item_click\")\n    ], MenuItemClick);\n    exports.MenuItemClick = MenuItemClick;\n    // A UIEvent is an event originating on a canvas this includes.\n    // DOM events such as keystrokes as well as hammer events and LOD events.\n    class UIEvent extends BokehEvent {\n    }\n    exports.UIEvent = UIEvent;\n    UIEvent.__name__ = \"UIEvent\";\n    let LODStart = class LODStart extends UIEvent {\n    };\n    LODStart.__name__ = \"LODStart\";\n    LODStart = __decorate([\n        event(\"lodstart\")\n    ], LODStart);\n    exports.LODStart = LODStart;\n    let LODEnd = class LODEnd extends UIEvent {\n    };\n    LODEnd.__name__ = \"LODEnd\";\n    LODEnd = __decorate([\n        event(\"lodend\")\n    ], LODEnd);\n    exports.LODEnd = LODEnd;\n    let SelectionGeometry = class SelectionGeometry extends UIEvent {\n        constructor(geometry, final) {\n            super();\n            this.geometry = geometry;\n            this.final = final;\n        }\n        _to_json() {\n            const { geometry, final } = this;\n            return Object.assign(Object.assign({}, super._to_json()), { geometry, final });\n        }\n    };\n    SelectionGeometry.__name__ = \"SelectionGeometry\";\n    SelectionGeometry = __decorate([\n        event(\"selectiongeometry\")\n    ], SelectionGeometry);\n    exports.SelectionGeometry = SelectionGeometry;\n    let Reset = class Reset extends UIEvent {\n    };\n    Reset.__name__ = \"Reset\";\n    Reset = __decorate([\n        event(\"reset\")\n    ], Reset);\n    exports.Reset = Reset;\n    class PointEvent extends UIEvent {\n        constructor(sx, sy, x, y) {\n            super();\n            this.sx = sx;\n            this.sy = sy;\n            this.x = x;\n            this.y = y;\n        }\n        _to_json() {\n            const { sx, sy, x, y } = this;\n            return Object.assign(Object.assign({}, super._to_json()), { sx, sy, x, y });\n        }\n    }\n    exports.PointEvent = PointEvent;\n    PointEvent.__name__ = \"PointEvent\";\n    let Pan = class Pan extends PointEvent {\n        /* TODO: direction: -1 | 1 */\n        constructor(sx, sy, x, y, delta_x, delta_y) {\n            super(sx, sy, x, y);\n            this.sx = sx;\n            this.sy = sy;\n            this.x = x;\n            this.y = y;\n            this.delta_x = delta_x;\n            this.delta_y = delta_y;\n        }\n        _to_json() {\n            const { delta_x, delta_y /*, direction*/ } = this;\n            return Object.assign(Object.assign({}, super._to_json()), { delta_x, delta_y /*, direction*/ });\n        }\n    };\n    Pan.__name__ = \"Pan\";\n    Pan = __decorate([\n        event(\"pan\")\n    ], Pan);\n    exports.Pan = Pan;\n    let Pinch = class Pinch extends PointEvent {\n        constructor(sx, sy, x, y, scale) {\n            super(sx, sy, x, y);\n            this.sx = sx;\n            this.sy = sy;\n            this.x = x;\n            this.y = y;\n            this.scale = scale;\n        }\n        _to_json() {\n            const { scale } = this;\n            return Object.assign(Object.assign({}, super._to_json()), { scale });\n        }\n    };\n    Pinch.__name__ = \"Pinch\";\n    Pinch = __decorate([\n        event(\"pinch\")\n    ], Pinch);\n    exports.Pinch = Pinch;\n    let Rotate = class Rotate extends PointEvent {\n        constructor(sx, sy, x, y, rotation) {\n            super(sx, sy, x, y);\n            this.sx = sx;\n            this.sy = sy;\n            this.x = x;\n            this.y = y;\n            this.rotation = rotation;\n        }\n        _to_json() {\n            const { rotation } = this;\n            return Object.assign(Object.assign({}, super._to_json()), { rotation });\n        }\n    };\n    Rotate.__name__ = \"Rotate\";\n    Rotate = __decorate([\n        event(\"rotate\")\n    ], Rotate);\n    exports.Rotate = Rotate;\n    let MouseWheel = class MouseWheel extends PointEvent {\n        constructor(sx, sy, x, y, delta) {\n            super(sx, sy, x, y);\n            this.sx = sx;\n            this.sy = sy;\n            this.x = x;\n            this.y = y;\n            this.delta = delta;\n        }\n        _to_json() {\n            const { delta } = this;\n            return Object.assign(Object.assign({}, super._to_json()), { delta });\n        }\n    };\n    MouseWheel.__name__ = \"MouseWheel\";\n    MouseWheel = __decorate([\n        event(\"wheel\")\n    ], MouseWheel);\n    exports.MouseWheel = MouseWheel;\n    let MouseMove = class MouseMove extends PointEvent {\n    };\n    MouseMove.__name__ = \"MouseMove\";\n    MouseMove = __decorate([\n        event(\"mousemove\")\n    ], MouseMove);\n    exports.MouseMove = MouseMove;\n    let MouseEnter = class MouseEnter extends PointEvent {\n    };\n    MouseEnter.__name__ = \"MouseEnter\";\n    MouseEnter = __decorate([\n        event(\"mouseenter\")\n    ], MouseEnter);\n    exports.MouseEnter = MouseEnter;\n    let MouseLeave = class MouseLeave extends PointEvent {\n    };\n    MouseLeave.__name__ = \"MouseLeave\";\n    MouseLeave = __decorate([\n        event(\"mouseleave\")\n    ], MouseLeave);\n    exports.MouseLeave = MouseLeave;\n    let Tap = class Tap extends PointEvent {\n    };\n    Tap.__name__ = \"Tap\";\n    Tap = __decorate([\n        event(\"tap\")\n    ], Tap);\n    exports.Tap = Tap;\n    let DoubleTap = class DoubleTap extends PointEvent {\n    };\n    DoubleTap.__name__ = \"DoubleTap\";\n    DoubleTap = __decorate([\n        event(\"doubletap\")\n    ], DoubleTap);\n    exports.DoubleTap = DoubleTap;\n    let Press = class Press extends PointEvent {\n    };\n    Press.__name__ = \"Press\";\n    Press = __decorate([\n        event(\"press\")\n    ], Press);\n    exports.Press = Press;\n    let PressUp = class PressUp extends PointEvent {\n    };\n    PressUp.__name__ = \"PressUp\";\n    PressUp = __decorate([\n        event(\"pressup\")\n    ], PressUp);\n    exports.PressUp = PressUp;\n    let PanStart = class PanStart extends PointEvent {\n    };\n    PanStart.__name__ = \"PanStart\";\n    PanStart = __decorate([\n        event(\"panstart\")\n    ], PanStart);\n    exports.PanStart = PanStart;\n    let PanEnd = class PanEnd extends PointEvent {\n    };\n    PanEnd.__name__ = \"PanEnd\";\n    PanEnd = __decorate([\n        event(\"panend\")\n    ], PanEnd);\n    exports.PanEnd = PanEnd;\n    let PinchStart = class PinchStart extends PointEvent {\n    };\n    PinchStart.__name__ = \"PinchStart\";\n    PinchStart = __decorate([\n        event(\"pinchstart\")\n    ], PinchStart);\n    exports.PinchStart = PinchStart;\n    let PinchEnd = class PinchEnd extends PointEvent {\n    };\n    PinchEnd.__name__ = \"PinchEnd\";\n    PinchEnd = __decorate([\n        event(\"pinchend\")\n    ], PinchEnd);\n    exports.PinchEnd = PinchEnd;\n    let RotateStart = class RotateStart extends PointEvent {\n    };\n    RotateStart.__name__ = \"RotateStart\";\n    RotateStart = __decorate([\n        event(\"rotatestart\")\n    ], RotateStart);\n    exports.RotateStart = RotateStart;\n    let RotateEnd = class RotateEnd extends PointEvent {\n    };\n    RotateEnd.__name__ = \"RotateEnd\";\n    RotateEnd = __decorate([\n        event(\"rotateend\")\n    ], RotateEnd);\n    exports.RotateEnd = RotateEnd;\n}\n","/* core/util/throttle.js */ function _(require, module, exports) {\n    function _delay_animation(callback) {\n        callback(Date.now()); // XXX: performance.now()\n        return -1;\n    }\n    const delay_animation = (typeof window !== 'undefined' ? window.requestAnimationFrame : undefined) ||\n        (typeof window !== 'undefined' ? window.webkitRequestAnimationFrame : undefined) ||\n        (typeof window !== 'undefined' ? window.mozRequestAnimationFrame : undefined) ||\n        (typeof window !== 'undefined' ? window.msRequestAnimationFrame : undefined) || _delay_animation;\n    // Returns a function, that, when invoked, will only be triggered at\n    // most once during a given window of time.\n    //\n    // In addition, if the browser supports requestAnimationFrame, the\n    // throttled function will be run no more frequently than request\n    // animation frame allows.\n    //\n    // @param func [function] the function to throttle\n    // @param wait [number] time in milliseconds to use for window\n    // @return [function] throttled function\n    //\n    function throttle(func, wait) {\n        let timeout = null;\n        let previous = 0;\n        let pending = false;\n        const later = function () {\n            previous = Date.now();\n            timeout = null;\n            pending = false;\n            func();\n        };\n        return function () {\n            const now = Date.now();\n            const remaining = wait - (now - previous);\n            if (remaining <= 0 && !pending) {\n                if (timeout != null)\n                    clearTimeout(timeout);\n                pending = true;\n                delay_animation(later);\n            }\n            else if (!timeout && !pending)\n                timeout = setTimeout(() => delay_animation(later), remaining);\n        };\n    }\n    exports.throttle = throttle;\n}\n","/* core/layout/side_panel.js */ function _(require, module, exports) {\n    const types_1 = require(181) /* ./types */;\n    const layoutable_1 = require(182) /* ./layoutable */;\n    const types_2 = require(7) /* ../util/types */;\n    // This table lays out the rules for configuring the baseline, alignment, etc. of\n    // title text, based on it's location and orientation\n    //\n    // side    orient        baseline   align     angle   normal-dist\n    // ------------------------------------------------------------------------------\n    // above   parallel      bottom     center    0       height\n    //         normal        middle     left      -90     width\n    //         horizontal    bottom     center    0       height\n    //         [angle > 0]   middle     left              width * sin + height * cos\n    //         [angle < 0]   middle     right             width * sin + height * cos\n    //\n    // below   parallel      top        center    0       height\n    //         normal        middle     right     90      width\n    //         horizontal    top        center    0       height\n    //         [angle > 0]   middle     right             width * sin + height * cos\n    //         [angle < 0]   middle     left              width * sin + height * cos\n    //\n    // left    parallel      bottom     center    90      height\n    //         normal        middle     right     0       width\n    //         horizontal    middle     right     0       width\n    //         [angle > 0]   middle     right             width * cos + height * sin\n    //         [angle < 0]   middle     right             width * cos + height + sin\n    //\n    // right   parallel      bottom     center   -90      height\n    //         normal        middle     left     0        width\n    //         horizontal    middle     left     0        width\n    //         [angle > 0]   middle     left              width * cos + height * sin\n    //         [angle < 0]   middle     left              width * cos + height + sin\n    const pi2 = Math.PI / 2;\n    const ALPHABETIC = 'alphabetic';\n    const TOP = 'top';\n    const BOTTOM = 'bottom';\n    const MIDDLE = 'middle';\n    const HANGING = 'hanging';\n    const LEFT = 'left';\n    const RIGHT = 'right';\n    const CENTER = 'center';\n    const _angle_lookup = {\n        above: {\n            parallel: 0,\n            normal: -pi2,\n            horizontal: 0,\n            vertical: -pi2,\n        },\n        below: {\n            parallel: 0,\n            normal: pi2,\n            horizontal: 0,\n            vertical: pi2,\n        },\n        left: {\n            parallel: -pi2,\n            normal: 0,\n            horizontal: 0,\n            vertical: -pi2,\n        },\n        right: {\n            parallel: pi2,\n            normal: 0,\n            horizontal: 0,\n            vertical: pi2,\n        },\n    };\n    const _baseline_lookup = {\n        above: {\n            justified: TOP,\n            parallel: ALPHABETIC,\n            normal: MIDDLE,\n            horizontal: ALPHABETIC,\n            vertical: MIDDLE,\n        },\n        below: {\n            justified: BOTTOM,\n            parallel: HANGING,\n            normal: MIDDLE,\n            horizontal: HANGING,\n            vertical: MIDDLE,\n        },\n        left: {\n            justified: TOP,\n            parallel: ALPHABETIC,\n            normal: MIDDLE,\n            horizontal: MIDDLE,\n            vertical: ALPHABETIC,\n        },\n        right: {\n            justified: TOP,\n            parallel: ALPHABETIC,\n            normal: MIDDLE,\n            horizontal: MIDDLE,\n            vertical: ALPHABETIC,\n        },\n    };\n    const _align_lookup = {\n        above: {\n            justified: CENTER,\n            parallel: CENTER,\n            normal: LEFT,\n            horizontal: CENTER,\n            vertical: LEFT,\n        },\n        below: {\n            justified: CENTER,\n            parallel: CENTER,\n            normal: LEFT,\n            horizontal: CENTER,\n            vertical: LEFT,\n        },\n        left: {\n            justified: CENTER,\n            parallel: CENTER,\n            normal: RIGHT,\n            horizontal: RIGHT,\n            vertical: CENTER,\n        },\n        right: {\n            justified: CENTER,\n            parallel: CENTER,\n            normal: LEFT,\n            horizontal: LEFT,\n            vertical: CENTER,\n        },\n    };\n    const _align_lookup_negative = {\n        above: RIGHT,\n        below: LEFT,\n        left: RIGHT,\n        right: LEFT,\n    };\n    const _align_lookup_positive = {\n        above: LEFT,\n        below: RIGHT,\n        left: RIGHT,\n        right: LEFT,\n    };\n    class SidePanel extends layoutable_1.ContentLayoutable {\n        constructor(side, obj) {\n            super();\n            this.side = side;\n            this.obj = obj;\n            switch (this.side) {\n                case \"above\":\n                    this._dim = 0;\n                    this._normals = [0, -1];\n                    break;\n                case \"below\":\n                    this._dim = 0;\n                    this._normals = [0, 1];\n                    break;\n                case \"left\":\n                    this._dim = 1;\n                    this._normals = [-1, 0];\n                    break;\n                case \"right\":\n                    this._dim = 1;\n                    this._normals = [1, 0];\n                    break;\n                default:\n                    throw new Error(\"unreachable\");\n            }\n            if (this.is_horizontal)\n                this.set_sizing({ width_policy: \"max\", height_policy: \"fixed\" });\n            else\n                this.set_sizing({ width_policy: \"fixed\", height_policy: \"max\" });\n        }\n        _content_size() {\n            return new types_1.Sizeable(this.get_oriented_size());\n        }\n        get_oriented_size() {\n            const { width, height } = this.obj.get_size();\n            if (!this.obj.rotate || this.is_horizontal)\n                return { width, height };\n            else\n                return { width: height, height: width };\n        }\n        has_size_changed() {\n            const { width, height } = this.get_oriented_size();\n            if (this.is_horizontal)\n                return this.bbox.height != height;\n            else\n                return this.bbox.width != width;\n        }\n        get dimension() {\n            return this._dim;\n        }\n        get normals() {\n            return this._normals;\n        }\n        get is_horizontal() {\n            return this._dim == 0;\n        }\n        get is_vertical() {\n            return this._dim == 1;\n        }\n        apply_label_text_heuristics(ctx, orient) {\n            const side = this.side;\n            let baseline;\n            let align;\n            if (types_2.isString(orient)) {\n                baseline = _baseline_lookup[side][orient];\n                align = _align_lookup[side][orient];\n            }\n            else {\n                if (orient === 0) {\n                    baseline = \"whatever\"; // XXX: _baseline_lookup[side][orient]\n                    align = \"whatever\"; // XXX: _align_lookup[side][orient]\n                }\n                else if (orient < 0) {\n                    baseline = 'middle';\n                    align = _align_lookup_negative[side];\n                }\n                else {\n                    baseline = 'middle';\n                    align = _align_lookup_positive[side];\n                }\n            }\n            ctx.textBaseline = baseline;\n            ctx.textAlign = align;\n        }\n        get_label_angle_heuristic(orient) {\n            return _angle_lookup[this.side][orient];\n        }\n    }\n    exports.SidePanel = SidePanel;\n    SidePanel.__name__ = \"SidePanel\";\n}\n","/* core/ui_events.js */ function _(require, module, exports) {\n    const Hammer = require(278) /* hammerjs */;\n    const signaling_1 = require(13) /* ./signaling */;\n    const logging_1 = require(65) /* ./logging */;\n    const dom_1 = require(61) /* ./dom */;\n    const wheel_1 = require(279) /* ./util/wheel */;\n    const array_1 = require(8) /* ./util/array */;\n    const object_1 = require(22) /* ./util/object */;\n    const types_1 = require(7) /* ./util/types */;\n    const compat_1 = require(95) /* ./util/compat */;\n    const events = require(274) /* ./bokeh_events */;\n    class UIEvents {\n        constructor(plot_view, toolbar, hit_area) {\n            this.plot_view = plot_view;\n            this.toolbar = toolbar;\n            this.hit_area = hit_area;\n            this.pan_start = new signaling_1.Signal(this, 'pan:start');\n            this.pan = new signaling_1.Signal(this, 'pan');\n            this.pan_end = new signaling_1.Signal(this, 'pan:end');\n            this.pinch_start = new signaling_1.Signal(this, 'pinch:start');\n            this.pinch = new signaling_1.Signal(this, 'pinch');\n            this.pinch_end = new signaling_1.Signal(this, 'pinch:end');\n            this.rotate_start = new signaling_1.Signal(this, 'rotate:start');\n            this.rotate = new signaling_1.Signal(this, 'rotate');\n            this.rotate_end = new signaling_1.Signal(this, 'rotate:end');\n            this.tap = new signaling_1.Signal(this, 'tap');\n            this.doubletap = new signaling_1.Signal(this, 'doubletap');\n            this.press = new signaling_1.Signal(this, 'press');\n            this.pressup = new signaling_1.Signal(this, 'pressup');\n            this.move_enter = new signaling_1.Signal(this, 'move:enter');\n            this.move = new signaling_1.Signal(this, 'move');\n            this.move_exit = new signaling_1.Signal(this, 'move:exit');\n            this.scroll = new signaling_1.Signal(this, 'scroll');\n            this.keydown = new signaling_1.Signal(this, 'keydown');\n            this.keyup = new signaling_1.Signal(this, 'keyup');\n            this.hammer = new Hammer(this.hit_area, { touchAction: 'auto' });\n            this._configure_hammerjs();\n            // Mouse & keyboard events not handled through hammerjs\n            // We can 'add and forget' these event listeners because this.hit_area is a DOM element\n            // that will be thrown away when the view is removed\n            this.hit_area.addEventListener(\"mousemove\", (e) => this._mouse_move(e));\n            this.hit_area.addEventListener(\"mouseenter\", (e) => this._mouse_enter(e));\n            this.hit_area.addEventListener(\"mouseleave\", (e) => this._mouse_exit(e));\n            this.hit_area.addEventListener(\"wheel\", (e) => this._mouse_wheel(e));\n            // But we MUST remove listeners registered on document or we'll leak memory: register\n            // 'this' as the listener (it implements the event listener interface, i.e. handleEvent)\n            // instead of an anonymous function so we can easily refer back to it for removing\n            document.addEventListener(\"keydown\", this);\n            document.addEventListener(\"keyup\", this);\n        }\n        destroy() {\n            this.hammer.destroy();\n            document.removeEventListener(\"keydown\", this);\n            document.removeEventListener(\"keyup\", this);\n        }\n        handleEvent(e) {\n            if (e.type == \"keydown\")\n                this._key_down(e);\n            else if (e.type == \"keyup\")\n                this._key_up(e);\n        }\n        _configure_hammerjs() {\n            // This is to be able to distinguish double taps from single taps\n            this.hammer.get('doubletap').recognizeWith('tap');\n            this.hammer.get('tap').requireFailure('doubletap');\n            this.hammer.get('doubletap').dropRequireFailure('tap');\n            this.hammer.on('doubletap', (e) => this._doubletap(e));\n            this.hammer.on('tap', (e) => this._tap(e));\n            this.hammer.on('press', (e) => this._press(e));\n            this.hammer.on('pressup', (e) => this._pressup(e));\n            this.hammer.get('pan').set({ direction: Hammer.DIRECTION_ALL });\n            this.hammer.on('panstart', (e) => this._pan_start(e));\n            this.hammer.on('pan', (e) => this._pan(e));\n            this.hammer.on('panend', (e) => this._pan_end(e));\n            this.hammer.get('pinch').set({ enable: true });\n            this.hammer.on('pinchstart', (e) => this._pinch_start(e));\n            this.hammer.on('pinch', (e) => this._pinch(e));\n            this.hammer.on('pinchend', (e) => this._pinch_end(e));\n            this.hammer.get('rotate').set({ enable: true });\n            this.hammer.on('rotatestart', (e) => this._rotate_start(e));\n            this.hammer.on('rotate', (e) => this._rotate(e));\n            this.hammer.on('rotateend', (e) => this._rotate_end(e));\n        }\n        register_tool(tool_view) {\n            const et = tool_view.model.event_type;\n            if (et != null) {\n                if (types_1.isString(et))\n                    this._register_tool(tool_view, et);\n                else {\n                    // Multi-tools should only registered shared events once\n                    et.forEach((e, index) => this._register_tool(tool_view, e, index < 1));\n                }\n            }\n        }\n        _register_tool(tool_view, et, shared = true) {\n            const v = tool_view;\n            const { id } = v.model;\n            const conditionally = (fn) => (arg) => {\n                if (arg.id == id)\n                    fn(arg.e);\n            };\n            const unconditionally = (fn) => (arg) => {\n                fn(arg.e);\n            };\n            switch (et) {\n                case \"pan\": {\n                    if (v._pan_start != null)\n                        v.connect(this.pan_start, conditionally(v._pan_start.bind(v)));\n                    if (v._pan != null)\n                        v.connect(this.pan, conditionally(v._pan.bind(v)));\n                    if (v._pan_end != null)\n                        v.connect(this.pan_end, conditionally(v._pan_end.bind(v)));\n                    break;\n                }\n                case \"pinch\": {\n                    if (v._pinch_start != null)\n                        v.connect(this.pinch_start, conditionally(v._pinch_start.bind(v)));\n                    if (v._pinch != null)\n                        v.connect(this.pinch, conditionally(v._pinch.bind(v)));\n                    if (v._pinch_end != null)\n                        v.connect(this.pinch_end, conditionally(v._pinch_end.bind(v)));\n                    break;\n                }\n                case \"rotate\": {\n                    if (v._rotate_start != null)\n                        v.connect(this.rotate_start, conditionally(v._rotate_start.bind(v)));\n                    if (v._rotate != null)\n                        v.connect(this.rotate, conditionally(v._rotate.bind(v)));\n                    if (v._rotate_end != null)\n                        v.connect(this.rotate_end, conditionally(v._rotate_end.bind(v)));\n                    break;\n                }\n                case \"move\": {\n                    if (v._move_enter != null)\n                        v.connect(this.move_enter, conditionally(v._move_enter.bind(v)));\n                    if (v._move != null)\n                        v.connect(this.move, conditionally(v._move.bind(v)));\n                    if (v._move_exit != null)\n                        v.connect(this.move_exit, conditionally(v._move_exit.bind(v)));\n                    break;\n                }\n                case \"tap\": {\n                    if (v._tap != null)\n                        v.connect(this.tap, conditionally(v._tap.bind(v)));\n                    break;\n                }\n                case \"press\": {\n                    if (v._press != null)\n                        v.connect(this.press, conditionally(v._press.bind(v)));\n                    if (v._pressup != null)\n                        v.connect(this.pressup, conditionally(v._pressup.bind(v)));\n                    break;\n                }\n                case \"scroll\": {\n                    if (v._scroll != null)\n                        v.connect(this.scroll, conditionally(v._scroll.bind(v)));\n                    break;\n                }\n                default:\n                    throw new Error(`unsupported event_type: ${et}`);\n            }\n            // Skip shared events if registering multi-tool\n            if (!shared)\n                return;\n            if (v._doubletap != null)\n                v.connect(this.doubletap, unconditionally(v._doubletap.bind(v)));\n            if (v._keydown != null)\n                v.connect(this.keydown, unconditionally(v._keydown.bind(v)));\n            if (v._keyup != null)\n                v.connect(this.keyup, unconditionally(v._keyup.bind(v)));\n            // Dual touch hack part 1/2\n            // This is a hack for laptops with touch screen who may be pinching or scrolling\n            // in order to use the wheel zoom tool. If it's a touch screen the WheelZoomTool event\n            // will be linked to pinch. But we also want to trigger in the case of a scroll.\n            if (compat_1.is_mobile && v._scroll != null && et == 'pinch') {\n                logging_1.logger.debug(\"Registering scroll on touch screen\");\n                v.connect(this.scroll, conditionally(v._scroll.bind(v)));\n            }\n        }\n        _hit_test_renderers(sx, sy) {\n            const views = this.plot_view.get_renderer_views();\n            for (const view of array_1.reversed(views)) {\n                const { level } = view.model;\n                if ((level == 'annotation' || level == 'overlay') && view.interactive_hit != null) {\n                    if (view.interactive_hit(sx, sy))\n                        return view;\n                }\n            }\n            return null;\n        }\n        _hit_test_frame(sx, sy) {\n            return this.plot_view.frame.bbox.contains(sx, sy);\n        }\n        _hit_test_canvas(sx, sy) {\n            return this.plot_view.layout.bbox.contains(sx, sy);\n        }\n        _trigger(signal, e, srcEvent) {\n            const gestures = this.toolbar.gestures;\n            let event_type = signal.name;\n            const base_type = event_type.split(\":\")[0];\n            const view = this._hit_test_renderers(e.sx, e.sy);\n            const on_canvas = this._hit_test_canvas(e.sx, e.sy);\n            switch (base_type) {\n                case \"move\": {\n                    const active_gesture = gestures[base_type].active;\n                    if (active_gesture != null)\n                        this.trigger(signal, e, active_gesture.id);\n                    const active_inspectors = this.toolbar.inspectors.filter(t => t.active);\n                    let cursor = \"default\";\n                    // the event happened on a renderer\n                    if (view != null) {\n                        cursor = view.cursor(e.sx, e.sy) || cursor;\n                        if (!object_1.isEmpty(active_inspectors)) {\n                            // override event_type to cause inspectors to clear overlays\n                            signal = this.move_exit; // XXX\n                            event_type = signal.name;\n                        }\n                        // the event happened on the plot frame but off a renderer\n                    }\n                    else if (this._hit_test_frame(e.sx, e.sy)) {\n                        if (!object_1.isEmpty(active_inspectors)) {\n                            cursor = \"crosshair\";\n                        }\n                    }\n                    this.plot_view.set_cursor(cursor);\n                    this.plot_view.set_toolbar_visibility(on_canvas);\n                    active_inspectors.map((inspector) => this.trigger(signal, e, inspector.id));\n                    break;\n                }\n                case \"tap\": {\n                    const { target } = srcEvent;\n                    if (target != null && target != this.hit_area)\n                        return; // don't trigger bokeh events\n                    if (view != null && view.on_hit != null)\n                        view.on_hit(e.sx, e.sy);\n                    const active_gesture = gestures[base_type].active;\n                    if (active_gesture != null)\n                        this.trigger(signal, e, active_gesture.id);\n                    break;\n                }\n                case \"scroll\": {\n                    // Dual touch hack part 2/2\n                    // This is a hack for laptops with touch screen who may be pinching or scrolling\n                    // in order to use the wheel zoom tool. If it's a touch screen the WheelZoomTool event\n                    // will be linked to pinch. But we also want to trigger in the case of a scroll.\n                    const base = compat_1.is_mobile ? \"pinch\" : \"scroll\";\n                    const active_gesture = gestures[base].active;\n                    if (active_gesture != null) {\n                        srcEvent.preventDefault();\n                        srcEvent.stopPropagation();\n                        this.trigger(signal, e, active_gesture.id);\n                    }\n                    break;\n                }\n                case \"pan\": {\n                    const active_gesture = gestures[base_type].active;\n                    if (active_gesture != null) {\n                        srcEvent.preventDefault();\n                        this.trigger(signal, e, active_gesture.id);\n                    }\n                    break;\n                }\n                default: {\n                    const active_gesture = gestures[base_type].active;\n                    if (active_gesture != null)\n                        this.trigger(signal, e, active_gesture.id);\n                }\n            }\n            this._trigger_bokeh_event(e);\n        }\n        trigger(signal, e, id = null) {\n            signal.emit({ id, e });\n        }\n        _trigger_bokeh_event(e) {\n            const ev = (() => {\n                const xscale = this.plot_view.frame.xscales.default;\n                const yscale = this.plot_view.frame.yscales.default;\n                const { sx, sy } = e;\n                const x = xscale.invert(sx);\n                const y = yscale.invert(sy);\n                switch (e.type) {\n                    case \"wheel\":\n                        return new events.MouseWheel(sx, sy, x, y, e.delta);\n                    case \"mousemove\":\n                        return new events.MouseMove(sx, sy, x, y);\n                    case \"mouseenter\":\n                        return new events.MouseEnter(sx, sy, x, y);\n                    case \"mouseleave\":\n                        return new events.MouseLeave(sx, sy, x, y);\n                    case \"tap\":\n                        return new events.Tap(sx, sy, x, y);\n                    case \"doubletap\":\n                        return new events.DoubleTap(sx, sy, x, y);\n                    case \"press\":\n                        return new events.Press(sx, sy, x, y);\n                    case \"pressup\":\n                        return new events.PressUp(sx, sy, x, y);\n                    case \"pan\":\n                        return new events.Pan(sx, sy, x, y, e.deltaX, e.deltaY);\n                    case \"panstart\":\n                        return new events.PanStart(sx, sy, x, y);\n                    case \"panend\":\n                        return new events.PanEnd(sx, sy, x, y);\n                    case \"pinch\":\n                        return new events.Pinch(sx, sy, x, y, e.scale);\n                    case \"pinchstart\":\n                        return new events.PinchStart(sx, sy, x, y);\n                    case \"pinchend\":\n                        return new events.PinchEnd(sx, sy, x, y);\n                    case \"rotate\":\n                        return new events.Rotate(sx, sy, x, y, e.rotation);\n                    case \"rotatestart\":\n                        return new events.RotateStart(sx, sy, x, y);\n                    case \"rotateend\":\n                        return new events.RotateEnd(sx, sy, x, y);\n                    default:\n                        return undefined;\n                }\n            })();\n            if (ev != null)\n                this.plot_view.model.trigger_event(ev);\n        }\n        _get_sxy(event) {\n            // XXX: jsdom doesn't support TouchEvent constructor\n            function is_touch(event) {\n                return typeof TouchEvent !== \"undefined\" && event instanceof TouchEvent;\n            }\n            const { pageX, pageY } = is_touch(event) ? (event.touches.length != 0 ? event.touches : event.changedTouches)[0] : event;\n            const { left, top } = dom_1.offset(this.hit_area);\n            return {\n                sx: pageX - left,\n                sy: pageY - top,\n            };\n        }\n        _pan_event(e) {\n            return Object.assign(Object.assign({ type: e.type }, this._get_sxy(e.srcEvent)), { deltaX: e.deltaX, deltaY: e.deltaY, shiftKey: e.srcEvent.shiftKey });\n        }\n        _pinch_event(e) {\n            return Object.assign(Object.assign({ type: e.type }, this._get_sxy(e.srcEvent)), { scale: e.scale, shiftKey: e.srcEvent.shiftKey });\n        }\n        _rotate_event(e) {\n            return Object.assign(Object.assign({ type: e.type }, this._get_sxy(e.srcEvent)), { rotation: e.rotation, shiftKey: e.srcEvent.shiftKey });\n        }\n        _tap_event(e) {\n            return Object.assign(Object.assign({ type: e.type }, this._get_sxy(e.srcEvent)), { shiftKey: e.srcEvent.shiftKey });\n        }\n        _move_event(e) {\n            return Object.assign({ type: e.type }, this._get_sxy(e));\n        }\n        _scroll_event(e) {\n            return Object.assign(Object.assign({ type: e.type }, this._get_sxy(e)), { delta: wheel_1.getDeltaY(e) });\n        }\n        _key_event(e) {\n            return {\n                type: e.type,\n                keyCode: e.keyCode,\n            };\n        }\n        _pan_start(e) {\n            const ev = this._pan_event(e);\n            // back out delta to get original center point\n            ev.sx -= e.deltaX;\n            ev.sy -= e.deltaY;\n            this._trigger(this.pan_start, ev, e.srcEvent);\n        }\n        _pan(e) {\n            this._trigger(this.pan, this._pan_event(e), e.srcEvent);\n        }\n        _pan_end(e) {\n            this._trigger(this.pan_end, this._pan_event(e), e.srcEvent);\n        }\n        _pinch_start(e) {\n            this._trigger(this.pinch_start, this._pinch_event(e), e.srcEvent);\n        }\n        _pinch(e) {\n            this._trigger(this.pinch, this._pinch_event(e), e.srcEvent);\n        }\n        _pinch_end(e) {\n            this._trigger(this.pinch_end, this._pinch_event(e), e.srcEvent);\n        }\n        _rotate_start(e) {\n            this._trigger(this.rotate_start, this._rotate_event(e), e.srcEvent);\n        }\n        _rotate(e) {\n            this._trigger(this.rotate, this._rotate_event(e), e.srcEvent);\n        }\n        _rotate_end(e) {\n            this._trigger(this.rotate_end, this._rotate_event(e), e.srcEvent);\n        }\n        _tap(e) {\n            this._trigger(this.tap, this._tap_event(e), e.srcEvent);\n        }\n        _doubletap(e) {\n            // NOTE: doubletap event triggered unconditionally\n            const ev = this._tap_event(e);\n            this._trigger_bokeh_event(ev);\n            this.trigger(this.doubletap, ev);\n        }\n        _press(e) {\n            this._trigger(this.press, this._tap_event(e), e.srcEvent);\n        }\n        _pressup(e) {\n            this._trigger(this.pressup, this._tap_event(e), e.srcEvent);\n        }\n        _mouse_enter(e) {\n            this._trigger(this.move_enter, this._move_event(e), e);\n        }\n        _mouse_move(e) {\n            this._trigger(this.move, this._move_event(e), e);\n        }\n        _mouse_exit(e) {\n            this._trigger(this.move_exit, this._move_event(e), e);\n        }\n        _mouse_wheel(e) {\n            this._trigger(this.scroll, this._scroll_event(e), e);\n        }\n        _key_down(e) {\n            // NOTE: keyup event triggered unconditionally\n            this.trigger(this.keydown, this._key_event(e));\n        }\n        _key_up(e) {\n            // NOTE: keyup event triggered unconditionally\n            this.trigger(this.keyup, this._key_event(e));\n        }\n    }\n    exports.UIEvents = UIEvents;\n    UIEvents.__name__ = \"UIEvents\";\n}\n","/* hammerjs/hammer.js */ function _(require, module, exports) {\n    /*! Hammer.JS - v2.0.7 - 2016-04-22\n     * http://hammerjs.github.io/\n     *\n     * Copyright (c) 2016 Jorik Tangelder;\n     * Licensed under the MIT license */\n    (function (window, document, exportName, undefined) {\n        'use strict';\n        var VENDOR_PREFIXES = ['', 'webkit', 'Moz', 'MS', 'ms', 'o'];\n        var TEST_ELEMENT = document.createElement('div');\n        var TYPE_FUNCTION = 'function';\n        var round = Math.round;\n        var abs = Math.abs;\n        var now = Date.now;\n        /**\n         * set a timeout with a given scope\n         * @param {Function} fn\n         * @param {Number} timeout\n         * @param {Object} context\n         * @returns {number}\n         */\n        function setTimeoutContext(fn, timeout, context) {\n            return setTimeout(bindFn(fn, context), timeout);\n        }\n        /**\n         * if the argument is an array, we want to execute the fn on each entry\n         * if it aint an array we don't want to do a thing.\n         * this is used by all the methods that accept a single and array argument.\n         * @param {*|Array} arg\n         * @param {String} fn\n         * @param {Object} [context]\n         * @returns {Boolean}\n         */\n        function invokeArrayArg(arg, fn, context) {\n            if (Array.isArray(arg)) {\n                each(arg, context[fn], context);\n                return true;\n            }\n            return false;\n        }\n        /**\n         * walk objects and arrays\n         * @param {Object} obj\n         * @param {Function} iterator\n         * @param {Object} context\n         */\n        function each(obj, iterator, context) {\n            var i;\n            if (!obj) {\n                return;\n            }\n            if (obj.forEach) {\n                obj.forEach(iterator, context);\n            }\n            else if (obj.length !== undefined) {\n                i = 0;\n                while (i < obj.length) {\n                    iterator.call(context, obj[i], i, obj);\n                    i++;\n                }\n            }\n            else {\n                for (i in obj) {\n                    obj.hasOwnProperty(i) && iterator.call(context, obj[i], i, obj);\n                }\n            }\n        }\n        /**\n         * wrap a method with a deprecation warning and stack trace\n         * @param {Function} method\n         * @param {String} name\n         * @param {String} message\n         * @returns {Function} A new function wrapping the supplied method.\n         */\n        function deprecate(method, name, message) {\n            var deprecationMessage = 'DEPRECATED METHOD: ' + name + '\\n' + message + ' AT \\n';\n            return function () {\n                var e = new Error('get-stack-trace');\n                var stack = e && e.stack ? e.stack.replace(/^[^\\(]+?[\\n$]/gm, '')\n                    .replace(/^\\s+at\\s+/gm, '')\n                    .replace(/^Object.<anonymous>\\s*\\(/gm, '{anonymous}()@') : 'Unknown Stack Trace';\n                var log = window.console && (window.console.warn || window.console.log);\n                if (log) {\n                    log.call(window.console, deprecationMessage, stack);\n                }\n                return method.apply(this, arguments);\n            };\n        }\n        /**\n         * extend object.\n         * means that properties in dest will be overwritten by the ones in src.\n         * @param {Object} target\n         * @param {...Object} objects_to_assign\n         * @returns {Object} target\n         */\n        var assign;\n        if (typeof Object.assign !== 'function') {\n            assign = function assign(target) {\n                if (target === undefined || target === null) {\n                    throw new TypeError('Cannot convert undefined or null to object');\n                }\n                var output = Object(target);\n                for (var index = 1; index < arguments.length; index++) {\n                    var source = arguments[index];\n                    if (source !== undefined && source !== null) {\n                        for (var nextKey in source) {\n                            if (source.hasOwnProperty(nextKey)) {\n                                output[nextKey] = source[nextKey];\n                            }\n                        }\n                    }\n                }\n                return output;\n            };\n        }\n        else {\n            assign = Object.assign;\n        }\n        /**\n         * extend object.\n         * means that properties in dest will be overwritten by the ones in src.\n         * @param {Object} dest\n         * @param {Object} src\n         * @param {Boolean} [merge=false]\n         * @returns {Object} dest\n         */\n        var extend = deprecate(function extend(dest, src, merge) {\n            var keys = Object.keys(src);\n            var i = 0;\n            while (i < keys.length) {\n                if (!merge || (merge && dest[keys[i]] === undefined)) {\n                    dest[keys[i]] = src[keys[i]];\n                }\n                i++;\n            }\n            return dest;\n        }, 'extend', 'Use `assign`.');\n        /**\n         * merge the values from src in the dest.\n         * means that properties that exist in dest will not be overwritten by src\n         * @param {Object} dest\n         * @param {Object} src\n         * @returns {Object} dest\n         */\n        var merge = deprecate(function merge(dest, src) {\n            return extend(dest, src, true);\n        }, 'merge', 'Use `assign`.');\n        /**\n         * simple class inheritance\n         * @param {Function} child\n         * @param {Function} base\n         * @param {Object} [properties]\n         */\n        function inherit(child, base, properties) {\n            var baseP = base.prototype, childP;\n            childP = child.prototype = Object.create(baseP);\n            childP.constructor = child;\n            childP._super = baseP;\n            if (properties) {\n                assign(childP, properties);\n            }\n        }\n        /**\n         * simple function bind\n         * @param {Function} fn\n         * @param {Object} context\n         * @returns {Function}\n         */\n        function bindFn(fn, context) {\n            return function boundFn() {\n                return fn.apply(context, arguments);\n            };\n        }\n        /**\n         * let a boolean value also be a function that must return a boolean\n         * this first item in args will be used as the context\n         * @param {Boolean|Function} val\n         * @param {Array} [args]\n         * @returns {Boolean}\n         */\n        function boolOrFn(val, args) {\n            if (typeof val == TYPE_FUNCTION) {\n                return val.apply(args ? args[0] || undefined : undefined, args);\n            }\n            return val;\n        }\n        /**\n         * use the val2 when val1 is undefined\n         * @param {*} val1\n         * @param {*} val2\n         * @returns {*}\n         */\n        function ifUndefined(val1, val2) {\n            return (val1 === undefined) ? val2 : val1;\n        }\n        /**\n         * addEventListener with multiple events at once\n         * @param {EventTarget} target\n         * @param {String} types\n         * @param {Function} handler\n         */\n        function addEventListeners(target, types, handler) {\n            each(splitStr(types), function (type) {\n                target.addEventListener(type, handler, false);\n            });\n        }\n        /**\n         * removeEventListener with multiple events at once\n         * @param {EventTarget} target\n         * @param {String} types\n         * @param {Function} handler\n         */\n        function removeEventListeners(target, types, handler) {\n            each(splitStr(types), function (type) {\n                target.removeEventListener(type, handler, false);\n            });\n        }\n        /**\n         * find if a node is in the given parent\n         * @method hasParent\n         * @param {HTMLElement} node\n         * @param {HTMLElement} parent\n         * @return {Boolean} found\n         */\n        function hasParent(node, parent) {\n            while (node) {\n                if (node == parent) {\n                    return true;\n                }\n                node = node.parentNode;\n            }\n            return false;\n        }\n        /**\n         * small indexOf wrapper\n         * @param {String} str\n         * @param {String} find\n         * @returns {Boolean} found\n         */\n        function inStr(str, find) {\n            return str.indexOf(find) > -1;\n        }\n        /**\n         * split string on whitespace\n         * @param {String} str\n         * @returns {Array} words\n         */\n        function splitStr(str) {\n            return str.trim().split(/\\s+/g);\n        }\n        /**\n         * find if a array contains the object using indexOf or a simple polyFill\n         * @param {Array} src\n         * @param {String} find\n         * @param {String} [findByKey]\n         * @return {Boolean|Number} false when not found, or the index\n         */\n        function inArray(src, find, findByKey) {\n            if (src.indexOf && !findByKey) {\n                return src.indexOf(find);\n            }\n            else {\n                var i = 0;\n                while (i < src.length) {\n                    if ((findByKey && src[i][findByKey] == find) || (!findByKey && src[i] === find)) {\n                        return i;\n                    }\n                    i++;\n                }\n                return -1;\n            }\n        }\n        /**\n         * convert array-like objects to real arrays\n         * @param {Object} obj\n         * @returns {Array}\n         */\n        function toArray(obj) {\n            return Array.prototype.slice.call(obj, 0);\n        }\n        /**\n         * unique array with objects based on a key (like 'id') or just by the array's value\n         * @param {Array} src [{id:1},{id:2},{id:1}]\n         * @param {String} [key]\n         * @param {Boolean} [sort=False]\n         * @returns {Array} [{id:1},{id:2}]\n         */\n        function uniqueArray(src, key, sort) {\n            var results = [];\n            var values = [];\n            var i = 0;\n            while (i < src.length) {\n                var val = key ? src[i][key] : src[i];\n                if (inArray(values, val) < 0) {\n                    results.push(src[i]);\n                }\n                values[i] = val;\n                i++;\n            }\n            if (sort) {\n                if (!key) {\n                    results = results.sort();\n                }\n                else {\n                    results = results.sort(function sortUniqueArray(a, b) {\n                        return a[key] > b[key];\n                    });\n                }\n            }\n            return results;\n        }\n        /**\n         * get the prefixed property\n         * @param {Object} obj\n         * @param {String} property\n         * @returns {String|Undefined} prefixed\n         */\n        function prefixed(obj, property) {\n            var prefix, prop;\n            var camelProp = property[0].toUpperCase() + property.slice(1);\n            var i = 0;\n            while (i < VENDOR_PREFIXES.length) {\n                prefix = VENDOR_PREFIXES[i];\n                prop = (prefix) ? prefix + camelProp : property;\n                if (prop in obj) {\n                    return prop;\n                }\n                i++;\n            }\n            return undefined;\n        }\n        /**\n         * get a unique id\n         * @returns {number} uniqueId\n         */\n        var _uniqueId = 1;\n        function uniqueId() {\n            return _uniqueId++;\n        }\n        /**\n         * get the window object of an element\n         * @param {HTMLElement} element\n         * @returns {DocumentView|Window}\n         */\n        function getWindowForElement(element) {\n            var doc = element.ownerDocument || element;\n            return (doc.defaultView || doc.parentWindow || window);\n        }\n        var MOBILE_REGEX = /mobile|tablet|ip(ad|hone|od)|android/i;\n        var SUPPORT_TOUCH = ('ontouchstart' in window);\n        var SUPPORT_POINTER_EVENTS = prefixed(window, 'PointerEvent') !== undefined;\n        var SUPPORT_ONLY_TOUCH = SUPPORT_TOUCH && MOBILE_REGEX.test(navigator.userAgent);\n        var INPUT_TYPE_TOUCH = 'touch';\n        var INPUT_TYPE_PEN = 'pen';\n        var INPUT_TYPE_MOUSE = 'mouse';\n        var INPUT_TYPE_KINECT = 'kinect';\n        var COMPUTE_INTERVAL = 25;\n        var INPUT_START = 1;\n        var INPUT_MOVE = 2;\n        var INPUT_END = 4;\n        var INPUT_CANCEL = 8;\n        var DIRECTION_NONE = 1;\n        var DIRECTION_LEFT = 2;\n        var DIRECTION_RIGHT = 4;\n        var DIRECTION_UP = 8;\n        var DIRECTION_DOWN = 16;\n        var DIRECTION_HORIZONTAL = DIRECTION_LEFT | DIRECTION_RIGHT;\n        var DIRECTION_VERTICAL = DIRECTION_UP | DIRECTION_DOWN;\n        var DIRECTION_ALL = DIRECTION_HORIZONTAL | DIRECTION_VERTICAL;\n        var PROPS_XY = ['x', 'y'];\n        var PROPS_CLIENT_XY = ['clientX', 'clientY'];\n        /**\n         * create new input type manager\n         * @param {Manager} manager\n         * @param {Function} callback\n         * @returns {Input}\n         * @constructor\n         */\n        function Input(manager, callback) {\n            var self = this;\n            this.manager = manager;\n            this.callback = callback;\n            this.element = manager.element;\n            this.target = manager.options.inputTarget;\n            // smaller wrapper around the handler, for the scope and the enabled state of the manager,\n            // so when disabled the input events are completely bypassed.\n            this.domHandler = function (ev) {\n                if (boolOrFn(manager.options.enable, [manager])) {\n                    self.handler(ev);\n                }\n            };\n            this.init();\n        }\n        Input.prototype = {\n            /**\n             * should handle the inputEvent data and trigger the callback\n             * @virtual\n             */\n            handler: function () { },\n            /**\n             * bind the events\n             */\n            init: function () {\n                this.evEl && addEventListeners(this.element, this.evEl, this.domHandler);\n                this.evTarget && addEventListeners(this.target, this.evTarget, this.domHandler);\n                this.evWin && addEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);\n            },\n            /**\n             * unbind the events\n             */\n            destroy: function () {\n                this.evEl && removeEventListeners(this.element, this.evEl, this.domHandler);\n                this.evTarget && removeEventListeners(this.target, this.evTarget, this.domHandler);\n                this.evWin && removeEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);\n            }\n        };\n        /**\n         * create new input type manager\n         * called by the Manager constructor\n         * @param {Hammer} manager\n         * @returns {Input}\n         */\n        function createInputInstance(manager) {\n            var Type;\n            var inputClass = manager.options.inputClass;\n            if (inputClass) {\n                Type = inputClass;\n            }\n            else if (SUPPORT_POINTER_EVENTS) {\n                Type = PointerEventInput;\n            }\n            else if (SUPPORT_ONLY_TOUCH) {\n                Type = TouchInput;\n            }\n            else if (!SUPPORT_TOUCH) {\n                Type = MouseInput;\n            }\n            else {\n                Type = TouchMouseInput;\n            }\n            return new (Type)(manager, inputHandler);\n        }\n        /**\n         * handle input events\n         * @param {Manager} manager\n         * @param {String} eventType\n         * @param {Object} input\n         */\n        function inputHandler(manager, eventType, input) {\n            var pointersLen = input.pointers.length;\n            var changedPointersLen = input.changedPointers.length;\n            var isFirst = (eventType & INPUT_START && (pointersLen - changedPointersLen === 0));\n            var isFinal = (eventType & (INPUT_END | INPUT_CANCEL) && (pointersLen - changedPointersLen === 0));\n            input.isFirst = !!isFirst;\n            input.isFinal = !!isFinal;\n            if (isFirst) {\n                manager.session = {};\n            }\n            // source event is the normalized value of the domEvents\n            // like 'touchstart, mouseup, pointerdown'\n            input.eventType = eventType;\n            // compute scale, rotation etc\n            computeInputData(manager, input);\n            // emit secret event\n            manager.emit('hammer.input', input);\n            manager.recognize(input);\n            manager.session.prevInput = input;\n        }\n        /**\n         * extend the data with some usable properties like scale, rotate, velocity etc\n         * @param {Object} manager\n         * @param {Object} input\n         */\n        function computeInputData(manager, input) {\n            var session = manager.session;\n            var pointers = input.pointers;\n            var pointersLength = pointers.length;\n            // store the first input to calculate the distance and direction\n            if (!session.firstInput) {\n                session.firstInput = simpleCloneInputData(input);\n            }\n            // to compute scale and rotation we need to store the multiple touches\n            if (pointersLength > 1 && !session.firstMultiple) {\n                session.firstMultiple = simpleCloneInputData(input);\n            }\n            else if (pointersLength === 1) {\n                session.firstMultiple = false;\n            }\n            var firstInput = session.firstInput;\n            var firstMultiple = session.firstMultiple;\n            var offsetCenter = firstMultiple ? firstMultiple.center : firstInput.center;\n            var center = input.center = getCenter(pointers);\n            input.timeStamp = now();\n            input.deltaTime = input.timeStamp - firstInput.timeStamp;\n            input.angle = getAngle(offsetCenter, center);\n            input.distance = getDistance(offsetCenter, center);\n            computeDeltaXY(session, input);\n            input.offsetDirection = getDirection(input.deltaX, input.deltaY);\n            var overallVelocity = getVelocity(input.deltaTime, input.deltaX, input.deltaY);\n            input.overallVelocityX = overallVelocity.x;\n            input.overallVelocityY = overallVelocity.y;\n            input.overallVelocity = (abs(overallVelocity.x) > abs(overallVelocity.y)) ? overallVelocity.x : overallVelocity.y;\n            input.scale = firstMultiple ? getScale(firstMultiple.pointers, pointers) : 1;\n            input.rotation = firstMultiple ? getRotation(firstMultiple.pointers, pointers) : 0;\n            input.maxPointers = !session.prevInput ? input.pointers.length : ((input.pointers.length >\n                session.prevInput.maxPointers) ? input.pointers.length : session.prevInput.maxPointers);\n            computeIntervalInputData(session, input);\n            // find the correct target\n            var target = manager.element;\n            if (hasParent(input.srcEvent.target, target)) {\n                target = input.srcEvent.target;\n            }\n            input.target = target;\n        }\n        function computeDeltaXY(session, input) {\n            var center = input.center;\n            var offset = session.offsetDelta || {};\n            var prevDelta = session.prevDelta || {};\n            var prevInput = session.prevInput || {};\n            if (input.eventType === INPUT_START || prevInput.eventType === INPUT_END) {\n                prevDelta = session.prevDelta = {\n                    x: prevInput.deltaX || 0,\n                    y: prevInput.deltaY || 0\n                };\n                offset = session.offsetDelta = {\n                    x: center.x,\n                    y: center.y\n                };\n            }\n            input.deltaX = prevDelta.x + (center.x - offset.x);\n            input.deltaY = prevDelta.y + (center.y - offset.y);\n        }\n        /**\n         * velocity is calculated every x ms\n         * @param {Object} session\n         * @param {Object} input\n         */\n        function computeIntervalInputData(session, input) {\n            var last = session.lastInterval || input, deltaTime = input.timeStamp - last.timeStamp, velocity, velocityX, velocityY, direction;\n            if (input.eventType != INPUT_CANCEL && (deltaTime > COMPUTE_INTERVAL || last.velocity === undefined)) {\n                var deltaX = input.deltaX - last.deltaX;\n                var deltaY = input.deltaY - last.deltaY;\n                var v = getVelocity(deltaTime, deltaX, deltaY);\n                velocityX = v.x;\n                velocityY = v.y;\n                velocity = (abs(v.x) > abs(v.y)) ? v.x : v.y;\n                direction = getDirection(deltaX, deltaY);\n                session.lastInterval = input;\n            }\n            else {\n                // use latest velocity info if it doesn't overtake a minimum period\n                velocity = last.velocity;\n                velocityX = last.velocityX;\n                velocityY = last.velocityY;\n                direction = last.direction;\n            }\n            input.velocity = velocity;\n            input.velocityX = velocityX;\n            input.velocityY = velocityY;\n            input.direction = direction;\n        }\n        /**\n         * create a simple clone from the input used for storage of firstInput and firstMultiple\n         * @param {Object} input\n         * @returns {Object} clonedInputData\n         */\n        function simpleCloneInputData(input) {\n            // make a simple copy of the pointers because we will get a reference if we don't\n            // we only need clientXY for the calculations\n            var pointers = [];\n            var i = 0;\n            while (i < input.pointers.length) {\n                pointers[i] = {\n                    clientX: round(input.pointers[i].clientX),\n                    clientY: round(input.pointers[i].clientY)\n                };\n                i++;\n            }\n            return {\n                timeStamp: now(),\n                pointers: pointers,\n                center: getCenter(pointers),\n                deltaX: input.deltaX,\n                deltaY: input.deltaY\n            };\n        }\n        /**\n         * get the center of all the pointers\n         * @param {Array} pointers\n         * @return {Object} center contains `x` and `y` properties\n         */\n        function getCenter(pointers) {\n            var pointersLength = pointers.length;\n            // no need to loop when only one touch\n            if (pointersLength === 1) {\n                return {\n                    x: round(pointers[0].clientX),\n                    y: round(pointers[0].clientY)\n                };\n            }\n            var x = 0, y = 0, i = 0;\n            while (i < pointersLength) {\n                x += pointers[i].clientX;\n                y += pointers[i].clientY;\n                i++;\n            }\n            return {\n                x: round(x / pointersLength),\n                y: round(y / pointersLength)\n            };\n        }\n        /**\n         * calculate the velocity between two points. unit is in px per ms.\n         * @param {Number} deltaTime\n         * @param {Number} x\n         * @param {Number} y\n         * @return {Object} velocity `x` and `y`\n         */\n        function getVelocity(deltaTime, x, y) {\n            return {\n                x: x / deltaTime || 0,\n                y: y / deltaTime || 0\n            };\n        }\n        /**\n         * get the direction between two points\n         * @param {Number} x\n         * @param {Number} y\n         * @return {Number} direction\n         */\n        function getDirection(x, y) {\n            if (x === y) {\n                return DIRECTION_NONE;\n            }\n            if (abs(x) >= abs(y)) {\n                return x < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;\n            }\n            return y < 0 ? DIRECTION_UP : DIRECTION_DOWN;\n        }\n        /**\n         * calculate the absolute distance between two points\n         * @param {Object} p1 {x, y}\n         * @param {Object} p2 {x, y}\n         * @param {Array} [props] containing x and y keys\n         * @return {Number} distance\n         */\n        function getDistance(p1, p2, props) {\n            if (!props) {\n                props = PROPS_XY;\n            }\n            var x = p2[props[0]] - p1[props[0]], y = p2[props[1]] - p1[props[1]];\n            return Math.sqrt((x * x) + (y * y));\n        }\n        /**\n         * calculate the angle between two coordinates\n         * @param {Object} p1\n         * @param {Object} p2\n         * @param {Array} [props] containing x and y keys\n         * @return {Number} angle\n         */\n        function getAngle(p1, p2, props) {\n            if (!props) {\n                props = PROPS_XY;\n            }\n            var x = p2[props[0]] - p1[props[0]], y = p2[props[1]] - p1[props[1]];\n            return Math.atan2(y, x) * 180 / Math.PI;\n        }\n        /**\n         * calculate the rotation degrees between two pointersets\n         * @param {Array} start array of pointers\n         * @param {Array} end array of pointers\n         * @return {Number} rotation\n         */\n        function getRotation(start, end) {\n            return getAngle(end[1], end[0], PROPS_CLIENT_XY) + getAngle(start[1], start[0], PROPS_CLIENT_XY);\n        }\n        /**\n         * calculate the scale factor between two pointersets\n         * no scale is 1, and goes down to 0 when pinched together, and bigger when pinched out\n         * @param {Array} start array of pointers\n         * @param {Array} end array of pointers\n         * @return {Number} scale\n         */\n        function getScale(start, end) {\n            return getDistance(end[0], end[1], PROPS_CLIENT_XY) / getDistance(start[0], start[1], PROPS_CLIENT_XY);\n        }\n        var MOUSE_INPUT_MAP = {\n            mousedown: INPUT_START,\n            mousemove: INPUT_MOVE,\n            mouseup: INPUT_END\n        };\n        var MOUSE_ELEMENT_EVENTS = 'mousedown';\n        var MOUSE_WINDOW_EVENTS = 'mousemove mouseup';\n        /**\n         * Mouse events input\n         * @constructor\n         * @extends Input\n         */\n        function MouseInput() {\n            this.evEl = MOUSE_ELEMENT_EVENTS;\n            this.evWin = MOUSE_WINDOW_EVENTS;\n            this.pressed = false; // mousedown state\n            Input.apply(this, arguments);\n        }\n        inherit(MouseInput, Input, {\n            /**\n             * handle mouse events\n             * @param {Object} ev\n             */\n            handler: function MEhandler(ev) {\n                var eventType = MOUSE_INPUT_MAP[ev.type];\n                // on start we want to have the left mouse button down\n                if (eventType & INPUT_START && ev.button === 0) {\n                    this.pressed = true;\n                }\n                if (eventType & INPUT_MOVE && ev.which !== 1) {\n                    eventType = INPUT_END;\n                }\n                // mouse must be down\n                if (!this.pressed) {\n                    return;\n                }\n                if (eventType & INPUT_END) {\n                    this.pressed = false;\n                }\n                this.callback(this.manager, eventType, {\n                    pointers: [ev],\n                    changedPointers: [ev],\n                    pointerType: INPUT_TYPE_MOUSE,\n                    srcEvent: ev\n                });\n            }\n        });\n        var POINTER_INPUT_MAP = {\n            pointerdown: INPUT_START,\n            pointermove: INPUT_MOVE,\n            pointerup: INPUT_END,\n            pointercancel: INPUT_CANCEL,\n            pointerout: INPUT_CANCEL\n        };\n        // in IE10 the pointer types is defined as an enum\n        var IE10_POINTER_TYPE_ENUM = {\n            2: INPUT_TYPE_TOUCH,\n            3: INPUT_TYPE_PEN,\n            4: INPUT_TYPE_MOUSE,\n            5: INPUT_TYPE_KINECT // see https://twitter.com/jacobrossi/status/480596438489890816\n        };\n        var POINTER_ELEMENT_EVENTS = 'pointerdown';\n        var POINTER_WINDOW_EVENTS = 'pointermove pointerup pointercancel';\n        // IE10 has prefixed support, and case-sensitive\n        if (window.MSPointerEvent && !window.PointerEvent) {\n            POINTER_ELEMENT_EVENTS = 'MSPointerDown';\n            POINTER_WINDOW_EVENTS = 'MSPointerMove MSPointerUp MSPointerCancel';\n        }\n        /**\n         * Pointer events input\n         * @constructor\n         * @extends Input\n         */\n        function PointerEventInput() {\n            this.evEl = POINTER_ELEMENT_EVENTS;\n            this.evWin = POINTER_WINDOW_EVENTS;\n            Input.apply(this, arguments);\n            this.store = (this.manager.session.pointerEvents = []);\n        }\n        inherit(PointerEventInput, Input, {\n            /**\n             * handle mouse events\n             * @param {Object} ev\n             */\n            handler: function PEhandler(ev) {\n                var store = this.store;\n                var removePointer = false;\n                var eventTypeNormalized = ev.type.toLowerCase().replace('ms', '');\n                var eventType = POINTER_INPUT_MAP[eventTypeNormalized];\n                var pointerType = IE10_POINTER_TYPE_ENUM[ev.pointerType] || ev.pointerType;\n                var isTouch = (pointerType == INPUT_TYPE_TOUCH);\n                // get index of the event in the store\n                var storeIndex = inArray(store, ev.pointerId, 'pointerId');\n                // start and mouse must be down\n                if (eventType & INPUT_START && (ev.button === 0 || isTouch)) {\n                    if (storeIndex < 0) {\n                        store.push(ev);\n                        storeIndex = store.length - 1;\n                    }\n                }\n                else if (eventType & (INPUT_END | INPUT_CANCEL)) {\n                    removePointer = true;\n                }\n                // it not found, so the pointer hasn't been down (so it's probably a hover)\n                if (storeIndex < 0) {\n                    return;\n                }\n                // update the event in the store\n                store[storeIndex] = ev;\n                this.callback(this.manager, eventType, {\n                    pointers: store,\n                    changedPointers: [ev],\n                    pointerType: pointerType,\n                    srcEvent: ev\n                });\n                if (removePointer) {\n                    // remove from the store\n                    store.splice(storeIndex, 1);\n                }\n            }\n        });\n        var SINGLE_TOUCH_INPUT_MAP = {\n            touchstart: INPUT_START,\n            touchmove: INPUT_MOVE,\n            touchend: INPUT_END,\n            touchcancel: INPUT_CANCEL\n        };\n        var SINGLE_TOUCH_TARGET_EVENTS = 'touchstart';\n        var SINGLE_TOUCH_WINDOW_EVENTS = 'touchstart touchmove touchend touchcancel';\n        /**\n         * Touch events input\n         * @constructor\n         * @extends Input\n         */\n        function SingleTouchInput() {\n            this.evTarget = SINGLE_TOUCH_TARGET_EVENTS;\n            this.evWin = SINGLE_TOUCH_WINDOW_EVENTS;\n            this.started = false;\n            Input.apply(this, arguments);\n        }\n        inherit(SingleTouchInput, Input, {\n            handler: function TEhandler(ev) {\n                var type = SINGLE_TOUCH_INPUT_MAP[ev.type];\n                // should we handle the touch events?\n                if (type === INPUT_START) {\n                    this.started = true;\n                }\n                if (!this.started) {\n                    return;\n                }\n                var touches = normalizeSingleTouches.call(this, ev, type);\n                // when done, reset the started state\n                if (type & (INPUT_END | INPUT_CANCEL) && touches[0].length - touches[1].length === 0) {\n                    this.started = false;\n                }\n                this.callback(this.manager, type, {\n                    pointers: touches[0],\n                    changedPointers: touches[1],\n                    pointerType: INPUT_TYPE_TOUCH,\n                    srcEvent: ev\n                });\n            }\n        });\n        /**\n         * @this {TouchInput}\n         * @param {Object} ev\n         * @param {Number} type flag\n         * @returns {undefined|Array} [all, changed]\n         */\n        function normalizeSingleTouches(ev, type) {\n            var all = toArray(ev.touches);\n            var changed = toArray(ev.changedTouches);\n            if (type & (INPUT_END | INPUT_CANCEL)) {\n                all = uniqueArray(all.concat(changed), 'identifier', true);\n            }\n            return [all, changed];\n        }\n        var TOUCH_INPUT_MAP = {\n            touchstart: INPUT_START,\n            touchmove: INPUT_MOVE,\n            touchend: INPUT_END,\n            touchcancel: INPUT_CANCEL\n        };\n        var TOUCH_TARGET_EVENTS = 'touchstart touchmove touchend touchcancel';\n        /**\n         * Multi-user touch events input\n         * @constructor\n         * @extends Input\n         */\n        function TouchInput() {\n            this.evTarget = TOUCH_TARGET_EVENTS;\n            this.targetIds = {};\n            Input.apply(this, arguments);\n        }\n        inherit(TouchInput, Input, {\n            handler: function MTEhandler(ev) {\n                var type = TOUCH_INPUT_MAP[ev.type];\n                var touches = getTouches.call(this, ev, type);\n                if (!touches) {\n                    return;\n                }\n                this.callback(this.manager, type, {\n                    pointers: touches[0],\n                    changedPointers: touches[1],\n                    pointerType: INPUT_TYPE_TOUCH,\n                    srcEvent: ev\n                });\n            }\n        });\n        /**\n         * @this {TouchInput}\n         * @param {Object} ev\n         * @param {Number} type flag\n         * @returns {undefined|Array} [all, changed]\n         */\n        function getTouches(ev, type) {\n            var allTouches = toArray(ev.touches);\n            var targetIds = this.targetIds;\n            // when there is only one touch, the process can be simplified\n            if (type & (INPUT_START | INPUT_MOVE) && allTouches.length === 1) {\n                targetIds[allTouches[0].identifier] = true;\n                return [allTouches, allTouches];\n            }\n            var i, targetTouches, changedTouches = toArray(ev.changedTouches), changedTargetTouches = [], target = this.target;\n            // get target touches from touches\n            targetTouches = allTouches.filter(function (touch) {\n                return hasParent(touch.target, target);\n            });\n            // collect touches\n            if (type === INPUT_START) {\n                i = 0;\n                while (i < targetTouches.length) {\n                    targetIds[targetTouches[i].identifier] = true;\n                    i++;\n                }\n            }\n            // filter changed touches to only contain touches that exist in the collected target ids\n            i = 0;\n            while (i < changedTouches.length) {\n                if (targetIds[changedTouches[i].identifier]) {\n                    changedTargetTouches.push(changedTouches[i]);\n                }\n                // cleanup removed touches\n                if (type & (INPUT_END | INPUT_CANCEL)) {\n                    delete targetIds[changedTouches[i].identifier];\n                }\n                i++;\n            }\n            if (!changedTargetTouches.length) {\n                return;\n            }\n            return [\n                // merge targetTouches with changedTargetTouches so it contains ALL touches, including 'end' and 'cancel'\n                uniqueArray(targetTouches.concat(changedTargetTouches), 'identifier', true),\n                changedTargetTouches\n            ];\n        }\n        /**\n         * Combined touch and mouse input\n         *\n         * Touch has a higher priority then mouse, and while touching no mouse events are allowed.\n         * This because touch devices also emit mouse events while doing a touch.\n         *\n         * @constructor\n         * @extends Input\n         */\n        var DEDUP_TIMEOUT = 2500;\n        var DEDUP_DISTANCE = 25;\n        function TouchMouseInput() {\n            Input.apply(this, arguments);\n            var handler = bindFn(this.handler, this);\n            this.touch = new TouchInput(this.manager, handler);\n            this.mouse = new MouseInput(this.manager, handler);\n            this.primaryTouch = null;\n            this.lastTouches = [];\n        }\n        inherit(TouchMouseInput, Input, {\n            /**\n             * handle mouse and touch events\n             * @param {Hammer} manager\n             * @param {String} inputEvent\n             * @param {Object} inputData\n             */\n            handler: function TMEhandler(manager, inputEvent, inputData) {\n                var isTouch = (inputData.pointerType == INPUT_TYPE_TOUCH), isMouse = (inputData.pointerType == INPUT_TYPE_MOUSE);\n                if (isMouse && inputData.sourceCapabilities && inputData.sourceCapabilities.firesTouchEvents) {\n                    return;\n                }\n                // when we're in a touch event, record touches to  de-dupe synthetic mouse event\n                if (isTouch) {\n                    recordTouches.call(this, inputEvent, inputData);\n                }\n                else if (isMouse && isSyntheticEvent.call(this, inputData)) {\n                    return;\n                }\n                this.callback(manager, inputEvent, inputData);\n            },\n            /**\n             * remove the event listeners\n             */\n            destroy: function destroy() {\n                this.touch.destroy();\n                this.mouse.destroy();\n            }\n        });\n        function recordTouches(eventType, eventData) {\n            if (eventType & INPUT_START) {\n                this.primaryTouch = eventData.changedPointers[0].identifier;\n                setLastTouch.call(this, eventData);\n            }\n            else if (eventType & (INPUT_END | INPUT_CANCEL)) {\n                setLastTouch.call(this, eventData);\n            }\n        }\n        function setLastTouch(eventData) {\n            var touch = eventData.changedPointers[0];\n            if (touch.identifier === this.primaryTouch) {\n                var lastTouch = { x: touch.clientX, y: touch.clientY };\n                this.lastTouches.push(lastTouch);\n                var lts = this.lastTouches;\n                var removeLastTouch = function () {\n                    var i = lts.indexOf(lastTouch);\n                    if (i > -1) {\n                        lts.splice(i, 1);\n                    }\n                };\n                setTimeout(removeLastTouch, DEDUP_TIMEOUT);\n            }\n        }\n        function isSyntheticEvent(eventData) {\n            var x = eventData.srcEvent.clientX, y = eventData.srcEvent.clientY;\n            for (var i = 0; i < this.lastTouches.length; i++) {\n                var t = this.lastTouches[i];\n                var dx = Math.abs(x - t.x), dy = Math.abs(y - t.y);\n                if (dx <= DEDUP_DISTANCE && dy <= DEDUP_DISTANCE) {\n                    return true;\n                }\n            }\n            return false;\n        }\n        var PREFIXED_TOUCH_ACTION = prefixed(TEST_ELEMENT.style, 'touchAction');\n        var NATIVE_TOUCH_ACTION = PREFIXED_TOUCH_ACTION !== undefined;\n        // magical touchAction value\n        var TOUCH_ACTION_COMPUTE = 'compute';\n        var TOUCH_ACTION_AUTO = 'auto';\n        var TOUCH_ACTION_MANIPULATION = 'manipulation'; // not implemented\n        var TOUCH_ACTION_NONE = 'none';\n        var TOUCH_ACTION_PAN_X = 'pan-x';\n        var TOUCH_ACTION_PAN_Y = 'pan-y';\n        var TOUCH_ACTION_MAP = getTouchActionProps();\n        /**\n         * Touch Action\n         * sets the touchAction property or uses the js alternative\n         * @param {Manager} manager\n         * @param {String} value\n         * @constructor\n         */\n        function TouchAction(manager, value) {\n            this.manager = manager;\n            this.set(value);\n        }\n        TouchAction.prototype = {\n            /**\n             * set the touchAction value on the element or enable the polyfill\n             * @param {String} value\n             */\n            set: function (value) {\n                // find out the touch-action by the event handlers\n                if (value == TOUCH_ACTION_COMPUTE) {\n                    value = this.compute();\n                }\n                if (NATIVE_TOUCH_ACTION && this.manager.element.style && TOUCH_ACTION_MAP[value]) {\n                    this.manager.element.style[PREFIXED_TOUCH_ACTION] = value;\n                }\n                this.actions = value.toLowerCase().trim();\n            },\n            /**\n             * just re-set the touchAction value\n             */\n            update: function () {\n                this.set(this.manager.options.touchAction);\n            },\n            /**\n             * compute the value for the touchAction property based on the recognizer's settings\n             * @returns {String} value\n             */\n            compute: function () {\n                var actions = [];\n                each(this.manager.recognizers, function (recognizer) {\n                    if (boolOrFn(recognizer.options.enable, [recognizer])) {\n                        actions = actions.concat(recognizer.getTouchAction());\n                    }\n                });\n                return cleanTouchActions(actions.join(' '));\n            },\n            /**\n             * this method is called on each input cycle and provides the preventing of the browser behavior\n             * @param {Object} input\n             */\n            preventDefaults: function (input) {\n                var srcEvent = input.srcEvent;\n                var direction = input.offsetDirection;\n                // if the touch action did prevented once this session\n                if (this.manager.session.prevented) {\n                    srcEvent.preventDefault();\n                    return;\n                }\n                var actions = this.actions;\n                var hasNone = inStr(actions, TOUCH_ACTION_NONE) && !TOUCH_ACTION_MAP[TOUCH_ACTION_NONE];\n                var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_Y];\n                var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_X];\n                if (hasNone) {\n                    //do not prevent defaults if this is a tap gesture\n                    var isTapPointer = input.pointers.length === 1;\n                    var isTapMovement = input.distance < 2;\n                    var isTapTouchTime = input.deltaTime < 250;\n                    if (isTapPointer && isTapMovement && isTapTouchTime) {\n                        return;\n                    }\n                }\n                if (hasPanX && hasPanY) {\n                    // `pan-x pan-y` means browser handles all scrolling/panning, do not prevent\n                    return;\n                }\n                if (hasNone ||\n                    (hasPanY && direction & DIRECTION_HORIZONTAL) ||\n                    (hasPanX && direction & DIRECTION_VERTICAL)) {\n                    return this.preventSrc(srcEvent);\n                }\n            },\n            /**\n             * call preventDefault to prevent the browser's default behavior (scrolling in most cases)\n             * @param {Object} srcEvent\n             */\n            preventSrc: function (srcEvent) {\n                this.manager.session.prevented = true;\n                srcEvent.preventDefault();\n            }\n        };\n        /**\n         * when the touchActions are collected they are not a valid value, so we need to clean things up. *\n         * @param {String} actions\n         * @returns {*}\n         */\n        function cleanTouchActions(actions) {\n            // none\n            if (inStr(actions, TOUCH_ACTION_NONE)) {\n                return TOUCH_ACTION_NONE;\n            }\n            var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);\n            var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y);\n            // if both pan-x and pan-y are set (different recognizers\n            // for different directions, e.g. horizontal pan but vertical swipe?)\n            // we need none (as otherwise with pan-x pan-y combined none of these\n            // recognizers will work, since the browser would handle all panning\n            if (hasPanX && hasPanY) {\n                return TOUCH_ACTION_NONE;\n            }\n            // pan-x OR pan-y\n            if (hasPanX || hasPanY) {\n                return hasPanX ? TOUCH_ACTION_PAN_X : TOUCH_ACTION_PAN_Y;\n            }\n            // manipulation\n            if (inStr(actions, TOUCH_ACTION_MANIPULATION)) {\n                return TOUCH_ACTION_MANIPULATION;\n            }\n            return TOUCH_ACTION_AUTO;\n        }\n        function getTouchActionProps() {\n            if (!NATIVE_TOUCH_ACTION) {\n                return false;\n            }\n            var touchMap = {};\n            var cssSupports = window.CSS && window.CSS.supports;\n            ['auto', 'manipulation', 'pan-y', 'pan-x', 'pan-x pan-y', 'none'].forEach(function (val) {\n                // If css.supports is not supported but there is native touch-action assume it supports\n                // all values. This is the case for IE 10 and 11.\n                touchMap[val] = cssSupports ? window.CSS.supports('touch-action', val) : true;\n            });\n            return touchMap;\n        }\n        /**\n         * Recognizer flow explained; *\n         * All recognizers have the initial state of POSSIBLE when a input session starts.\n         * The definition of a input session is from the first input until the last input, with all it's movement in it. *\n         * Example session for mouse-input: mousedown -> mousemove -> mouseup\n         *\n         * On each recognizing cycle (see Manager.recognize) the .recognize() method is executed\n         * which determines with state it should be.\n         *\n         * If the recognizer has the state FAILED, CANCELLED or RECOGNIZED (equals ENDED), it is reset to\n         * POSSIBLE to give it another change on the next cycle.\n         *\n         *               Possible\n         *                  |\n         *            +-----+---------------+\n         *            |                     |\n         *      +-----+-----+               |\n         *      |           |               |\n         *   Failed      Cancelled          |\n         *                          +-------+------+\n         *                          |              |\n         *                      Recognized       Began\n         *                                         |\n         *                                      Changed\n         *                                         |\n         *                                  Ended/Recognized\n         */\n        var STATE_POSSIBLE = 1;\n        var STATE_BEGAN = 2;\n        var STATE_CHANGED = 4;\n        var STATE_ENDED = 8;\n        var STATE_RECOGNIZED = STATE_ENDED;\n        var STATE_CANCELLED = 16;\n        var STATE_FAILED = 32;\n        /**\n         * Recognizer\n         * Every recognizer needs to extend from this class.\n         * @constructor\n         * @param {Object} options\n         */\n        function Recognizer(options) {\n            this.options = assign({}, this.defaults, options || {});\n            this.id = uniqueId();\n            this.manager = null;\n            // default is enable true\n            this.options.enable = ifUndefined(this.options.enable, true);\n            this.state = STATE_POSSIBLE;\n            this.simultaneous = {};\n            this.requireFail = [];\n        }\n        Recognizer.prototype = {\n            /**\n             * @virtual\n             * @type {Object}\n             */\n            defaults: {},\n            /**\n             * set options\n             * @param {Object} options\n             * @return {Recognizer}\n             */\n            set: function (options) {\n                assign(this.options, options);\n                // also update the touchAction, in case something changed about the directions/enabled state\n                this.manager && this.manager.touchAction.update();\n                return this;\n            },\n            /**\n             * recognize simultaneous with an other recognizer.\n             * @param {Recognizer} otherRecognizer\n             * @returns {Recognizer} this\n             */\n            recognizeWith: function (otherRecognizer) {\n                if (invokeArrayArg(otherRecognizer, 'recognizeWith', this)) {\n                    return this;\n                }\n                var simultaneous = this.simultaneous;\n                otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n                if (!simultaneous[otherRecognizer.id]) {\n                    simultaneous[otherRecognizer.id] = otherRecognizer;\n                    otherRecognizer.recognizeWith(this);\n                }\n                return this;\n            },\n            /**\n             * drop the simultaneous link. it doesnt remove the link on the other recognizer.\n             * @param {Recognizer} otherRecognizer\n             * @returns {Recognizer} this\n             */\n            dropRecognizeWith: function (otherRecognizer) {\n                if (invokeArrayArg(otherRecognizer, 'dropRecognizeWith', this)) {\n                    return this;\n                }\n                otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n                delete this.simultaneous[otherRecognizer.id];\n                return this;\n            },\n            /**\n             * recognizer can only run when an other is failing\n             * @param {Recognizer} otherRecognizer\n             * @returns {Recognizer} this\n             */\n            requireFailure: function (otherRecognizer) {\n                if (invokeArrayArg(otherRecognizer, 'requireFailure', this)) {\n                    return this;\n                }\n                var requireFail = this.requireFail;\n                otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n                if (inArray(requireFail, otherRecognizer) === -1) {\n                    requireFail.push(otherRecognizer);\n                    otherRecognizer.requireFailure(this);\n                }\n                return this;\n            },\n            /**\n             * drop the requireFailure link. it does not remove the link on the other recognizer.\n             * @param {Recognizer} otherRecognizer\n             * @returns {Recognizer} this\n             */\n            dropRequireFailure: function (otherRecognizer) {\n                if (invokeArrayArg(otherRecognizer, 'dropRequireFailure', this)) {\n                    return this;\n                }\n                otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n                var index = inArray(this.requireFail, otherRecognizer);\n                if (index > -1) {\n                    this.requireFail.splice(index, 1);\n                }\n                return this;\n            },\n            /**\n             * has require failures boolean\n             * @returns {boolean}\n             */\n            hasRequireFailures: function () {\n                return this.requireFail.length > 0;\n            },\n            /**\n             * if the recognizer can recognize simultaneous with an other recognizer\n             * @param {Recognizer} otherRecognizer\n             * @returns {Boolean}\n             */\n            canRecognizeWith: function (otherRecognizer) {\n                return !!this.simultaneous[otherRecognizer.id];\n            },\n            /**\n             * You should use `tryEmit` instead of `emit` directly to check\n             * that all the needed recognizers has failed before emitting.\n             * @param {Object} input\n             */\n            emit: function (input) {\n                var self = this;\n                var state = this.state;\n                function emit(event) {\n                    self.manager.emit(event, input);\n                }\n                // 'panstart' and 'panmove'\n                if (state < STATE_ENDED) {\n                    emit(self.options.event + stateStr(state));\n                }\n                emit(self.options.event); // simple 'eventName' events\n                if (input.additionalEvent) { // additional event(panleft, panright, pinchin, pinchout...)\n                    emit(input.additionalEvent);\n                }\n                // panend and pancancel\n                if (state >= STATE_ENDED) {\n                    emit(self.options.event + stateStr(state));\n                }\n            },\n            /**\n             * Check that all the require failure recognizers has failed,\n             * if true, it emits a gesture event,\n             * otherwise, setup the state to FAILED.\n             * @param {Object} input\n             */\n            tryEmit: function (input) {\n                if (this.canEmit()) {\n                    return this.emit(input);\n                }\n                // it's failing anyway\n                this.state = STATE_FAILED;\n            },\n            /**\n             * can we emit?\n             * @returns {boolean}\n             */\n            canEmit: function () {\n                var i = 0;\n                while (i < this.requireFail.length) {\n                    if (!(this.requireFail[i].state & (STATE_FAILED | STATE_POSSIBLE))) {\n                        return false;\n                    }\n                    i++;\n                }\n                return true;\n            },\n            /**\n             * update the recognizer\n             * @param {Object} inputData\n             */\n            recognize: function (inputData) {\n                // make a new copy of the inputData\n                // so we can change the inputData without messing up the other recognizers\n                var inputDataClone = assign({}, inputData);\n                // is is enabled and allow recognizing?\n                if (!boolOrFn(this.options.enable, [this, inputDataClone])) {\n                    this.reset();\n                    this.state = STATE_FAILED;\n                    return;\n                }\n                // reset when we've reached the end\n                if (this.state & (STATE_RECOGNIZED | STATE_CANCELLED | STATE_FAILED)) {\n                    this.state = STATE_POSSIBLE;\n                }\n                this.state = this.process(inputDataClone);\n                // the recognizer has recognized a gesture\n                // so trigger an event\n                if (this.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED | STATE_CANCELLED)) {\n                    this.tryEmit(inputDataClone);\n                }\n            },\n            /**\n             * return the state of the recognizer\n             * the actual recognizing happens in this method\n             * @virtual\n             * @param {Object} inputData\n             * @returns {Const} STATE\n             */\n            process: function (inputData) { },\n            /**\n             * return the preferred touch-action\n             * @virtual\n             * @returns {Array}\n             */\n            getTouchAction: function () { },\n            /**\n             * called when the gesture isn't allowed to recognize\n             * like when another is being recognized or it is disabled\n             * @virtual\n             */\n            reset: function () { }\n        };\n        /**\n         * get a usable string, used as event postfix\n         * @param {Const} state\n         * @returns {String} state\n         */\n        function stateStr(state) {\n            if (state & STATE_CANCELLED) {\n                return 'cancel';\n            }\n            else if (state & STATE_ENDED) {\n                return 'end';\n            }\n            else if (state & STATE_CHANGED) {\n                return 'move';\n            }\n            else if (state & STATE_BEGAN) {\n                return 'start';\n            }\n            return '';\n        }\n        /**\n         * direction cons to string\n         * @param {Const} direction\n         * @returns {String}\n         */\n        function directionStr(direction) {\n            if (direction == DIRECTION_DOWN) {\n                return 'down';\n            }\n            else if (direction == DIRECTION_UP) {\n                return 'up';\n            }\n            else if (direction == DIRECTION_LEFT) {\n                return 'left';\n            }\n            else if (direction == DIRECTION_RIGHT) {\n                return 'right';\n            }\n            return '';\n        }\n        /**\n         * get a recognizer by name if it is bound to a manager\n         * @param {Recognizer|String} otherRecognizer\n         * @param {Recognizer} recognizer\n         * @returns {Recognizer}\n         */\n        function getRecognizerByNameIfManager(otherRecognizer, recognizer) {\n            var manager = recognizer.manager;\n            if (manager) {\n                return manager.get(otherRecognizer);\n            }\n            return otherRecognizer;\n        }\n        /**\n         * This recognizer is just used as a base for the simple attribute recognizers.\n         * @constructor\n         * @extends Recognizer\n         */\n        function AttrRecognizer() {\n            Recognizer.apply(this, arguments);\n        }\n        inherit(AttrRecognizer, Recognizer, {\n            /**\n             * @namespace\n             * @memberof AttrRecognizer\n             */\n            defaults: {\n                /**\n                 * @type {Number}\n                 * @default 1\n                 */\n                pointers: 1\n            },\n            /**\n             * Used to check if it the recognizer receives valid input, like input.distance > 10.\n             * @memberof AttrRecognizer\n             * @param {Object} input\n             * @returns {Boolean} recognized\n             */\n            attrTest: function (input) {\n                var optionPointers = this.options.pointers;\n                return optionPointers === 0 || input.pointers.length === optionPointers;\n            },\n            /**\n             * Process the input and return the state for the recognizer\n             * @memberof AttrRecognizer\n             * @param {Object} input\n             * @returns {*} State\n             */\n            process: function (input) {\n                var state = this.state;\n                var eventType = input.eventType;\n                var isRecognized = state & (STATE_BEGAN | STATE_CHANGED);\n                var isValid = this.attrTest(input);\n                // on cancel input and we've recognized before, return STATE_CANCELLED\n                if (isRecognized && (eventType & INPUT_CANCEL || !isValid)) {\n                    return state | STATE_CANCELLED;\n                }\n                else if (isRecognized || isValid) {\n                    if (eventType & INPUT_END) {\n                        return state | STATE_ENDED;\n                    }\n                    else if (!(state & STATE_BEGAN)) {\n                        return STATE_BEGAN;\n                    }\n                    return state | STATE_CHANGED;\n                }\n                return STATE_FAILED;\n            }\n        });\n        /**\n         * Pan\n         * Recognized when the pointer is down and moved in the allowed direction.\n         * @constructor\n         * @extends AttrRecognizer\n         */\n        function PanRecognizer() {\n            AttrRecognizer.apply(this, arguments);\n            this.pX = null;\n            this.pY = null;\n        }\n        inherit(PanRecognizer, AttrRecognizer, {\n            /**\n             * @namespace\n             * @memberof PanRecognizer\n             */\n            defaults: {\n                event: 'pan',\n                threshold: 10,\n                pointers: 1,\n                direction: DIRECTION_ALL\n            },\n            getTouchAction: function () {\n                var direction = this.options.direction;\n                var actions = [];\n                if (direction & DIRECTION_HORIZONTAL) {\n                    actions.push(TOUCH_ACTION_PAN_Y);\n                }\n                if (direction & DIRECTION_VERTICAL) {\n                    actions.push(TOUCH_ACTION_PAN_X);\n                }\n                return actions;\n            },\n            directionTest: function (input) {\n                var options = this.options;\n                var hasMoved = true;\n                var distance = input.distance;\n                var direction = input.direction;\n                var x = input.deltaX;\n                var y = input.deltaY;\n                // lock to axis?\n                if (!(direction & options.direction)) {\n                    if (options.direction & DIRECTION_HORIZONTAL) {\n                        direction = (x === 0) ? DIRECTION_NONE : (x < 0) ? DIRECTION_LEFT : DIRECTION_RIGHT;\n                        hasMoved = x != this.pX;\n                        distance = Math.abs(input.deltaX);\n                    }\n                    else {\n                        direction = (y === 0) ? DIRECTION_NONE : (y < 0) ? DIRECTION_UP : DIRECTION_DOWN;\n                        hasMoved = y != this.pY;\n                        distance = Math.abs(input.deltaY);\n                    }\n                }\n                input.direction = direction;\n                return hasMoved && distance > options.threshold && direction & options.direction;\n            },\n            attrTest: function (input) {\n                return AttrRecognizer.prototype.attrTest.call(this, input) &&\n                    (this.state & STATE_BEGAN || (!(this.state & STATE_BEGAN) && this.directionTest(input)));\n            },\n            emit: function (input) {\n                this.pX = input.deltaX;\n                this.pY = input.deltaY;\n                var direction = directionStr(input.direction);\n                if (direction) {\n                    input.additionalEvent = this.options.event + direction;\n                }\n                this._super.emit.call(this, input);\n            }\n        });\n        /**\n         * Pinch\n         * Recognized when two or more pointers are moving toward (zoom-in) or away from each other (zoom-out).\n         * @constructor\n         * @extends AttrRecognizer\n         */\n        function PinchRecognizer() {\n            AttrRecognizer.apply(this, arguments);\n        }\n        inherit(PinchRecognizer, AttrRecognizer, {\n            /**\n             * @namespace\n             * @memberof PinchRecognizer\n             */\n            defaults: {\n                event: 'pinch',\n                threshold: 0,\n                pointers: 2\n            },\n            getTouchAction: function () {\n                return [TOUCH_ACTION_NONE];\n            },\n            attrTest: function (input) {\n                return this._super.attrTest.call(this, input) &&\n                    (Math.abs(input.scale - 1) > this.options.threshold || this.state & STATE_BEGAN);\n            },\n            emit: function (input) {\n                if (input.scale !== 1) {\n                    var inOut = input.scale < 1 ? 'in' : 'out';\n                    input.additionalEvent = this.options.event + inOut;\n                }\n                this._super.emit.call(this, input);\n            }\n        });\n        /**\n         * Press\n         * Recognized when the pointer is down for x ms without any movement.\n         * @constructor\n         * @extends Recognizer\n         */\n        function PressRecognizer() {\n            Recognizer.apply(this, arguments);\n            this._timer = null;\n            this._input = null;\n        }\n        inherit(PressRecognizer, Recognizer, {\n            /**\n             * @namespace\n             * @memberof PressRecognizer\n             */\n            defaults: {\n                event: 'press',\n                pointers: 1,\n                time: 251,\n                threshold: 9 // a minimal movement is ok, but keep it low\n            },\n            getTouchAction: function () {\n                return [TOUCH_ACTION_AUTO];\n            },\n            process: function (input) {\n                var options = this.options;\n                var validPointers = input.pointers.length === options.pointers;\n                var validMovement = input.distance < options.threshold;\n                var validTime = input.deltaTime > options.time;\n                this._input = input;\n                // we only allow little movement\n                // and we've reached an end event, so a tap is possible\n                if (!validMovement || !validPointers || (input.eventType & (INPUT_END | INPUT_CANCEL) && !validTime)) {\n                    this.reset();\n                }\n                else if (input.eventType & INPUT_START) {\n                    this.reset();\n                    this._timer = setTimeoutContext(function () {\n                        this.state = STATE_RECOGNIZED;\n                        this.tryEmit();\n                    }, options.time, this);\n                }\n                else if (input.eventType & INPUT_END) {\n                    return STATE_RECOGNIZED;\n                }\n                return STATE_FAILED;\n            },\n            reset: function () {\n                clearTimeout(this._timer);\n            },\n            emit: function (input) {\n                if (this.state !== STATE_RECOGNIZED) {\n                    return;\n                }\n                if (input && (input.eventType & INPUT_END)) {\n                    this.manager.emit(this.options.event + 'up', input);\n                }\n                else {\n                    this._input.timeStamp = now();\n                    this.manager.emit(this.options.event, this._input);\n                }\n            }\n        });\n        /**\n         * Rotate\n         * Recognized when two or more pointer are moving in a circular motion.\n         * @constructor\n         * @extends AttrRecognizer\n         */\n        function RotateRecognizer() {\n            AttrRecognizer.apply(this, arguments);\n        }\n        inherit(RotateRecognizer, AttrRecognizer, {\n            /**\n             * @namespace\n             * @memberof RotateRecognizer\n             */\n            defaults: {\n                event: 'rotate',\n                threshold: 0,\n                pointers: 2\n            },\n            getTouchAction: function () {\n                return [TOUCH_ACTION_NONE];\n            },\n            attrTest: function (input) {\n                return this._super.attrTest.call(this, input) &&\n                    (Math.abs(input.rotation) > this.options.threshold || this.state & STATE_BEGAN);\n            }\n        });\n        /**\n         * Swipe\n         * Recognized when the pointer is moving fast (velocity), with enough distance in the allowed direction.\n         * @constructor\n         * @extends AttrRecognizer\n         */\n        function SwipeRecognizer() {\n            AttrRecognizer.apply(this, arguments);\n        }\n        inherit(SwipeRecognizer, AttrRecognizer, {\n            /**\n             * @namespace\n             * @memberof SwipeRecognizer\n             */\n            defaults: {\n                event: 'swipe',\n                threshold: 10,\n                velocity: 0.3,\n                direction: DIRECTION_HORIZONTAL | DIRECTION_VERTICAL,\n                pointers: 1\n            },\n            getTouchAction: function () {\n                return PanRecognizer.prototype.getTouchAction.call(this);\n            },\n            attrTest: function (input) {\n                var direction = this.options.direction;\n                var velocity;\n                if (direction & (DIRECTION_HORIZONTAL | DIRECTION_VERTICAL)) {\n                    velocity = input.overallVelocity;\n                }\n                else if (direction & DIRECTION_HORIZONTAL) {\n                    velocity = input.overallVelocityX;\n                }\n                else if (direction & DIRECTION_VERTICAL) {\n                    velocity = input.overallVelocityY;\n                }\n                return this._super.attrTest.call(this, input) &&\n                    direction & input.offsetDirection &&\n                    input.distance > this.options.threshold &&\n                    input.maxPointers == this.options.pointers &&\n                    abs(velocity) > this.options.velocity && input.eventType & INPUT_END;\n            },\n            emit: function (input) {\n                var direction = directionStr(input.offsetDirection);\n                if (direction) {\n                    this.manager.emit(this.options.event + direction, input);\n                }\n                this.manager.emit(this.options.event, input);\n            }\n        });\n        /**\n         * A tap is ecognized when the pointer is doing a small tap/click. Multiple taps are recognized if they occur\n         * between the given interval and position. The delay option can be used to recognize multi-taps without firing\n         * a single tap.\n         *\n         * The eventData from the emitted event contains the property `tapCount`, which contains the amount of\n         * multi-taps being recognized.\n         * @constructor\n         * @extends Recognizer\n         */\n        function TapRecognizer() {\n            Recognizer.apply(this, arguments);\n            // previous time and center,\n            // used for tap counting\n            this.pTime = false;\n            this.pCenter = false;\n            this._timer = null;\n            this._input = null;\n            this.count = 0;\n        }\n        inherit(TapRecognizer, Recognizer, {\n            /**\n             * @namespace\n             * @memberof PinchRecognizer\n             */\n            defaults: {\n                event: 'tap',\n                pointers: 1,\n                taps: 1,\n                interval: 300,\n                time: 250,\n                threshold: 9,\n                posThreshold: 10 // a multi-tap can be a bit off the initial position\n            },\n            getTouchAction: function () {\n                return [TOUCH_ACTION_MANIPULATION];\n            },\n            process: function (input) {\n                var options = this.options;\n                var validPointers = input.pointers.length === options.pointers;\n                var validMovement = input.distance < options.threshold;\n                var validTouchTime = input.deltaTime < options.time;\n                this.reset();\n                if ((input.eventType & INPUT_START) && (this.count === 0)) {\n                    return this.failTimeout();\n                }\n                // we only allow little movement\n                // and we've reached an end event, so a tap is possible\n                if (validMovement && validTouchTime && validPointers) {\n                    if (input.eventType != INPUT_END) {\n                        return this.failTimeout();\n                    }\n                    var validInterval = this.pTime ? (input.timeStamp - this.pTime < options.interval) : true;\n                    var validMultiTap = !this.pCenter || getDistance(this.pCenter, input.center) < options.posThreshold;\n                    this.pTime = input.timeStamp;\n                    this.pCenter = input.center;\n                    if (!validMultiTap || !validInterval) {\n                        this.count = 1;\n                    }\n                    else {\n                        this.count += 1;\n                    }\n                    this._input = input;\n                    // if tap count matches we have recognized it,\n                    // else it has began recognizing...\n                    var tapCount = this.count % options.taps;\n                    if (tapCount === 0) {\n                        // no failing requirements, immediately trigger the tap event\n                        // or wait as long as the multitap interval to trigger\n                        if (!this.hasRequireFailures()) {\n                            return STATE_RECOGNIZED;\n                        }\n                        else {\n                            this._timer = setTimeoutContext(function () {\n                                this.state = STATE_RECOGNIZED;\n                                this.tryEmit();\n                            }, options.interval, this);\n                            return STATE_BEGAN;\n                        }\n                    }\n                }\n                return STATE_FAILED;\n            },\n            failTimeout: function () {\n                this._timer = setTimeoutContext(function () {\n                    this.state = STATE_FAILED;\n                }, this.options.interval, this);\n                return STATE_FAILED;\n            },\n            reset: function () {\n                clearTimeout(this._timer);\n            },\n            emit: function () {\n                if (this.state == STATE_RECOGNIZED) {\n                    this._input.tapCount = this.count;\n                    this.manager.emit(this.options.event, this._input);\n                }\n            }\n        });\n        /**\n         * Simple way to create a manager with a default set of recognizers.\n         * @param {HTMLElement} element\n         * @param {Object} [options]\n         * @constructor\n         */\n        function Hammer(element, options) {\n            options = options || {};\n            options.recognizers = ifUndefined(options.recognizers, Hammer.defaults.preset);\n            return new Manager(element, options);\n        }\n        /**\n         * @const {string}\n         */\n        Hammer.VERSION = '2.0.7';\n        /**\n         * default settings\n         * @namespace\n         */\n        Hammer.defaults = {\n            /**\n             * set if DOM events are being triggered.\n             * But this is slower and unused by simple implementations, so disabled by default.\n             * @type {Boolean}\n             * @default false\n             */\n            domEvents: false,\n            /**\n             * The value for the touchAction property/fallback.\n             * When set to `compute` it will magically set the correct value based on the added recognizers.\n             * @type {String}\n             * @default compute\n             */\n            touchAction: TOUCH_ACTION_COMPUTE,\n            /**\n             * @type {Boolean}\n             * @default true\n             */\n            enable: true,\n            /**\n             * EXPERIMENTAL FEATURE -- can be removed/changed\n             * Change the parent input target element.\n             * If Null, then it is being set the to main element.\n             * @type {Null|EventTarget}\n             * @default null\n             */\n            inputTarget: null,\n            /**\n             * force an input class\n             * @type {Null|Function}\n             * @default null\n             */\n            inputClass: null,\n            /**\n             * Default recognizer setup when calling `Hammer()`\n             * When creating a new Manager these will be skipped.\n             * @type {Array}\n             */\n            preset: [\n                // RecognizerClass, options, [recognizeWith, ...], [requireFailure, ...]\n                [RotateRecognizer, { enable: false }],\n                [PinchRecognizer, { enable: false }, ['rotate']],\n                [SwipeRecognizer, { direction: DIRECTION_HORIZONTAL }],\n                [PanRecognizer, { direction: DIRECTION_HORIZONTAL }, ['swipe']],\n                [TapRecognizer],\n                [TapRecognizer, { event: 'doubletap', taps: 2 }, ['tap']],\n                [PressRecognizer]\n            ],\n            /**\n             * Some CSS properties can be used to improve the working of Hammer.\n             * Add them to this method and they will be set when creating a new Manager.\n             * @namespace\n             */\n            cssProps: {\n                /**\n                 * Disables text selection to improve the dragging gesture. Mainly for desktop browsers.\n                 * @type {String}\n                 * @default 'none'\n                 */\n                userSelect: 'none',\n                /**\n                 * Disable the Windows Phone grippers when pressing an element.\n                 * @type {String}\n                 * @default 'none'\n                 */\n                touchSelect: 'none',\n                /**\n                 * Disables the default callout shown when you touch and hold a touch target.\n                 * On iOS, when you touch and hold a touch target such as a link, Safari displays\n                 * a callout containing information about the link. This property allows you to disable that callout.\n                 * @type {String}\n                 * @default 'none'\n                 */\n                touchCallout: 'none',\n                /**\n                 * Specifies whether zooming is enabled. Used by IE10>\n                 * @type {String}\n                 * @default 'none'\n                 */\n                contentZooming: 'none',\n                /**\n                 * Specifies that an entire element should be draggable instead of its contents. Mainly for desktop browsers.\n                 * @type {String}\n                 * @default 'none'\n                 */\n                userDrag: 'none',\n                /**\n                 * Overrides the highlight color shown when the user taps a link or a JavaScript\n                 * clickable element in iOS. This property obeys the alpha value, if specified.\n                 * @type {String}\n                 * @default 'rgba(0,0,0,0)'\n                 */\n                tapHighlightColor: 'rgba(0,0,0,0)'\n            }\n        };\n        var STOP = 1;\n        var FORCED_STOP = 2;\n        /**\n         * Manager\n         * @param {HTMLElement} element\n         * @param {Object} [options]\n         * @constructor\n         */\n        function Manager(element, options) {\n            this.options = assign({}, Hammer.defaults, options || {});\n            this.options.inputTarget = this.options.inputTarget || element;\n            this.handlers = {};\n            this.session = {};\n            this.recognizers = [];\n            this.oldCssProps = {};\n            this.element = element;\n            this.input = createInputInstance(this);\n            this.touchAction = new TouchAction(this, this.options.touchAction);\n            toggleCssProps(this, true);\n            each(this.options.recognizers, function (item) {\n                var recognizer = this.add(new (item[0])(item[1]));\n                item[2] && recognizer.recognizeWith(item[2]);\n                item[3] && recognizer.requireFailure(item[3]);\n            }, this);\n        }\n        Manager.prototype = {\n            /**\n             * set options\n             * @param {Object} options\n             * @returns {Manager}\n             */\n            set: function (options) {\n                assign(this.options, options);\n                // Options that need a little more setup\n                if (options.touchAction) {\n                    this.touchAction.update();\n                }\n                if (options.inputTarget) {\n                    // Clean up existing event listeners and reinitialize\n                    this.input.destroy();\n                    this.input.target = options.inputTarget;\n                    this.input.init();\n                }\n                return this;\n            },\n            /**\n             * stop recognizing for this session.\n             * This session will be discarded, when a new [input]start event is fired.\n             * When forced, the recognizer cycle is stopped immediately.\n             * @param {Boolean} [force]\n             */\n            stop: function (force) {\n                this.session.stopped = force ? FORCED_STOP : STOP;\n            },\n            /**\n             * run the recognizers!\n             * called by the inputHandler function on every movement of the pointers (touches)\n             * it walks through all the recognizers and tries to detect the gesture that is being made\n             * @param {Object} inputData\n             */\n            recognize: function (inputData) {\n                var session = this.session;\n                if (session.stopped) {\n                    return;\n                }\n                // run the touch-action polyfill\n                this.touchAction.preventDefaults(inputData);\n                var recognizer;\n                var recognizers = this.recognizers;\n                // this holds the recognizer that is being recognized.\n                // so the recognizer's state needs to be BEGAN, CHANGED, ENDED or RECOGNIZED\n                // if no recognizer is detecting a thing, it is set to `null`\n                var curRecognizer = session.curRecognizer;\n                // reset when the last recognizer is recognized\n                // or when we're in a new session\n                if (!curRecognizer || (curRecognizer && curRecognizer.state & STATE_RECOGNIZED)) {\n                    curRecognizer = session.curRecognizer = null;\n                }\n                var i = 0;\n                while (i < recognizers.length) {\n                    recognizer = recognizers[i];\n                    // find out if we are allowed try to recognize the input for this one.\n                    // 1.   allow if the session is NOT forced stopped (see the .stop() method)\n                    // 2.   allow if we still haven't recognized a gesture in this session, or the this recognizer is the one\n                    //      that is being recognized.\n                    // 3.   allow if the recognizer is allowed to run simultaneous with the current recognized recognizer.\n                    //      this can be setup with the `recognizeWith()` method on the recognizer.\n                    if (session.stopped !== FORCED_STOP && ( // 1\n                    !curRecognizer || recognizer == curRecognizer || // 2\n                        recognizer.canRecognizeWith(curRecognizer))) { // 3\n                        recognizer.recognize(inputData);\n                    }\n                    else {\n                        recognizer.reset();\n                    }\n                    // if the recognizer has been recognizing the input as a valid gesture, we want to store this one as the\n                    // current active recognizer. but only if we don't already have an active recognizer\n                    if (!curRecognizer && recognizer.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED)) {\n                        curRecognizer = session.curRecognizer = recognizer;\n                    }\n                    i++;\n                }\n            },\n            /**\n             * get a recognizer by its event name.\n             * @param {Recognizer|String} recognizer\n             * @returns {Recognizer|Null}\n             */\n            get: function (recognizer) {\n                if (recognizer instanceof Recognizer) {\n                    return recognizer;\n                }\n                var recognizers = this.recognizers;\n                for (var i = 0; i < recognizers.length; i++) {\n                    if (recognizers[i].options.event == recognizer) {\n                        return recognizers[i];\n                    }\n                }\n                return null;\n            },\n            /**\n             * add a recognizer to the manager\n             * existing recognizers with the same event name will be removed\n             * @param {Recognizer} recognizer\n             * @returns {Recognizer|Manager}\n             */\n            add: function (recognizer) {\n                if (invokeArrayArg(recognizer, 'add', this)) {\n                    return this;\n                }\n                // remove existing\n                var existing = this.get(recognizer.options.event);\n                if (existing) {\n                    this.remove(existing);\n                }\n                this.recognizers.push(recognizer);\n                recognizer.manager = this;\n                this.touchAction.update();\n                return recognizer;\n            },\n            /**\n             * remove a recognizer by name or instance\n             * @param {Recognizer|String} recognizer\n             * @returns {Manager}\n             */\n            remove: function (recognizer) {\n                if (invokeArrayArg(recognizer, 'remove', this)) {\n                    return this;\n                }\n                recognizer = this.get(recognizer);\n                // let's make sure this recognizer exists\n                if (recognizer) {\n                    var recognizers = this.recognizers;\n                    var index = inArray(recognizers, recognizer);\n                    if (index !== -1) {\n                        recognizers.splice(index, 1);\n                        this.touchAction.update();\n                    }\n                }\n                return this;\n            },\n            /**\n             * bind event\n             * @param {String} events\n             * @param {Function} handler\n             * @returns {EventEmitter} this\n             */\n            on: function (events, handler) {\n                if (events === undefined) {\n                    return;\n                }\n                if (handler === undefined) {\n                    return;\n                }\n                var handlers = this.handlers;\n                each(splitStr(events), function (event) {\n                    handlers[event] = handlers[event] || [];\n                    handlers[event].push(handler);\n                });\n                return this;\n            },\n            /**\n             * unbind event, leave emit blank to remove all handlers\n             * @param {String} events\n             * @param {Function} [handler]\n             * @returns {EventEmitter} this\n             */\n            off: function (events, handler) {\n                if (events === undefined) {\n                    return;\n                }\n                var handlers = this.handlers;\n                each(splitStr(events), function (event) {\n                    if (!handler) {\n                        delete handlers[event];\n                    }\n                    else {\n                        handlers[event] && handlers[event].splice(inArray(handlers[event], handler), 1);\n                    }\n                });\n                return this;\n            },\n            /**\n             * emit event to the listeners\n             * @param {String} event\n             * @param {Object} data\n             */\n            emit: function (event, data) {\n                // we also want to trigger dom events\n                if (this.options.domEvents) {\n                    triggerDomEvent(event, data);\n                }\n                // no handlers, so skip it all\n                var handlers = this.handlers[event] && this.handlers[event].slice();\n                if (!handlers || !handlers.length) {\n                    return;\n                }\n                data.type = event;\n                data.preventDefault = function () {\n                    data.srcEvent.preventDefault();\n                };\n                var i = 0;\n                while (i < handlers.length) {\n                    handlers[i](data);\n                    i++;\n                }\n            },\n            /**\n             * destroy the manager and unbinds all events\n             * it doesn't unbind dom events, that is the user own responsibility\n             */\n            destroy: function () {\n                this.element && toggleCssProps(this, false);\n                this.handlers = {};\n                this.session = {};\n                this.input.destroy();\n                this.element = null;\n            }\n        };\n        /**\n         * add/remove the css properties as defined in manager.options.cssProps\n         * @param {Manager} manager\n         * @param {Boolean} add\n         */\n        function toggleCssProps(manager, add) {\n            var element = manager.element;\n            if (!element.style) {\n                return;\n            }\n            var prop;\n            each(manager.options.cssProps, function (value, name) {\n                prop = prefixed(element.style, name);\n                if (add) {\n                    manager.oldCssProps[prop] = element.style[prop];\n                    element.style[prop] = value;\n                }\n                else {\n                    element.style[prop] = manager.oldCssProps[prop] || '';\n                }\n            });\n            if (!add) {\n                manager.oldCssProps = {};\n            }\n        }\n        /**\n         * trigger dom event\n         * @param {String} event\n         * @param {Object} data\n         */\n        function triggerDomEvent(event, data) {\n            var gestureEvent = document.createEvent('Event');\n            gestureEvent.initEvent(event, true, true);\n            gestureEvent.gesture = data;\n            data.target.dispatchEvent(gestureEvent);\n        }\n        assign(Hammer, {\n            INPUT_START: INPUT_START,\n            INPUT_MOVE: INPUT_MOVE,\n            INPUT_END: INPUT_END,\n            INPUT_CANCEL: INPUT_CANCEL,\n            STATE_POSSIBLE: STATE_POSSIBLE,\n            STATE_BEGAN: STATE_BEGAN,\n            STATE_CHANGED: STATE_CHANGED,\n            STATE_ENDED: STATE_ENDED,\n            STATE_RECOGNIZED: STATE_RECOGNIZED,\n            STATE_CANCELLED: STATE_CANCELLED,\n            STATE_FAILED: STATE_FAILED,\n            DIRECTION_NONE: DIRECTION_NONE,\n            DIRECTION_LEFT: DIRECTION_LEFT,\n            DIRECTION_RIGHT: DIRECTION_RIGHT,\n            DIRECTION_UP: DIRECTION_UP,\n            DIRECTION_DOWN: DIRECTION_DOWN,\n            DIRECTION_HORIZONTAL: DIRECTION_HORIZONTAL,\n            DIRECTION_VERTICAL: DIRECTION_VERTICAL,\n            DIRECTION_ALL: DIRECTION_ALL,\n            Manager: Manager,\n            Input: Input,\n            TouchAction: TouchAction,\n            TouchInput: TouchInput,\n            MouseInput: MouseInput,\n            PointerEventInput: PointerEventInput,\n            TouchMouseInput: TouchMouseInput,\n            SingleTouchInput: SingleTouchInput,\n            Recognizer: Recognizer,\n            AttrRecognizer: AttrRecognizer,\n            Tap: TapRecognizer,\n            Pan: PanRecognizer,\n            Swipe: SwipeRecognizer,\n            Pinch: PinchRecognizer,\n            Rotate: RotateRecognizer,\n            Press: PressRecognizer,\n            on: addEventListeners,\n            off: removeEventListeners,\n            each: each,\n            merge: merge,\n            extend: extend,\n            assign: assign,\n            inherit: inherit,\n            bindFn: bindFn,\n            prefixed: prefixed\n        });\n        // this prevents errors when Hammer is loaded in the presence of an AMD\n        //  style loader but by script tag, not by the loader.\n        var freeGlobal = (typeof window !== 'undefined' ? window : (typeof self !== 'undefined' ? self : {})); // jshint ignore:line\n        freeGlobal.Hammer = Hammer;\n        if (typeof define === 'function' && define.amd) {\n            define(function () {\n                return Hammer;\n            });\n        }\n        else if (typeof module != 'undefined' && module.exports) {\n            module.exports = Hammer;\n        }\n        else {\n            window[exportName] = Hammer;\n        }\n    })(window, document, 'Hammer');\n}\n","/* core/util/wheel.js */ function _(require, module, exports) {\n    function fontSize(element) {\n        const value = getComputedStyle(element).fontSize;\n        if (value != null)\n            return parseInt(value, 10);\n        return null;\n    }\n    function lineHeight(element) {\n        const parent = element.offsetParent || document.body;\n        return fontSize(parent) || fontSize(element) || 16;\n    }\n    function pageHeight(element) {\n        return element.clientHeight; // XXX: should be content height?\n    }\n    function getDeltaY(event) {\n        let deltaY = -event.deltaY;\n        if (event.target instanceof HTMLElement) {\n            switch (event.deltaMode) {\n                case event.DOM_DELTA_LINE:\n                    deltaY *= lineHeight(event.target);\n                    break;\n                case event.DOM_DELTA_PAGE:\n                    deltaY *= pageHeight(event.target);\n                    break;\n            }\n        }\n        return deltaY;\n    }\n    exports.getDeltaY = getDeltaY;\n}\n","/* models/plots/gmap_plot_canvas.js */ function _(require, module, exports) {\n    const signaling_1 = require(13) /* ../../core/signaling */;\n    const projections_1 = require(30) /* ../../core/util/projections */;\n    const plot_canvas_1 = require(273) /* ./plot_canvas */;\n    const gmaps_ready = new signaling_1.Signal0({}, \"gmaps_ready\");\n    const load_google_api = function (api_key) {\n        window._bokeh_gmaps_callback = () => gmaps_ready.emit();\n        const script = document.createElement('script');\n        script.type = 'text/javascript';\n        script.src = `https://maps.googleapis.com/maps/api/js?v=3.36&key=${api_key}&callback=_bokeh_gmaps_callback`;\n        document.body.appendChild(script);\n    };\n    class GMapPlotView extends plot_canvas_1.PlotView {\n        initialize() {\n            this.pause();\n            super.initialize();\n            this._tiles_loaded = false;\n            this.zoom_count = 0;\n            const { zoom, lat, lng } = this.model.map_options;\n            this.initial_zoom = zoom;\n            this.initial_lat = lat;\n            this.initial_lng = lng;\n            this.canvas_view.map_el.style.position = \"absolute\";\n            if (typeof google === \"undefined\" || google.maps == null) {\n                if (typeof window._bokeh_gmaps_callback === \"undefined\") {\n                    load_google_api(this.model.api_key);\n                }\n                gmaps_ready.connect(() => this.request_render());\n            }\n            this.unpause();\n        }\n        update_range(range_info) {\n            // RESET -------------------------\n            if (range_info == null) {\n                this.map.setCenter({ lat: this.initial_lat, lng: this.initial_lng });\n                this.map.setOptions({ zoom: this.initial_zoom });\n                super.update_range(null);\n                // PAN ----------------------------\n            }\n            else if (range_info.sdx != null || range_info.sdy != null) {\n                this.map.panBy(range_info.sdx || 0, range_info.sdy || 0);\n                super.update_range(range_info);\n                // ZOOM ---------------------------\n            }\n            else if (range_info.factor != null) {\n                // The zoom count decreases the sensitivity of the zoom. (We could make this user configurable)\n                let zoom_change;\n                if (this.zoom_count !== 10) {\n                    this.zoom_count += 1;\n                    return;\n                }\n                this.zoom_count = 0;\n                this.pause();\n                super.update_range(range_info);\n                if (range_info.factor < 0)\n                    zoom_change = -1;\n                else\n                    zoom_change = 1;\n                const old_map_zoom = this.map.getZoom();\n                const new_map_zoom = old_map_zoom + zoom_change;\n                // Zooming out too far causes problems\n                if (new_map_zoom >= 2) {\n                    this.map.setZoom(new_map_zoom);\n                    // Check we haven't gone out of bounds, and if we have undo the zoom\n                    const [proj_xstart, proj_xend, ,] = this._get_projected_bounds();\n                    if (proj_xend - proj_xstart < 0) {\n                        this.map.setZoom(old_map_zoom);\n                    }\n                }\n                this.unpause();\n            }\n            // Finally re-center\n            this._set_bokeh_ranges();\n        }\n        _build_map() {\n            const { maps } = google;\n            this.map_types = {\n                satellite: maps.MapTypeId.SATELLITE,\n                terrain: maps.MapTypeId.TERRAIN,\n                roadmap: maps.MapTypeId.ROADMAP,\n                hybrid: maps.MapTypeId.HYBRID,\n            };\n            const mo = this.model.map_options;\n            const map_options = {\n                center: new maps.LatLng(mo.lat, mo.lng),\n                zoom: mo.zoom,\n                disableDefaultUI: true,\n                mapTypeId: this.map_types[mo.map_type],\n                scaleControl: mo.scale_control,\n                tilt: mo.tilt,\n            };\n            if (mo.styles != null)\n                map_options.styles = JSON.parse(mo.styles);\n            // create the map with above options in div\n            this.map = new maps.Map(this.canvas_view.map_el, map_options);\n            // update bokeh ranges whenever the map idles, which should be after most UI action\n            maps.event.addListener(this.map, 'idle', () => this._set_bokeh_ranges());\n            // also need an event when bounds change so that map resizes trigger renders too\n            maps.event.addListener(this.map, 'bounds_changed', () => this._set_bokeh_ranges());\n            maps.event.addListenerOnce(this.map, 'tilesloaded', () => this._render_finished());\n            // wire up listeners so that changes to properties are reflected\n            this.connect(this.model.properties.map_options.change, () => this._update_options());\n            this.connect(this.model.map_options.properties.styles.change, () => this._update_styles());\n            this.connect(this.model.map_options.properties.lat.change, () => this._update_center('lat'));\n            this.connect(this.model.map_options.properties.lng.change, () => this._update_center('lng'));\n            this.connect(this.model.map_options.properties.zoom.change, () => this._update_zoom());\n            this.connect(this.model.map_options.properties.map_type.change, () => this._update_map_type());\n            this.connect(this.model.map_options.properties.scale_control.change, () => this._update_scale_control());\n            this.connect(this.model.map_options.properties.tilt.change, () => this._update_tilt());\n        }\n        _render_finished() {\n            this._tiles_loaded = true;\n            this.notify_finished();\n        }\n        has_finished() {\n            return super.has_finished() && this._tiles_loaded === true;\n        }\n        _get_latlon_bounds() {\n            const bounds = this.map.getBounds();\n            const top_right = bounds.getNorthEast();\n            const bottom_left = bounds.getSouthWest();\n            const xstart = bottom_left.lng();\n            const xend = top_right.lng();\n            const ystart = bottom_left.lat();\n            const yend = top_right.lat();\n            return [xstart, xend, ystart, yend];\n        }\n        _get_projected_bounds() {\n            const [xstart, xend, ystart, yend] = this._get_latlon_bounds();\n            const [proj_xstart, proj_ystart] = projections_1.wgs84_mercator.forward([xstart, ystart]);\n            const [proj_xend, proj_yend] = projections_1.wgs84_mercator.forward([xend, yend]);\n            return [proj_xstart, proj_xend, proj_ystart, proj_yend];\n        }\n        _set_bokeh_ranges() {\n            const [proj_xstart, proj_xend, proj_ystart, proj_yend] = this._get_projected_bounds();\n            this.frame.x_range.setv({ start: proj_xstart, end: proj_xend });\n            this.frame.y_range.setv({ start: proj_ystart, end: proj_yend });\n        }\n        _update_center(fld) {\n            const c = this.map.getCenter().toJSON();\n            c[fld] = this.model.map_options[fld];\n            this.map.setCenter(c);\n            this._set_bokeh_ranges();\n        }\n        _update_map_type() {\n            this.map.setOptions({ mapTypeId: this.map_types[this.model.map_options.map_type] });\n        }\n        _update_scale_control() {\n            this.map.setOptions({ scaleControl: this.model.map_options.scale_control });\n        }\n        _update_tilt() {\n            this.map.setOptions({ tilt: this.model.map_options.tilt });\n        }\n        _update_options() {\n            this._update_styles();\n            this._update_center('lat');\n            this._update_center('lng');\n            this._update_zoom();\n            this._update_map_type();\n        }\n        _update_styles() {\n            this.map.setOptions({ styles: JSON.parse(this.model.map_options.styles) });\n        }\n        _update_zoom() {\n            this.map.setOptions({ zoom: this.model.map_options.zoom });\n            this._set_bokeh_ranges();\n        }\n        // this method is expected and called by PlotView.render\n        _map_hook(_ctx, frame_box) {\n            const [left, top, width, height] = frame_box;\n            this.canvas_view.map_el.style.top = `${top}px`;\n            this.canvas_view.map_el.style.left = `${left}px`;\n            this.canvas_view.map_el.style.width = `${width}px`;\n            this.canvas_view.map_el.style.height = `${height}px`;\n            if (this.map == null && typeof google !== \"undefined\" && google.maps != null)\n                this._build_map();\n        }\n        // this overrides the standard _paint_empty to make the inner canvas transparent\n        _paint_empty(ctx, frame_box) {\n            const ow = this.layout._width.value;\n            const oh = this.layout._height.value;\n            const [left, top, iw, ih] = frame_box;\n            ctx.clearRect(0, 0, ow, oh);\n            ctx.beginPath();\n            ctx.moveTo(0, 0);\n            ctx.lineTo(0, oh);\n            ctx.lineTo(ow, oh);\n            ctx.lineTo(ow, 0);\n            ctx.lineTo(0, 0);\n            ctx.moveTo(left, top);\n            ctx.lineTo(left + iw, top);\n            ctx.lineTo(left + iw, top + ih);\n            ctx.lineTo(left, top + ih);\n            ctx.lineTo(left, top);\n            ctx.closePath();\n            if (this.model.border_fill_color != null) {\n                ctx.fillStyle = this.model.border_fill_color;\n                ctx.fill();\n            }\n        }\n    }\n    exports.GMapPlotView = GMapPlotView;\n    GMapPlotView.__name__ = \"GMapPlotView\";\n}\n","/* models/ranges/index.js */ function _(require, module, exports) {\n    var data_range_1 = require(179) /* ./data_range */;\n    exports.DataRange = data_range_1.DataRange;\n    var data_range1d_1 = require(178) /* ./data_range1d */;\n    exports.DataRange1d = data_range1d_1.DataRange1d;\n    var factor_range_1 = require(82) /* ./factor_range */;\n    exports.FactorRange = factor_range_1.FactorRange;\n    var range_1 = require(83) /* ./range */;\n    exports.Range = range_1.Range;\n    var range1d_1 = require(123) /* ./range1d */;\n    exports.Range1d = range1d_1.Range1d;\n}\n","/* models/renderers/index.js */ function _(require, module, exports) {\n    var glyph_renderer_1 = require(73) /* ./glyph_renderer */;\n    exports.GlyphRenderer = glyph_renderer_1.GlyphRenderer;\n    var graph_renderer_1 = require(90) /* ./graph_renderer */;\n    exports.GraphRenderer = graph_renderer_1.GraphRenderer;\n    var guide_renderer_1 = require(142) /* ./guide_renderer */;\n    exports.GuideRenderer = guide_renderer_1.GuideRenderer;\n    var renderer_1 = require(58) /* ./renderer */;\n    exports.Renderer = renderer_1.Renderer;\n}\n","/* models/scales/index.js */ function _(require, module, exports) {\n    var categorical_scale_1 = require(177) /* ./categorical_scale */;\n    exports.CategoricalScale = categorical_scale_1.CategoricalScale;\n    var linear_scale_1 = require(113) /* ./linear_scale */;\n    exports.LinearScale = linear_scale_1.LinearScale;\n    var log_scale_1 = require(122) /* ./log_scale */;\n    exports.LogScale = log_scale_1.LogScale;\n    var scale_1 = require(114) /* ./scale */;\n    exports.Scale = scale_1.Scale;\n}\n","/* models/selections/index.js */ function _(require, module, exports) {\n    function __export(m) {\n        for (var p in m)\n            if (!exports.hasOwnProperty(p))\n                exports[p] = m[p];\n    }\n    __export(require(93) /* ./interaction_policy */);\n    var selection_1 = require(71) /* ./selection */;\n    exports.Selection = selection_1.Selection;\n}\n","/* models/sources/index.js */ function _(require, module, exports) {\n    var server_sent_data_source_1 = require(286) /* ./server_sent_data_source */;\n    exports.ServerSentDataSource = server_sent_data_source_1.ServerSentDataSource;\n    var ajax_data_source_1 = require(288) /* ./ajax_data_source */;\n    exports.AjaxDataSource = ajax_data_source_1.AjaxDataSource;\n    var column_data_source_1 = require(68) /* ./column_data_source */;\n    exports.ColumnDataSource = column_data_source_1.ColumnDataSource;\n    var columnar_data_source_1 = require(69) /* ./columnar_data_source */;\n    exports.ColumnarDataSource = columnar_data_source_1.ColumnarDataSource;\n    var cds_view_1 = require(89) /* ./cds_view */;\n    exports.CDSView = cds_view_1.CDSView;\n    var data_source_1 = require(70) /* ./data_source */;\n    exports.DataSource = data_source_1.DataSource;\n    var geojson_data_source_1 = require(290) /* ./geojson_data_source */;\n    exports.GeoJSONDataSource = geojson_data_source_1.GeoJSONDataSource;\n    var remote_data_source_1 = require(289) /* ./remote_data_source */;\n    exports.RemoteDataSource = remote_data_source_1.RemoteDataSource;\n}\n","/* models/sources/server_sent_data_source.js */ function _(require, module, exports) {\n    const web_data_source_1 = require(287) /* ./web_data_source */;\n    class ServerSentDataSource extends web_data_source_1.WebDataSource {\n        constructor(attrs) {\n            super(attrs);\n            this.initialized = false;\n        }\n        destroy() {\n            super.destroy();\n        }\n        setup() {\n            if (!this.initialized) {\n                this.initialized = true;\n                const source = new EventSource(this.data_url);\n                source.onmessage = (event) => {\n                    this.load_data(JSON.parse(event.data), this.mode, this.max_size);\n                };\n            }\n        }\n    }\n    exports.ServerSentDataSource = ServerSentDataSource;\n    ServerSentDataSource.__name__ = \"ServerSentDataSource\";\n}\n","/* models/sources/web_data_source.js */ function _(require, module, exports) {\n    const column_data_source_1 = require(68) /* ./column_data_source */;\n    const p = require(18) /* ../../core/properties */;\n    class WebDataSource extends column_data_source_1.ColumnDataSource {\n        constructor(attrs) {\n            super(attrs);\n        }\n        get_column(colname) {\n            const column = this.data[colname];\n            return column != null ? column : [];\n        }\n        initialize() {\n            super.initialize();\n            this.setup();\n        }\n        load_data(raw_data, mode, max_size) {\n            const { adapter } = this;\n            let data;\n            if (adapter != null)\n                data = adapter.execute(this, { response: raw_data });\n            else\n                data = raw_data;\n            switch (mode) {\n                case \"replace\": {\n                    this.data = data;\n                    break;\n                }\n                case \"append\": {\n                    const original_data = this.data;\n                    for (const column of this.columns()) {\n                        // XXX: support typed arrays\n                        const old_col = Array.from(original_data[column]);\n                        const new_col = Array.from(data[column]);\n                        data[column] = old_col.concat(new_col).slice(-max_size);\n                    }\n                    this.data = data;\n                    break;\n                }\n            }\n        }\n        static init_WebDataSource() {\n            this.define({\n                mode: [p.UpdateMode, 'replace'],\n                max_size: [p.Number],\n                adapter: [p.Any, null],\n                data_url: [p.String],\n            });\n        }\n    }\n    exports.WebDataSource = WebDataSource;\n    WebDataSource.__name__ = \"WebDataSource\";\n    WebDataSource.init_WebDataSource();\n}\n","/* models/sources/ajax_data_source.js */ function _(require, module, exports) {\n    const remote_data_source_1 = require(289) /* ./remote_data_source */;\n    const logging_1 = require(65) /* ../../core/logging */;\n    const p = require(18) /* ../../core/properties */;\n    class AjaxDataSource extends remote_data_source_1.RemoteDataSource {\n        constructor(attrs) {\n            super(attrs);\n            this.initialized = false;\n        }\n        static init_AjaxDataSource() {\n            this.define({\n                content_type: [p.String, 'application/json'],\n                http_headers: [p.Any, {}],\n                method: [p.HTTPMethod, 'POST'],\n                if_modified: [p.Boolean, false],\n            });\n        }\n        destroy() {\n            if (this.interval != null)\n                clearInterval(this.interval);\n            super.destroy();\n        }\n        setup() {\n            if (!this.initialized) {\n                this.initialized = true;\n                this.get_data(this.mode);\n                if (this.polling_interval) {\n                    const callback = () => this.get_data(this.mode, this.max_size, this.if_modified);\n                    this.interval = setInterval(callback, this.polling_interval);\n                }\n            }\n        }\n        get_data(mode, max_size = 0, _if_modified = false) {\n            const xhr = this.prepare_request();\n            // TODO: if_modified\n            xhr.addEventListener(\"load\", () => this.do_load(xhr, mode, max_size));\n            xhr.addEventListener(\"error\", () => this.do_error(xhr));\n            xhr.send();\n        }\n        prepare_request() {\n            const xhr = new XMLHttpRequest();\n            xhr.open(this.method, this.data_url, true);\n            xhr.withCredentials = false;\n            xhr.setRequestHeader(\"Content-Type\", this.content_type);\n            const http_headers = this.http_headers;\n            for (const name in http_headers) {\n                const value = http_headers[name];\n                xhr.setRequestHeader(name, value);\n            }\n            return xhr;\n        }\n        do_load(xhr, mode, max_size) {\n            if (xhr.status === 200) {\n                const raw_data = JSON.parse(xhr.responseText);\n                this.load_data(raw_data, mode, max_size);\n            }\n        }\n        do_error(xhr) {\n            logging_1.logger.error(`Failed to fetch JSON from ${this.data_url} with code ${xhr.status}`);\n        }\n    }\n    exports.AjaxDataSource = AjaxDataSource;\n    AjaxDataSource.__name__ = \"AjaxDataSource\";\n    AjaxDataSource.init_AjaxDataSource();\n}\n","/* models/sources/remote_data_source.js */ function _(require, module, exports) {\n    const web_data_source_1 = require(287) /* ./web_data_source */;\n    const p = require(18) /* ../../core/properties */;\n    class RemoteDataSource extends web_data_source_1.WebDataSource {\n        constructor(attrs) {\n            super(attrs);\n        }\n        get_column(colname) {\n            const column = this.data[colname];\n            return column != null ? column : [];\n        }\n        initialize() {\n            super.initialize();\n            this.setup();\n        }\n        static init_RemoteDataSource() {\n            this.define({\n                polling_interval: [p.Number],\n            });\n        }\n    }\n    exports.RemoteDataSource = RemoteDataSource;\n    RemoteDataSource.__name__ = \"RemoteDataSource\";\n    RemoteDataSource.init_RemoteDataSource();\n}\n","/* models/sources/geojson_data_source.js */ function _(require, module, exports) {\n    const columnar_data_source_1 = require(69) /* ./columnar_data_source */;\n    const logging_1 = require(65) /* ../../core/logging */;\n    const p = require(18) /* ../../core/properties */;\n    const array_1 = require(8) /* ../../core/util/array */;\n    function orNaN(v) {\n        return v != null ? v : NaN;\n    }\n    class GeoJSONDataSource extends columnar_data_source_1.ColumnarDataSource {\n        constructor(attrs) {\n            super(attrs);\n        }\n        static init_GeoJSONDataSource() {\n            this.define({\n                geojson: [p.Any],\n            });\n            this.internal({\n                data: [p.Any, {}],\n            });\n        }\n        initialize() {\n            super.initialize();\n            this._update_data();\n        }\n        connect_signals() {\n            super.connect_signals();\n            this.connect(this.properties.geojson.change, () => this._update_data());\n        }\n        _update_data() {\n            this.data = this.geojson_to_column_data();\n        }\n        _get_new_list_array(length) {\n            return array_1.range(0, length).map((_i) => []);\n        }\n        _get_new_nan_array(length) {\n            return array_1.range(0, length).map((_i) => NaN);\n        }\n        _add_properties(item, data, i, item_count) {\n            const properties = item.properties || {};\n            for (const property in properties) {\n                if (!data.hasOwnProperty(property))\n                    data[property] = this._get_new_nan_array(item_count);\n                // orNaN necessary here to prevent null values from ending up in the column\n                data[property][i] = orNaN(properties[property]);\n            }\n        }\n        _add_geometry(geometry, data, i) {\n            function flatten(acc, item) {\n                return acc.concat([[NaN, NaN, NaN]]).concat(item);\n            }\n            switch (geometry.type) {\n                case \"Point\": {\n                    const [x, y, z] = geometry.coordinates;\n                    data.x[i] = x;\n                    data.y[i] = y;\n                    data.z[i] = orNaN(z);\n                    break;\n                }\n                case \"LineString\": {\n                    const { coordinates } = geometry;\n                    for (let j = 0; j < coordinates.length; j++) {\n                        const [x, y, z] = coordinates[j];\n                        data.xs[i][j] = x;\n                        data.ys[i][j] = y;\n                        data.zs[i][j] = orNaN(z);\n                    }\n                    break;\n                }\n                case \"Polygon\": {\n                    if (geometry.coordinates.length > 1)\n                        logging_1.logger.warn('Bokeh does not support Polygons with holes in, only exterior ring used.');\n                    const exterior_ring = geometry.coordinates[0];\n                    for (let j = 0; j < exterior_ring.length; j++) {\n                        const [x, y, z] = exterior_ring[j];\n                        data.xs[i][j] = x;\n                        data.ys[i][j] = y;\n                        data.zs[i][j] = orNaN(z);\n                    }\n                    break;\n                }\n                case \"MultiPoint\": {\n                    logging_1.logger.warn('MultiPoint not supported in Bokeh');\n                    break;\n                }\n                case \"MultiLineString\": {\n                    const coordinates = geometry.coordinates.reduce(flatten);\n                    for (let j = 0; j < coordinates.length; j++) {\n                        const [x, y, z] = coordinates[j];\n                        data.xs[i][j] = x;\n                        data.ys[i][j] = y;\n                        data.zs[i][j] = orNaN(z);\n                    }\n                    break;\n                }\n                case \"MultiPolygon\": {\n                    const exterior_rings = [];\n                    for (const polygon of geometry.coordinates) {\n                        if (polygon.length > 1)\n                            logging_1.logger.warn('Bokeh does not support Polygons with holes in, only exterior ring used.');\n                        exterior_rings.push(polygon[0]);\n                    }\n                    const coordinates = exterior_rings.reduce(flatten);\n                    for (let j = 0; j < coordinates.length; j++) {\n                        const [x, y, z] = coordinates[j];\n                        data.xs[i][j] = x;\n                        data.ys[i][j] = y;\n                        data.zs[i][j] = orNaN(z);\n                    }\n                    break;\n                }\n                default:\n                    throw new Error(`Invalid GeoJSON geometry type: ${geometry.type}`);\n            }\n        }\n        geojson_to_column_data() {\n            const geojson = JSON.parse(this.geojson);\n            let items;\n            switch (geojson.type) {\n                case \"GeometryCollection\": {\n                    if (geojson.geometries == null)\n                        throw new Error('No geometries found in GeometryCollection');\n                    if (geojson.geometries.length === 0)\n                        throw new Error('geojson.geometries must have one or more items');\n                    items = geojson.geometries;\n                    break;\n                }\n                case \"FeatureCollection\": {\n                    if (geojson.features == null)\n                        throw new Error('No features found in FeaturesCollection');\n                    if (geojson.features.length == 0)\n                        throw new Error('geojson.features must have one or more items');\n                    items = geojson.features;\n                    break;\n                }\n                default:\n                    throw new Error('Bokeh only supports type GeometryCollection and FeatureCollection at top level');\n            }\n            let item_count = 0;\n            for (const item of items) {\n                const geometry = item.type === 'Feature' ? item.geometry : item;\n                if (geometry.type == 'GeometryCollection')\n                    item_count += geometry.geometries.length;\n                else\n                    item_count += 1;\n            }\n            const data = {\n                x: this._get_new_nan_array(item_count),\n                y: this._get_new_nan_array(item_count),\n                z: this._get_new_nan_array(item_count),\n                xs: this._get_new_list_array(item_count),\n                ys: this._get_new_list_array(item_count),\n                zs: this._get_new_list_array(item_count),\n            };\n            let arr_index = 0;\n            for (const item of items) {\n                const geometry = item.type == 'Feature' ? item.geometry : item;\n                if (geometry.type == \"GeometryCollection\") {\n                    for (const g of geometry.geometries) {\n                        this._add_geometry(g, data, arr_index);\n                        if (item.type === 'Feature')\n                            this._add_properties(item, data, arr_index, item_count);\n                        arr_index += 1;\n                    }\n                }\n                else {\n                    this._add_geometry(geometry, data, arr_index);\n                    if (item.type === 'Feature')\n                        this._add_properties(item, data, arr_index, item_count);\n                    arr_index += 1;\n                }\n            }\n            return data;\n        }\n    }\n    exports.GeoJSONDataSource = GeoJSONDataSource;\n    GeoJSONDataSource.__name__ = \"GeoJSONDataSource\";\n    GeoJSONDataSource.init_GeoJSONDataSource();\n}\n","/* models/tickers/index.js */ function _(require, module, exports) {\n    var adaptive_ticker_1 = require(103) /* ./adaptive_ticker */;\n    exports.AdaptiveTicker = adaptive_ticker_1.AdaptiveTicker;\n    var basic_ticker_1 = require(102) /* ./basic_ticker */;\n    exports.BasicTicker = basic_ticker_1.BasicTicker;\n    var categorical_ticker_1 = require(144) /* ./categorical_ticker */;\n    exports.CategoricalTicker = categorical_ticker_1.CategoricalTicker;\n    var composite_ticker_1 = require(155) /* ./composite_ticker */;\n    exports.CompositeTicker = composite_ticker_1.CompositeTicker;\n    var continuous_ticker_1 = require(104) /* ./continuous_ticker */;\n    exports.ContinuousTicker = continuous_ticker_1.ContinuousTicker;\n    var datetime_ticker_1 = require(154) /* ./datetime_ticker */;\n    exports.DatetimeTicker = datetime_ticker_1.DatetimeTicker;\n    var days_ticker_1 = require(156) /* ./days_ticker */;\n    exports.DaysTicker = days_ticker_1.DaysTicker;\n    var fixed_ticker_1 = require(292) /* ./fixed_ticker */;\n    exports.FixedTicker = fixed_ticker_1.FixedTicker;\n    var log_ticker_1 = require(163) /* ./log_ticker */;\n    exports.LogTicker = log_ticker_1.LogTicker;\n    var mercator_ticker_1 = require(166) /* ./mercator_ticker */;\n    exports.MercatorTicker = mercator_ticker_1.MercatorTicker;\n    var months_ticker_1 = require(159) /* ./months_ticker */;\n    exports.MonthsTicker = months_ticker_1.MonthsTicker;\n    var single_interval_ticker_1 = require(157) /* ./single_interval_ticker */;\n    exports.SingleIntervalTicker = single_interval_ticker_1.SingleIntervalTicker;\n    var ticker_1 = require(105) /* ./ticker */;\n    exports.Ticker = ticker_1.Ticker;\n    var years_ticker_1 = require(160) /* ./years_ticker */;\n    exports.YearsTicker = years_ticker_1.YearsTicker;\n}\n","/* models/tickers/fixed_ticker.js */ function _(require, module, exports) {\n    const continuous_ticker_1 = require(104) /* ./continuous_ticker */;\n    const p = require(18) /* ../../core/properties */;\n    class FixedTicker extends continuous_ticker_1.ContinuousTicker {\n        constructor(attrs) {\n            super(attrs);\n            this.min_interval = 0;\n            this.max_interval = 0;\n        }\n        static init_FixedTicker() {\n            this.define({\n                ticks: [p.Array, []],\n                minor_ticks: [p.Array, []],\n            });\n        }\n        get_ticks_no_defaults(_data_low, _data_high, _cross_loc, _desired_n_ticks) {\n            return {\n                major: this.ticks,\n                minor: this.minor_ticks,\n            };\n        }\n        // XXX: whatever, because FixedTicker needs to fulfill the interface somehow\n        get_interval(_data_low, _data_high, _desired_n_ticks) {\n            return 0;\n        }\n    }\n    exports.FixedTicker = FixedTicker;\n    FixedTicker.__name__ = \"FixedTicker\";\n    FixedTicker.init_FixedTicker();\n}\n","/* models/tiles/index.js */ function _(require, module, exports) {\n    var bbox_tile_source_1 = require(294) /* ./bbox_tile_source */;\n    exports.BBoxTileSource = bbox_tile_source_1.BBoxTileSource;\n    var mercator_tile_source_1 = require(295) /* ./mercator_tile_source */;\n    exports.MercatorTileSource = mercator_tile_source_1.MercatorTileSource;\n    var quadkey_tile_source_1 = require(298) /* ./quadkey_tile_source */;\n    exports.QUADKEYTileSource = quadkey_tile_source_1.QUADKEYTileSource;\n    var tile_renderer_1 = require(299) /* ./tile_renderer */;\n    exports.TileRenderer = tile_renderer_1.TileRenderer;\n    var tile_source_1 = require(296) /* ./tile_source */;\n    exports.TileSource = tile_source_1.TileSource;\n    var tms_tile_source_1 = require(302) /* ./tms_tile_source */;\n    exports.TMSTileSource = tms_tile_source_1.TMSTileSource;\n    var wmts_tile_source_1 = require(300) /* ./wmts_tile_source */;\n    exports.WMTSTileSource = wmts_tile_source_1.WMTSTileSource;\n}\n","/* models/tiles/bbox_tile_source.js */ function _(require, module, exports) {\n    const mercator_tile_source_1 = require(295) /* ./mercator_tile_source */;\n    const p = require(18) /* ../../core/properties */;\n    class BBoxTileSource extends mercator_tile_source_1.MercatorTileSource {\n        constructor(attrs) {\n            super(attrs);\n        }\n        static init_BBoxTileSource() {\n            this.define({\n                use_latlon: [p.Boolean, false],\n            });\n        }\n        get_image_url(x, y, z) {\n            const image_url = this.string_lookup_replace(this.url, this.extra_url_vars);\n            let xmax, xmin, ymax, ymin;\n            if (this.use_latlon)\n                [xmin, ymin, xmax, ymax] = this.get_tile_geographic_bounds(x, y, z);\n            else\n                [xmin, ymin, xmax, ymax] = this.get_tile_meter_bounds(x, y, z);\n            return image_url\n                .replace(\"{XMIN}\", xmin.toString())\n                .replace(\"{YMIN}\", ymin.toString())\n                .replace(\"{XMAX}\", xmax.toString())\n                .replace(\"{YMAX}\", ymax.toString());\n        }\n    }\n    exports.BBoxTileSource = BBoxTileSource;\n    BBoxTileSource.__name__ = \"BBoxTileSource\";\n    BBoxTileSource.init_BBoxTileSource();\n}\n","/* models/tiles/mercator_tile_source.js */ function _(require, module, exports) {\n    const tile_source_1 = require(296) /* ./tile_source */;\n    const p = require(18) /* ../../core/properties */;\n    const array_1 = require(8) /* ../../core/util/array */;\n    const tile_utils_1 = require(297) /* ./tile_utils */;\n    class MercatorTileSource extends tile_source_1.TileSource {\n        constructor(attrs) {\n            super(attrs);\n        }\n        static init_MercatorTileSource() {\n            this.define({\n                snap_to_zoom: [p.Boolean, false],\n                wrap_around: [p.Boolean, true],\n            });\n            this.override({\n                x_origin_offset: 20037508.34,\n                y_origin_offset: 20037508.34,\n                initial_resolution: 156543.03392804097,\n            });\n        }\n        initialize() {\n            super.initialize();\n            this._resolutions = array_1.range(this.min_zoom, this.max_zoom + 1).map((z) => this.get_resolution(z));\n        }\n        _computed_initial_resolution() {\n            if (this.initial_resolution != null)\n                return this.initial_resolution;\n            else {\n                // TODO testing 2015-11-17, if this codepath is used it seems\n                // to use 100% cpu and wedge Chrome\n                return (2 * Math.PI * 6378137) / this.tile_size;\n            }\n        }\n        is_valid_tile(x, y, z) {\n            if (!this.wrap_around) {\n                if (x < 0 || x >= Math.pow(2, z))\n                    return false;\n            }\n            if (y < 0 || y >= Math.pow(2, z))\n                return false;\n            return true;\n        }\n        parent_by_tile_xyz(x, y, z) {\n            const quadkey = this.tile_xyz_to_quadkey(x, y, z);\n            const parent_quadkey = quadkey.substring(0, quadkey.length - 1);\n            return this.quadkey_to_tile_xyz(parent_quadkey);\n        }\n        get_resolution(level) {\n            return this._computed_initial_resolution() / Math.pow(2, level);\n        }\n        get_resolution_by_extent(extent, height, width) {\n            const x_rs = (extent[2] - extent[0]) / width;\n            const y_rs = (extent[3] - extent[1]) / height;\n            return [x_rs, y_rs];\n        }\n        get_level_by_extent(extent, height, width) {\n            const x_rs = (extent[2] - extent[0]) / width;\n            const y_rs = (extent[3] - extent[1]) / height;\n            const resolution = Math.max(x_rs, y_rs);\n            let i = 0;\n            for (const r of this._resolutions) {\n                if (resolution > r) {\n                    if (i == 0)\n                        return 0;\n                    if (i > 0)\n                        return i - 1;\n                }\n                i += 1;\n            }\n            // otherwise return the highest available resolution\n            return (i - 1);\n        }\n        get_closest_level_by_extent(extent, height, width) {\n            const x_rs = (extent[2] - extent[0]) / width;\n            const y_rs = (extent[3] - extent[1]) / height;\n            const resolution = Math.max(x_rs, y_rs);\n            const closest = this._resolutions.reduce(function (previous, current) {\n                if (Math.abs(current - resolution) < Math.abs(previous - resolution))\n                    return current;\n                else\n                    return previous;\n            });\n            return this._resolutions.indexOf(closest);\n        }\n        snap_to_zoom_level(extent, height, width, level) {\n            const [xmin, ymin, xmax, ymax] = extent;\n            const desired_res = this._resolutions[level];\n            let desired_x_delta = width * desired_res;\n            let desired_y_delta = height * desired_res;\n            if (!this.snap_to_zoom) {\n                const xscale = (xmax - xmin) / desired_x_delta;\n                const yscale = (ymax - ymin) / desired_y_delta;\n                if (xscale > yscale) {\n                    desired_x_delta = (xmax - xmin);\n                    desired_y_delta = desired_y_delta * xscale;\n                }\n                else {\n                    desired_x_delta = desired_x_delta * yscale;\n                    desired_y_delta = (ymax - ymin);\n                }\n            }\n            const x_adjust = (desired_x_delta - (xmax - xmin)) / 2;\n            const y_adjust = (desired_y_delta - (ymax - ymin)) / 2;\n            return [xmin - x_adjust, ymin - y_adjust, xmax + x_adjust, ymax + y_adjust];\n        }\n        tms_to_wmts(x, y, z) {\n            'Note this works both ways';\n            return [x, Math.pow(2, z) - 1 - y, z];\n        }\n        wmts_to_tms(x, y, z) {\n            'Note this works both ways';\n            return [x, Math.pow(2, z) - 1 - y, z];\n        }\n        pixels_to_meters(px, py, level) {\n            const res = this.get_resolution(level);\n            const mx = (px * res) - this.x_origin_offset;\n            const my = (py * res) - this.y_origin_offset;\n            return [mx, my];\n        }\n        meters_to_pixels(mx, my, level) {\n            const res = this.get_resolution(level);\n            const px = (mx + this.x_origin_offset) / res;\n            const py = (my + this.y_origin_offset) / res;\n            return [px, py];\n        }\n        pixels_to_tile(px, py) {\n            let tx = Math.ceil(px / this.tile_size);\n            tx = tx === 0 ? tx : tx - 1;\n            const ty = Math.max(Math.ceil(py / this.tile_size) - 1, 0);\n            return [tx, ty];\n        }\n        pixels_to_raster(px, py, level) {\n            const mapSize = this.tile_size << level;\n            return [px, mapSize - py];\n        }\n        meters_to_tile(mx, my, level) {\n            const [px, py] = this.meters_to_pixels(mx, my, level);\n            return this.pixels_to_tile(px, py);\n        }\n        get_tile_meter_bounds(tx, ty, level) {\n            // expects tms styles coordinates (bottom-left origin)\n            const [xmin, ymin] = this.pixels_to_meters(tx * this.tile_size, ty * this.tile_size, level);\n            const [xmax, ymax] = this.pixels_to_meters((tx + 1) * this.tile_size, (ty + 1) * this.tile_size, level);\n            return [xmin, ymin, xmax, ymax];\n        }\n        get_tile_geographic_bounds(tx, ty, level) {\n            const bounds = this.get_tile_meter_bounds(tx, ty, level);\n            const [minLon, minLat, maxLon, maxLat] = tile_utils_1.meters_extent_to_geographic(bounds);\n            return [minLon, minLat, maxLon, maxLat];\n        }\n        get_tiles_by_extent(extent, level, tile_border = 1) {\n            // unpack extent and convert to tile coordinates\n            const [xmin, ymin, xmax, ymax] = extent;\n            let [txmin, tymin] = this.meters_to_tile(xmin, ymin, level);\n            let [txmax, tymax] = this.meters_to_tile(xmax, ymax, level);\n            // add tiles which border\n            txmin -= tile_border;\n            tymin -= tile_border;\n            txmax += tile_border;\n            tymax += tile_border;\n            const tiles = [];\n            for (let ty = tymax; ty >= tymin; ty--) {\n                for (let tx = txmin; tx <= txmax; tx++) {\n                    if (this.is_valid_tile(tx, ty, level))\n                        tiles.push([tx, ty, level, this.get_tile_meter_bounds(tx, ty, level)]);\n                }\n            }\n            this.sort_tiles_from_center(tiles, [txmin, tymin, txmax, tymax]);\n            return tiles;\n        }\n        quadkey_to_tile_xyz(quadKey) {\n            /**\n             * Computes tile x, y and z values based on quadKey.\n             */\n            let tileX = 0;\n            let tileY = 0;\n            const tileZ = quadKey.length;\n            for (let i = tileZ; i > 0; i--) {\n                const value = quadKey.charAt(tileZ - i);\n                const mask = 1 << (i - 1);\n                switch (value) {\n                    case '0':\n                        continue;\n                    case '1':\n                        tileX |= mask;\n                        break;\n                    case '2':\n                        tileY |= mask;\n                        break;\n                    case '3':\n                        tileX |= mask;\n                        tileY |= mask;\n                        break;\n                    default:\n                        throw new TypeError(`Invalid Quadkey: ${quadKey}`);\n                }\n            }\n            return [tileX, tileY, tileZ];\n        }\n        tile_xyz_to_quadkey(x, y, z) {\n            /*\n             * Computes quadkey value based on tile x, y and z values.\n             */\n            let quadkey = \"\";\n            for (let i = z; i > 0; i--) {\n                const mask = 1 << (i - 1);\n                let digit = 0;\n                if ((x & mask) !== 0) {\n                    digit += 1;\n                }\n                if ((y & mask) !== 0) {\n                    digit += 2;\n                }\n                quadkey += digit.toString();\n            }\n            return quadkey;\n        }\n        children_by_tile_xyz(x, y, z) {\n            const quadkey = this.tile_xyz_to_quadkey(x, y, z);\n            const child_tile_xyz = [];\n            for (let i = 0; i <= 3; i++) {\n                const [x, y, z] = this.quadkey_to_tile_xyz(quadkey + i.toString());\n                const b = this.get_tile_meter_bounds(x, y, z);\n                child_tile_xyz.push([x, y, z, b]);\n            }\n            return child_tile_xyz;\n        }\n        get_closest_parent_by_tile_xyz(x, y, z) {\n            const world_x = this.calculate_world_x_by_tile_xyz(x, y, z);\n            [x, y, z] = this.normalize_xyz(x, y, z);\n            let quadkey = this.tile_xyz_to_quadkey(x, y, z);\n            while (quadkey.length > 0) {\n                quadkey = quadkey.substring(0, quadkey.length - 1);\n                [x, y, z] = this.quadkey_to_tile_xyz(quadkey);\n                [x, y, z] = this.denormalize_xyz(x, y, z, world_x);\n                if (this.tiles.has(this.tile_xyz_to_key(x, y, z)))\n                    return [x, y, z];\n            }\n            return [0, 0, 0];\n        }\n        normalize_xyz(x, y, z) {\n            if (this.wrap_around) {\n                const tile_count = Math.pow(2, z);\n                return [((x % tile_count) + tile_count) % tile_count, y, z];\n            }\n            else {\n                return [x, y, z];\n            }\n        }\n        denormalize_xyz(x, y, z, world_x) {\n            return [x + (world_x * Math.pow(2, z)), y, z];\n        }\n        denormalize_meters(meters_x, meters_y, _level, world_x) {\n            return [meters_x + (world_x * 2 * Math.PI * 6378137), meters_y];\n        }\n        calculate_world_x_by_tile_xyz(x, _y, z) {\n            return Math.floor(x / Math.pow(2, z));\n        }\n    }\n    exports.MercatorTileSource = MercatorTileSource;\n    MercatorTileSource.__name__ = \"MercatorTileSource\";\n    MercatorTileSource.init_MercatorTileSource();\n}\n","/* models/tiles/tile_source.js */ function _(require, module, exports) {\n    const model_1 = require(64) /* ../../model */;\n    const p = require(18) /* ../../core/properties */;\n    class TileSource extends model_1.Model {\n        constructor(attrs) {\n            super(attrs);\n        }\n        static init_TileSource() {\n            this.define({\n                url: [p.String, ''],\n                tile_size: [p.Number, 256],\n                max_zoom: [p.Number, 30],\n                min_zoom: [p.Number, 0],\n                extra_url_vars: [p.Any, {}],\n                attribution: [p.String, ''],\n                x_origin_offset: [p.Number],\n                y_origin_offset: [p.Number],\n                initial_resolution: [p.Number],\n            });\n        }\n        initialize() {\n            super.initialize();\n            this.tiles = new Map();\n            this._normalize_case();\n        }\n        connect_signals() {\n            super.connect_signals();\n            this.connect(this.change, () => this._clear_cache());\n        }\n        string_lookup_replace(str, lookup) {\n            let result_str = str;\n            for (const key in lookup) {\n                const value = lookup[key];\n                result_str = result_str.replace(`{${key}}`, value);\n            }\n            return result_str;\n        }\n        _normalize_case() {\n            /*\n             * Note: should probably be refactored into subclasses.\n             */\n            const url = this.url\n                .replace('{x}', '{X}')\n                .replace('{y}', '{Y}')\n                .replace('{z}', '{Z}')\n                .replace('{q}', '{Q}')\n                .replace('{xmin}', '{XMIN}')\n                .replace('{ymin}', '{YMIN}')\n                .replace('{xmax}', '{XMAX}')\n                .replace('{ymax}', '{YMAX}');\n            this.url = url;\n        }\n        _clear_cache() {\n            this.tiles = new Map();\n        }\n        tile_xyz_to_key(x, y, z) {\n            return `${x}:${y}:${z}`;\n        }\n        key_to_tile_xyz(key) {\n            const [x, y, z] = key.split(':').map((c) => parseInt(c));\n            return [x, y, z];\n        }\n        sort_tiles_from_center(tiles, tile_extent) {\n            const [txmin, tymin, txmax, tymax] = tile_extent;\n            const center_x = ((txmax - txmin) / 2) + txmin;\n            const center_y = ((tymax - tymin) / 2) + tymin;\n            tiles.sort(function (a, b) {\n                const a_distance = Math.sqrt(Math.pow(center_x - a[0], 2) + Math.pow(center_y - a[1], 2));\n                const b_distance = Math.sqrt(Math.pow(center_x - b[0], 2) + Math.pow(center_y - b[1], 2));\n                return a_distance - b_distance;\n            });\n        }\n        get_image_url(x, y, z) {\n            const image_url = this.string_lookup_replace(this.url, this.extra_url_vars);\n            return image_url\n                .replace(\"{X}\", x.toString())\n                .replace('{Y}', y.toString())\n                .replace(\"{Z}\", z.toString());\n        }\n    }\n    exports.TileSource = TileSource;\n    TileSource.__name__ = \"TileSource\";\n    TileSource.init_TileSource();\n}\n","/* models/tiles/tile_utils.js */ function _(require, module, exports) {\n    const projections_1 = require(30) /* ../../core/util/projections */;\n    function geographic_to_meters(xLon, yLat) {\n        return projections_1.wgs84_mercator.forward([xLon, yLat]);\n    }\n    exports.geographic_to_meters = geographic_to_meters;\n    function meters_to_geographic(mx, my) {\n        return projections_1.wgs84_mercator.inverse([mx, my]);\n    }\n    exports.meters_to_geographic = meters_to_geographic;\n    function geographic_extent_to_meters(extent) {\n        const [g_xmin, g_ymin, g_xmax, g_ymax] = extent;\n        const [m_xmin, m_ymin] = geographic_to_meters(g_xmin, g_ymin);\n        const [m_xmax, m_ymax] = geographic_to_meters(g_xmax, g_ymax);\n        return [m_xmin, m_ymin, m_xmax, m_ymax];\n    }\n    exports.geographic_extent_to_meters = geographic_extent_to_meters;\n    function meters_extent_to_geographic(extent) {\n        const [m_xmin, m_ymin, m_xmax, m_ymax] = extent;\n        const [g_xmin, g_ymin] = meters_to_geographic(m_xmin, m_ymin);\n        const [g_xmax, g_ymax] = meters_to_geographic(m_xmax, m_ymax);\n        return [g_xmin, g_ymin, g_xmax, g_ymax];\n    }\n    exports.meters_extent_to_geographic = meters_extent_to_geographic;\n}\n","/* models/tiles/quadkey_tile_source.js */ function _(require, module, exports) {\n    const mercator_tile_source_1 = require(295) /* ./mercator_tile_source */;\n    class QUADKEYTileSource extends mercator_tile_source_1.MercatorTileSource {\n        constructor(attrs) {\n            super(attrs);\n        }\n        get_image_url(x, y, z) {\n            const image_url = this.string_lookup_replace(this.url, this.extra_url_vars);\n            const [wx, wy, wz] = this.tms_to_wmts(x, y, z);\n            const quadKey = this.tile_xyz_to_quadkey(wx, wy, wz);\n            return image_url.replace(\"{Q}\", quadKey);\n        }\n    }\n    exports.QUADKEYTileSource = QUADKEYTileSource;\n    QUADKEYTileSource.__name__ = \"QUADKEYTileSource\";\n}\n","/* models/tiles/tile_renderer.js */ function _(require, module, exports) {\n    const wmts_tile_source_1 = require(300) /* ./wmts_tile_source */;\n    const data_renderer_1 = require(74) /* ../renderers/data_renderer */;\n    const range1d_1 = require(123) /* ../ranges/range1d */;\n    const dom_1 = require(61) /* ../../core/dom */;\n    const p = require(18) /* ../../core/properties */;\n    const image_1 = require(216) /* ../../core/util/image */;\n    const array_1 = require(8) /* ../../core/util/array */;\n    const types_1 = require(7) /* ../../core/util/types */;\n    const selection_manager_1 = require(72) /* ../../core/selection_manager */;\n    const column_data_source_1 = require(68) /* ../sources/column_data_source */;\n    const tiles_1 = require(301) /* ../../styles/tiles */;\n    class TileRendererView extends data_renderer_1.DataRendererView {\n        initialize() {\n            this._tiles = [];\n            super.initialize();\n        }\n        connect_signals() {\n            super.connect_signals();\n            this.connect(this.model.change, () => this.request_render());\n            this.connect(this.model.tile_source.change, () => this.request_render());\n        }\n        get_extent() {\n            return [this.x_range.start, this.y_range.start, this.x_range.end, this.y_range.end];\n        }\n        get map_plot() {\n            return this.plot_model;\n        }\n        get map_canvas() {\n            return this.plot_view.canvas_view.ctx;\n        }\n        get map_frame() {\n            return this.plot_view.frame;\n        }\n        get x_range() {\n            return this.map_plot.x_range;\n        }\n        get y_range() {\n            return this.map_plot.y_range;\n        }\n        _set_data() {\n            this.extent = this.get_extent();\n            this._last_height = undefined;\n            this._last_width = undefined;\n        }\n        _update_attribution() {\n            if (this.attribution_el != null)\n                dom_1.removeElement(this.attribution_el);\n            const { attribution } = this.model.tile_source;\n            if (types_1.isString(attribution) && attribution.length > 0) {\n                const { layout, frame } = this.plot_view;\n                const offset_right = layout._width.value - frame._right.value;\n                const offset_bottom = layout._height.value - frame._bottom.value;\n                const max_width = frame._width.value;\n                this.attribution_el = dom_1.div({\n                    class: tiles_1.bk_tile_attribution,\n                    style: {\n                        position: \"absolute\",\n                        right: `${offset_right}px`,\n                        bottom: `${offset_bottom}px`,\n                        'max-width': `${max_width - 4 /*padding*/}px`,\n                        padding: \"2px\",\n                        'background-color': 'rgba(255,255,255,0.5)',\n                        'font-size': '7pt',\n                        'line-height': '1.05',\n                        'white-space': 'nowrap',\n                        overflow: 'hidden',\n                        'text-overflow': 'ellipsis',\n                    },\n                });\n                const overlays = this.plot_view.canvas_view.events_el;\n                overlays.appendChild(this.attribution_el);\n                this.attribution_el.innerHTML = attribution;\n                this.attribution_el.title = this.attribution_el.textContent.replace(/\\s*\\n\\s*/g, \" \");\n            }\n        }\n        _map_data() {\n            this.initial_extent = this.get_extent();\n            const zoom_level = this.model.tile_source.get_level_by_extent(this.initial_extent, this.map_frame._height.value, this.map_frame._width.value);\n            const new_extent = this.model.tile_source.snap_to_zoom_level(this.initial_extent, this.map_frame._height.value, this.map_frame._width.value, zoom_level);\n            this.x_range.start = new_extent[0];\n            this.y_range.start = new_extent[1];\n            this.x_range.end = new_extent[2];\n            this.y_range.end = new_extent[3];\n            if (this.x_range instanceof range1d_1.Range1d) {\n                this.x_range.reset_start = new_extent[0];\n                this.x_range.reset_end = new_extent[2];\n            }\n            if (this.y_range instanceof range1d_1.Range1d) {\n                this.y_range.reset_start = new_extent[1];\n                this.y_range.reset_end = new_extent[3];\n            }\n            this._update_attribution();\n        }\n        _create_tile(x, y, z, bounds, cache_only = false) {\n            const [nx, ny, nz] = this.model.tile_source.normalize_xyz(x, y, z);\n            const tile = {\n                img: undefined,\n                tile_coords: [x, y, z],\n                normalized_coords: [nx, ny, nz],\n                quadkey: this.model.tile_source.tile_xyz_to_quadkey(x, y, z),\n                cache_key: this.model.tile_source.tile_xyz_to_key(x, y, z),\n                bounds,\n                loaded: false,\n                finished: false,\n                x_coord: bounds[0],\n                y_coord: bounds[3],\n            };\n            const src = this.model.tile_source.get_image_url(nx, ny, nz);\n            new image_1.ImageLoader(src, {\n                loaded: (img) => {\n                    Object.assign(tile, { img, loaded: true });\n                    if (cache_only) {\n                        tile.finished = true;\n                        this.notify_finished();\n                    }\n                    else\n                        this.request_render();\n                },\n                failed() {\n                    tile.finished = true;\n                },\n            });\n            this.model.tile_source.tiles.set(tile.cache_key, tile);\n            this._tiles.push(tile);\n        }\n        _enforce_aspect_ratio() {\n            // brute force way of handling resize or sizing_mode event -------------------------------------------------------------\n            if ((this._last_height !== this.map_frame._height.value) || (this._last_width !== this.map_frame._width.value)) {\n                const extent = this.get_extent();\n                const zoom_level = this.model.tile_source.get_level_by_extent(extent, this.map_frame._height.value, this.map_frame._width.value);\n                const new_extent = this.model.tile_source.snap_to_zoom_level(extent, this.map_frame._height.value, this.map_frame._width.value, zoom_level);\n                this.x_range.setv({ start: new_extent[0], end: new_extent[2] });\n                this.y_range.setv({ start: new_extent[1], end: new_extent[3] });\n                this.extent = new_extent;\n                this._last_height = this.map_frame._height.value;\n                this._last_width = this.map_frame._width.value;\n            }\n        }\n        has_finished() {\n            if (!super.has_finished()) {\n                return false;\n            }\n            if (this._tiles.length === 0) {\n                return false;\n            }\n            for (const tile of this._tiles) {\n                if (!tile.finished) {\n                    return false;\n                }\n            }\n            return true;\n        }\n        render() {\n            if (this.map_initialized == null) {\n                this._set_data();\n                this._map_data();\n                this.map_initialized = true;\n            }\n            this._enforce_aspect_ratio();\n            this._update();\n            if (this.prefetch_timer != null) {\n                clearTimeout(this.prefetch_timer);\n            }\n            this.prefetch_timer = setTimeout(this._prefetch_tiles.bind(this), 500);\n            if (this.has_finished()) {\n                this.notify_finished();\n            }\n        }\n        _draw_tile(tile_key) {\n            const tile_data = this.model.tile_source.tiles.get(tile_key);\n            if (tile_data != null && tile_data.loaded) {\n                const [[sxmin], [symin]] = this.plot_view.map_to_screen([tile_data.bounds[0]], [tile_data.bounds[3]]);\n                const [[sxmax], [symax]] = this.plot_view.map_to_screen([tile_data.bounds[2]], [tile_data.bounds[1]]);\n                const sw = sxmax - sxmin;\n                const sh = symax - symin;\n                const sx = sxmin;\n                const sy = symin;\n                const old_smoothing = this.map_canvas.getImageSmoothingEnabled();\n                this.map_canvas.setImageSmoothingEnabled(this.model.smoothing);\n                this.map_canvas.drawImage(tile_data.img, sx, sy, sw, sh);\n                this.map_canvas.setImageSmoothingEnabled(old_smoothing);\n                tile_data.finished = true;\n            }\n        }\n        _set_rect() {\n            const outline_width = this.plot_model.properties.outline_line_width.value();\n            const l = this.map_frame._left.value + (outline_width / 2);\n            const t = this.map_frame._top.value + (outline_width / 2);\n            const w = this.map_frame._width.value - outline_width;\n            const h = this.map_frame._height.value - outline_width;\n            this.map_canvas.rect(l, t, w, h);\n            this.map_canvas.clip();\n        }\n        _render_tiles(tile_keys) {\n            this.map_canvas.save();\n            this._set_rect();\n            this.map_canvas.globalAlpha = this.model.alpha;\n            for (const tile_key of tile_keys) {\n                this._draw_tile(tile_key);\n            }\n            this.map_canvas.restore();\n        }\n        _prefetch_tiles() {\n            const { tile_source } = this.model;\n            const extent = this.get_extent();\n            const h = this.map_frame._height.value;\n            const w = this.map_frame._width.value;\n            const zoom_level = this.model.tile_source.get_level_by_extent(extent, h, w);\n            const tiles = this.model.tile_source.get_tiles_by_extent(extent, zoom_level);\n            for (let t = 0, end = Math.min(10, tiles.length); t < end; t++) {\n                const [x, y, z] = tiles[t];\n                const children = this.model.tile_source.children_by_tile_xyz(x, y, z);\n                for (const c of children) {\n                    const [cx, cy, cz, cbounds] = c;\n                    if (tile_source.tiles.has(tile_source.tile_xyz_to_key(cx, cy, cz))) {\n                        continue;\n                    }\n                    else {\n                        this._create_tile(cx, cy, cz, cbounds, true);\n                    }\n                }\n            }\n        }\n        _fetch_tiles(tiles) {\n            for (const tile of tiles) {\n                const [x, y, z, bounds] = tile;\n                this._create_tile(x, y, z, bounds);\n            }\n        }\n        _update() {\n            const { tile_source } = this.model;\n            const { min_zoom } = tile_source;\n            const { max_zoom } = tile_source;\n            let extent = this.get_extent();\n            const zooming_out = (this.extent[2] - this.extent[0]) < (extent[2] - extent[0]);\n            const h = this.map_frame._height.value;\n            const w = this.map_frame._width.value;\n            let zoom_level = tile_source.get_level_by_extent(extent, h, w);\n            let snap_back = false;\n            if (zoom_level < min_zoom) {\n                extent = this.extent;\n                zoom_level = min_zoom;\n                snap_back = true;\n            }\n            else if (zoom_level > max_zoom) {\n                extent = this.extent;\n                zoom_level = max_zoom;\n                snap_back = true;\n            }\n            if (snap_back) {\n                this.x_range.setv({ x_range: { start: extent[0], end: extent[2] } });\n                this.y_range.setv({ start: extent[1], end: extent[3] });\n                this.extent = extent;\n            }\n            this.extent = extent;\n            const tiles = tile_source.get_tiles_by_extent(extent, zoom_level);\n            const need_load = [];\n            const cached = [];\n            const parents = [];\n            const children = [];\n            for (const t of tiles) {\n                const [x, y, z] = t;\n                const key = tile_source.tile_xyz_to_key(x, y, z);\n                const tile = tile_source.tiles.get(key);\n                if (tile != null && tile.loaded) {\n                    cached.push(key);\n                }\n                else {\n                    if (this.model.render_parents) {\n                        const [px, py, pz] = tile_source.get_closest_parent_by_tile_xyz(x, y, z);\n                        const parent_key = tile_source.tile_xyz_to_key(px, py, pz);\n                        const parent_tile = tile_source.tiles.get(parent_key);\n                        if ((parent_tile != null) && parent_tile.loaded && !array_1.includes(parents, parent_key)) {\n                            parents.push(parent_key);\n                        }\n                        if (zooming_out) {\n                            const child_tiles = tile_source.children_by_tile_xyz(x, y, z);\n                            for (const [cx, cy, cz] of child_tiles) {\n                                const child_key = tile_source.tile_xyz_to_key(cx, cy, cz);\n                                if (tile_source.tiles.has(child_key))\n                                    children.push(child_key);\n                            }\n                        }\n                    }\n                }\n                if (tile == null)\n                    need_load.push(t);\n            }\n            // draw stand-in parents ----------\n            this._render_tiles(parents);\n            this._render_tiles(children);\n            // draw cached ----------\n            this._render_tiles(cached);\n            // fetch missing -------\n            if (this.render_timer != null) {\n                clearTimeout(this.render_timer);\n            }\n            this.render_timer = setTimeout((() => this._fetch_tiles(need_load)), 65);\n        }\n    }\n    exports.TileRendererView = TileRendererView;\n    TileRendererView.__name__ = \"TileRendererView\";\n    class TileRenderer extends data_renderer_1.DataRenderer {\n        constructor(attrs) {\n            super(attrs);\n            // XXX: tile renderer doesn't allow selection, but needs to fulfil the APIs\n            this._selection_manager = new selection_manager_1.SelectionManager({\n                source: new column_data_source_1.ColumnDataSource(),\n            });\n        }\n        static init_TileRenderer() {\n            this.prototype.default_view = TileRendererView;\n            this.define({\n                alpha: [p.Number, 1.0],\n                smoothing: [p.Boolean, true],\n                tile_source: [p.Instance, () => new wmts_tile_source_1.WMTSTileSource()],\n                render_parents: [p.Boolean, true],\n            });\n        }\n        get_selection_manager() {\n            return this._selection_manager;\n        }\n    }\n    exports.TileRenderer = TileRenderer;\n    TileRenderer.__name__ = \"TileRenderer\";\n    TileRenderer.init_TileRenderer();\n}\n","/* models/tiles/wmts_tile_source.js */ function _(require, module, exports) {\n    const mercator_tile_source_1 = require(295) /* ./mercator_tile_source */;\n    class WMTSTileSource extends mercator_tile_source_1.MercatorTileSource {\n        constructor(attrs) {\n            super(attrs);\n        }\n        get_image_url(x, y, z) {\n            const image_url = this.string_lookup_replace(this.url, this.extra_url_vars);\n            const [wx, wy, wz] = this.tms_to_wmts(x, y, z);\n            return image_url\n                .replace(\"{X}\", wx.toString())\n                .replace(\"{Y}\", wy.toString())\n                .replace(\"{Z}\", wz.toString());\n        }\n    }\n    exports.WMTSTileSource = WMTSTileSource;\n    WMTSTileSource.__name__ = \"WMTSTileSource\";\n}\n","/* styles/tiles.js */ function _(require, module, exports) {\n    require(62) /* ./root */;\n    const _a = require(61) /* ../core/dom */;\n    _a.styles.append(\".bk-root .bk-tile-attribution a {\\n  color: black;\\n}\\n\");\n    exports.bk_tile_attribution = \"bk-tile-attribution\";\n}\n","/* models/tiles/tms_tile_source.js */ function _(require, module, exports) {\n    const mercator_tile_source_1 = require(295) /* ./mercator_tile_source */;\n    class TMSTileSource extends mercator_tile_source_1.MercatorTileSource {\n        constructor(attrs) {\n            super(attrs);\n        }\n        get_image_url(x, y, z) {\n            const image_url = this.string_lookup_replace(this.url, this.extra_url_vars);\n            return image_url\n                .replace(\"{X}\", x.toString())\n                .replace('{Y}', y.toString())\n                .replace(\"{Z}\", z.toString());\n        }\n    }\n    exports.TMSTileSource = TMSTileSource;\n    TMSTileSource.__name__ = \"TMSTileSource\";\n}\n","/* models/textures/index.js */ function _(require, module, exports) {\n    var canvas_texture_1 = require(304) /* ./canvas_texture */;\n    exports.CanvasTexture = canvas_texture_1.CanvasTexture;\n    var image_url_texture_1 = require(306) /* ./image_url_texture */;\n    exports.ImageURLTexture = image_url_texture_1.ImageURLTexture;\n    var texture_1 = require(305) /* ./texture */;\n    exports.Texture = texture_1.Texture;\n}\n","/* models/textures/canvas_texture.js */ function _(require, module, exports) {\n    const texture_1 = require(305) /* ./texture */;\n    const p = require(18) /* ../../core/properties */;\n    const string_1 = require(25) /* ../../core/util/string */;\n    class CanvasTexture extends texture_1.Texture {\n        constructor(attrs) {\n            super(attrs);\n        }\n        static init_CanvasTexture() {\n            this.define({\n                code: [p.String],\n            });\n        }\n        get func() {\n            const code = string_1.use_strict(this.code);\n            return new Function(\"ctx\", \"color\", \"scale\", \"weight\", \"require\", \"exports\", code);\n        }\n        get_pattern(color, scale, weight) {\n            return (ctx) => {\n                const canvas = document.createElement('canvas');\n                canvas.width = scale;\n                canvas.height = scale;\n                const pattern_ctx = canvas.getContext('2d');\n                this.func.call(this, pattern_ctx, color, scale, weight, require, {});\n                return ctx.createPattern(canvas, this.repetition);\n            };\n        }\n    }\n    exports.CanvasTexture = CanvasTexture;\n    CanvasTexture.__name__ = \"CanvasTexture\";\n    CanvasTexture.init_CanvasTexture();\n}\n","/* models/textures/texture.js */ function _(require, module, exports) {\n    const model_1 = require(64) /* ../../model */;\n    const p = require(18) /* ../../core/properties */;\n    class Texture extends model_1.Model {\n        constructor(attrs) {\n            super(attrs);\n        }\n        static init_Texture() {\n            this.define({\n                repetition: [p.TextureRepetition, \"repeat\"],\n            });\n        }\n        onload(defer_func) {\n            defer_func();\n        }\n    }\n    exports.Texture = Texture;\n    Texture.__name__ = \"Texture\";\n    Texture.init_Texture();\n}\n","/* models/textures/image_url_texture.js */ function _(require, module, exports) {\n    const texture_1 = require(305) /* ./texture */;\n    const p = require(18) /* ../../core/properties */;\n    const image_1 = require(216) /* ../../core/util/image */;\n    class ImageURLTexture extends texture_1.Texture {\n        constructor(attrs) {\n            super(attrs);\n        }\n        static init_ImageURLTexture() {\n            this.define({\n                url: [p.String],\n            });\n        }\n        initialize() {\n            super.initialize();\n            this._loader = new image_1.ImageLoader(this.url);\n        }\n        get_pattern(_color, _scale, _weight) {\n            return (ctx) => {\n                if (!this._loader.finished) {\n                    return null;\n                }\n                return ctx.createPattern(this._loader.image, this.repetition);\n            };\n        }\n        onload(defer_func) {\n            this._loader.promise.then(() => defer_func());\n        }\n    }\n    exports.ImageURLTexture = ImageURLTexture;\n    ImageURLTexture.__name__ = \"ImageURLTexture\";\n    ImageURLTexture.init_ImageURLTexture();\n}\n","/* models/tools/index.js */ function _(require, module, exports) {\n    var action_tool_1 = require(269) /* ./actions/action_tool */;\n    exports.ActionTool = action_tool_1.ActionTool;\n    var custom_action_1 = require(308) /* ./actions/custom_action */;\n    exports.CustomAction = custom_action_1.CustomAction;\n    var help_tool_1 = require(270) /* ./actions/help_tool */;\n    exports.HelpTool = help_tool_1.HelpTool;\n    var redo_tool_1 = require(309) /* ./actions/redo_tool */;\n    exports.RedoTool = redo_tool_1.RedoTool;\n    var reset_tool_1 = require(310) /* ./actions/reset_tool */;\n    exports.ResetTool = reset_tool_1.ResetTool;\n    var save_tool_1 = require(311) /* ./actions/save_tool */;\n    exports.SaveTool = save_tool_1.SaveTool;\n    var undo_tool_1 = require(312) /* ./actions/undo_tool */;\n    exports.UndoTool = undo_tool_1.UndoTool;\n    var zoom_in_tool_1 = require(313) /* ./actions/zoom_in_tool */;\n    exports.ZoomInTool = zoom_in_tool_1.ZoomInTool;\n    var zoom_out_tool_1 = require(315) /* ./actions/zoom_out_tool */;\n    exports.ZoomOutTool = zoom_out_tool_1.ZoomOutTool;\n    var button_tool_1 = require(263) /* ./button_tool */;\n    exports.ButtonTool = button_tool_1.ButtonTool;\n    var edit_tool_1 = require(316) /* ./edit/edit_tool */;\n    exports.EditTool = edit_tool_1.EditTool;\n    var box_edit_tool_1 = require(317) /* ./edit/box_edit_tool */;\n    exports.BoxEditTool = box_edit_tool_1.BoxEditTool;\n    var freehand_draw_tool_1 = require(318) /* ./edit/freehand_draw_tool */;\n    exports.FreehandDrawTool = freehand_draw_tool_1.FreehandDrawTool;\n    var point_draw_tool_1 = require(319) /* ./edit/point_draw_tool */;\n    exports.PointDrawTool = point_draw_tool_1.PointDrawTool;\n    var poly_draw_tool_1 = require(320) /* ./edit/poly_draw_tool */;\n    exports.PolyDrawTool = poly_draw_tool_1.PolyDrawTool;\n    var poly_tool_1 = require(321) /* ./edit/poly_tool */;\n    exports.PolyTool = poly_tool_1.PolyTool;\n    var poly_edit_tool_1 = require(322) /* ./edit/poly_edit_tool */;\n    exports.PolyEditTool = poly_edit_tool_1.PolyEditTool;\n    var box_select_tool_1 = require(323) /* ./gestures/box_select_tool */;\n    exports.BoxSelectTool = box_select_tool_1.BoxSelectTool;\n    var box_zoom_tool_1 = require(326) /* ./gestures/box_zoom_tool */;\n    exports.BoxZoomTool = box_zoom_tool_1.BoxZoomTool;\n    var gesture_tool_1 = require(268) /* ./gestures/gesture_tool */;\n    exports.GestureTool = gesture_tool_1.GestureTool;\n    var lasso_select_tool_1 = require(327) /* ./gestures/lasso_select_tool */;\n    exports.LassoSelectTool = lasso_select_tool_1.LassoSelectTool;\n    var pan_tool_1 = require(328) /* ./gestures/pan_tool */;\n    exports.PanTool = pan_tool_1.PanTool;\n    var poly_select_tool_1 = require(329) /* ./gestures/poly_select_tool */;\n    exports.PolySelectTool = poly_select_tool_1.PolySelectTool;\n    var range_tool_1 = require(330) /* ./gestures/range_tool */;\n    exports.RangeTool = range_tool_1.RangeTool;\n    var select_tool_1 = require(324) /* ./gestures/select_tool */;\n    exports.SelectTool = select_tool_1.SelectTool;\n    var tap_tool_1 = require(331) /* ./gestures/tap_tool */;\n    exports.TapTool = tap_tool_1.TapTool;\n    var wheel_pan_tool_1 = require(332) /* ./gestures/wheel_pan_tool */;\n    exports.WheelPanTool = wheel_pan_tool_1.WheelPanTool;\n    var wheel_zoom_tool_1 = require(333) /* ./gestures/wheel_zoom_tool */;\n    exports.WheelZoomTool = wheel_zoom_tool_1.WheelZoomTool;\n    var crosshair_tool_1 = require(334) /* ./inspectors/crosshair_tool */;\n    exports.CrosshairTool = crosshair_tool_1.CrosshairTool;\n    var customjs_hover_1 = require(335) /* ./inspectors/customjs_hover */;\n    exports.CustomJSHover = customjs_hover_1.CustomJSHover;\n    var hover_tool_1 = require(336) /* ./inspectors/hover_tool */;\n    exports.HoverTool = hover_tool_1.HoverTool;\n    var inspect_tool_1 = require(262) /* ./inspectors/inspect_tool */;\n    exports.InspectTool = inspect_tool_1.InspectTool;\n    var tool_1 = require(264) /* ./tool */;\n    exports.Tool = tool_1.Tool;\n    var tool_proxy_1 = require(337) /* ./tool_proxy */;\n    exports.ToolProxy = tool_proxy_1.ToolProxy;\n    var toolbar_1 = require(261) /* ./toolbar */;\n    exports.Toolbar = toolbar_1.Toolbar;\n    var toolbar_base_1 = require(267) /* ./toolbar_base */;\n    exports.ToolbarBase = toolbar_base_1.ToolbarBase;\n    var toolbar_box_1 = require(338) /* ./toolbar_box */;\n    exports.ProxyToolbar = toolbar_box_1.ProxyToolbar;\n    var toolbar_box_2 = require(338) /* ./toolbar_box */;\n    exports.ToolbarBox = toolbar_box_2.ToolbarBox;\n}\n","/* models/tools/actions/custom_action.js */ function _(require, module, exports) {\n    const action_tool_1 = require(269) /* ./action_tool */;\n    const p = require(18) /* ../../../core/properties */;\n    const toolbar_1 = require(265) /* ../../../styles/toolbar */;\n    class CustomActionButtonView extends action_tool_1.ActionToolButtonView {\n        css_classes() {\n            return super.css_classes().concat(toolbar_1.bk_toolbar_button_custom_action);\n        }\n    }\n    exports.CustomActionButtonView = CustomActionButtonView;\n    CustomActionButtonView.__name__ = \"CustomActionButtonView\";\n    class CustomActionView extends action_tool_1.ActionToolView {\n        doit() {\n            if (this.model.callback != null)\n                this.model.callback.execute(this.model);\n        }\n    }\n    exports.CustomActionView = CustomActionView;\n    CustomActionView.__name__ = \"CustomActionView\";\n    class CustomAction extends action_tool_1.ActionTool {\n        constructor(attrs) {\n            super(attrs);\n            this.tool_name = \"Custom Action\";\n            this.button_view = CustomActionButtonView;\n        }\n        static init_CustomAction() {\n            this.prototype.default_view = CustomActionView;\n            this.define({\n                action_tooltip: [p.String, 'Perform a Custom Action'],\n                callback: [p.Any],\n                icon: [p.String],\n            });\n        }\n        get tooltip() {\n            return this.action_tooltip;\n        }\n    }\n    exports.CustomAction = CustomAction;\n    CustomAction.__name__ = \"CustomAction\";\n    CustomAction.init_CustomAction();\n}\n","/* models/tools/actions/redo_tool.js */ function _(require, module, exports) {\n    const action_tool_1 = require(269) /* ./action_tool */;\n    const icons_1 = require(271) /* ../../../styles/icons */;\n    class RedoToolView extends action_tool_1.ActionToolView {\n        connect_signals() {\n            super.connect_signals();\n            this.connect(this.plot_view.state_changed, () => this.model.disabled = !this.plot_view.can_redo());\n        }\n        doit() {\n            this.plot_view.redo();\n        }\n    }\n    exports.RedoToolView = RedoToolView;\n    RedoToolView.__name__ = \"RedoToolView\";\n    class RedoTool extends action_tool_1.ActionTool {\n        constructor(attrs) {\n            super(attrs);\n            this.tool_name = \"Redo\";\n            this.icon = icons_1.bk_tool_icon_redo;\n        }\n        static init_RedoTool() {\n            this.prototype.default_view = RedoToolView;\n            this.override({\n                disabled: true,\n            });\n        }\n    }\n    exports.RedoTool = RedoTool;\n    RedoTool.__name__ = \"RedoTool\";\n    RedoTool.init_RedoTool();\n}\n","/* models/tools/actions/reset_tool.js */ function _(require, module, exports) {\n    const action_tool_1 = require(269) /* ./action_tool */;\n    const icons_1 = require(271) /* ../../../styles/icons */;\n    class ResetToolView extends action_tool_1.ActionToolView {\n        doit() {\n            this.plot_view.reset();\n        }\n    }\n    exports.ResetToolView = ResetToolView;\n    ResetToolView.__name__ = \"ResetToolView\";\n    class ResetTool extends action_tool_1.ActionTool {\n        constructor(attrs) {\n            super(attrs);\n            this.tool_name = \"Reset\";\n            this.icon = icons_1.bk_tool_icon_reset;\n        }\n        static init_ResetTool() {\n            this.prototype.default_view = ResetToolView;\n        }\n    }\n    exports.ResetTool = ResetTool;\n    ResetTool.__name__ = \"ResetTool\";\n    ResetTool.init_ResetTool();\n}\n","/* models/tools/actions/save_tool.js */ function _(require, module, exports) {\n    const action_tool_1 = require(269) /* ./action_tool */;\n    const icons_1 = require(271) /* ../../../styles/icons */;\n    class SaveToolView extends action_tool_1.ActionToolView {\n        doit() {\n            this.plot_view.save(\"bokeh_plot\");\n        }\n    }\n    exports.SaveToolView = SaveToolView;\n    SaveToolView.__name__ = \"SaveToolView\";\n    class SaveTool extends action_tool_1.ActionTool {\n        constructor(attrs) {\n            super(attrs);\n            this.tool_name = \"Save\";\n            this.icon = icons_1.bk_tool_icon_save;\n        }\n        static init_SaveTool() {\n            this.prototype.default_view = SaveToolView;\n        }\n    }\n    exports.SaveTool = SaveTool;\n    SaveTool.__name__ = \"SaveTool\";\n    SaveTool.init_SaveTool();\n}\n","/* models/tools/actions/undo_tool.js */ function _(require, module, exports) {\n    const action_tool_1 = require(269) /* ./action_tool */;\n    const icons_1 = require(271) /* ../../../styles/icons */;\n    class UndoToolView extends action_tool_1.ActionToolView {\n        connect_signals() {\n            super.connect_signals();\n            this.connect(this.plot_view.state_changed, () => this.model.disabled = !this.plot_view.can_undo());\n        }\n        doit() {\n            this.plot_view.undo();\n        }\n    }\n    exports.UndoToolView = UndoToolView;\n    UndoToolView.__name__ = \"UndoToolView\";\n    class UndoTool extends action_tool_1.ActionTool {\n        constructor(attrs) {\n            super(attrs);\n            this.tool_name = \"Undo\";\n            this.icon = icons_1.bk_tool_icon_undo;\n        }\n        static init_UndoTool() {\n            this.prototype.default_view = UndoToolView;\n            this.override({\n                disabled: true,\n            });\n        }\n    }\n    exports.UndoTool = UndoTool;\n    UndoTool.__name__ = \"UndoTool\";\n    UndoTool.init_UndoTool();\n}\n","/* models/tools/actions/zoom_in_tool.js */ function _(require, module, exports) {\n    const action_tool_1 = require(269) /* ./action_tool */;\n    const zoom_1 = require(314) /* ../../../core/util/zoom */;\n    const p = require(18) /* ../../../core/properties */;\n    const icons_1 = require(271) /* ../../../styles/icons */;\n    class ZoomInToolView extends action_tool_1.ActionToolView {\n        doit() {\n            const frame = this.plot_view.frame;\n            const dims = this.model.dimensions;\n            // restrict to axis configured in tool's dimensions property\n            const h_axis = dims == 'width' || dims == 'both';\n            const v_axis = dims == 'height' || dims == 'both';\n            const zoom_info = zoom_1.scale_range(frame, this.model.factor, h_axis, v_axis);\n            this.plot_view.push_state('zoom_out', { range: zoom_info });\n            this.plot_view.update_range(zoom_info, false, true);\n            if (this.model.document)\n                this.model.document.interactive_start(this.plot_model);\n        }\n    }\n    exports.ZoomInToolView = ZoomInToolView;\n    ZoomInToolView.__name__ = \"ZoomInToolView\";\n    class ZoomInTool extends action_tool_1.ActionTool {\n        constructor(attrs) {\n            super(attrs);\n            this.tool_name = \"Zoom In\";\n            this.icon = icons_1.bk_tool_icon_zoom_in;\n        }\n        static init_ZoomInTool() {\n            this.prototype.default_view = ZoomInToolView;\n            this.define({\n                factor: [p.Percent, 0.1],\n                dimensions: [p.Dimensions, \"both\"],\n            });\n        }\n        get tooltip() {\n            return this._get_dim_tooltip(this.tool_name, this.dimensions);\n        }\n    }\n    exports.ZoomInTool = ZoomInTool;\n    ZoomInTool.__name__ = \"ZoomInTool\";\n    ZoomInTool.init_ZoomInTool();\n}\n","/* core/util/zoom.js */ function _(require, module, exports) {\n    const math_1 = require(9) /* ./math */;\n    // Module for zoom-related functions\n    function scale_highlow(range, factor, center) {\n        const [low, high] = [range.start, range.end];\n        const x = center != null ? center : (high + low) / 2.0;\n        const x0 = low - (low - x) * factor;\n        const x1 = high - (high - x) * factor;\n        return [x0, x1];\n    }\n    exports.scale_highlow = scale_highlow;\n    function get_info(scales, [sxy0, sxy1]) {\n        const info = {};\n        for (const name in scales) {\n            const scale = scales[name];\n            const [start, end] = scale.r_invert(sxy0, sxy1);\n            info[name] = { start, end };\n        }\n        return info;\n    }\n    exports.get_info = get_info;\n    function scale_range(frame, factor, h_axis = true, v_axis = true, center) {\n        /*\n         * Utility function for zoom tools to calculate/create the zoom_info object\n         * of the form required by ``PlotView.update_range``\n         *\n         * Parameters:\n         *   frame : CartesianFrame\n         *   factor : Number\n         *   h_axis : Boolean, optional\n         *     whether to zoom the horizontal axis (default = true)\n         *   v_axis : Boolean, optional\n         *     whether to zoom the horizontal axis (default = true)\n         *   center : object, optional\n         *     of form {'x': Number, 'y', Number}\n         *\n         * Returns:\n         *   object:\n         */\n        // clamp the  magnitude of factor, if it is > 1 bad things happen\n        factor = math_1.clamp(factor, -0.9, 0.9);\n        const hfactor = h_axis ? factor : 0;\n        const [sx0, sx1] = scale_highlow(frame.bbox.h_range, hfactor, center != null ? center.x : undefined);\n        const xrs = get_info(frame.xscales, [sx0, sx1]);\n        const vfactor = v_axis ? factor : 0;\n        const [sy0, sy1] = scale_highlow(frame.bbox.v_range, vfactor, center != null ? center.y : undefined);\n        const yrs = get_info(frame.yscales, [sy0, sy1]);\n        // OK this sucks we can't set factor independently in each direction. It is used\n        // for GMap plots, and GMap plots always preserve aspect, so effective the value\n        // of 'dimensions' is ignored.\n        return { xrs, yrs, factor };\n    }\n    exports.scale_range = scale_range;\n}\n","/* models/tools/actions/zoom_out_tool.js */ function _(require, module, exports) {\n    const action_tool_1 = require(269) /* ./action_tool */;\n    const zoom_1 = require(314) /* ../../../core/util/zoom */;\n    const p = require(18) /* ../../../core/properties */;\n    const icons_1 = require(271) /* ../../../styles/icons */;\n    class ZoomOutToolView extends action_tool_1.ActionToolView {\n        doit() {\n            const frame = this.plot_view.frame;\n            const dims = this.model.dimensions;\n            // restrict to axis configured in tool's dimensions property\n            const h_axis = dims == 'width' || dims == 'both';\n            const v_axis = dims == 'height' || dims == 'both';\n            // zooming out requires a negative factor to scale_range\n            const zoom_info = zoom_1.scale_range(frame, -this.model.factor, h_axis, v_axis);\n            this.plot_view.push_state('zoom_out', { range: zoom_info });\n            this.plot_view.update_range(zoom_info, false, true);\n            if (this.model.document)\n                this.model.document.interactive_start(this.plot_model);\n        }\n    }\n    exports.ZoomOutToolView = ZoomOutToolView;\n    ZoomOutToolView.__name__ = \"ZoomOutToolView\";\n    class ZoomOutTool extends action_tool_1.ActionTool {\n        constructor(attrs) {\n            super(attrs);\n            this.tool_name = \"Zoom Out\";\n            this.icon = icons_1.bk_tool_icon_zoom_out;\n        }\n        static init_ZoomOutTool() {\n            this.prototype.default_view = ZoomOutToolView;\n            this.define({\n                factor: [p.Percent, 0.1],\n                dimensions: [p.Dimensions, \"both\"],\n            });\n        }\n        get tooltip() {\n            return this._get_dim_tooltip(this.tool_name, this.dimensions);\n        }\n    }\n    exports.ZoomOutTool = ZoomOutTool;\n    ZoomOutTool.__name__ = \"ZoomOutTool\";\n    ZoomOutTool.init_ZoomOutTool();\n}\n","/* models/tools/edit/edit_tool.js */ function _(require, module, exports) {\n    const p = require(18) /* ../../../core/properties */;\n    const array_1 = require(8) /* ../../../core/util/array */;\n    const types_1 = require(7) /* ../../../core/util/types */;\n    const gesture_tool_1 = require(268) /* ../gestures/gesture_tool */;\n    class EditToolView extends gesture_tool_1.GestureToolView {\n        constructor() {\n            super(...arguments);\n            this._mouse_in_frame = true;\n        }\n        _move_enter(_e) {\n            this._mouse_in_frame = true;\n        }\n        _move_exit(_e) {\n            this._mouse_in_frame = false;\n        }\n        _map_drag(sx, sy, renderer) {\n            // Maps screen to data coordinates\n            const frame = this.plot_view.frame;\n            if (!frame.bbox.contains(sx, sy)) {\n                return null;\n            }\n            const x = frame.xscales[renderer.x_range_name].invert(sx);\n            const y = frame.yscales[renderer.y_range_name].invert(sy);\n            return [x, y];\n        }\n        _delete_selected(renderer) {\n            // Deletes all selected rows in the ColumnDataSource\n            const cds = renderer.data_source;\n            const indices = cds.selected.indices;\n            indices.sort();\n            for (const column of cds.columns()) {\n                const values = cds.get_array(column);\n                for (let index = 0; index < indices.length; index++) {\n                    const ind = indices[index];\n                    values.splice(ind - index, 1);\n                }\n            }\n            this._emit_cds_changes(cds);\n        }\n        _pop_glyphs(cds, num_objects) {\n            // Pops rows in the CDS until only num_objects are left\n            const columns = cds.columns();\n            if (!num_objects || !columns.length)\n                return;\n            for (const column of columns) {\n                let array = cds.get_array(column);\n                const drop = array.length - num_objects + 1;\n                if (drop < 1)\n                    continue;\n                if (!types_1.isArray(array)) {\n                    array = Array.from(array);\n                    cds.data[column] = array;\n                }\n                array.splice(0, drop);\n            }\n        }\n        _emit_cds_changes(cds, redraw = true, clear = true, emit = true) {\n            if (clear)\n                cds.selection_manager.clear();\n            if (redraw)\n                cds.change.emit();\n            if (emit) {\n                cds.data = cds.data;\n                cds.properties.data.change.emit();\n            }\n        }\n        _drag_points(ev, renderers) {\n            if (this._basepoint == null)\n                return;\n            const [bx, by] = this._basepoint;\n            for (const renderer of renderers) {\n                const basepoint = this._map_drag(bx, by, renderer);\n                const point = this._map_drag(ev.sx, ev.sy, renderer);\n                if (point == null || basepoint == null) {\n                    continue;\n                }\n                const [x, y] = point;\n                const [px, py] = basepoint;\n                const [dx, dy] = [x - px, y - py];\n                // Type once dataspecs are typed\n                const glyph = renderer.glyph;\n                const cds = renderer.data_source;\n                const [xkey, ykey] = [glyph.x.field, glyph.y.field];\n                for (const index of cds.selected.indices) {\n                    if (xkey)\n                        cds.data[xkey][index] += dx;\n                    if (ykey)\n                        cds.data[ykey][index] += dy;\n                }\n                cds.change.emit();\n            }\n            this._basepoint = [ev.sx, ev.sy];\n        }\n        _pad_empty_columns(cds, coord_columns) {\n            // Pad ColumnDataSource non-coordinate columns with empty_value\n            for (const column of cds.columns()) {\n                if (!array_1.includes(coord_columns, column))\n                    cds.get_array(column).push(this.model.empty_value);\n            }\n        }\n        _select_event(ev, append, renderers) {\n            // Process selection event on the supplied renderers and return selected renderers\n            const frame = this.plot_view.frame;\n            const { sx, sy } = ev;\n            if (!frame.bbox.contains(sx, sy)) {\n                return [];\n            }\n            const geometry = { type: 'point', sx, sy };\n            const selected = [];\n            for (const renderer of renderers) {\n                const sm = renderer.get_selection_manager();\n                const cds = renderer.data_source;\n                const views = [this.plot_view.renderer_views[renderer.id]];\n                const did_hit = sm.select(views, geometry, true, append);\n                if (did_hit) {\n                    selected.push(renderer);\n                }\n                cds.properties.selected.change.emit();\n            }\n            return selected;\n        }\n    }\n    exports.EditToolView = EditToolView;\n    EditToolView.__name__ = \"EditToolView\";\n    class EditTool extends gesture_tool_1.GestureTool {\n        constructor(attrs) {\n            super(attrs);\n        }\n        static init_EditTool() {\n            this.define({\n                custom_icon: [p.String],\n                custom_tooltip: [p.String],\n                empty_value: [p.Any],\n                renderers: [p.Array, []],\n            });\n        }\n        get tooltip() {\n            return this.custom_tooltip || this.tool_name;\n        }\n        get computed_icon() {\n            return this.custom_icon || this.icon;\n        }\n    }\n    exports.EditTool = EditTool;\n    EditTool.__name__ = \"EditTool\";\n    EditTool.init_EditTool();\n}\n","/* models/tools/edit/box_edit_tool.js */ function _(require, module, exports) {\n    const dom_1 = require(61) /* ../../../core/dom */;\n    const p = require(18) /* ../../../core/properties */;\n    const edit_tool_1 = require(316) /* ./edit_tool */;\n    const icons_1 = require(271) /* ../../../styles/icons */;\n    class BoxEditToolView extends edit_tool_1.EditToolView {\n        _tap(ev) {\n            if ((this._draw_basepoint != null) || (this._basepoint != null))\n                return;\n            const append = ev.shiftKey;\n            this._select_event(ev, append, this.model.renderers);\n        }\n        _keyup(ev) {\n            if (!this.model.active || !this._mouse_in_frame)\n                return;\n            for (const renderer of this.model.renderers) {\n                if (ev.keyCode === dom_1.Keys.Backspace) {\n                    this._delete_selected(renderer);\n                }\n                else if (ev.keyCode == dom_1.Keys.Esc) {\n                    // Type properly once selection_manager is typed\n                    const cds = renderer.data_source;\n                    cds.selection_manager.clear();\n                }\n            }\n        }\n        _set_extent([sx0, sx1], [sy0, sy1], append, emit = false) {\n            const renderer = this.model.renderers[0];\n            const frame = this.plot_view.frame;\n            // Type once dataspecs are typed\n            const glyph = renderer.glyph;\n            const cds = renderer.data_source;\n            const xscale = frame.xscales[renderer.x_range_name];\n            const yscale = frame.yscales[renderer.y_range_name];\n            const [x0, x1] = xscale.r_invert(sx0, sx1);\n            const [y0, y1] = yscale.r_invert(sy0, sy1);\n            const [x, y] = [(x0 + x1) / 2, (y0 + y1) / 2];\n            const [w, h] = [x1 - x0, y1 - y0];\n            const [xkey, ykey] = [glyph.x.field, glyph.y.field];\n            const [wkey, hkey] = [glyph.width.field, glyph.height.field];\n            if (append) {\n                this._pop_glyphs(cds, this.model.num_objects);\n                if (xkey)\n                    cds.get_array(xkey).push(x);\n                if (ykey)\n                    cds.get_array(ykey).push(y);\n                if (wkey)\n                    cds.get_array(wkey).push(w);\n                if (hkey)\n                    cds.get_array(hkey).push(h);\n                this._pad_empty_columns(cds, [xkey, ykey, wkey, hkey]);\n            }\n            else {\n                const index = cds.data[xkey].length - 1;\n                if (xkey)\n                    cds.data[xkey][index] = x;\n                if (ykey)\n                    cds.data[ykey][index] = y;\n                if (wkey)\n                    cds.data[wkey][index] = w;\n                if (hkey)\n                    cds.data[hkey][index] = h;\n            }\n            this._emit_cds_changes(cds, true, false, emit);\n        }\n        _update_box(ev, append = false, emit = false) {\n            if (this._draw_basepoint == null)\n                return;\n            const curpoint = [ev.sx, ev.sy];\n            const frame = this.plot_view.frame;\n            const dims = this.model.dimensions;\n            const limits = this.model._get_dim_limits(this._draw_basepoint, curpoint, frame, dims);\n            if (limits != null) {\n                const [sxlim, sylim] = limits;\n                this._set_extent(sxlim, sylim, append, emit);\n            }\n        }\n        _doubletap(ev) {\n            if (!this.model.active)\n                return;\n            if (this._draw_basepoint != null) {\n                this._update_box(ev, false, true);\n                this._draw_basepoint = null;\n            }\n            else {\n                this._draw_basepoint = [ev.sx, ev.sy];\n                this._select_event(ev, true, this.model.renderers);\n                this._update_box(ev, true, false);\n            }\n        }\n        _move(ev) {\n            this._update_box(ev, false, false);\n        }\n        _pan_start(ev) {\n            if (ev.shiftKey) {\n                if (this._draw_basepoint != null)\n                    return;\n                this._draw_basepoint = [ev.sx, ev.sy];\n                this._update_box(ev, true, false);\n            }\n            else {\n                if (this._basepoint != null)\n                    return;\n                this._select_event(ev, true, this.model.renderers);\n                this._basepoint = [ev.sx, ev.sy];\n            }\n        }\n        _pan(ev, append = false, emit = false) {\n            if (ev.shiftKey) {\n                if (this._draw_basepoint == null)\n                    return;\n                this._update_box(ev, append, emit);\n            }\n            else {\n                if (this._basepoint == null)\n                    return;\n                this._drag_points(ev, this.model.renderers);\n            }\n        }\n        _pan_end(ev) {\n            this._pan(ev, false, true);\n            if (ev.shiftKey) {\n                this._draw_basepoint = null;\n            }\n            else {\n                this._basepoint = null;\n                for (const renderer of this.model.renderers)\n                    this._emit_cds_changes(renderer.data_source, false, true, true);\n            }\n        }\n    }\n    exports.BoxEditToolView = BoxEditToolView;\n    BoxEditToolView.__name__ = \"BoxEditToolView\";\n    class BoxEditTool extends edit_tool_1.EditTool {\n        constructor(attrs) {\n            super(attrs);\n            this.tool_name = \"Box Edit Tool\";\n            this.icon = icons_1.bk_tool_icon_box_edit;\n            this.event_type = [\"tap\", \"pan\", \"move\"];\n            this.default_order = 1;\n        }\n        static init_BoxEditTool() {\n            this.prototype.default_view = BoxEditToolView;\n            this.define({\n                dimensions: [p.Dimensions, \"both\"],\n                num_objects: [p.Int, 0],\n            });\n        }\n    }\n    exports.BoxEditTool = BoxEditTool;\n    BoxEditTool.__name__ = \"BoxEditTool\";\n    BoxEditTool.init_BoxEditTool();\n}\n","/* models/tools/edit/freehand_draw_tool.js */ function _(require, module, exports) {\n    const dom_1 = require(61) /* ../../../core/dom */;\n    const p = require(18) /* ../../../core/properties */;\n    const types_1 = require(7) /* ../../../core/util/types */;\n    const edit_tool_1 = require(316) /* ./edit_tool */;\n    const icons_1 = require(271) /* ../../../styles/icons */;\n    class FreehandDrawToolView extends edit_tool_1.EditToolView {\n        _draw(ev, mode, emit = false) {\n            if (!this.model.active)\n                return;\n            const renderer = this.model.renderers[0];\n            const point = this._map_drag(ev.sx, ev.sy, renderer);\n            if (point == null)\n                return;\n            const [x, y] = point;\n            const cds = renderer.data_source;\n            const glyph = renderer.glyph;\n            const [xkey, ykey] = [glyph.xs.field, glyph.ys.field];\n            if (mode == 'new') {\n                this._pop_glyphs(cds, this.model.num_objects);\n                if (xkey)\n                    cds.get_array(xkey).push([x]);\n                if (ykey)\n                    cds.get_array(ykey).push([y]);\n                this._pad_empty_columns(cds, [xkey, ykey]);\n            }\n            else if (mode == 'add') {\n                if (xkey) {\n                    const xidx = cds.data[xkey].length - 1;\n                    let xs = cds.get_array(xkey)[xidx];\n                    if (!types_1.isArray(xs)) {\n                        xs = Array.from(xs);\n                        cds.data[xkey][xidx] = xs;\n                    }\n                    xs.push(x);\n                }\n                if (ykey) {\n                    const yidx = cds.data[ykey].length - 1;\n                    let ys = cds.get_array(ykey)[yidx];\n                    if (!types_1.isArray(ys)) {\n                        ys = Array.from(ys);\n                        cds.data[ykey][yidx] = ys;\n                    }\n                    ys.push(y);\n                }\n            }\n            this._emit_cds_changes(cds, true, true, emit);\n        }\n        _pan_start(ev) {\n            this._draw(ev, 'new');\n        }\n        _pan(ev) {\n            this._draw(ev, 'add');\n        }\n        _pan_end(ev) {\n            this._draw(ev, 'add', true);\n        }\n        _tap(ev) {\n            this._select_event(ev, ev.shiftKey, this.model.renderers);\n        }\n        _keyup(ev) {\n            if (!this.model.active || !this._mouse_in_frame)\n                return;\n            for (const renderer of this.model.renderers) {\n                if (ev.keyCode === dom_1.Keys.Esc) {\n                    renderer.data_source.selection_manager.clear();\n                }\n                else if (ev.keyCode === dom_1.Keys.Backspace) {\n                    this._delete_selected(renderer);\n                }\n            }\n        }\n    }\n    exports.FreehandDrawToolView = FreehandDrawToolView;\n    FreehandDrawToolView.__name__ = \"FreehandDrawToolView\";\n    class FreehandDrawTool extends edit_tool_1.EditTool {\n        constructor(attrs) {\n            super(attrs);\n            this.tool_name = \"Freehand Draw Tool\";\n            this.icon = icons_1.bk_tool_icon_freehand_draw;\n            this.event_type = [\"pan\", \"tap\"];\n            this.default_order = 3;\n        }\n        static init_FreehandDrawTool() {\n            this.prototype.default_view = FreehandDrawToolView;\n            this.define({\n                num_objects: [p.Int, 0],\n            });\n        }\n    }\n    exports.FreehandDrawTool = FreehandDrawTool;\n    FreehandDrawTool.__name__ = \"FreehandDrawTool\";\n    FreehandDrawTool.init_FreehandDrawTool();\n}\n","/* models/tools/edit/point_draw_tool.js */ function _(require, module, exports) {\n    const dom_1 = require(61) /* ../../../core/dom */;\n    const p = require(18) /* ../../../core/properties */;\n    const edit_tool_1 = require(316) /* ./edit_tool */;\n    const icons_1 = require(271) /* ../../../styles/icons */;\n    class PointDrawToolView extends edit_tool_1.EditToolView {\n        _tap(ev) {\n            const append = ev.shiftKey;\n            const renderers = this._select_event(ev, append, this.model.renderers);\n            if (renderers.length || !this.model.add) {\n                return;\n            }\n            const renderer = this.model.renderers[0];\n            const point = this._map_drag(ev.sx, ev.sy, renderer);\n            if (point == null)\n                return;\n            // Type once dataspecs are typed\n            const glyph = renderer.glyph;\n            const cds = renderer.data_source;\n            const [xkey, ykey] = [glyph.x.field, glyph.y.field];\n            const [x, y] = point;\n            this._pop_glyphs(cds, this.model.num_objects);\n            if (xkey)\n                cds.get_array(xkey).push(x);\n            if (ykey)\n                cds.get_array(ykey).push(y);\n            this._pad_empty_columns(cds, [xkey, ykey]);\n            cds.change.emit();\n            cds.data = cds.data;\n            cds.properties.data.change.emit();\n        }\n        _keyup(ev) {\n            if (!this.model.active || !this._mouse_in_frame)\n                return;\n            for (const renderer of this.model.renderers) {\n                if (ev.keyCode === dom_1.Keys.Backspace) {\n                    this._delete_selected(renderer);\n                }\n                else if (ev.keyCode == dom_1.Keys.Esc) {\n                    renderer.data_source.selection_manager.clear();\n                }\n            }\n        }\n        _pan_start(ev) {\n            if (!this.model.drag)\n                return;\n            this._select_event(ev, true, this.model.renderers);\n            this._basepoint = [ev.sx, ev.sy];\n        }\n        _pan(ev) {\n            if (!this.model.drag || this._basepoint == null)\n                return;\n            this._drag_points(ev, this.model.renderers);\n        }\n        _pan_end(ev) {\n            if (!this.model.drag)\n                return;\n            this._pan(ev);\n            for (const renderer of this.model.renderers)\n                this._emit_cds_changes(renderer.data_source, false, true, true);\n            this._basepoint = null;\n        }\n    }\n    exports.PointDrawToolView = PointDrawToolView;\n    PointDrawToolView.__name__ = \"PointDrawToolView\";\n    class PointDrawTool extends edit_tool_1.EditTool {\n        constructor(attrs) {\n            super(attrs);\n            this.tool_name = \"Point Draw Tool\";\n            this.icon = icons_1.bk_tool_icon_point_draw;\n            this.event_type = [\"tap\", \"pan\", \"move\"];\n            this.default_order = 2;\n        }\n        static init_PointDrawTool() {\n            this.prototype.default_view = PointDrawToolView;\n            this.define({\n                add: [p.Boolean, true],\n                drag: [p.Boolean, true],\n                num_objects: [p.Int, 0],\n            });\n        }\n    }\n    exports.PointDrawTool = PointDrawTool;\n    PointDrawTool.__name__ = \"PointDrawTool\";\n    PointDrawTool.init_PointDrawTool();\n}\n","/* models/tools/edit/poly_draw_tool.js */ function _(require, module, exports) {\n    const dom_1 = require(61) /* ../../../core/dom */;\n    const p = require(18) /* ../../../core/properties */;\n    const types_1 = require(7) /* ../../../core/util/types */;\n    const poly_tool_1 = require(321) /* ./poly_tool */;\n    const icons_1 = require(271) /* ../../../styles/icons */;\n    class PolyDrawToolView extends poly_tool_1.PolyToolView {\n        constructor() {\n            super(...arguments);\n            this._drawing = false;\n            this._initialized = false;\n        }\n        _tap(ev) {\n            if (this._drawing)\n                this._draw(ev, 'add', true);\n            else\n                this._select_event(ev, ev.shiftKey, this.model.renderers);\n        }\n        _draw(ev, mode, emit = false) {\n            const renderer = this.model.renderers[0];\n            const point = this._map_drag(ev.sx, ev.sy, renderer);\n            if (!this._initialized)\n                this.activate(); // Ensure that activate has been called\n            if (point == null)\n                return;\n            const [x, y] = this._snap_to_vertex(ev, ...point);\n            const cds = renderer.data_source;\n            const glyph = renderer.glyph;\n            const [xkey, ykey] = [glyph.xs.field, glyph.ys.field];\n            if (mode == 'new') {\n                this._pop_glyphs(cds, this.model.num_objects);\n                if (xkey)\n                    cds.get_array(xkey).push([x, x]);\n                if (ykey)\n                    cds.get_array(ykey).push([y, y]);\n                this._pad_empty_columns(cds, [xkey, ykey]);\n            }\n            else if (mode == 'edit') {\n                if (xkey) {\n                    const xs = cds.data[xkey][cds.data[xkey].length - 1];\n                    xs[xs.length - 1] = x;\n                }\n                if (ykey) {\n                    const ys = cds.data[ykey][cds.data[ykey].length - 1];\n                    ys[ys.length - 1] = y;\n                }\n            }\n            else if (mode == 'add') {\n                if (xkey) {\n                    const xidx = cds.data[xkey].length - 1;\n                    let xs = cds.get_array(xkey)[xidx];\n                    const nx = xs[xs.length - 1];\n                    xs[xs.length - 1] = x;\n                    if (!types_1.isArray(xs)) {\n                        xs = Array.from(xs);\n                        cds.data[xkey][xidx] = xs;\n                    }\n                    xs.push(nx);\n                }\n                if (ykey) {\n                    const yidx = cds.data[ykey].length - 1;\n                    let ys = cds.get_array(ykey)[yidx];\n                    const ny = ys[ys.length - 1];\n                    ys[ys.length - 1] = y;\n                    if (!types_1.isArray(ys)) {\n                        ys = Array.from(ys);\n                        cds.data[ykey][yidx] = ys;\n                    }\n                    ys.push(ny);\n                }\n            }\n            this._emit_cds_changes(cds, true, false, emit);\n        }\n        _show_vertices() {\n            if (!this.model.active) {\n                return;\n            }\n            const xs = [];\n            const ys = [];\n            for (let i = 0; i < this.model.renderers.length; i++) {\n                const renderer = this.model.renderers[i];\n                const cds = renderer.data_source;\n                const glyph = renderer.glyph;\n                const [xkey, ykey] = [glyph.xs.field, glyph.ys.field];\n                if (xkey) {\n                    for (const array of cds.get_array(xkey))\n                        Array.prototype.push.apply(xs, array);\n                }\n                if (ykey) {\n                    for (const array of cds.get_array(ykey))\n                        Array.prototype.push.apply(ys, array);\n                }\n                if (this._drawing && (i == (this.model.renderers.length - 1))) {\n                    // Skip currently drawn vertex\n                    xs.splice(xs.length - 1, 1);\n                    ys.splice(ys.length - 1, 1);\n                }\n            }\n            this._set_vertices(xs, ys);\n        }\n        _doubletap(ev) {\n            if (!this.model.active)\n                return;\n            if (this._drawing) {\n                this._drawing = false;\n                this._draw(ev, 'edit', true);\n            }\n            else {\n                this._drawing = true;\n                this._draw(ev, 'new', true);\n            }\n        }\n        _move(ev) {\n            if (this._drawing) {\n                this._draw(ev, 'edit');\n            }\n        }\n        _remove() {\n            const renderer = this.model.renderers[0];\n            const cds = renderer.data_source;\n            const glyph = renderer.glyph;\n            const [xkey, ykey] = [glyph.xs.field, glyph.ys.field];\n            if (xkey) {\n                const xidx = cds.data[xkey].length - 1;\n                const xs = cds.get_array(xkey)[xidx];\n                xs.splice(xs.length - 1, 1);\n            }\n            if (ykey) {\n                const yidx = cds.data[ykey].length - 1;\n                const ys = cds.get_array(ykey)[yidx];\n                ys.splice(ys.length - 1, 1);\n            }\n            this._emit_cds_changes(cds);\n        }\n        _keyup(ev) {\n            if (!this.model.active || !this._mouse_in_frame)\n                return;\n            for (const renderer of this.model.renderers) {\n                if (ev.keyCode === dom_1.Keys.Backspace) {\n                    this._delete_selected(renderer);\n                }\n                else if (ev.keyCode == dom_1.Keys.Esc) {\n                    if (this._drawing) {\n                        this._remove();\n                        this._drawing = false;\n                    }\n                    renderer.data_source.selection_manager.clear();\n                }\n            }\n        }\n        _pan_start(ev) {\n            if (!this.model.drag)\n                return;\n            this._select_event(ev, true, this.model.renderers);\n            this._basepoint = [ev.sx, ev.sy];\n        }\n        _pan(ev) {\n            if (this._basepoint == null || !this.model.drag)\n                return;\n            const [bx, by] = this._basepoint;\n            // Process polygon/line dragging\n            for (const renderer of this.model.renderers) {\n                const basepoint = this._map_drag(bx, by, renderer);\n                const point = this._map_drag(ev.sx, ev.sy, renderer);\n                if (point == null || basepoint == null)\n                    continue;\n                const cds = renderer.data_source;\n                // Type once dataspecs are typed\n                const glyph = renderer.glyph;\n                const [xkey, ykey] = [glyph.xs.field, glyph.ys.field];\n                if (!xkey && !ykey)\n                    continue;\n                const [x, y] = point;\n                const [px, py] = basepoint;\n                const [dx, dy] = [x - px, y - py];\n                for (const index of cds.selected.indices) {\n                    let length, xs, ys;\n                    if (xkey)\n                        xs = cds.data[xkey][index];\n                    if (ykey) {\n                        ys = cds.data[ykey][index];\n                        length = ys.length;\n                    }\n                    else {\n                        length = xs.length;\n                    }\n                    for (let i = 0; i < length; i++) {\n                        if (xs)\n                            xs[i] += dx;\n                        if (ys)\n                            ys[i] += dy;\n                    }\n                }\n                cds.change.emit();\n            }\n            this._basepoint = [ev.sx, ev.sy];\n        }\n        _pan_end(ev) {\n            if (!this.model.drag)\n                return;\n            this._pan(ev);\n            for (const renderer of this.model.renderers)\n                this._emit_cds_changes(renderer.data_source);\n            this._basepoint = null;\n        }\n        activate() {\n            if (!this.model.vertex_renderer || !this.model.active)\n                return;\n            this._show_vertices();\n            if (!this._initialized) {\n                for (const renderer of this.model.renderers) {\n                    const cds = renderer.data_source;\n                    cds.connect(cds.properties.data.change, () => this._show_vertices());\n                }\n            }\n            this._initialized = true;\n        }\n        deactivate() {\n            if (this._drawing) {\n                this._remove();\n                this._drawing = false;\n            }\n            if (this.model.vertex_renderer)\n                this._hide_vertices();\n        }\n    }\n    exports.PolyDrawToolView = PolyDrawToolView;\n    PolyDrawToolView.__name__ = \"PolyDrawToolView\";\n    class PolyDrawTool extends poly_tool_1.PolyTool {\n        constructor(attrs) {\n            super(attrs);\n            this.tool_name = \"Polygon Draw Tool\";\n            this.icon = icons_1.bk_tool_icon_poly_draw;\n            this.event_type = [\"pan\", \"tap\", \"move\"];\n            this.default_order = 3;\n        }\n        static init_PolyDrawTool() {\n            this.prototype.default_view = PolyDrawToolView;\n            this.define({\n                drag: [p.Boolean, true],\n                num_objects: [p.Int, 0],\n            });\n        }\n    }\n    exports.PolyDrawTool = PolyDrawTool;\n    PolyDrawTool.__name__ = \"PolyDrawTool\";\n    PolyDrawTool.init_PolyDrawTool();\n}\n","/* models/tools/edit/poly_tool.js */ function _(require, module, exports) {\n    const p = require(18) /* ../../../core/properties */;\n    const types_1 = require(7) /* ../../../core/util/types */;\n    const edit_tool_1 = require(316) /* ./edit_tool */;\n    class PolyToolView extends edit_tool_1.EditToolView {\n        _set_vertices(xs, ys) {\n            const point_glyph = this.model.vertex_renderer.glyph;\n            const point_cds = this.model.vertex_renderer.data_source;\n            const [pxkey, pykey] = [point_glyph.x.field, point_glyph.y.field];\n            if (pxkey) {\n                if (types_1.isArray(xs))\n                    point_cds.data[pxkey] = xs;\n                else\n                    point_glyph.x = { value: xs };\n            }\n            if (pykey) {\n                if (types_1.isArray(ys))\n                    point_cds.data[pykey] = ys;\n                else\n                    point_glyph.y = { value: ys };\n            }\n            this._emit_cds_changes(point_cds, true, true, false);\n        }\n        _hide_vertices() {\n            this._set_vertices([], []);\n        }\n        _snap_to_vertex(ev, x, y) {\n            if (this.model.vertex_renderer) {\n                // If an existing vertex is hit snap to it\n                const vertex_selected = this._select_event(ev, false, [this.model.vertex_renderer]);\n                const point_ds = this.model.vertex_renderer.data_source;\n                // Type once dataspecs are typed\n                const point_glyph = this.model.vertex_renderer.glyph;\n                const [pxkey, pykey] = [point_glyph.x.field, point_glyph.y.field];\n                if (vertex_selected.length) {\n                    const index = point_ds.selected.indices[0];\n                    if (pxkey)\n                        x = point_ds.data[pxkey][index];\n                    if (pykey)\n                        y = point_ds.data[pykey][index];\n                    point_ds.selection_manager.clear();\n                }\n            }\n            return [x, y];\n        }\n    }\n    exports.PolyToolView = PolyToolView;\n    PolyToolView.__name__ = \"PolyToolView\";\n    class PolyTool extends edit_tool_1.EditTool {\n        constructor(attrs) {\n            super(attrs);\n        }\n        static init_PolyTool() {\n            this.prototype.default_view = PolyToolView;\n            this.define({\n                vertex_renderer: [p.Instance],\n            });\n        }\n    }\n    exports.PolyTool = PolyTool;\n    PolyTool.__name__ = \"PolyTool\";\n    PolyTool.init_PolyTool();\n}\n","/* models/tools/edit/poly_edit_tool.js */ function _(require, module, exports) {\n    const dom_1 = require(61) /* ../../../core/dom */;\n    const types_1 = require(7) /* ../../../core/util/types */;\n    const poly_tool_1 = require(321) /* ./poly_tool */;\n    const icons_1 = require(271) /* ../../../styles/icons */;\n    class PolyEditToolView extends poly_tool_1.PolyToolView {\n        constructor() {\n            super(...arguments);\n            this._drawing = false;\n        }\n        _doubletap(ev) {\n            if (!this.model.active)\n                return;\n            const point = this._map_drag(ev.sx, ev.sy, this.model.vertex_renderer);\n            if (point == null)\n                return;\n            const [x, y] = point;\n            // Perform hit testing\n            const vertex_selected = this._select_event(ev, false, [this.model.vertex_renderer]);\n            const point_cds = this.model.vertex_renderer.data_source;\n            // Type once dataspecs are typed\n            const point_glyph = this.model.vertex_renderer.glyph;\n            const [pxkey, pykey] = [point_glyph.x.field, point_glyph.y.field];\n            if (vertex_selected.length && this._selected_renderer != null) {\n                // Insert a new point after the selected vertex and enter draw mode\n                const index = point_cds.selected.indices[0];\n                if (this._drawing) {\n                    this._drawing = false;\n                    point_cds.selection_manager.clear();\n                }\n                else {\n                    point_cds.selected.indices = [index + 1];\n                    if (pxkey)\n                        point_cds.get_array(pxkey).splice(index + 1, 0, x);\n                    if (pykey)\n                        point_cds.get_array(pykey).splice(index + 1, 0, y);\n                    this._drawing = true;\n                }\n                point_cds.change.emit();\n                this._emit_cds_changes(this._selected_renderer.data_source);\n            }\n            else {\n                this._show_vertices(ev);\n            }\n        }\n        _show_vertices(ev) {\n            if (!this.model.active)\n                return;\n            const renderers = this._select_event(ev, false, this.model.renderers);\n            if (!renderers.length) {\n                this._set_vertices([], []);\n                this._selected_renderer = null;\n                this._drawing = false;\n                return;\n            }\n            const renderer = renderers[0];\n            const glyph = renderer.glyph;\n            const cds = renderer.data_source;\n            const index = cds.selected.indices[0];\n            const [xkey, ykey] = [glyph.xs.field, glyph.ys.field];\n            let xs;\n            let ys;\n            if (xkey) {\n                xs = cds.data[xkey][index];\n                if (!types_1.isArray(xs))\n                    cds.data[xkey][index] = xs = Array.from(xs);\n            }\n            else {\n                xs = glyph.xs.value;\n            }\n            if (ykey) {\n                ys = cds.data[ykey][index];\n                if (!types_1.isArray(ys))\n                    cds.data[ykey][index] = ys = Array.from(ys);\n            }\n            else {\n                ys = glyph.ys.value;\n            }\n            this._selected_renderer = renderer;\n            this._set_vertices(xs, ys);\n        }\n        _move(ev) {\n            if (this._drawing && this._selected_renderer != null) {\n                const renderer = this.model.vertex_renderer;\n                const cds = renderer.data_source;\n                const glyph = renderer.glyph;\n                const point = this._map_drag(ev.sx, ev.sy, renderer);\n                if (point == null)\n                    return;\n                let [x, y] = point;\n                const indices = cds.selected.indices;\n                [x, y] = this._snap_to_vertex(ev, x, y);\n                cds.selected.indices = indices;\n                const [xkey, ykey] = [glyph.x.field, glyph.y.field];\n                const index = indices[0];\n                if (xkey)\n                    cds.data[xkey][index] = x;\n                if (ykey)\n                    cds.data[ykey][index] = y;\n                cds.change.emit();\n                this._selected_renderer.data_source.change.emit();\n            }\n        }\n        _tap(ev) {\n            const renderer = this.model.vertex_renderer;\n            const point = this._map_drag(ev.sx, ev.sy, renderer);\n            if (point == null)\n                return;\n            else if (this._drawing && this._selected_renderer) {\n                let [x, y] = point;\n                const cds = renderer.data_source;\n                // Type once dataspecs are typed\n                const glyph = renderer.glyph;\n                const [xkey, ykey] = [glyph.x.field, glyph.y.field];\n                const indices = cds.selected.indices;\n                [x, y] = this._snap_to_vertex(ev, x, y);\n                const index = indices[0];\n                cds.selected.indices = [index + 1];\n                if (xkey) {\n                    const xs = cds.get_array(xkey);\n                    const nx = xs[index];\n                    xs[index] = x;\n                    xs.splice(index + 1, 0, nx);\n                }\n                if (ykey) {\n                    const ys = cds.get_array(ykey);\n                    const ny = ys[index];\n                    ys[index] = y;\n                    ys.splice(index + 1, 0, ny);\n                }\n                cds.change.emit();\n                this._emit_cds_changes(this._selected_renderer.data_source, true, false, true);\n                return;\n            }\n            const append = ev.shiftKey;\n            this._select_event(ev, append, [renderer]);\n            this._select_event(ev, append, this.model.renderers);\n        }\n        _remove_vertex() {\n            if (!this._drawing || !this._selected_renderer)\n                return;\n            const renderer = this.model.vertex_renderer;\n            const cds = renderer.data_source;\n            // Type once dataspecs are typed\n            const glyph = renderer.glyph;\n            const index = cds.selected.indices[0];\n            const [xkey, ykey] = [glyph.x.field, glyph.y.field];\n            if (xkey)\n                cds.get_array(xkey).splice(index, 1);\n            if (ykey)\n                cds.get_array(ykey).splice(index, 1);\n            cds.change.emit();\n            this._emit_cds_changes(this._selected_renderer.data_source);\n        }\n        _pan_start(ev) {\n            this._select_event(ev, true, [this.model.vertex_renderer]);\n            this._basepoint = [ev.sx, ev.sy];\n        }\n        _pan(ev) {\n            if (this._basepoint == null)\n                return;\n            this._drag_points(ev, [this.model.vertex_renderer]);\n            if (this._selected_renderer)\n                this._selected_renderer.data_source.change.emit();\n        }\n        _pan_end(ev) {\n            if (this._basepoint == null)\n                return;\n            this._drag_points(ev, [this.model.vertex_renderer]);\n            this._emit_cds_changes(this.model.vertex_renderer.data_source, false, true, true);\n            if (this._selected_renderer) {\n                this._emit_cds_changes(this._selected_renderer.data_source);\n            }\n            this._basepoint = null;\n        }\n        _keyup(ev) {\n            if (!this.model.active || !this._mouse_in_frame)\n                return;\n            let renderers;\n            if (this._selected_renderer) {\n                renderers = [this.model.vertex_renderer];\n            }\n            else {\n                renderers = this.model.renderers;\n            }\n            for (const renderer of renderers) {\n                if (ev.keyCode === dom_1.Keys.Backspace) {\n                    this._delete_selected(renderer);\n                    if (this._selected_renderer) {\n                        this._emit_cds_changes(this._selected_renderer.data_source);\n                    }\n                }\n                else if (ev.keyCode == dom_1.Keys.Esc) {\n                    if (this._drawing) {\n                        this._remove_vertex();\n                        this._drawing = false;\n                    }\n                    else if (this._selected_renderer) {\n                        this._hide_vertices();\n                    }\n                    renderer.data_source.selection_manager.clear();\n                }\n            }\n        }\n        deactivate() {\n            if (!this._selected_renderer) {\n                return;\n            }\n            else if (this._drawing) {\n                this._remove_vertex();\n                this._drawing = false;\n            }\n            this._hide_vertices();\n        }\n    }\n    exports.PolyEditToolView = PolyEditToolView;\n    PolyEditToolView.__name__ = \"PolyEditToolView\";\n    class PolyEditTool extends poly_tool_1.PolyTool {\n        constructor(attrs) {\n            super(attrs);\n            this.tool_name = \"Poly Edit Tool\";\n            this.icon = icons_1.bk_tool_icon_poly_edit;\n            this.event_type = [\"tap\", \"pan\", \"move\"];\n            this.default_order = 4;\n        }\n        static init_PolyEditTool() {\n            this.prototype.default_view = PolyEditToolView;\n        }\n    }\n    exports.PolyEditTool = PolyEditTool;\n    PolyEditTool.__name__ = \"PolyEditTool\";\n    PolyEditTool.init_PolyEditTool();\n}\n","/* models/tools/gestures/box_select_tool.js */ function _(require, module, exports) {\n    const select_tool_1 = require(324) /* ./select_tool */;\n    const box_annotation_1 = require(99) /* ../../annotations/box_annotation */;\n    const p = require(18) /* ../../../core/properties */;\n    const icons_1 = require(271) /* ../../../styles/icons */;\n    class BoxSelectToolView extends select_tool_1.SelectToolView {\n        _compute_limits(curpoint) {\n            const frame = this.plot_view.frame;\n            const dims = this.model.dimensions;\n            let base_point = this._base_point;\n            if (this.model.origin == \"center\") {\n                const [cx, cy] = base_point;\n                const [dx, dy] = curpoint;\n                base_point = [cx - (dx - cx), cy - (dy - cy)];\n            }\n            return this.model._get_dim_limits(base_point, curpoint, frame, dims);\n        }\n        _pan_start(ev) {\n            const { sx, sy } = ev;\n            this._base_point = [sx, sy];\n        }\n        _pan(ev) {\n            const { sx, sy } = ev;\n            const curpoint = [sx, sy];\n            const [sxlim, sylim] = this._compute_limits(curpoint);\n            this.model.overlay.update({ left: sxlim[0], right: sxlim[1], top: sylim[0], bottom: sylim[1] });\n            if (this.model.select_every_mousemove) {\n                const append = ev.shiftKey;\n                this._do_select(sxlim, sylim, false, append);\n            }\n        }\n        _pan_end(ev) {\n            const { sx, sy } = ev;\n            const curpoint = [sx, sy];\n            const [sxlim, sylim] = this._compute_limits(curpoint);\n            const append = ev.shiftKey;\n            this._do_select(sxlim, sylim, true, append);\n            this.model.overlay.update({ left: null, right: null, top: null, bottom: null });\n            this._base_point = null;\n            this.plot_view.push_state('box_select', { selection: this.plot_view.get_selection() });\n        }\n        _do_select([sx0, sx1], [sy0, sy1], final, append = false) {\n            const geometry = { type: 'rect', sx0, sx1, sy0, sy1 };\n            this._select(geometry, final, append);\n        }\n        _emit_callback(geometry) {\n            const r = this.computed_renderers[0];\n            const frame = this.plot_view.frame;\n            const xscale = frame.xscales[r.x_range_name];\n            const yscale = frame.yscales[r.y_range_name];\n            const { sx0, sx1, sy0, sy1 } = geometry;\n            const [x0, x1] = xscale.r_invert(sx0, sx1);\n            const [y0, y1] = yscale.r_invert(sy0, sy1);\n            const g = Object.assign({ x0, y0, x1, y1 }, geometry);\n            if (this.model.callback != null)\n                this.model.callback.execute(this.model, { geometry: g });\n        }\n    }\n    exports.BoxSelectToolView = BoxSelectToolView;\n    BoxSelectToolView.__name__ = \"BoxSelectToolView\";\n    const DEFAULT_BOX_OVERLAY = () => {\n        return new box_annotation_1.BoxAnnotation({\n            level: \"overlay\",\n            render_mode: \"css\",\n            top_units: \"screen\",\n            left_units: \"screen\",\n            bottom_units: \"screen\",\n            right_units: \"screen\",\n            fill_color: { value: \"lightgrey\" },\n            fill_alpha: { value: 0.5 },\n            line_color: { value: \"black\" },\n            line_alpha: { value: 1.0 },\n            line_width: { value: 2 },\n            line_dash: { value: [4, 4] },\n        });\n    };\n    class BoxSelectTool extends select_tool_1.SelectTool {\n        constructor(attrs) {\n            super(attrs);\n            this.tool_name = \"Box Select\";\n            this.icon = icons_1.bk_tool_icon_box_select;\n            this.event_type = \"pan\";\n            this.default_order = 30;\n        }\n        static init_BoxSelectTool() {\n            this.prototype.default_view = BoxSelectToolView;\n            this.define({\n                dimensions: [p.Dimensions, \"both\"],\n                select_every_mousemove: [p.Boolean, false],\n                callback: [p.Any],\n                overlay: [p.Instance, DEFAULT_BOX_OVERLAY],\n                origin: [p.BoxOrigin, \"corner\"],\n            });\n        }\n        get tooltip() {\n            return this._get_dim_tooltip(this.tool_name, this.dimensions);\n        }\n    }\n    exports.BoxSelectTool = BoxSelectTool;\n    BoxSelectTool.__name__ = \"BoxSelectTool\";\n    BoxSelectTool.init_BoxSelectTool();\n}\n","/* models/tools/gestures/select_tool.js */ function _(require, module, exports) {\n    const gesture_tool_1 = require(268) /* ./gesture_tool */;\n    const glyph_renderer_1 = require(73) /* ../../renderers/glyph_renderer */;\n    const graph_renderer_1 = require(90) /* ../../renderers/graph_renderer */;\n    const util_1 = require(325) /* ../util */;\n    const p = require(18) /* ../../../core/properties */;\n    const dom_1 = require(61) /* ../../../core/dom */;\n    const bokeh_events_1 = require(274) /* ../../../core/bokeh_events */;\n    class SelectToolView extends gesture_tool_1.GestureToolView {\n        get computed_renderers() {\n            const renderers = this.model.renderers;\n            const all_renderers = this.plot_model.renderers;\n            const names = this.model.names;\n            return util_1.compute_renderers(renderers, all_renderers, names);\n        }\n        _computed_renderers_by_data_source() {\n            const renderers_by_source = {};\n            for (const r of this.computed_renderers) {\n                let source_id;\n                if (r instanceof glyph_renderer_1.GlyphRenderer)\n                    source_id = r.data_source.id;\n                else if (r instanceof graph_renderer_1.GraphRenderer)\n                    source_id = r.node_renderer.data_source.id;\n                else\n                    continue;\n                if (!(source_id in renderers_by_source))\n                    renderers_by_source[source_id] = [];\n                renderers_by_source[source_id].push(r);\n            }\n            return renderers_by_source;\n        }\n        _keyup(ev) {\n            if (ev.keyCode == dom_1.Keys.Esc) {\n                for (const r of this.computed_renderers) {\n                    r.get_selection_manager().clear();\n                }\n                this.plot_view.request_render();\n            }\n        }\n        _select(geometry, final, append) {\n            const renderers_by_source = this._computed_renderers_by_data_source();\n            for (const id in renderers_by_source) {\n                const renderers = renderers_by_source[id];\n                const sm = renderers[0].get_selection_manager();\n                const r_views = [];\n                for (const r of renderers) {\n                    if (r.id in this.plot_view.renderer_views)\n                        r_views.push(this.plot_view.renderer_views[r.id]);\n                }\n                sm.select(r_views, geometry, final, append);\n            }\n            // XXX: messed up class structure\n            if (this.model.callback != null)\n                this._emit_callback(geometry);\n            this._emit_selection_event(geometry, final);\n        }\n        _emit_selection_event(geometry, final = true) {\n            const { frame } = this.plot_view;\n            const xm = frame.xscales.default;\n            const ym = frame.yscales.default;\n            let g; // XXX: Geometry & something\n            switch (geometry.type) {\n                case 'point': {\n                    const { sx, sy } = geometry;\n                    const x = xm.invert(sx);\n                    const y = ym.invert(sy);\n                    g = Object.assign(Object.assign({}, geometry), { x, y });\n                    break;\n                }\n                case 'rect': {\n                    const { sx0, sx1, sy0, sy1 } = geometry;\n                    const [x0, x1] = xm.r_invert(sx0, sx1);\n                    const [y0, y1] = ym.r_invert(sy0, sy1);\n                    g = Object.assign(Object.assign({}, geometry), { x0, y0, x1, y1 });\n                    break;\n                }\n                case 'poly': {\n                    const { sx, sy } = geometry;\n                    const x = xm.v_invert(sx);\n                    const y = ym.v_invert(sy);\n                    g = Object.assign(Object.assign({}, geometry), { x, y });\n                    break;\n                }\n                default:\n                    throw new Error(`Unrecognized selection geometry type: '${geometry.type}'`);\n            }\n            this.plot_model.trigger_event(new bokeh_events_1.SelectionGeometry(g, final));\n        }\n    }\n    exports.SelectToolView = SelectToolView;\n    SelectToolView.__name__ = \"SelectToolView\";\n    class SelectTool extends gesture_tool_1.GestureTool {\n        constructor(attrs) {\n            super(attrs);\n        }\n        static init_SelectTool() {\n            this.define({\n                renderers: [p.Any, 'auto'],\n                names: [p.Array, []],\n            });\n        }\n    }\n    exports.SelectTool = SelectTool;\n    SelectTool.__name__ = \"SelectTool\";\n    SelectTool.init_SelectTool();\n}\n","/* models/tools/util.js */ function _(require, module, exports) {\n    const array_1 = require(8) /* ../../core/util/array */;\n    function compute_renderers(renderers, all_renderers, names) {\n        if (renderers == null)\n            return [];\n        let result = renderers == 'auto' ? all_renderers : renderers;\n        if (names.length > 0)\n            result = result.filter((r) => array_1.includes(names, r.name));\n        return result;\n    }\n    exports.compute_renderers = compute_renderers;\n}\n","/* models/tools/gestures/box_zoom_tool.js */ function _(require, module, exports) {\n    const gesture_tool_1 = require(268) /* ./gesture_tool */;\n    const box_annotation_1 = require(99) /* ../../annotations/box_annotation */;\n    const p = require(18) /* ../../../core/properties */;\n    const icons_1 = require(271) /* ../../../styles/icons */;\n    class BoxZoomToolView extends gesture_tool_1.GestureToolView {\n        _match_aspect(base_point, curpoint, frame) {\n            // aspect ratio of plot frame\n            const a = frame.bbox.aspect;\n            const hend = frame.bbox.h_range.end;\n            const hstart = frame.bbox.h_range.start;\n            const vend = frame.bbox.v_range.end;\n            const vstart = frame.bbox.v_range.start;\n            // current aspect of cursor-defined box\n            let vw = Math.abs(base_point[0] - curpoint[0]);\n            let vh = Math.abs(base_point[1] - curpoint[1]);\n            const va = vh == 0 ? 0 : vw / vh;\n            const [xmod] = va >= a ? [1, va / a] : [a / va, 1];\n            // OK the code blocks below merit some explanation. They do:\n            //\n            // compute left/right, pin to frame if necessary\n            // compute top/bottom (based on new left/right), pin to frame if necessary\n            // recompute left/right (based on top/bottom), in case top/bottom were pinned\n            // base_point[0] is left\n            let left;\n            let right;\n            if (base_point[0] <= curpoint[0]) {\n                left = base_point[0];\n                right = base_point[0] + vw * xmod;\n                if (right > hend)\n                    right = hend;\n                // base_point[0] is right\n            }\n            else {\n                right = base_point[0];\n                left = base_point[0] - vw * xmod;\n                if (left < hstart)\n                    left = hstart;\n            }\n            vw = Math.abs(right - left);\n            // base_point[1] is bottom\n            let top;\n            let bottom;\n            if (base_point[1] <= curpoint[1]) {\n                bottom = base_point[1];\n                top = base_point[1] + vw / a;\n                if (top > vend)\n                    top = vend;\n                // base_point[1] is top\n            }\n            else {\n                top = base_point[1];\n                bottom = base_point[1] - vw / a;\n                if (bottom < vstart)\n                    bottom = vstart;\n            }\n            vh = Math.abs(top - bottom);\n            // base_point[0] is left\n            if (base_point[0] <= curpoint[0])\n                right = base_point[0] + a * vh;\n            // base_point[0] is right\n            else\n                left = base_point[0] - a * vh;\n            return [[left, right], [bottom, top]];\n        }\n        _compute_limits(curpoint) {\n            const frame = this.plot_view.frame;\n            const dims = this.model.dimensions;\n            let base_point = this._base_point;\n            if (this.model.origin == \"center\") {\n                const [cx, cy] = base_point;\n                const [dx, dy] = curpoint;\n                base_point = [cx - (dx - cx), cy - (dy - cy)];\n            }\n            let sx;\n            let sy;\n            if (this.model.match_aspect && dims == 'both')\n                [sx, sy] = this._match_aspect(base_point, curpoint, frame);\n            else\n                [sx, sy] = this.model._get_dim_limits(base_point, curpoint, frame, dims);\n            return [sx, sy];\n        }\n        _pan_start(ev) {\n            this._base_point = [ev.sx, ev.sy];\n        }\n        _pan(ev) {\n            const curpoint = [ev.sx, ev.sy];\n            const [sx, sy] = this._compute_limits(curpoint);\n            this.model.overlay.update({ left: sx[0], right: sx[1], top: sy[0], bottom: sy[1] });\n        }\n        _pan_end(ev) {\n            const curpoint = [ev.sx, ev.sy];\n            const [sx, sy] = this._compute_limits(curpoint);\n            this._update(sx, sy);\n            this.model.overlay.update({ left: null, right: null, top: null, bottom: null });\n            this._base_point = null;\n        }\n        _update([sx0, sx1], [sy0, sy1]) {\n            // If the viewing window is too small, no-op: it is likely that the user did\n            // not intend to make this box zoom and instead was trying to cancel out of the\n            // zoom, a la matplotlib's ToolZoom. Like matplotlib, set the threshold at 5 pixels.\n            if (Math.abs(sx1 - sx0) <= 5 || Math.abs(sy1 - sy0) <= 5)\n                return;\n            const { xscales, yscales } = this.plot_view.frame;\n            const xrs = {};\n            for (const name in xscales) {\n                const scale = xscales[name];\n                const [start, end] = scale.r_invert(sx0, sx1);\n                xrs[name] = { start, end };\n            }\n            const yrs = {};\n            for (const name in yscales) {\n                const scale = yscales[name];\n                const [start, end] = scale.r_invert(sy0, sy1);\n                yrs[name] = { start, end };\n            }\n            const zoom_info = { xrs, yrs };\n            this.plot_view.push_state('box_zoom', { range: zoom_info });\n            this.plot_view.update_range(zoom_info);\n        }\n    }\n    exports.BoxZoomToolView = BoxZoomToolView;\n    BoxZoomToolView.__name__ = \"BoxZoomToolView\";\n    const DEFAULT_BOX_OVERLAY = () => {\n        return new box_annotation_1.BoxAnnotation({\n            level: \"overlay\",\n            render_mode: \"css\",\n            top_units: \"screen\",\n            left_units: \"screen\",\n            bottom_units: \"screen\",\n            right_units: \"screen\",\n            fill_color: { value: \"lightgrey\" },\n            fill_alpha: { value: 0.5 },\n            line_color: { value: \"black\" },\n            line_alpha: { value: 1.0 },\n            line_width: { value: 2 },\n            line_dash: { value: [4, 4] },\n        });\n    };\n    class BoxZoomTool extends gesture_tool_1.GestureTool {\n        constructor(attrs) {\n            super(attrs);\n            this.tool_name = \"Box Zoom\";\n            this.icon = icons_1.bk_tool_icon_box_zoom;\n            this.event_type = \"pan\";\n            this.default_order = 20;\n        }\n        static init_BoxZoomTool() {\n            this.prototype.default_view = BoxZoomToolView;\n            this.define({\n                dimensions: [p.Dimensions, \"both\"],\n                overlay: [p.Instance, DEFAULT_BOX_OVERLAY],\n                match_aspect: [p.Boolean, false],\n                origin: [p.BoxOrigin, \"corner\"],\n            });\n        }\n        get tooltip() {\n            return this._get_dim_tooltip(this.tool_name, this.dimensions);\n        }\n    }\n    exports.BoxZoomTool = BoxZoomTool;\n    BoxZoomTool.__name__ = \"BoxZoomTool\";\n    BoxZoomTool.init_BoxZoomTool();\n}\n","/* models/tools/gestures/lasso_select_tool.js */ function _(require, module, exports) {\n    const select_tool_1 = require(324) /* ./select_tool */;\n    const poly_annotation_1 = require(131) /* ../../annotations/poly_annotation */;\n    const dom_1 = require(61) /* ../../../core/dom */;\n    const p = require(18) /* ../../../core/properties */;\n    const icons_1 = require(271) /* ../../../styles/icons */;\n    class LassoSelectToolView extends select_tool_1.SelectToolView {\n        initialize() {\n            super.initialize();\n            this.data = null;\n        }\n        connect_signals() {\n            super.connect_signals();\n            this.connect(this.model.properties.active.change, () => this._active_change());\n        }\n        _active_change() {\n            if (!this.model.active)\n                this._clear_overlay();\n        }\n        _keyup(ev) {\n            if (ev.keyCode == dom_1.Keys.Enter)\n                this._clear_overlay();\n        }\n        _pan_start(ev) {\n            const { sx, sy } = ev;\n            this.data = { sx: [sx], sy: [sy] };\n        }\n        _pan(ev) {\n            const { sx: _sx, sy: _sy } = ev;\n            const [sx, sy] = this.plot_view.frame.bbox.clip(_sx, _sy);\n            this.data.sx.push(sx);\n            this.data.sy.push(sy);\n            const overlay = this.model.overlay;\n            overlay.update({ xs: this.data.sx, ys: this.data.sy });\n            if (this.model.select_every_mousemove) {\n                const append = ev.shiftKey;\n                this._do_select(this.data.sx, this.data.sy, false, append);\n            }\n        }\n        _pan_end(ev) {\n            this._clear_overlay();\n            const append = ev.shiftKey;\n            this._do_select(this.data.sx, this.data.sy, true, append);\n            this.plot_view.push_state('lasso_select', { selection: this.plot_view.get_selection() });\n        }\n        _clear_overlay() {\n            this.model.overlay.update({ xs: [], ys: [] });\n        }\n        _do_select(sx, sy, final, append) {\n            const geometry = { type: 'poly', sx, sy };\n            this._select(geometry, final, append);\n        }\n        _emit_callback(geometry) {\n            const r = this.computed_renderers[0];\n            const frame = this.plot_view.frame;\n            const xscale = frame.xscales[r.x_range_name];\n            const yscale = frame.yscales[r.y_range_name];\n            const x = xscale.v_invert(geometry.sx);\n            const y = yscale.v_invert(geometry.sy);\n            const g = Object.assign({ x, y }, geometry);\n            if (this.model.callback != null)\n                this.model.callback.execute(this.model, { geometry: g });\n        }\n    }\n    exports.LassoSelectToolView = LassoSelectToolView;\n    LassoSelectToolView.__name__ = \"LassoSelectToolView\";\n    const DEFAULT_POLY_OVERLAY = () => {\n        return new poly_annotation_1.PolyAnnotation({\n            level: \"overlay\",\n            xs_units: \"screen\",\n            ys_units: \"screen\",\n            fill_color: { value: \"lightgrey\" },\n            fill_alpha: { value: 0.5 },\n            line_color: { value: \"black\" },\n            line_alpha: { value: 1.0 },\n            line_width: { value: 2 },\n            line_dash: { value: [4, 4] },\n        });\n    };\n    class LassoSelectTool extends select_tool_1.SelectTool {\n        constructor(attrs) {\n            super(attrs);\n            this.tool_name = \"Lasso Select\";\n            this.icon = icons_1.bk_tool_icon_lasso_select;\n            this.event_type = \"pan\";\n            this.default_order = 12;\n        }\n        static init_LassoSelectTool() {\n            this.prototype.default_view = LassoSelectToolView;\n            this.define({\n                select_every_mousemove: [p.Boolean, true],\n                callback: [p.Any],\n                overlay: [p.Instance, DEFAULT_POLY_OVERLAY],\n            });\n        }\n    }\n    exports.LassoSelectTool = LassoSelectTool;\n    LassoSelectTool.__name__ = \"LassoSelectTool\";\n    LassoSelectTool.init_LassoSelectTool();\n}\n","/* models/tools/gestures/pan_tool.js */ function _(require, module, exports) {\n    const gesture_tool_1 = require(268) /* ./gesture_tool */;\n    const p = require(18) /* ../../../core/properties */;\n    const icons_1 = require(271) /* ../../../styles/icons */;\n    class PanToolView extends gesture_tool_1.GestureToolView {\n        _pan_start(ev) {\n            this.last_dx = 0;\n            this.last_dy = 0;\n            const { sx, sy } = ev;\n            const bbox = this.plot_view.frame.bbox;\n            if (!bbox.contains(sx, sy)) {\n                const hr = bbox.h_range;\n                const vr = bbox.v_range;\n                if (sx < hr.start || sx > hr.end)\n                    this.v_axis_only = true;\n                if (sy < vr.start || sy > vr.end)\n                    this.h_axis_only = true;\n            }\n            if (this.model.document != null)\n                this.model.document.interactive_start(this.plot_model);\n        }\n        _pan(ev) {\n            this._update(ev.deltaX, ev.deltaY);\n            if (this.model.document != null)\n                this.model.document.interactive_start(this.plot_model);\n        }\n        _pan_end(_e) {\n            this.h_axis_only = false;\n            this.v_axis_only = false;\n            if (this.pan_info != null)\n                this.plot_view.push_state('pan', { range: this.pan_info });\n        }\n        _update(dx, dy) {\n            const frame = this.plot_view.frame;\n            const new_dx = dx - this.last_dx;\n            const new_dy = dy - this.last_dy;\n            const hr = frame.bbox.h_range;\n            const sx_low = hr.start - new_dx;\n            const sx_high = hr.end - new_dx;\n            const vr = frame.bbox.v_range;\n            const sy_low = vr.start - new_dy;\n            const sy_high = vr.end - new_dy;\n            const dims = this.model.dimensions;\n            let sx0;\n            let sx1;\n            let sdx;\n            if ((dims == 'width' || dims == 'both') && !this.v_axis_only) {\n                sx0 = sx_low;\n                sx1 = sx_high;\n                sdx = -new_dx;\n            }\n            else {\n                sx0 = hr.start;\n                sx1 = hr.end;\n                sdx = 0;\n            }\n            let sy0;\n            let sy1;\n            let sdy;\n            if ((dims == 'height' || dims == 'both') && !this.h_axis_only) {\n                sy0 = sy_low;\n                sy1 = sy_high;\n                sdy = -new_dy;\n            }\n            else {\n                sy0 = vr.start;\n                sy1 = vr.end;\n                sdy = 0;\n            }\n            this.last_dx = dx;\n            this.last_dy = dy;\n            const { xscales, yscales } = frame;\n            const xrs = {};\n            for (const name in xscales) {\n                const scale = xscales[name];\n                const [start, end] = scale.r_invert(sx0, sx1);\n                xrs[name] = { start, end };\n            }\n            const yrs = {};\n            for (const name in yscales) {\n                const scale = yscales[name];\n                const [start, end] = scale.r_invert(sy0, sy1);\n                yrs[name] = { start, end };\n            }\n            this.pan_info = { xrs, yrs, sdx, sdy };\n            this.plot_view.update_range(this.pan_info, true);\n        }\n    }\n    exports.PanToolView = PanToolView;\n    PanToolView.__name__ = \"PanToolView\";\n    class PanTool extends gesture_tool_1.GestureTool {\n        constructor(attrs) {\n            super(attrs);\n            this.tool_name = \"Pan\";\n            this.event_type = \"pan\";\n            this.default_order = 10;\n        }\n        static init_PanTool() {\n            this.prototype.default_view = PanToolView;\n            this.define({\n                dimensions: [p.Dimensions, \"both\"],\n            });\n        }\n        get tooltip() {\n            return this._get_dim_tooltip(\"Pan\", this.dimensions);\n        }\n        get icon() {\n            switch (this.dimensions) {\n                case \"both\": return icons_1.bk_tool_icon_pan;\n                case \"width\": return icons_1.bk_tool_icon_xpan;\n                case \"height\": return icons_1.bk_tool_icon_ypan;\n            }\n        }\n    }\n    exports.PanTool = PanTool;\n    PanTool.__name__ = \"PanTool\";\n    PanTool.init_PanTool();\n}\n","/* models/tools/gestures/poly_select_tool.js */ function _(require, module, exports) {\n    const select_tool_1 = require(324) /* ./select_tool */;\n    const poly_annotation_1 = require(131) /* ../../annotations/poly_annotation */;\n    const dom_1 = require(61) /* ../../../core/dom */;\n    const p = require(18) /* ../../../core/properties */;\n    const array_1 = require(8) /* ../../../core/util/array */;\n    const icons_1 = require(271) /* ../../../styles/icons */;\n    class PolySelectToolView extends select_tool_1.SelectToolView {\n        initialize() {\n            super.initialize();\n            this.data = { sx: [], sy: [] };\n        }\n        connect_signals() {\n            super.connect_signals();\n            this.connect(this.model.properties.active.change, () => this._active_change());\n        }\n        _active_change() {\n            if (!this.model.active)\n                this._clear_data();\n        }\n        _keyup(ev) {\n            if (ev.keyCode == dom_1.Keys.Enter)\n                this._clear_data();\n        }\n        _doubletap(ev) {\n            const append = ev.shiftKey;\n            this._do_select(this.data.sx, this.data.sy, true, append);\n            this.plot_view.push_state('poly_select', { selection: this.plot_view.get_selection() });\n            this._clear_data();\n        }\n        _clear_data() {\n            this.data = { sx: [], sy: [] };\n            this.model.overlay.update({ xs: [], ys: [] });\n        }\n        _tap(ev) {\n            const { sx, sy } = ev;\n            const frame = this.plot_view.frame;\n            if (!frame.bbox.contains(sx, sy))\n                return;\n            this.data.sx.push(sx);\n            this.data.sy.push(sy);\n            this.model.overlay.update({ xs: array_1.copy(this.data.sx), ys: array_1.copy(this.data.sy) });\n        }\n        _do_select(sx, sy, final, append) {\n            const geometry = { type: 'poly', sx, sy };\n            this._select(geometry, final, append);\n        }\n        _emit_callback(geometry) {\n            const r = this.computed_renderers[0];\n            const frame = this.plot_view.frame;\n            const xscale = frame.xscales[r.x_range_name];\n            const yscale = frame.yscales[r.y_range_name];\n            const x = xscale.v_invert(geometry.sx);\n            const y = yscale.v_invert(geometry.sy);\n            const g = Object.assign({ x, y }, geometry);\n            if (this.model.callback != null)\n                this.model.callback.execute(this.model, { geometry: g });\n        }\n    }\n    exports.PolySelectToolView = PolySelectToolView;\n    PolySelectToolView.__name__ = \"PolySelectToolView\";\n    const DEFAULT_POLY_OVERLAY = () => {\n        return new poly_annotation_1.PolyAnnotation({\n            level: \"overlay\",\n            xs_units: \"screen\",\n            ys_units: \"screen\",\n            fill_color: { value: \"lightgrey\" },\n            fill_alpha: { value: 0.5 },\n            line_color: { value: \"black\" },\n            line_alpha: { value: 1.0 },\n            line_width: { value: 2 },\n            line_dash: { value: [4, 4] },\n        });\n    };\n    class PolySelectTool extends select_tool_1.SelectTool {\n        constructor(attrs) {\n            super(attrs);\n            this.tool_name = \"Poly Select\";\n            this.icon = icons_1.bk_tool_icon_polygon_select;\n            this.event_type = \"tap\";\n            this.default_order = 11;\n        }\n        static init_PolySelectTool() {\n            this.prototype.default_view = PolySelectToolView;\n            this.define({\n                callback: [p.Any],\n                overlay: [p.Instance, DEFAULT_POLY_OVERLAY],\n            });\n        }\n    }\n    exports.PolySelectTool = PolySelectTool;\n    PolySelectTool.__name__ = \"PolySelectTool\";\n    PolySelectTool.init_PolySelectTool();\n}\n","/* models/tools/gestures/range_tool.js */ function _(require, module, exports) {\n    const box_annotation_1 = require(99) /* ../../annotations/box_annotation */;\n    const logging_1 = require(65) /* ../../../core/logging */;\n    const p = require(18) /* ../../../core/properties */;\n    const gesture_tool_1 = require(268) /* ./gesture_tool */;\n    const icons_1 = require(271) /* ../../../styles/icons */;\n    function flip_side(side) {\n        switch (side) {\n            case 1 /* Left */: return 2 /* Right */;\n            case 2 /* Right */: return 1 /* Left */;\n            case 4 /* Bottom */: return 5 /* Top */;\n            case 5 /* Top */: return 4 /* Bottom */;\n            default: return side;\n        }\n    }\n    exports.flip_side = flip_side;\n    // TODO (bev) This would be better directly with BoxAnnotation, but hard\n    // to test on a view. Move when \"View Models\" are implemented\n    function is_near(pos, value, scale, tolerance) {\n        if (value == null)\n            return false;\n        const svalue = scale.compute(value);\n        return Math.abs(pos - svalue) < tolerance;\n    }\n    exports.is_near = is_near;\n    // TODO (bev) This would be better directly with BoxAnnotation, but hard\n    // to test on a view. Move when \"View Models\" are implemented\n    function is_inside(sx, sy, xscale, yscale, overlay) {\n        let result = true;\n        if (overlay.left != null && overlay.right != null) {\n            const x = xscale.invert(sx);\n            if (x < overlay.left || x > overlay.right)\n                result = false;\n        }\n        if (overlay.bottom != null && overlay.top != null) {\n            const y = yscale.invert(sy);\n            if (y < overlay.bottom || y > overlay.top)\n                result = false;\n        }\n        return result;\n    }\n    exports.is_inside = is_inside;\n    function sides_inside(start, end, range) {\n        let result = 0;\n        if (start >= range.start && start <= range.end)\n            result += 1;\n        if (end >= range.start && end <= range.end)\n            result += 1;\n        return result;\n    }\n    exports.sides_inside = sides_inside;\n    function compute_value(value, scale, sdelta, range) {\n        const svalue = scale.compute(value);\n        const new_value = scale.invert(svalue + sdelta);\n        if (new_value >= range.start && new_value <= range.end)\n            return new_value;\n        return value;\n    }\n    exports.compute_value = compute_value;\n    function update_range_end_side(end, range, side) {\n        if (end > range.start) {\n            range.end = end;\n            return side;\n        }\n        else {\n            range.end = range.start;\n            range.start = end;\n            return flip_side(side);\n        }\n    }\n    exports.update_range_end_side = update_range_end_side;\n    function update_range_start_side(start, range, side) {\n        if (start < range.end) {\n            range.start = start;\n            return side;\n        }\n        else {\n            range.start = range.end;\n            range.end = start;\n            return flip_side(side);\n        }\n    }\n    exports.update_range_start_side = update_range_start_side;\n    function update_range(range, scale, delta, plot_range) {\n        const [sstart, send] = scale.r_compute(range.start, range.end);\n        const [start, end] = scale.r_invert(sstart + delta, send + delta);\n        const initial_sides_inside = sides_inside(range.start, range.end, plot_range);\n        const final_sides_inside = sides_inside(start, end, plot_range);\n        // Allow the update as long as the number of sides in-bounds does not decrease\n        if (final_sides_inside >= initial_sides_inside) {\n            range.start = start;\n            range.end = end;\n        }\n    }\n    exports.update_range = update_range;\n    class RangeToolView extends gesture_tool_1.GestureToolView {\n        initialize() {\n            super.initialize();\n            this.side = 0 /* None */;\n            this.model.update_overlay_from_ranges();\n        }\n        connect_signals() {\n            super.connect_signals();\n            if (this.model.x_range != null)\n                this.connect(this.model.x_range.change, () => this.model.update_overlay_from_ranges());\n            if (this.model.y_range != null)\n                this.connect(this.model.y_range.change, () => this.model.update_overlay_from_ranges());\n        }\n        _pan_start(ev) {\n            this.last_dx = 0;\n            this.last_dy = 0;\n            const xr = this.model.x_range;\n            const yr = this.model.y_range;\n            const frame = this.plot_view.frame;\n            const xscale = frame.xscales.default;\n            const yscale = frame.yscales.default;\n            const overlay = this.model.overlay;\n            const { left, right, top, bottom } = overlay;\n            const tolerance = this.model.overlay.properties.line_width.value() + box_annotation_1.EDGE_TOLERANCE;\n            if (xr != null && this.model.x_interaction) {\n                if (is_near(ev.sx, left, xscale, tolerance))\n                    this.side = 1 /* Left */;\n                else if (is_near(ev.sx, right, xscale, tolerance))\n                    this.side = 2 /* Right */;\n                else if (is_inside(ev.sx, ev.sy, xscale, yscale, overlay)) {\n                    this.side = 3 /* LeftRight */;\n                }\n            }\n            if (yr != null && this.model.y_interaction) {\n                if (this.side == 0 /* None */ && is_near(ev.sy, bottom, yscale, tolerance))\n                    this.side = 4 /* Bottom */;\n                if (this.side == 0 /* None */ && is_near(ev.sy, top, yscale, tolerance))\n                    this.side = 5 /* Top */;\n                else if (is_inside(ev.sx, ev.sy, xscale, yscale, this.model.overlay)) {\n                    if (this.side == 3 /* LeftRight */)\n                        this.side = 7 /* LeftRightBottomTop */;\n                    else\n                        this.side = 6 /* BottomTop */;\n                }\n            }\n        }\n        _pan(ev) {\n            const frame = this.plot_view.frame;\n            const new_dx = ev.deltaX - this.last_dx;\n            const new_dy = ev.deltaY - this.last_dy;\n            const xr = this.model.x_range;\n            const yr = this.model.y_range;\n            const xscale = frame.xscales.default;\n            const yscale = frame.yscales.default;\n            if (xr != null) {\n                if (this.side == 3 /* LeftRight */ || this.side == 7 /* LeftRightBottomTop */)\n                    update_range(xr, xscale, new_dx, frame.x_range);\n                else if (this.side == 1 /* Left */) {\n                    const start = compute_value(xr.start, xscale, new_dx, frame.x_range);\n                    this.side = update_range_start_side(start, xr, this.side);\n                }\n                else if (this.side == 2 /* Right */) {\n                    const end = compute_value(xr.end, xscale, new_dx, frame.x_range);\n                    this.side = update_range_end_side(end, xr, this.side);\n                }\n            }\n            if (yr != null) {\n                if (this.side == 6 /* BottomTop */ || this.side == 7 /* LeftRightBottomTop */)\n                    update_range(yr, yscale, new_dy, frame.y_range);\n                else if (this.side == 4 /* Bottom */) {\n                    const start = compute_value(yr.start, yscale, new_dy, frame.y_range);\n                    this.side = update_range_start_side(start, yr, this.side);\n                }\n                else if (this.side == 5 /* Top */) {\n                    const end = compute_value(yr.end, yscale, new_dy, frame.y_range);\n                    this.side = update_range_end_side(end, yr, this.side);\n                }\n            }\n            this.last_dx = ev.deltaX;\n            this.last_dy = ev.deltaY;\n        }\n        _pan_end(_ev) {\n            this.side = 0 /* None */;\n        }\n    }\n    exports.RangeToolView = RangeToolView;\n    RangeToolView.__name__ = \"RangeToolView\";\n    const DEFAULT_RANGE_OVERLAY = () => {\n        return new box_annotation_1.BoxAnnotation({\n            level: \"overlay\",\n            render_mode: \"canvas\",\n            fill_color: \"lightgrey\",\n            fill_alpha: { value: 0.5 },\n            line_color: { value: \"black\" },\n            line_alpha: { value: 1.0 },\n            line_width: { value: 0.5 },\n            line_dash: [2, 2],\n        });\n    };\n    class RangeTool extends gesture_tool_1.GestureTool {\n        constructor(attrs) {\n            super(attrs);\n            this.tool_name = \"Range Tool\";\n            this.icon = icons_1.bk_tool_icon_range;\n            this.event_type = \"pan\";\n            this.default_order = 1;\n        }\n        static init_RangeTool() {\n            this.prototype.default_view = RangeToolView;\n            this.define({\n                x_range: [p.Instance, null],\n                x_interaction: [p.Boolean, true],\n                y_range: [p.Instance, null],\n                y_interaction: [p.Boolean, true],\n                overlay: [p.Instance, DEFAULT_RANGE_OVERLAY],\n            });\n        }\n        initialize() {\n            super.initialize();\n            this.overlay.in_cursor = \"grab\";\n            this.overlay.ew_cursor = this.x_range != null && this.x_interaction ? \"ew-resize\" : null;\n            this.overlay.ns_cursor = this.y_range != null && this.y_interaction ? \"ns-resize\" : null;\n        }\n        update_overlay_from_ranges() {\n            if (this.x_range == null && this.y_range == null) {\n                this.overlay.left = null;\n                this.overlay.right = null;\n                this.overlay.bottom = null;\n                this.overlay.top = null;\n                logging_1.logger.warn('RangeTool not configured with any Ranges.');\n            }\n            if (this.x_range == null) {\n                this.overlay.left = null;\n                this.overlay.right = null;\n            }\n            else {\n                this.overlay.left = this.x_range.start;\n                this.overlay.right = this.x_range.end;\n            }\n            if (this.y_range == null) {\n                this.overlay.bottom = null;\n                this.overlay.top = null;\n            }\n            else {\n                this.overlay.bottom = this.y_range.start;\n                this.overlay.top = this.y_range.end;\n            }\n        }\n    }\n    exports.RangeTool = RangeTool;\n    RangeTool.__name__ = \"RangeTool\";\n    RangeTool.init_RangeTool();\n}\n","/* models/tools/gestures/tap_tool.js */ function _(require, module, exports) {\n    const select_tool_1 = require(324) /* ./select_tool */;\n    const p = require(18) /* ../../../core/properties */;\n    const icons_1 = require(271) /* ../../../styles/icons */;\n    class TapToolView extends select_tool_1.SelectToolView {\n        _tap(ev) {\n            const { sx, sy } = ev;\n            const geometry = { type: 'point', sx, sy };\n            const append = ev.shiftKey;\n            this._select(geometry, true, append);\n        }\n        _select(geometry, final, append) {\n            const callback = this.model.callback;\n            if (this.model.behavior == \"select\") {\n                const renderers_by_source = this._computed_renderers_by_data_source();\n                for (const id in renderers_by_source) {\n                    const renderers = renderers_by_source[id];\n                    const sm = renderers[0].get_selection_manager();\n                    const r_views = renderers.map((r) => this.plot_view.renderer_views[r.id]);\n                    const did_hit = sm.select(r_views, geometry, final, append);\n                    if (did_hit && callback != null) {\n                        const { frame } = this.plot_view;\n                        const xscale = frame.xscales[renderers[0].x_range_name];\n                        const yscale = frame.yscales[renderers[0].y_range_name];\n                        const x = xscale.invert(geometry.sx);\n                        const y = yscale.invert(geometry.sy);\n                        const data = { geometries: Object.assign(Object.assign({}, geometry), { x, y }), source: sm.source };\n                        callback.execute(this.model, data);\n                    }\n                }\n                this._emit_selection_event(geometry);\n                this.plot_view.push_state('tap', { selection: this.plot_view.get_selection() });\n            }\n            else {\n                for (const r of this.computed_renderers) {\n                    const sm = r.get_selection_manager();\n                    const did_hit = sm.inspect(this.plot_view.renderer_views[r.id], geometry);\n                    if (did_hit && callback != null) {\n                        const { frame } = this.plot_view;\n                        const xscale = frame.xscales[r.x_range_name];\n                        const yscale = frame.yscales[r.y_range_name];\n                        const x = xscale.invert(geometry.sx);\n                        const y = yscale.invert(geometry.sy);\n                        const data = { geometries: Object.assign(Object.assign({}, geometry), { x, y }), source: sm.source };\n                        callback.execute(this.model, data);\n                    }\n                }\n            }\n        }\n    }\n    exports.TapToolView = TapToolView;\n    TapToolView.__name__ = \"TapToolView\";\n    class TapTool extends select_tool_1.SelectTool {\n        constructor(attrs) {\n            super(attrs);\n            this.tool_name = \"Tap\";\n            this.icon = icons_1.bk_tool_icon_tap_select;\n            this.event_type = \"tap\";\n            this.default_order = 10;\n        }\n        static init_TapTool() {\n            this.prototype.default_view = TapToolView;\n            this.define({\n                behavior: [p.TapBehavior, \"select\"],\n                callback: [p.Any],\n            });\n        }\n    }\n    exports.TapTool = TapTool;\n    TapTool.__name__ = \"TapTool\";\n    TapTool.init_TapTool();\n}\n","/* models/tools/gestures/wheel_pan_tool.js */ function _(require, module, exports) {\n    const gesture_tool_1 = require(268) /* ./gesture_tool */;\n    const p = require(18) /* ../../../core/properties */;\n    const icons_1 = require(271) /* ../../../styles/icons */;\n    class WheelPanToolView extends gesture_tool_1.GestureToolView {\n        _scroll(ev) {\n            let factor = this.model.speed * ev.delta;\n            // clamp the magnitude of factor, if it is > 1 bad things happen\n            if (factor > 0.9)\n                factor = 0.9;\n            else if (factor < -0.9)\n                factor = -0.9;\n            this._update_ranges(factor);\n        }\n        _update_ranges(factor) {\n            const { frame } = this.plot_view;\n            const hr = frame.bbox.h_range;\n            const vr = frame.bbox.v_range;\n            const [sx_low, sx_high] = [hr.start, hr.end];\n            const [sy_low, sy_high] = [vr.start, vr.end];\n            let sx0;\n            let sx1;\n            let sy0;\n            let sy1;\n            switch (this.model.dimension) {\n                case \"height\": {\n                    const sy_range = Math.abs(sy_high - sy_low);\n                    sx0 = sx_low;\n                    sx1 = sx_high;\n                    sy0 = sy_low - sy_range * factor;\n                    sy1 = sy_high - sy_range * factor;\n                    break;\n                }\n                case \"width\": {\n                    const sx_range = Math.abs(sx_high - sx_low);\n                    sx0 = sx_low - sx_range * factor;\n                    sx1 = sx_high - sx_range * factor;\n                    sy0 = sy_low;\n                    sy1 = sy_high;\n                    break;\n                }\n                default:\n                    throw new Error(\"this shouldn't have happened\");\n            }\n            const { xscales, yscales } = frame;\n            const xrs = {};\n            for (const name in xscales) {\n                const scale = xscales[name];\n                const [start, end] = scale.r_invert(sx0, sx1);\n                xrs[name] = { start, end };\n            }\n            const yrs = {};\n            for (const name in yscales) {\n                const scale = yscales[name];\n                const [start, end] = scale.r_invert(sy0, sy1);\n                yrs[name] = { start, end };\n            }\n            // OK this sucks we can't set factor independently in each direction. It is used\n            // for GMap plots, and GMap plots always preserve aspect, so effective the value\n            // of 'dimensions' is ignored.\n            const pan_info = { xrs, yrs, factor };\n            this.plot_view.push_state('wheel_pan', { range: pan_info });\n            this.plot_view.update_range(pan_info, false, true);\n            if (this.model.document != null)\n                this.model.document.interactive_start(this.plot_model);\n        }\n    }\n    exports.WheelPanToolView = WheelPanToolView;\n    WheelPanToolView.__name__ = \"WheelPanToolView\";\n    class WheelPanTool extends gesture_tool_1.GestureTool {\n        constructor(attrs) {\n            super(attrs);\n            this.tool_name = \"Wheel Pan\";\n            this.icon = icons_1.bk_tool_icon_wheel_pan;\n            this.event_type = \"scroll\";\n            this.default_order = 12;\n        }\n        static init_WheelPanTool() {\n            this.prototype.default_view = WheelPanToolView;\n            this.define({\n                dimension: [p.Dimension, \"width\"],\n            });\n            this.internal({\n                speed: [p.Number, 1 / 1000],\n            });\n        }\n        get tooltip() {\n            return this._get_dim_tooltip(this.tool_name, this.dimension);\n        }\n    }\n    exports.WheelPanTool = WheelPanTool;\n    WheelPanTool.__name__ = \"WheelPanTool\";\n    WheelPanTool.init_WheelPanTool();\n}\n","/* models/tools/gestures/wheel_zoom_tool.js */ function _(require, module, exports) {\n    const gesture_tool_1 = require(268) /* ./gesture_tool */;\n    const zoom_1 = require(314) /* ../../../core/util/zoom */;\n    const p = require(18) /* ../../../core/properties */;\n    const compat_1 = require(95) /* ../../../core/util/compat */;\n    const icons_1 = require(271) /* ../../../styles/icons */;\n    class WheelZoomToolView extends gesture_tool_1.GestureToolView {\n        _pinch(ev) {\n            // TODO (bev) this can probably be done much better\n            const { sx, sy, scale } = ev;\n            let delta;\n            if (scale >= 1)\n                delta = (scale - 1) * 20.0;\n            else\n                delta = -20.0 / scale;\n            this._scroll({ type: \"wheel\", sx, sy, delta });\n        }\n        _scroll(ev) {\n            const { frame } = this.plot_view;\n            const hr = frame.bbox.h_range;\n            const vr = frame.bbox.v_range;\n            const { sx, sy } = ev;\n            const dims = this.model.dimensions;\n            // restrict to axis configured in tool's dimensions property and if\n            // zoom origin is inside of frame range/domain\n            const h_axis = (dims == 'width' || dims == 'both') && hr.start < sx && sx < hr.end;\n            const v_axis = (dims == 'height' || dims == 'both') && vr.start < sy && sy < vr.end;\n            if ((!h_axis || !v_axis) && !this.model.zoom_on_axis) {\n                return;\n            }\n            const factor = this.model.speed * ev.delta;\n            const zoom_info = zoom_1.scale_range(frame, factor, h_axis, v_axis, { x: sx, y: sy });\n            this.plot_view.push_state('wheel_zoom', { range: zoom_info });\n            this.plot_view.update_range(zoom_info, false, true, this.model.maintain_focus);\n            if (this.model.document != null)\n                this.model.document.interactive_start(this.plot_model);\n        }\n    }\n    exports.WheelZoomToolView = WheelZoomToolView;\n    WheelZoomToolView.__name__ = \"WheelZoomToolView\";\n    class WheelZoomTool extends gesture_tool_1.GestureTool {\n        constructor(attrs) {\n            super(attrs);\n            this.tool_name = \"Wheel Zoom\";\n            this.icon = icons_1.bk_tool_icon_wheel_zoom;\n            this.event_type = compat_1.is_mobile ? \"pinch\" : \"scroll\";\n            this.default_order = 10;\n        }\n        static init_WheelZoomTool() {\n            this.prototype.default_view = WheelZoomToolView;\n            this.define({\n                dimensions: [p.Dimensions, \"both\"],\n                maintain_focus: [p.Boolean, true],\n                zoom_on_axis: [p.Boolean, true],\n                speed: [p.Number, 1 / 600],\n            });\n        }\n        get tooltip() {\n            return this._get_dim_tooltip(this.tool_name, this.dimensions);\n        }\n    }\n    exports.WheelZoomTool = WheelZoomTool;\n    WheelZoomTool.__name__ = \"WheelZoomTool\";\n    WheelZoomTool.init_WheelZoomTool();\n}\n","/* models/tools/inspectors/crosshair_tool.js */ function _(require, module, exports) {\n    const inspect_tool_1 = require(262) /* ./inspect_tool */;\n    const span_1 = require(133) /* ../../annotations/span */;\n    const p = require(18) /* ../../../core/properties */;\n    const object_1 = require(22) /* ../../../core/util/object */;\n    const icons_1 = require(271) /* ../../../styles/icons */;\n    class CrosshairToolView extends inspect_tool_1.InspectToolView {\n        _move(ev) {\n            if (!this.model.active)\n                return;\n            const { sx, sy } = ev;\n            if (!this.plot_view.frame.bbox.contains(sx, sy))\n                this._update_spans(null, null);\n            else\n                this._update_spans(sx, sy);\n        }\n        _move_exit(_e) {\n            this._update_spans(null, null);\n        }\n        _update_spans(x, y) {\n            const dims = this.model.dimensions;\n            if (dims == \"width\" || dims == \"both\")\n                this.model.spans.width.computed_location = y;\n            if (dims == \"height\" || dims == \"both\")\n                this.model.spans.height.computed_location = x;\n        }\n    }\n    exports.CrosshairToolView = CrosshairToolView;\n    CrosshairToolView.__name__ = \"CrosshairToolView\";\n    class CrosshairTool extends inspect_tool_1.InspectTool {\n        constructor(attrs) {\n            super(attrs);\n            this.tool_name = \"Crosshair\";\n            this.icon = icons_1.bk_tool_icon_crosshair;\n        }\n        static init_CrosshairTool() {\n            this.prototype.default_view = CrosshairToolView;\n            this.define({\n                dimensions: [p.Dimensions, \"both\"],\n                line_color: [p.Color, 'black'],\n                line_width: [p.Number, 1],\n                line_alpha: [p.Number, 1.0],\n            });\n            this.internal({\n                location_units: [p.SpatialUnits, \"screen\"],\n                render_mode: [p.RenderMode, \"css\"],\n                spans: [p.Any],\n            });\n        }\n        get tooltip() {\n            return this._get_dim_tooltip(\"Crosshair\", this.dimensions);\n        }\n        get synthetic_renderers() {\n            return object_1.values(this.spans);\n        }\n        initialize() {\n            super.initialize();\n            this.spans = {\n                width: new span_1.Span({\n                    for_hover: true,\n                    dimension: \"width\",\n                    render_mode: this.render_mode,\n                    location_units: this.location_units,\n                    line_color: this.line_color,\n                    line_width: this.line_width,\n                    line_alpha: this.line_alpha,\n                }),\n                height: new span_1.Span({\n                    for_hover: true,\n                    dimension: \"height\",\n                    render_mode: this.render_mode,\n                    location_units: this.location_units,\n                    line_color: this.line_color,\n                    line_width: this.line_width,\n                    line_alpha: this.line_alpha,\n                }),\n            };\n        }\n    }\n    exports.CrosshairTool = CrosshairTool;\n    CrosshairTool.__name__ = \"CrosshairTool\";\n    CrosshairTool.init_CrosshairTool();\n}\n","/* models/tools/inspectors/customjs_hover.js */ function _(require, module, exports) {\n    const model_1 = require(64) /* ../../../model */;\n    const p = require(18) /* ../../../core/properties */;\n    const object_1 = require(22) /* ../../../core/util/object */;\n    const string_1 = require(25) /* ../../../core/util/string */;\n    class CustomJSHover extends model_1.Model {\n        constructor(attrs) {\n            super(attrs);\n        }\n        static init_CustomJSHover() {\n            this.define({\n                args: [p.Any, {}],\n                code: [p.String, \"\"],\n            });\n        }\n        get values() {\n            return object_1.values(this.args);\n        }\n        /*protected*/ _make_code(valname, formatname, varsname, fn) {\n            // this relies on keys(args) and values(args) returning keys and values\n            // in the same order\n            return new Function(...object_1.keys(this.args), valname, formatname, varsname, \"require\", \"exports\", string_1.use_strict(fn));\n        }\n        format(value, format, special_vars) {\n            const formatter = this._make_code(\"value\", \"format\", \"special_vars\", this.code);\n            return formatter(...this.values, value, format, special_vars, require, exports);\n        }\n    }\n    exports.CustomJSHover = CustomJSHover;\n    CustomJSHover.__name__ = \"CustomJSHover\";\n    CustomJSHover.init_CustomJSHover();\n}\n","/* models/tools/inspectors/hover_tool.js */ function _(require, module, exports) {\n    const inspect_tool_1 = require(262) /* ./inspect_tool */;\n    const tooltip_1 = require(136) /* ../../annotations/tooltip */;\n    const glyph_renderer_1 = require(73) /* ../../renderers/glyph_renderer */;\n    const graph_renderer_1 = require(90) /* ../../renderers/graph_renderer */;\n    const util_1 = require(325) /* ../util */;\n    const hittest = require(81) /* ../../../core/hittest */;\n    const templating_1 = require(151) /* ../../../core/util/templating */;\n    const dom_1 = require(61) /* ../../../core/dom */;\n    const p = require(18) /* ../../../core/properties */;\n    const color_1 = require(20) /* ../../../core/util/color */;\n    const object_1 = require(22) /* ../../../core/util/object */;\n    const types_1 = require(7) /* ../../../core/util/types */;\n    const build_views_1 = require(92) /* ../../../core/build_views */;\n    const icons_1 = require(271) /* ../../../styles/icons */;\n    const tooltips_1 = require(137) /* ../../../styles/tooltips */;\n    function _nearest_line_hit(i, geometry, sx, sy, dx, dy) {\n        const d1 = { x: dx[i], y: dy[i] };\n        const d2 = { x: dx[i + 1], y: dy[i + 1] };\n        let dist1;\n        let dist2;\n        if (geometry.type == \"span\") {\n            if (geometry.direction == \"h\") {\n                dist1 = Math.abs(d1.x - sx);\n                dist2 = Math.abs(d2.x - sx);\n            }\n            else {\n                dist1 = Math.abs(d1.y - sy);\n                dist2 = Math.abs(d2.y - sy);\n            }\n        }\n        else {\n            const s = { x: sx, y: sy };\n            dist1 = hittest.dist_2_pts(d1, s);\n            dist2 = hittest.dist_2_pts(d2, s);\n        }\n        if (dist1 < dist2)\n            return [[d1.x, d1.y], i];\n        else\n            return [[d2.x, d2.y], i + 1];\n    }\n    exports._nearest_line_hit = _nearest_line_hit;\n    function _line_hit(xs, ys, ind) {\n        return [[xs[ind], ys[ind]], ind];\n    }\n    exports._line_hit = _line_hit;\n    class HoverToolView extends inspect_tool_1.InspectToolView {\n        initialize() {\n            super.initialize();\n            this.ttviews = {};\n        }\n        remove() {\n            build_views_1.remove_views(this.ttviews);\n            super.remove();\n        }\n        connect_signals() {\n            super.connect_signals();\n            for (const r of this.computed_renderers) {\n                if (r instanceof glyph_renderer_1.GlyphRenderer)\n                    this.connect(r.data_source.inspect, this._update);\n                else if (r instanceof graph_renderer_1.GraphRenderer) {\n                    this.connect(r.node_renderer.data_source.inspect, this._update);\n                    this.connect(r.edge_renderer.data_source.inspect, this._update);\n                }\n            }\n            // TODO: this.connect(this.plot_model.properties.renderers.change, () => this._computed_renderers = this._ttmodels = null)\n            this.connect(this.model.properties.renderers.change, () => this._computed_renderers = this._ttmodels = null);\n            this.connect(this.model.properties.names.change, () => this._computed_renderers = this._ttmodels = null);\n            this.connect(this.model.properties.tooltips.change, () => this._ttmodels = null);\n        }\n        _compute_ttmodels() {\n            const ttmodels = {};\n            const tooltips = this.model.tooltips;\n            if (tooltips != null) {\n                for (const r of this.computed_renderers) {\n                    if (r instanceof glyph_renderer_1.GlyphRenderer) {\n                        const tooltip = new tooltip_1.Tooltip({\n                            custom: types_1.isString(tooltips) || types_1.isFunction(tooltips),\n                            attachment: this.model.attachment,\n                            show_arrow: this.model.show_arrow,\n                        });\n                        ttmodels[r.id] = tooltip;\n                    }\n                    else if (r instanceof graph_renderer_1.GraphRenderer) {\n                        const tooltip = new tooltip_1.Tooltip({\n                            custom: types_1.isString(tooltips) || types_1.isFunction(tooltips),\n                            attachment: this.model.attachment,\n                            show_arrow: this.model.show_arrow,\n                        });\n                        ttmodels[r.node_renderer.id] = tooltip;\n                        ttmodels[r.edge_renderer.id] = tooltip;\n                    }\n                }\n            }\n            build_views_1.build_views(this.ttviews, object_1.values(ttmodels), { parent: this.plot_view });\n            return ttmodels;\n        }\n        get computed_renderers() {\n            if (this._computed_renderers == null) {\n                const renderers = this.model.renderers;\n                const all_renderers = this.plot_model.renderers;\n                const names = this.model.names;\n                this._computed_renderers = util_1.compute_renderers(renderers, all_renderers, names);\n            }\n            return this._computed_renderers;\n        }\n        get ttmodels() {\n            if (this._ttmodels == null)\n                this._ttmodels = this._compute_ttmodels();\n            return this._ttmodels;\n        }\n        _clear() {\n            this._inspect(Infinity, Infinity);\n            for (const rid in this.ttmodels) {\n                const tt = this.ttmodels[rid];\n                tt.clear();\n            }\n        }\n        _move(ev) {\n            if (!this.model.active)\n                return;\n            const { sx, sy } = ev;\n            if (!this.plot_view.frame.bbox.contains(sx, sy))\n                this._clear();\n            else\n                this._inspect(sx, sy);\n        }\n        _move_exit() {\n            this._clear();\n        }\n        _inspect(sx, sy) {\n            let geometry;\n            if (this.model.mode == 'mouse')\n                geometry = { type: 'point', sx, sy };\n            else {\n                const direction = this.model.mode == 'vline' ? 'h' : 'v';\n                geometry = { type: 'span', direction, sx, sy };\n            }\n            for (const r of this.computed_renderers) {\n                const sm = r.get_selection_manager();\n                sm.inspect(this.plot_view.renderer_views[r.id], geometry);\n            }\n            if (this.model.callback != null)\n                this._emit_callback(geometry);\n        }\n        _update([renderer_view, { geometry }]) {\n            if (!this.model.active)\n                return;\n            if (!(renderer_view instanceof glyph_renderer_1.GlyphRendererView || renderer_view instanceof graph_renderer_1.GraphRendererView))\n                return;\n            const { model: renderer } = renderer_view;\n            const tooltip = this.ttmodels[renderer.id];\n            if (tooltip == null)\n                return;\n            tooltip.clear();\n            const selection_manager = renderer.get_selection_manager();\n            let indices = selection_manager.inspectors[renderer.id];\n            if (renderer instanceof glyph_renderer_1.GlyphRenderer)\n                indices = renderer.view.convert_selection_to_subset(indices);\n            if (indices.is_empty())\n                return;\n            const ds = selection_manager.source;\n            const { frame } = this.plot_view;\n            const { sx, sy } = geometry;\n            const xscale = frame.xscales[renderer.x_range_name];\n            const yscale = frame.yscales[renderer.y_range_name];\n            const x = xscale.invert(sx);\n            const y = yscale.invert(sy);\n            const glyph = renderer_view.glyph; // XXX\n            for (const i of indices.line_indices) {\n                let data_x = glyph._x[i + 1];\n                let data_y = glyph._y[i + 1];\n                let ii = i;\n                let rx;\n                let ry;\n                switch (this.model.line_policy) {\n                    case \"interp\": { // and renderer.get_interpolation_hit?\n                        [data_x, data_y] = glyph.get_interpolation_hit(i, geometry);\n                        rx = xscale.compute(data_x);\n                        ry = yscale.compute(data_y);\n                        break;\n                    }\n                    case \"prev\": {\n                        [[rx, ry], ii] = _line_hit(glyph.sx, glyph.sy, i);\n                        break;\n                    }\n                    case \"next\": {\n                        [[rx, ry], ii] = _line_hit(glyph.sx, glyph.sy, i + 1);\n                        break;\n                    }\n                    case \"nearest\": {\n                        [[rx, ry], ii] = _nearest_line_hit(i, geometry, sx, sy, glyph.sx, glyph.sy);\n                        data_x = glyph._x[ii];\n                        data_y = glyph._y[ii];\n                        break;\n                    }\n                    default: {\n                        [rx, ry] = [sx, sy];\n                    }\n                }\n                const vars = {\n                    index: ii,\n                    x, y, sx, sy, data_x, data_y, rx, ry,\n                    indices: indices.line_indices,\n                    name: renderer_view.model.name,\n                };\n                tooltip.add(rx, ry, this._render_tooltips(ds, ii, vars));\n            }\n            for (const struct of indices.image_indices) {\n                const vars = { index: struct.index, x, y, sx, sy };\n                const rendered = this._render_tooltips(ds, struct, vars);\n                tooltip.add(sx, sy, rendered);\n            }\n            for (const i of indices.indices) {\n                // multiglyphs set additional indices, e.g. multiline_indices for different tooltips\n                if (!object_1.isEmpty(indices.multiline_indices)) {\n                    for (const j of indices.multiline_indices[i.toString()]) {\n                        let data_x = glyph._xs[i][j];\n                        let data_y = glyph._ys[i][j];\n                        let jj = j;\n                        let rx;\n                        let ry;\n                        switch (this.model.line_policy) {\n                            case \"interp\": { // and renderer.get_interpolation_hit?\n                                [data_x, data_y] = glyph.get_interpolation_hit(i, j, geometry);\n                                rx = xscale.compute(data_x);\n                                ry = yscale.compute(data_y);\n                                break;\n                            }\n                            case \"prev\": {\n                                [[rx, ry], jj] = _line_hit(glyph.sxs[i], glyph.sys[i], j);\n                                break;\n                            }\n                            case \"next\": {\n                                [[rx, ry], jj] = _line_hit(glyph.sxs[i], glyph.sys[i], j + 1);\n                                break;\n                            }\n                            case \"nearest\": {\n                                [[rx, ry], jj] = _nearest_line_hit(j, geometry, sx, sy, glyph.sxs[i], glyph.sys[i]);\n                                data_x = glyph._xs[i][jj];\n                                data_y = glyph._ys[i][jj];\n                                break;\n                            }\n                            default:\n                                throw new Error(\"should't have happened\");\n                        }\n                        let index;\n                        if (renderer instanceof glyph_renderer_1.GlyphRenderer)\n                            index = renderer.view.convert_indices_from_subset([i])[0];\n                        else\n                            index = i;\n                        const vars = {\n                            index, x, y, sx, sy, data_x, data_y,\n                            segment_index: jj,\n                            indices: indices.multiline_indices,\n                            name: renderer_view.model.name,\n                        };\n                        tooltip.add(rx, ry, this._render_tooltips(ds, index, vars));\n                    }\n                }\n                else {\n                    // handle non-multiglyphs\n                    const data_x = glyph._x != null ? glyph._x[i] : undefined;\n                    const data_y = glyph._y != null ? glyph._y[i] : undefined;\n                    let rx;\n                    let ry;\n                    if (this.model.point_policy == 'snap_to_data') { // and renderer.glyph.sx? and renderer.glyph.sy?\n                        // Pass in our screen position so we can determine which patch we're\n                        // over if there are discontinuous patches.\n                        let pt = glyph.get_anchor_point(this.model.anchor, i, [sx, sy]);\n                        if (pt == null)\n                            pt = glyph.get_anchor_point(\"center\", i, [sx, sy]);\n                        rx = pt.x;\n                        ry = pt.y;\n                    }\n                    else\n                        [rx, ry] = [sx, sy];\n                    let index;\n                    if (renderer instanceof glyph_renderer_1.GlyphRenderer)\n                        index = renderer.view.convert_indices_from_subset([i])[0];\n                    else\n                        index = i;\n                    const vars = {\n                        index, x, y, sx, sy, data_x, data_y,\n                        indices: indices.indices,\n                        name: renderer_view.model.name,\n                    };\n                    tooltip.add(rx, ry, this._render_tooltips(ds, index, vars));\n                }\n            }\n        }\n        _emit_callback(geometry) {\n            for (const r of this.computed_renderers) {\n                const index = r.data_source.inspected;\n                const { frame } = this.plot_view;\n                const xscale = frame.xscales[r.x_range_name];\n                const yscale = frame.yscales[r.y_range_name];\n                const x = xscale.invert(geometry.sx);\n                const y = yscale.invert(geometry.sy);\n                const g = Object.assign({ x, y }, geometry);\n                this.model.callback.execute(this.model, { index, geometry: g, renderer: r });\n            }\n        }\n        _render_tooltips(ds, i, vars) {\n            const tooltips = this.model.tooltips;\n            if (types_1.isString(tooltips)) {\n                const el = dom_1.div();\n                el.innerHTML = templating_1.replace_placeholders(tooltips, ds, i, this.model.formatters, vars);\n                return el;\n            }\n            else if (types_1.isFunction(tooltips)) {\n                return tooltips(ds, vars);\n            }\n            else {\n                const rows = dom_1.div({ style: { display: \"table\", borderSpacing: \"2px\" } });\n                for (const [label, value] of tooltips) {\n                    const row = dom_1.div({ style: { display: \"table-row\" } });\n                    rows.appendChild(row);\n                    let cell;\n                    cell = dom_1.div({ style: { display: \"table-cell\" }, class: tooltips_1.bk_tooltip_row_label }, label.length != 0 ? `${label}: ` : \"\");\n                    row.appendChild(cell);\n                    cell = dom_1.div({ style: { display: \"table-cell\" }, class: tooltips_1.bk_tooltip_row_value });\n                    row.appendChild(cell);\n                    if (value.indexOf(\"$color\") >= 0) {\n                        const [, opts = \"\", colname] = value.match(/\\$color(\\[.*\\])?:(\\w*)/); // XXX!\n                        const column = ds.get_column(colname); // XXX: change to columnar ds\n                        if (column == null) {\n                            const el = dom_1.span({}, `${colname} unknown`);\n                            cell.appendChild(el);\n                            continue;\n                        }\n                        const hex = opts.indexOf(\"hex\") >= 0;\n                        const swatch = opts.indexOf(\"swatch\") >= 0;\n                        let color = types_1.isNumber(i) ? column[i] : null;\n                        if (color == null) {\n                            const el = dom_1.span({}, \"(null)\");\n                            cell.appendChild(el);\n                            continue;\n                        }\n                        if (hex)\n                            color = color_1.color2hex(color);\n                        let el = dom_1.span({}, color);\n                        cell.appendChild(el);\n                        if (swatch) {\n                            el = dom_1.span({ class: tooltips_1.bk_tooltip_color_block, style: { backgroundColor: color } }, \" \");\n                            cell.appendChild(el);\n                        }\n                    }\n                    else {\n                        const el = dom_1.span();\n                        el.innerHTML = templating_1.replace_placeholders(value.replace(\"$~\", \"$data_\"), ds, i, this.model.formatters, vars);\n                        cell.appendChild(el);\n                    }\n                }\n                return rows;\n            }\n        }\n    }\n    exports.HoverToolView = HoverToolView;\n    HoverToolView.__name__ = \"HoverToolView\";\n    class HoverTool extends inspect_tool_1.InspectTool {\n        constructor(attrs) {\n            super(attrs);\n            this.tool_name = \"Hover\";\n            this.icon = icons_1.bk_tool_icon_hover;\n        }\n        static init_HoverTool() {\n            this.prototype.default_view = HoverToolView;\n            this.define({\n                tooltips: [p.Any, [\n                        [\"index\", \"$index\"],\n                        [\"data (x, y)\", \"($x, $y)\"],\n                        [\"screen (x, y)\", \"($sx, $sy)\"],\n                    ]],\n                formatters: [p.Any, {}],\n                renderers: [p.Any, 'auto'],\n                names: [p.Array, []],\n                mode: [p.HoverMode, 'mouse'],\n                point_policy: [p.PointPolicy, 'snap_to_data'],\n                line_policy: [p.LinePolicy, 'nearest'],\n                show_arrow: [p.Boolean, true],\n                anchor: [p.Anchor, 'center'],\n                attachment: [p.TooltipAttachment, 'horizontal'],\n                callback: [p.Any],\n            });\n        }\n    }\n    exports.HoverTool = HoverTool;\n    HoverTool.__name__ = \"HoverTool\";\n    HoverTool.init_HoverTool();\n}\n","/* models/tools/tool_proxy.js */ function _(require, module, exports) {\n    const p = require(18) /* ../../core/properties */;\n    const signaling_1 = require(13) /* ../../core/signaling */;\n    const model_1 = require(64) /* ../../model */;\n    const inspect_tool_1 = require(262) /* ./inspectors/inspect_tool */;\n    class ToolProxy extends model_1.Model {\n        constructor(attrs) {\n            super(attrs);\n        }\n        static init_ToolProxy() {\n            this.define({\n                tools: [p.Array, []],\n                active: [p.Boolean, false],\n                disabled: [p.Boolean, false],\n            });\n        }\n        // Operates all the tools given only one button\n        get button_view() {\n            return this.tools[0].button_view;\n        }\n        get event_type() {\n            return this.tools[0].event_type;\n        }\n        get tooltip() {\n            return this.tools[0].tooltip;\n        }\n        get tool_name() {\n            return this.tools[0].tool_name;\n        }\n        get icon() {\n            return this.tools[0].computed_icon;\n        }\n        get computed_icon() {\n            return this.icon;\n        }\n        get toggleable() {\n            const tool = this.tools[0];\n            return tool instanceof inspect_tool_1.InspectTool && tool.toggleable;\n        }\n        initialize() {\n            super.initialize();\n            this.do = new signaling_1.Signal0(this, \"do\");\n        }\n        connect_signals() {\n            super.connect_signals();\n            this.connect(this.do, () => this.doit());\n            this.connect(this.properties.active.change, () => this.set_active());\n        }\n        doit() {\n            for (const tool of this.tools) {\n                tool.do.emit();\n            }\n        }\n        set_active() {\n            for (const tool of this.tools) {\n                tool.active = this.active;\n            }\n        }\n    }\n    exports.ToolProxy = ToolProxy;\n    ToolProxy.__name__ = \"ToolProxy\";\n    ToolProxy.init_ToolProxy();\n}\n","/* models/tools/toolbar_box.js */ function _(require, module, exports) {\n    const p = require(18) /* ../../core/properties */;\n    const array_1 = require(8) /* ../../core/util/array */;\n    const toolbar_base_1 = require(267) /* ./toolbar_base */;\n    const tool_proxy_1 = require(337) /* ./tool_proxy */;\n    const layout_dom_1 = require(237) /* ../layouts/layout_dom */;\n    const layout_1 = require(180) /* ../../core/layout */;\n    class ProxyToolbar extends toolbar_base_1.ToolbarBase {\n        constructor(attrs) {\n            super(attrs);\n        }\n        initialize() {\n            super.initialize();\n            this._merge_tools();\n        }\n        _merge_tools() {\n            // Go through all the tools on the toolbar and replace them with\n            // a proxy e.g. PanTool, BoxSelectTool, etc.\n            this._proxied_tools = [];\n            const inspectors = {};\n            const actions = {};\n            const gestures = {};\n            const new_help_tools = [];\n            const new_help_urls = [];\n            for (const helptool of this.help) {\n                if (!array_1.includes(new_help_urls, helptool.redirect)) {\n                    new_help_tools.push(helptool);\n                    new_help_urls.push(helptool.redirect);\n                }\n            }\n            this._proxied_tools.push(...new_help_tools);\n            this.help = new_help_tools;\n            for (const event_type in this.gestures) {\n                const gesture = this.gestures[event_type];\n                if (!(event_type in gestures)) {\n                    gestures[event_type] = {};\n                }\n                for (const tool of gesture.tools) {\n                    if (!(tool.type in gestures[event_type])) {\n                        gestures[event_type][tool.type] = [];\n                    }\n                    gestures[event_type][tool.type].push(tool);\n                }\n            }\n            for (const tool of this.inspectors) {\n                if (!(tool.type in inspectors)) {\n                    inspectors[tool.type] = [];\n                }\n                inspectors[tool.type].push(tool);\n            }\n            for (const tool of this.actions) {\n                if (!(tool.type in actions)) {\n                    actions[tool.type] = [];\n                }\n                actions[tool.type].push(tool);\n            }\n            // Add a proxy for each of the groups of tools.\n            const make_proxy = (tools, active = false) => {\n                const proxy = new tool_proxy_1.ToolProxy({ tools, active });\n                this._proxied_tools.push(proxy);\n                return proxy;\n            };\n            for (const event_type in gestures) {\n                const gesture = this.gestures[event_type];\n                gesture.tools = [];\n                for (const tool_type in gestures[event_type]) {\n                    const tools = gestures[event_type][tool_type];\n                    if (tools.length > 0) {\n                        if (event_type == 'multi') {\n                            for (const tool of tools) {\n                                const proxy = make_proxy([tool]);\n                                gesture.tools.push(proxy);\n                                this.connect(proxy.properties.active.change, this._active_change.bind(this, proxy));\n                            }\n                        }\n                        else {\n                            const proxy = make_proxy(tools);\n                            gesture.tools.push(proxy);\n                            this.connect(proxy.properties.active.change, this._active_change.bind(this, proxy));\n                        }\n                    }\n                }\n            }\n            this.actions = [];\n            for (const tool_type in actions) {\n                const tools = actions[tool_type];\n                if (tool_type == 'CustomAction') {\n                    for (const tool of tools)\n                        this.actions.push(make_proxy([tool]));\n                }\n                else if (tools.length > 0) {\n                    this.actions.push(make_proxy(tools)); // XXX\n                }\n            }\n            this.inspectors = [];\n            for (const tool_type in inspectors) {\n                const tools = inspectors[tool_type];\n                if (tools.length > 0)\n                    this.inspectors.push(make_proxy(tools, true)); // XXX\n            }\n            for (const et in this.gestures) {\n                const gesture = this.gestures[et];\n                if (gesture.tools.length == 0)\n                    continue;\n                gesture.tools = array_1.sort_by(gesture.tools, (tool) => tool.default_order);\n                if (!(et == 'pinch' || et == 'scroll' || et == 'multi'))\n                    gesture.tools[0].active = true;\n            }\n        }\n    }\n    exports.ProxyToolbar = ProxyToolbar;\n    ProxyToolbar.__name__ = \"ProxyToolbar\";\n    class ToolbarBoxView extends layout_dom_1.LayoutDOMView {\n        initialize() {\n            this.model.toolbar.toolbar_location = this.model.toolbar_location;\n            super.initialize();\n        }\n        get child_models() {\n            return [this.model.toolbar]; // XXX\n        }\n        _update_layout() {\n            this.layout = new layout_1.ContentBox(this.child_views[0].el);\n            const { toolbar } = this.model;\n            if (toolbar.horizontal) {\n                this.layout.set_sizing({\n                    width_policy: \"fit\", min_width: 100, height_policy: \"fixed\",\n                });\n            }\n            else {\n                this.layout.set_sizing({\n                    width_policy: \"fixed\", height_policy: \"fit\", min_height: 100,\n                });\n            }\n        }\n    }\n    exports.ToolbarBoxView = ToolbarBoxView;\n    ToolbarBoxView.__name__ = \"ToolbarBoxView\";\n    class ToolbarBox extends layout_dom_1.LayoutDOM {\n        constructor(attrs) {\n            super(attrs);\n        }\n        static init_ToolbarBox() {\n            this.prototype.default_view = ToolbarBoxView;\n            this.define({\n                toolbar: [p.Instance],\n                toolbar_location: [p.Location, \"right\"],\n            });\n        }\n    }\n    exports.ToolbarBox = ToolbarBox;\n    ToolbarBox.__name__ = \"ToolbarBox\";\n    ToolbarBox.init_ToolbarBox();\n}\n","/* embed/standalone.js */ function _(require, module, exports) {\n    const document_1 = require(4) /* ../document */;\n    const dom_1 = require(61) /* ../core/dom */;\n    const dom_2 = require(340) /* ./dom */;\n    // A map from the root model IDs to their views.\n    exports.index = {};\n    function _create_view(model) {\n        const view = new model.default_view({ model, parent: null });\n        exports.index[model.id] = view;\n        return view;\n    }\n    function add_document_standalone(document, element, roots = {}, use_for_title = false) {\n        // this is a LOCAL index of views used only by this particular rendering\n        // call, so we can remove the views we create.\n        const views = {};\n        function render_model(model) {\n            let root_el;\n            if (model.id in roots)\n                root_el = roots[model.id];\n            else if (element.classList.contains(dom_2.BOKEH_ROOT))\n                root_el = element;\n            else {\n                root_el = dom_1.div({ class: dom_2.BOKEH_ROOT });\n                element.appendChild(root_el);\n            }\n            const view = _create_view(model);\n            view.renderTo(root_el);\n            views[model.id] = view;\n        }\n        function unrender_model(model) {\n            const { id } = model;\n            if (id in views) {\n                const view = views[id];\n                view.remove();\n                delete views[id];\n                delete exports.index[id];\n            }\n        }\n        for (const model of document.roots())\n            render_model(model);\n        if (use_for_title)\n            window.document.title = document.title();\n        document.on_change((event) => {\n            if (event instanceof document_1.RootAddedEvent)\n                render_model(event.model);\n            else if (event instanceof document_1.RootRemovedEvent)\n                unrender_model(event.model);\n            else if (use_for_title && event instanceof document_1.TitleChangedEvent)\n                window.document.title = event.title;\n        });\n        return views;\n    }\n    exports.add_document_standalone = add_document_standalone;\n}\n","/* embed/dom.js */ function _(require, module, exports) {\n    const dom_1 = require(61) /* ../core/dom */;\n    const root_1 = require(62) /* ../styles/root */;\n    // Matches Bokeh CSS class selector. Setting all Bokeh parent element class names\n    // with this var prevents user configurations where css styling is unset.\n    exports.BOKEH_ROOT = root_1.bk_root;\n    function _get_element(elementid) {\n        let element = document.getElementById(elementid);\n        if (element == null)\n            throw new Error(`Error rendering Bokeh model: could not find #${elementid} HTML tag`);\n        if (!document.body.contains(element))\n            throw new Error(`Error rendering Bokeh model: element #${elementid} must be under <body>`);\n        // If autoload script, replace script tag with div for embedding.\n        if (element.tagName == \"SCRIPT\") {\n            const root_el = dom_1.div({ class: exports.BOKEH_ROOT });\n            dom_1.replaceWith(element, root_el);\n            element = root_el;\n        }\n        return element;\n    }\n    function _resolve_element(item) {\n        const { elementid } = item;\n        if (elementid != null)\n            return _get_element(elementid);\n        else\n            return document.body;\n    }\n    exports._resolve_element = _resolve_element;\n    function _resolve_root_elements(item) {\n        const roots = {};\n        if (item.roots != null) {\n            for (const root_id in item.roots)\n                roots[root_id] = _get_element(item.roots[root_id]);\n        }\n        return roots;\n    }\n    exports._resolve_root_elements = _resolve_root_elements;\n}\n","/* embed/server.js */ function _(require, module, exports) {\n    const connection_1 = require(342) /* ../client/connection */;\n    const logging_1 = require(65) /* ../core/logging */;\n    const standalone_1 = require(339) /* ./standalone */;\n    // @internal\n    function _get_ws_url(app_path, absolute_url) {\n        let protocol = 'ws:';\n        if (window.location.protocol == 'https:')\n            protocol = 'wss:';\n        let loc;\n        if (absolute_url != null) {\n            loc = document.createElement('a');\n            loc.href = absolute_url;\n        }\n        else\n            loc = window.location;\n        if (app_path != null) {\n            if (app_path == \"/\")\n                app_path = \"\";\n        }\n        else\n            app_path = loc.pathname.replace(/\\/+$/, '');\n        return protocol + '//' + loc.host + app_path + '/ws';\n    }\n    exports._get_ws_url = _get_ws_url;\n    // map { websocket url to map { session id to promise of ClientSession } }\n    const _sessions = {};\n    function _get_session(websocket_url, session_id, args_string) {\n        if (!(websocket_url in _sessions))\n            _sessions[websocket_url] = {};\n        const subsessions = _sessions[websocket_url];\n        if (!(session_id in subsessions))\n            subsessions[session_id] = connection_1.pull_session(websocket_url, session_id, args_string);\n        return subsessions[session_id];\n    }\n    // Fill element with the roots from session_id\n    function add_document_from_session(websocket_url, session_id, element, roots = {}, use_for_title = false) {\n        const args_string = window.location.search.substr(1);\n        const promise = _get_session(websocket_url, session_id, args_string);\n        return promise.then((session) => {\n            return standalone_1.add_document_standalone(session.document, element, roots, use_for_title);\n        }, (error) => {\n            logging_1.logger.error(`Failed to load Bokeh session ${session_id}: ${error}`);\n            throw error;\n        });\n    }\n    exports.add_document_from_session = add_document_from_session;\n}\n","/* client/connection.js */ function _(require, module, exports) {\n    const logging_1 = require(65) /* ../core/logging */;\n    const document_1 = require(4) /* ../document */;\n    const message_1 = require(343) /* ../protocol/message */;\n    const receiver_1 = require(344) /* ../protocol/receiver */;\n    const session_1 = require(345) /* ./session */;\n    exports.DEFAULT_SERVER_WEBSOCKET_URL = \"ws://localhost:5006/ws\";\n    exports.DEFAULT_SESSION_ID = \"default\";\n    let _connection_count = 0;\n    class ClientConnection {\n        constructor(url = exports.DEFAULT_SERVER_WEBSOCKET_URL, id = exports.DEFAULT_SESSION_ID, args_string = null, _on_have_session_hook = null, _on_closed_permanently_hook = null) {\n            this.url = url;\n            this.id = id;\n            this.args_string = args_string;\n            this._on_have_session_hook = _on_have_session_hook;\n            this._on_closed_permanently_hook = _on_closed_permanently_hook;\n            this._number = _connection_count++;\n            this.socket = null;\n            this.session = null;\n            this.closed_permanently = false;\n            this._current_handler = null;\n            this._pending_ack = null; // null or [resolve,reject]\n            this._pending_replies = {}; // map reqid to [resolve,reject]\n            this._pending_messages = [];\n            this._receiver = new receiver_1.Receiver();\n            logging_1.logger.debug(`Creating websocket ${this._number} to '${this.url}' session '${this.id}'`);\n        }\n        connect() {\n            if (this.closed_permanently)\n                return Promise.reject(new Error(\"Cannot connect() a closed ClientConnection\"));\n            if (this.socket != null)\n                return Promise.reject(new Error(\"Already connected\"));\n            this._pending_replies = {};\n            this._current_handler = null;\n            try {\n                let versioned_url = `${this.url}?bokeh-protocol-version=1.0&bokeh-session-id=${this.id}`;\n                if (this.args_string != null && this.args_string.length > 0)\n                    versioned_url += `&${this.args_string}`;\n                this.socket = new WebSocket(versioned_url);\n                return new Promise((resolve, reject) => {\n                    // \"arraybuffer\" gives us binary data we can look at;\n                    // if we just needed an opaque blob we could use \"blob\"\n                    this.socket.binaryType = \"arraybuffer\";\n                    this.socket.onopen = () => this._on_open(resolve, reject);\n                    this.socket.onmessage = (event) => this._on_message(event);\n                    this.socket.onclose = (event) => this._on_close(event);\n                    this.socket.onerror = () => this._on_error(reject);\n                });\n            }\n            catch (error) {\n                logging_1.logger.error(`websocket creation failed to url: ${this.url}`);\n                logging_1.logger.error(` - ${error}`);\n                return Promise.reject(error);\n            }\n        }\n        close() {\n            if (!this.closed_permanently) {\n                logging_1.logger.debug(`Permanently closing websocket connection ${this._number}`);\n                this.closed_permanently = true;\n                if (this.socket != null)\n                    this.socket.close(1000, `close method called on ClientConnection ${this._number}`);\n                this.session._connection_closed();\n                if (this._on_closed_permanently_hook != null) {\n                    this._on_closed_permanently_hook();\n                    this._on_closed_permanently_hook = null;\n                }\n            }\n        }\n        _schedule_reconnect(milliseconds) {\n            const retry = () => {\n                // TODO commented code below until we fix reconnection to repull\n                // the document when required. Otherwise, we get a lot of\n                // confusing errors that are causing trouble when debugging.\n                /*\n                if (this.closed_permanently) {\n                */\n                if (!this.closed_permanently)\n                    logging_1.logger.info(`Websocket connection ${this._number} disconnected, will not attempt to reconnect`);\n                return;\n                /*\n                } else {\n                  logger.debug(`Attempting to reconnect websocket ${this._number}`)\n                  this.connect()\n                }\n                */\n            };\n            setTimeout(retry, milliseconds);\n        }\n        send(message) {\n            if (this.socket == null)\n                throw new Error(`not connected so cannot send ${message}`);\n            message.send(this.socket);\n        }\n        send_with_reply(message) {\n            const promise = new Promise((resolve, reject) => {\n                this._pending_replies[message.msgid()] = [resolve, reject];\n                this.send(message);\n            });\n            return promise.then((message) => {\n                if (message.msgtype() === \"ERROR\")\n                    throw new Error(`Error reply ${message.content.text}`);\n                else\n                    return message;\n            }, (error) => {\n                throw error;\n            });\n        }\n        _pull_doc_json() {\n            const message = message_1.Message.create(\"PULL-DOC-REQ\", {});\n            const promise = this.send_with_reply(message);\n            return promise.then((reply) => {\n                if (!('doc' in reply.content))\n                    throw new Error(\"No 'doc' field in PULL-DOC-REPLY\");\n                return reply.content.doc;\n            }, (error) => {\n                throw error;\n            });\n        }\n        _repull_session_doc() {\n            if (this.session == null)\n                logging_1.logger.debug(\"Pulling session for first time\");\n            else\n                logging_1.logger.debug(\"Repulling session\");\n            this._pull_doc_json().then((doc_json) => {\n                if (this.session == null) {\n                    if (this.closed_permanently)\n                        logging_1.logger.debug(\"Got new document after connection was already closed\");\n                    else {\n                        const document = document_1.Document.from_json(doc_json);\n                        // Constructing models changes some of their attributes, we deal with that\n                        // here. This happens when models set attributes during construction\n                        // or initialization.\n                        const patch = document_1.Document._compute_patch_since_json(doc_json, document);\n                        if (patch.events.length > 0) {\n                            logging_1.logger.debug(`Sending ${patch.events.length} changes from model construction back to server`);\n                            const patch_message = message_1.Message.create('PATCH-DOC', {}, patch);\n                            this.send(patch_message);\n                        }\n                        this.session = new session_1.ClientSession(this, document, this.id);\n                        for (const msg of this._pending_messages) {\n                            this.session.handle(msg);\n                        }\n                        this._pending_messages = [];\n                        logging_1.logger.debug(\"Created a new session from new pulled doc\");\n                        if (this._on_have_session_hook != null) {\n                            this._on_have_session_hook(this.session);\n                            this._on_have_session_hook = null;\n                        }\n                    }\n                }\n                else {\n                    this.session.document.replace_with_json(doc_json);\n                    logging_1.logger.debug(\"Updated existing session with new pulled doc\");\n                }\n            }, (error) => {\n                // handling the error here is useless because we wouldn't\n                // get errors from the resolve handler above, so see\n                // the catch below instead\n                throw error;\n            }).catch((error) => {\n                if (console.trace != null)\n                    console.trace(error);\n                logging_1.logger.error(`Failed to repull session ${error}`);\n            });\n        }\n        _on_open(resolve, reject) {\n            logging_1.logger.info(`Websocket connection ${this._number} is now open`);\n            this._pending_ack = [resolve, reject];\n            this._current_handler = (message) => {\n                this._awaiting_ack_handler(message);\n            };\n        }\n        _on_message(event) {\n            if (this._current_handler == null)\n                logging_1.logger.error(\"Got a message with no current handler set\");\n            try {\n                this._receiver.consume(event.data);\n            }\n            catch (e) {\n                this._close_bad_protocol(e.toString());\n            }\n            if (this._receiver.message == null)\n                return;\n            const msg = this._receiver.message;\n            const problem = msg.problem();\n            if (problem != null)\n                this._close_bad_protocol(problem);\n            this._current_handler(msg);\n        }\n        _on_close(event) {\n            logging_1.logger.info(`Lost websocket ${this._number} connection, ${event.code} (${event.reason})`);\n            this.socket = null;\n            if (this._pending_ack != null) {\n                this._pending_ack[1](new Error(`Lost websocket connection, ${event.code} (${event.reason})`));\n                this._pending_ack = null;\n            }\n            const pop_pending = () => {\n                for (const reqid in this._pending_replies) {\n                    const promise_funcs = this._pending_replies[reqid];\n                    delete this._pending_replies[reqid];\n                    return promise_funcs;\n                }\n                return null;\n            };\n            let promise_funcs = pop_pending();\n            while (promise_funcs != null) {\n                promise_funcs[1](\"Disconnected\");\n                promise_funcs = pop_pending();\n            }\n            if (!this.closed_permanently)\n                this._schedule_reconnect(2000);\n        }\n        _on_error(reject) {\n            logging_1.logger.debug(`Websocket error on socket ${this._number}`);\n            reject(new Error(\"Could not open websocket\"));\n        }\n        _close_bad_protocol(detail) {\n            logging_1.logger.error(`Closing connection: ${detail}`);\n            if (this.socket != null)\n                this.socket.close(1002, detail); // 1002 = protocol error\n        }\n        _awaiting_ack_handler(message) {\n            if (message.msgtype() === \"ACK\") {\n                this._current_handler = (message) => this._steady_state_handler(message);\n                // Reload any sessions\n                this._repull_session_doc();\n                if (this._pending_ack != null) {\n                    this._pending_ack[0](this);\n                    this._pending_ack = null;\n                }\n            }\n            else\n                this._close_bad_protocol(\"First message was not an ACK\");\n        }\n        _steady_state_handler(message) {\n            if (message.reqid() in this._pending_replies) {\n                const promise_funcs = this._pending_replies[message.reqid()];\n                delete this._pending_replies[message.reqid()];\n                promise_funcs[0](message);\n            }\n            else if (this.session) {\n                this.session.handle(message);\n            }\n            else {\n                this._pending_messages.push(message);\n            }\n        }\n    }\n    exports.ClientConnection = ClientConnection;\n    ClientConnection.__name__ = \"ClientConnection\";\n    // Returns a promise of a ClientSession\n    // The returned promise has a close() method in case you want to close before\n    // getting a session; session.close() works too once you have a session.\n    function pull_session(url, session_id, args_string) {\n        const promise = new Promise((resolve, reject) => {\n            const connection = new ClientConnection(url, session_id, args_string, (session) => {\n                try {\n                    resolve(session);\n                }\n                catch (error) {\n                    logging_1.logger.error(`Promise handler threw an error, closing session ${error}`);\n                    session.close();\n                    throw error;\n                }\n            }, () => {\n                // we rely on reject() as a no-op if we already resolved\n                reject(new Error(\"Connection was closed before we successfully pulled a session\"));\n            });\n            connection.connect().then((_) => undefined, (error) => {\n                logging_1.logger.error(`Failed to connect to Bokeh server ${error}`);\n                throw error;\n            });\n        });\n        return promise;\n    }\n    exports.pull_session = pull_session;\n}\n","/* protocol/message.js */ function _(require, module, exports) {\n    const string_1 = require(25) /* ../core/util/string */;\n    class Message {\n        constructor(header, metadata, content) {\n            this.header = header;\n            this.metadata = metadata;\n            this.content = content;\n            this.buffers = [];\n        }\n        static assemble(header_json, metadata_json, content_json) {\n            const header = JSON.parse(header_json);\n            const metadata = JSON.parse(metadata_json);\n            const content = JSON.parse(content_json);\n            return new Message(header, metadata, content);\n        }\n        assemble_buffer(buf_header, buf_payload) {\n            const nb = this.header.num_buffers != null ? this.header.num_buffers : 0;\n            if (nb <= this.buffers.length)\n                throw new Error(\"too many buffers received, expecting #{nb}\");\n            this.buffers.push([buf_header, buf_payload]);\n        }\n        // not defined for BokehJS, only *receiving* buffers is supported\n        // add_buffer: (buf_header, buf_payload) ->\n        // write_buffers: (socket)\n        static create(msgtype, metadata, content = {}) {\n            const header = Message.create_header(msgtype);\n            return new Message(header, metadata, content);\n        }\n        static create_header(msgtype) {\n            return {\n                msgid: string_1.uniqueId(),\n                msgtype,\n            };\n        }\n        complete() {\n            if (this.header != null && this.metadata != null && this.content != null) {\n                if ('num_buffers' in this.header)\n                    return this.buffers.length === this.header.num_buffers;\n                else\n                    return true;\n            }\n            else\n                return false;\n        }\n        send(socket) {\n            const nb = this.header.num_buffers != null ? this.header.num_buffers : 0;\n            if (nb > 0)\n                throw new Error(\"BokehJS only supports receiving buffers, not sending\");\n            const header_json = JSON.stringify(this.header);\n            const metadata_json = JSON.stringify(this.metadata);\n            const content_json = JSON.stringify(this.content);\n            socket.send(header_json);\n            socket.send(metadata_json);\n            socket.send(content_json);\n        }\n        msgid() {\n            return this.header.msgid;\n        }\n        msgtype() {\n            return this.header.msgtype;\n        }\n        reqid() {\n            return this.header.reqid;\n        }\n        // return the reason we should close on bad protocol, if there is one\n        problem() {\n            if (!('msgid' in this.header))\n                return \"No msgid in header\";\n            else if (!('msgtype' in this.header))\n                return \"No msgtype in header\";\n            else\n                return null;\n        }\n    }\n    exports.Message = Message;\n    Message.__name__ = \"Message\";\n}\n","/* protocol/receiver.js */ function _(require, module, exports) {\n    const message_1 = require(343) /* ./message */;\n    class Receiver {\n        constructor() {\n            this.message = null;\n            this._partial = null;\n            this._fragments = [];\n            this._buf_header = null;\n            this._current_consumer = this._HEADER;\n        }\n        consume(fragment) {\n            this._current_consumer(fragment);\n        }\n        _HEADER(fragment) {\n            this._assume_text(fragment);\n            this.message = null;\n            this._partial = null;\n            this._fragments = [fragment];\n            this._buf_header = null;\n            this._current_consumer = this._METADATA;\n        }\n        _METADATA(fragment) {\n            this._assume_text(fragment);\n            this._fragments.push(fragment);\n            this._current_consumer = this._CONTENT;\n        }\n        _CONTENT(fragment) {\n            this._assume_text(fragment);\n            this._fragments.push(fragment);\n            const [header_json, metadata_json, content_json] = this._fragments.slice(0, 3);\n            this._partial = message_1.Message.assemble(header_json, metadata_json, content_json);\n            this._check_complete();\n        }\n        _BUFFER_HEADER(fragment) {\n            this._assume_text(fragment);\n            this._buf_header = fragment; // XXX: assume text but Header is expected\n            this._current_consumer = this._BUFFER_PAYLOAD;\n        }\n        _BUFFER_PAYLOAD(fragment) {\n            this._assume_binary(fragment);\n            this._partial.assemble_buffer(this._buf_header, fragment);\n            this._check_complete();\n        }\n        _assume_text(fragment) {\n            if (fragment instanceof ArrayBuffer)\n                throw new Error(\"Expected text fragment but received binary fragment\");\n        }\n        _assume_binary(fragment) {\n            if (!(fragment instanceof ArrayBuffer))\n                throw new Error(\"Expected binary fragment but received text fragment\");\n        }\n        _check_complete() {\n            if (this._partial.complete()) {\n                this.message = this._partial;\n                this._current_consumer = this._HEADER;\n            }\n            else\n                this._current_consumer = this._BUFFER_HEADER;\n        }\n    }\n    exports.Receiver = Receiver;\n    Receiver.__name__ = \"Receiver\";\n}\n","/* client/session.js */ function _(require, module, exports) {\n    const document_1 = require(4) /* ../document */;\n    const message_1 = require(343) /* ../protocol/message */;\n    const logging_1 = require(65) /* ../core/logging */;\n    class ClientSession {\n        constructor(_connection, document, id) {\n            this._connection = _connection;\n            this.document = document;\n            this.id = id;\n            this._document_listener = (event) => this._document_changed(event);\n            this.document.on_change(this._document_listener);\n            this.event_manager = this.document.event_manager;\n            this.event_manager.session = this;\n        }\n        handle(message) {\n            const msgtype = message.msgtype();\n            if (msgtype === 'PATCH-DOC')\n                this._handle_patch(message);\n            else if (msgtype === 'OK')\n                this._handle_ok(message);\n            else if (msgtype === 'ERROR')\n                this._handle_error(message);\n            else\n                logging_1.logger.debug(`Doing nothing with message ${message.msgtype()}`);\n        }\n        close() {\n            this._connection.close();\n        }\n        send_event(event) {\n            const message = message_1.Message.create('EVENT', {}, JSON.stringify(event.to_json()));\n            this._connection.send(message);\n        }\n        /*protected*/ _connection_closed() {\n            this.document.remove_on_change(this._document_listener);\n        }\n        // Sends a request to the server for info about the server, such as its Bokeh\n        // version. Returns a promise, the value of the promise is a free-form dictionary\n        // of server details.\n        request_server_info() {\n            const message = message_1.Message.create('SERVER-INFO-REQ', {});\n            const promise = this._connection.send_with_reply(message);\n            return promise.then((reply) => reply.content);\n        }\n        // Sends some request to the server (no guarantee about which one) and returns\n        // a promise which is completed when the server replies. The purpose of this\n        // is that if you wait for the promise to be completed, you know the server\n        // has processed the request. This is useful when writing tests because once\n        // the server has processed this request it should also have processed any\n        // events or requests you sent previously, which means you can check for the\n        // results of that processing without a race condition. (This assumes the\n        // server processes events in sequence, which it mostly has to semantically,\n        // since reordering events might change the final state.)\n        force_roundtrip() {\n            return this.request_server_info().then((_) => undefined);\n        }\n        _document_changed(event) {\n            // Filter out events that were initiated by the ClientSession itself\n            if (event.setter_id === this.id) // XXX: not all document events define this\n                return;\n            // Filter out changes to attributes that aren't server-visible\n            if (event instanceof document_1.ModelChangedEvent && !(event.attr in event.model.serializable_attributes()))\n                return;\n            // TODO (havocp) the connection may be closed here, which will\n            // cause this send to throw an error - need to deal with it more cleanly.\n            const message = message_1.Message.create('PATCH-DOC', {}, this.document.create_json_patch([event]));\n            this._connection.send(message);\n        }\n        _handle_patch(message) {\n            this.document.apply_json_patch(message.content, message.buffers, this.id);\n        }\n        _handle_ok(message) {\n            logging_1.logger.trace(`Unhandled OK reply to ${message.reqid()}`);\n        }\n        _handle_error(message) {\n            logging_1.logger.error(`Unhandled ERROR reply to ${message.reqid()}: ${message.content.text}`);\n        }\n    }\n    exports.ClientSession = ClientSession;\n    ClientSession.__name__ = \"ClientSession\";\n}\n","/* embed/notebook.js */ function _(require, module, exports) {\n    const document_1 = require(4) /* ../document */;\n    const receiver_1 = require(344) /* ../protocol/receiver */;\n    const logging_1 = require(65) /* ../core/logging */;\n    const object_1 = require(22) /* ../core/util/object */;\n    const standalone_1 = require(339) /* ./standalone */;\n    const dom_1 = require(340) /* ./dom */;\n    require(272) /* ../styles/logo */;\n    require(347) /* ../styles/notebook */;\n    // This exists to allow the @bokeh/jupyter_bokeh extension to store the\n    // notebook kernel so that _init_comms can register the comms target.\n    // This has to be available at window.Bokeh.embed.kernels in JupyterLab.\n    exports.kernels = {};\n    function _handle_notebook_comms(receiver, comm_msg) {\n        if (comm_msg.buffers.length > 0)\n            receiver.consume(comm_msg.buffers[0].buffer);\n        else\n            receiver.consume(comm_msg.content.data);\n        const msg = receiver.message;\n        if (msg != null)\n            this.apply_json_patch(msg.content, msg.buffers);\n    }\n    function _init_comms(target, doc) {\n        if (typeof Jupyter !== 'undefined' && Jupyter.notebook.kernel != null) {\n            logging_1.logger.info(`Registering Jupyter comms for target ${target}`);\n            const comm_manager = Jupyter.notebook.kernel.comm_manager;\n            try {\n                comm_manager.register_target(target, (comm) => {\n                    logging_1.logger.info(`Registering Jupyter comms for target ${target}`);\n                    const r = new receiver_1.Receiver();\n                    comm.on_msg(_handle_notebook_comms.bind(doc, r));\n                });\n            }\n            catch (e) {\n                logging_1.logger.warn(`Jupyter comms failed to register. push_notebook() will not function. (exception reported: ${e})`);\n            }\n        }\n        else if (doc.roots()[0].id in exports.kernels) {\n            logging_1.logger.info(`Registering JupyterLab comms for target ${target}`);\n            const kernel = exports.kernels[doc.roots()[0].id];\n            try {\n                kernel.registerCommTarget(target, (comm) => {\n                    logging_1.logger.info(`Registering JupyterLab comms for target ${target}`);\n                    const r = new receiver_1.Receiver();\n                    comm.onMsg = _handle_notebook_comms.bind(doc, r);\n                });\n            }\n            catch (e) {\n                logging_1.logger.warn(`Jupyter comms failed to register. push_notebook() will not function. (exception reported: ${e})`);\n            }\n        }\n        else {\n            console.warn(`Jupyter notebooks comms not available. push_notebook() will not function. If running JupyterLab ensure the latest @bokeh/jupyter_bokeh extension is installed. In an exported notebook this warning is expected.`);\n        }\n    }\n    function embed_items_notebook(docs_json, render_items) {\n        if (object_1.size(docs_json) != 1)\n            throw new Error(\"embed_items_notebook expects exactly one document in docs_json\");\n        const document = document_1.Document.from_json(object_1.values(docs_json)[0]);\n        for (const item of render_items) {\n            if (item.notebook_comms_target != null)\n                _init_comms(item.notebook_comms_target, document);\n            const element = dom_1._resolve_element(item);\n            const roots = dom_1._resolve_root_elements(item);\n            standalone_1.add_document_standalone(document, element, roots);\n        }\n    }\n    exports.embed_items_notebook = embed_items_notebook;\n}\n","/* styles/notebook.js */ function _(require, module, exports) {\n    require(62) /* ./root */;\n    const _a = require(61) /* ../core/dom */;\n    _a.styles.append(\"/* notebook specific tweaks so no black outline and matching padding\\n/* can't be wrapped inside bk-root. here are the offending jupyter lines:\\n/* https://github.com/jupyter/notebook/blob/master/notebook/static/notebook/less/renderedhtml.less#L59-L76 */\\n.rendered_html .bk-root .bk-tooltip table,\\n.rendered_html .bk-root .bk-tooltip tr,\\n.rendered_html .bk-root .bk-tooltip th,\\n.rendered_html .bk-root .bk-tooltip td {\\n  border: none;\\n  padding: 1px;\\n}\\n\");\n}\n","/* protocol/index.js */ function _(require, module, exports) {\n    function __export(m) {\n        for (var p in m)\n            if (!exports.hasOwnProperty(p))\n                exports[p] = m[p];\n    }\n    __export(require(343) /* ./message */);\n    __export(require(344) /* ./receiver */);\n}\n","/* testing.js */ function _(require, module, exports) {\n    // Just a dumb key/value record for collecting arbitrary info for tests\n    exports.results = {};\n    // Selenium has race conditions that make it difficult to read out the\n    // results structure. This function deletes/creates a div that can act as\n    // a semaphore. Tests should wait for the previous div to be stale, then\n    // find the new div. At that point the results should be available\n    function _update_test_div() {\n        const body = document.getElementsByTagName(\"body\")[0];\n        const col = document.getElementsByClassName(\"bokeh-test-div\");\n        if (col.length == 1) {\n            body.removeChild(col[0]);\n            delete col[0];\n        }\n        const box = document.createElement(\"div\");\n        box.classList.add(\"bokeh-test-div\");\n        box.style.display = \"none\";\n        body.insertBefore(box, body.firstChild);\n    }\n    function init() {\n        _update_test_div();\n    }\n    exports.init = init;\n    function record(key, value) {\n        exports.results[key] = value;\n        _update_test_div();\n    }\n    exports.record = record;\n    function count(key) {\n        if (exports.results[key] == undefined)\n            exports.results[key] = 0;\n        exports.results[key] += 1;\n        _update_test_div();\n    }\n    exports.count = count;\n    function clear() {\n        for (const prop of Object.keys(exports.results))\n            delete exports.results[prop];\n        _update_test_div();\n    }\n    exports.clear = clear;\n}\n","/* safely.js */ function _(require, module, exports) {\n    function _burst_into_flames(error) {\n        // Make box\n        const box = document.createElement(\"div\");\n        box.style.backgroundColor = \"#f2dede\";\n        box.style.border = \"1px solid #a94442\";\n        box.style.borderRadius = \"4px\";\n        box.style.display = \"inline-block\";\n        box.style.fontFamily = \"sans-serif\";\n        box.style.marginTop = \"5px\";\n        box.style.minWidth = \"200px\";\n        box.style.padding = \"5px 5px 5px 10px\";\n        box.classList.add(\"bokeh-error-box-into-flames\");\n        // Make button\n        const button = document.createElement(\"span\");\n        button.style.backgroundColor = \"#a94442\";\n        button.style.borderRadius = \"0px 4px 0px 0px\";\n        button.style.color = \"white\";\n        button.style.cursor = \"pointer\";\n        button.style.cssFloat = \"right\";\n        button.style.fontSize = \"0.8em\";\n        button.style.margin = \"-6px -6px 0px 0px\";\n        button.style.padding = \"2px 5px 4px 5px\";\n        button.title = \"close\";\n        button.setAttribute(\"aria-label\", \"close\");\n        button.appendChild(document.createTextNode(\"x\"));\n        button.addEventListener(\"click\", () => body.removeChild(box));\n        // Make title\n        const title = document.createElement(\"h3\");\n        title.style.color = \"#a94442\";\n        title.style.margin = \"8px 0px 0px 0px\";\n        title.style.padding = \"0px\";\n        title.appendChild(document.createTextNode(\"Bokeh Error\"));\n        // Make message\n        const message = document.createElement(\"pre\");\n        message.style.whiteSpace = \"unset\";\n        message.style.overflowX = \"auto\";\n        const text = error instanceof Error ? error.message : error;\n        message.appendChild(document.createTextNode(text));\n        // Add pieces to box\n        box.appendChild(button);\n        box.appendChild(title);\n        box.appendChild(message);\n        // Put box in doc\n        const body = document.getElementsByTagName(\"body\")[0];\n        body.insertBefore(box, body.firstChild);\n    }\n    function safely(fn, silent = false) {\n        try {\n            return fn();\n        }\n        catch (error) {\n            _burst_into_flames(error);\n            if (!silent)\n                throw error;\n            else\n                return;\n        }\n    }\n    exports.safely = safely;\n}\n"]}